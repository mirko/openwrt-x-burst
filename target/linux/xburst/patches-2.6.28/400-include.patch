--- linux-2.6.24.7.old/include/asm-mips/bootinfo.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/asm-mips/bootinfo.h	2009-04-12 18:13:57.000000000 +0200
@@ -198,6 +198,14 @@
 #define MACH_GROUP_BRCM		23	/* Broadcom			*/
 #define  MACH_BCM47XX		1	/* Broadcom BCM47XX		*/
 
+/*
+ * Valid machtype for group INGENIC
+ */
+#define  MACH_INGENIC_JZ4730	0	/* JZ4730 SOC		*/
+#define  MACH_INGENIC_JZ4740	1	/* JZ4740 SOC		*/
+#define  MACH_INGENIC_JZ4750	2	/* JZ4750 SOC		*/
+#define  MACH_INGENIC_JZ4750D	3	/* JZ4750D SOC		*/
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);
--- linux-2.6.24.7.old/include/asm-mips/cpu.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/asm-mips/cpu.h	2009-04-12 18:13:57.000000000 +0200
@@ -33,6 +33,7 @@
 #define PRID_COMP_TOSHIBA	0x070000
 #define PRID_COMP_LSI		0x080000
 #define PRID_COMP_LEXRA		0x0b0000
+#define PRID_COMP_INGENIC	0xd00000
 
 
 /*
@@ -113,6 +114,12 @@
 #define PRID_IMP_BCM3302	0x9000
 
 /*
+ * These are the PRID's for when 23:16 == PRID_COMP_INGENIC
+ */
+
+#define PRID_IMP_JZRISC        0x0200
+
+/*
  * Definitions for 7:0 on legacy processors
  */
 
@@ -203,6 +210,11 @@
 	 */
 	CPU_5KC, CPU_20KC, CPU_25KF, CPU_SB1, CPU_SB1A, CPU_LOONGSON2,
 
+	/*
+	 * Ingenic class processors
+	 */
+	CPU_JZRISC, CPU_XBURST,
+
 	CPU_LAST
 };
 
--- linux-2.6.24.7.old/include/asm-mips/jzsoc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/jzsoc.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ *  linux/include/asm-mips/jzsoc.h
+ *
+ *  Ingenic's JZXXXX SoC common include.
+ *
+ *  Copyright (C) 2006 - 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZSOC_H__
+#define __ASM_JZSOC_H__
+
+/*
+ * SoC include
+ */
+
+#ifdef CONFIG_SOC_JZ4730
+#include <asm/mach-jz4730/jz4730.h>
+#endif
+
+#ifdef CONFIG_SOC_JZ4740
+#include <asm/mach-jz4740/jz4740.h>
+#endif
+
+#ifdef CONFIG_SOC_JZ4750
+#include <asm/mach-jz4750/jz4750.h>
+#endif
+
+#ifdef CONFIG_SOC_JZ4750D
+#include <asm/mach-jz4750d/jz4750d.h>
+#endif
+
+/*
+ * Generic I/O routines
+ */
+#define readb(addr)	(*(volatile unsigned char *)(addr))
+#define readw(addr)	(*(volatile unsigned short *)(addr))
+#define readl(addr)	(*(volatile unsigned int *)(addr))
+
+#define writeb(b,addr)	((*(volatile unsigned char *)(addr)) = (b))
+#define writew(b,addr)	((*(volatile unsigned short *)(addr)) = (b))
+#define writel(b,addr)	((*(volatile unsigned int *)(addr)) = (b))
+
+#endif /* __ASM_JZSOC_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-generic/irq.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/asm-mips/mach-generic/irq.h	2009-04-12 18:13:57.000000000 +0200
@@ -9,7 +9,7 @@
 #define __ASM_MACH_GENERIC_IRQ_H
 
 #ifndef NR_IRQS
-#define NR_IRQS	128
+#define NR_IRQS	256
 #endif
 
 #ifdef CONFIG_I8259
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4730/board-pmp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4730/board-pmp.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,83 @@
+/*
+ *  linux/include/asm-mips/mach-jz4730/board-pmp.h
+ *
+ *  JZ4730-based PMP board ver 2.x definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4730_PMP_H__
+#define __ASM_JZ4730_PMP_H__
+
+/*====================================================================== 
+ * EXTAL frequency
+ */
+#define JZ_EXTAL		12000000	/* EXTAL: 12 MHz */
+#define JZ_EXTAL2		32768		/* EXTAL2: 32.768 KHz */
+
+
+/*====================================================================== 
+ * GPIO
+ */
+#define GPIO_PW_I         97
+#define GPIO_PW_O         66
+#define GPIO_LED_EN       92
+#define GPIO_DISP_OFF_N   93
+#define GPIO_PWM0         94
+#define GPIO_RTC_IRQ      96
+#define GPIO_USB_CLK_EN   29
+#define GPIO_CHARG_STAT   125
+#define GPIO_TS_PENIRQ    98
+#define GPIO_UDC_HOTPLUG  86
+
+/*====================================================================== 
+ * MMC/SD
+ */
+#define MSC_WP_PIN         82
+#define MSC_POWEREN_PIN    91
+#define MSC_HOTPLUG_PIN    90
+#define MSC_HOTPLUG_IRQ    (IRQ_GPIO_0 + MSC_HOTPLUG_PIN)
+
+/* enable slot power */
+#define __msc_init_io()				\
+do {						\
+      	__gpio_as_input(MSC_WP_PIN);		\
+      	__gpio_as_output(MSC_POWEREN_PIN);	\
+} while (0)
+
+/* enable slot power */
+#define __msc_enable_power()			\
+do {						\
+      	__gpio_clear_pin(MSC_POWEREN_PIN);	\
+} while (0)
+
+/* disable slot power */
+#define __msc_disable_power()			\
+do {						\
+      	__gpio_set_pin(MSC_POWEREN_PIN);	\
+} while (0)
+
+/* detect card insertion or not */
+#define __msc_card_detected(slot)				\
+({							\
+	int ret;					\
+	if (slot == 0) {				\
+	      	__gpio_mask_irq(MSC_HOTPLUG_IRQ);	\
+	      	__gpio_as_input(MSC_HOTPLUG_PIN);	\
+	     	ret = __gpio_get_pin(MSC_HOTPLUG_PIN);	\
+		__gpio_unmask_irq(MSC_HOTPLUG_IRQ);	\
+	}						\
+	else {						\
+     		ret = 1;				\
+	}						\
+	ret = !ret;					\
+	ret;						\
+})
+
+#endif /* __ASM_JZ4730_PMP_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4730/clock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4730/clock.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,184 @@
+/*
+ *  linux/include/asm-mips/mach-jz4730/clock.h
+ *
+ *  JZ4730 clocks definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4730_CLOCK_H__
+#define __ASM_JZ4730_CLOCK_H__
+
+#ifndef JZ_EXTAL
+#define JZ_EXTAL 3686400
+#endif
+
+#ifndef JZ_EXTAL2
+#define JZ_EXTAL2 32768
+#endif
+
+/*
+ * JZ4730 clocks structure
+ */
+typedef struct {
+	unsigned int iclk;	/* CPU core clock */
+	unsigned int sclk;	/* AHB bus clock */
+	unsigned int mclk;	/* Memory bus clock */
+	unsigned int pclk;	/* APB bus clock */
+	unsigned int devclk;	/* Devcie clock to specific modules */
+	unsigned int rtcclk;	/* RTC module clock */
+	unsigned int uartclk;	/* UART module clock */
+	unsigned int lcdclk;	/* LCD module clock */
+	unsigned int pixclk;	/* LCD pixel clock */
+	unsigned int usbclk;	/* USB module clock */
+	unsigned int i2sclk;	/* I2S module clock */
+	unsigned int mscclk;	/* MMC/SD module clock */
+} jz_clocks_t;
+
+extern jz_clocks_t jz_clocks;
+
+
+static __inline__ unsigned int __cpm_get_pllout(void)
+{
+	unsigned int nf, nr, no, pllout;
+	unsigned long plcr = REG_CPM_PLCR1;
+	unsigned long od[4] = {1, 2, 2, 4};
+	if (plcr & CPM_PLCR1_PLL1EN) {
+		nf = (plcr & CPM_PLCR1_PLL1FD_MASK) >> CPM_PLCR1_PLL1FD_BIT;
+		nr = (plcr & CPM_PLCR1_PLL1RD_MASK) >> CPM_PLCR1_PLL1RD_BIT;
+		no = od[((plcr & CPM_PLCR1_PLL1OD_MASK) >> CPM_PLCR1_PLL1OD_BIT)];
+		pllout = (JZ_EXTAL) / ((nr+2) * no) * (nf+2);
+	} else
+		pllout = JZ_EXTAL;
+	return pllout;
+}
+
+static __inline__ unsigned int __cpm_get_iclk(void)
+{
+	unsigned int iclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		iclk = __cpm_get_pllout() /
+		       div[(cfcr & CPM_CFCR_IFR_MASK) >> CPM_CFCR_IFR_BIT];
+	else
+		iclk = JZ_EXTAL;
+	return iclk;
+}
+
+static __inline__ unsigned int __cpm_get_sclk(void)
+{
+	unsigned int sclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		sclk = __cpm_get_pllout() /
+		       div[(cfcr & CPM_CFCR_SFR_MASK) >> CPM_CFCR_SFR_BIT];
+	else
+		sclk = JZ_EXTAL;
+	return sclk;
+}
+
+static __inline__ unsigned int __cpm_get_mclk(void)
+{
+	unsigned int mclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		mclk = __cpm_get_pllout() /
+		       div[(cfcr & CPM_CFCR_MFR_MASK) >> CPM_CFCR_MFR_BIT];
+	else
+		mclk = JZ_EXTAL;
+	return mclk;
+}
+
+static __inline__ unsigned int __cpm_get_pclk(void)
+{
+	unsigned int devclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		devclk = __cpm_get_pllout() /
+			 div[(cfcr & CPM_CFCR_PFR_MASK) >> CPM_CFCR_PFR_BIT];
+	else
+		devclk = JZ_EXTAL;
+	return devclk;
+}
+
+static __inline__ unsigned int __cpm_get_lcdclk(void)
+{
+	unsigned int lcdclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned long cfcr = REG_CPM_CFCR;
+	unsigned long plcr = REG_CPM_PLCR1;
+	if (plcr & CPM_PLCR1_PLL1EN)
+		lcdclk = __cpm_get_pllout() /
+			 div[(cfcr & CPM_CFCR_LFR_MASK) >> CPM_CFCR_LFR_BIT];
+	else
+		lcdclk = JZ_EXTAL;
+	return lcdclk;
+}
+
+static __inline__ unsigned int __cpm_get_pixclk(void)
+{
+	unsigned int pixclk;
+	unsigned long cfcr2 = REG_CPM_CFCR2;
+	pixclk = __cpm_get_pllout() / (cfcr2 + 1);
+	return pixclk;
+}
+
+static __inline__ unsigned int __cpm_get_devclk(void)
+{
+	return JZ_EXTAL;
+}
+
+static __inline__ unsigned int __cpm_get_rtcclk(void)
+{
+	return JZ_EXTAL2;
+}
+
+static __inline__ unsigned int __cpm_get_uartclk(void)
+{
+	return JZ_EXTAL;
+}
+
+static __inline__ unsigned int __cpm_get_usbclk(void)
+{
+	unsigned int usbclk;
+	unsigned long cfcr = REG_CPM_CFCR;
+	if (cfcr & CPM_CFCR_UCS)
+		usbclk = 48000000;
+	else
+		usbclk = __cpm_get_pllout() /
+			(((cfcr &CPM_CFCR_UFR_MASK) >> CPM_CFCR_UFR_BIT) + 1);
+	return usbclk;
+}
+
+static __inline__ unsigned int __cpm_get_i2sclk(void)
+{
+	unsigned int i2sclk;
+	unsigned long cfcr = REG_CPM_CFCR;
+	i2sclk = __cpm_get_pllout() /
+		((cfcr & CPM_CFCR_I2S) ? 2: 1);
+	return i2sclk;
+}
+
+static __inline__ unsigned int __cpm_get_mscclk(void)
+{
+	if (REG_CPM_CFCR & CPM_CFCR_MSC)
+		return 24000000;
+	else
+		return 16000000;
+}
+
+#endif /* __ASM_JZ4730_CLOCK_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4730/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4730/dma.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,272 @@
+/*
+ *  linux/include/asm-mips/mach-jz4730/dma.h
+ *
+ *  JZ4730 DMA definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4730_DMA_H__
+#define __ASM_JZ4730_DMA_H__
+
+#include <linux/interrupt.h>
+#include <asm/io.h>			/* need byte IO */
+#include <linux/spinlock.h>		/* And spinlocks */
+#include <linux/delay.h>
+#include <asm/system.h>
+
+#define DMA_UNIT_32     32
+#define DMA_UNIT_16     16
+
+
+/* block-mode  EOP: high  DREQ: high  DACK: low*/
+#define DMA_BLOCK_CONF					\
+	DMAC_DCCSR_TM |					\
+	DMAC_DCCSR_DS_8b | DMAC_DCCSR_RDIL_IGN |	\
+	DMAC_DCCSR_ERDM_HLEVEL | DMAC_DCCSR_EACKS
+
+/* single-mode  EOP: high  DREQ: high  DACK: low */
+#define DMA_SINGLE_CONF					\
+	DMAC_DCCSR_DS_8b | DMAC_DCCSR_RDIL_IGN |	\
+	DMAC_DCCSR_ERDM_HLEVEL | DMAC_DCCSR_EACKS
+
+#define DMA_8bit_RX_CONF				\
+	DMAC_DCCSR_DAM |				\
+	DMAC_DCCSR_SWDH_8 | DMAC_DCCSR_DWDH_32 |	\
+	DMAC_DCCSR_DS_8b | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_8bit_TX_CONF				\
+	DMAC_DCCSR_SAM |				\
+	DMAC_DCCSR_SWDH_32 | DMAC_DCCSR_DWDH_8 |	\
+	DMAC_DCCSR_DS_8b | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_16bit_RX_CONF				\
+	DMAC_DCCSR_DAM |				\
+	DMAC_DCCSR_SWDH_16 | DMAC_DCCSR_DWDH_32 |	\
+	DMAC_DCCSR_DS_16b | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_16bit_TX_CONF				\
+	DMAC_DCCSR_SAM |				\
+	DMAC_DCCSR_SWDH_32 | DMAC_DCCSR_DWDH_16 |	\
+	DMAC_DCCSR_DS_16b | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_32bit_RX_CONF				\
+	DMAC_DCCSR_DAM |				\
+	DMAC_DCCSR_SWDH_32 | DMAC_DCCSR_DWDH_32 |	\
+	DMAC_DCCSR_DS_32b | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_32bit_TX_CONF				\
+	DMAC_DCCSR_SAM |				\
+	DMAC_DCCSR_SWDH_32 | DMAC_DCCSR_DWDH_32 |	\
+	DMAC_DCCSR_DS_32b | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_16BYTE_RX_CONF				\
+	DMAC_DCCSR_DAM |				\
+	DMAC_DCCSR_SWDH_8 | DMAC_DCCSR_DWDH_32 |	\
+	DMAC_DCCSR_DS_16B | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_16BYTE_TX_CONF				\
+	DMAC_DCCSR_SAM |				\
+	DMAC_DCCSR_SWDH_32 | DMAC_DCCSR_DWDH_8 |	\
+	DMAC_DCCSR_DS_16B | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_AIC_32_16BYTE_TX_CMD			\
+	DMAC_DCCSR_SAM |				\
+	DMAC_DCCSR_SWDH_32 | DMAC_DCCSR_DWDH_32 |	\
+	DMAC_DCCSR_DS_16B | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_AIC_32_16BYTE_RX_CMD			\
+	DMAC_DCCSR_DAM |				\
+	DMAC_DCCSR_SWDH_32 | DMAC_DCCSR_DWDH_32 |	\
+	DMAC_DCCSR_DS_16B | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_AIC_16BIT_TX_CMD				\
+	DMAC_DCCSR_SAM |				\
+	DMAC_DCCSR_SWDH_16 | DMAC_DCCSR_DWDH_16 |	\
+	DMAC_DCCSR_DS_16b | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_AIC_16BIT_RX_CMD				\
+	DMAC_DCCSR_DAM |				\
+	DMAC_DCCSR_SWDH_16 | DMAC_DCCSR_DWDH_16 |	\
+	DMAC_DCCSR_DS_16b | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_AIC_16BYTE_RX_CMD				\
+	DMAC_DCCSR_DAM |				\
+	DMAC_DCCSR_SWDH_16 | DMAC_DCCSR_DWDH_16 |	\
+	DMAC_DCCSR_DS_16B | DMAC_DCCSR_RDIL_IGN
+
+#define DMA_AIC_16BYTE_TX_CMD				\
+	DMAC_DCCSR_SAM |				\
+	DMAC_DCCSR_SWDH_16 | DMAC_DCCSR_DWDH_16 |	\
+	DMAC_DCCSR_DS_16B | DMAC_DCCSR_RDIL_IGN
+
+/* DMA Device ID's follow */
+enum {
+	DMA_ID_UART0_TX = 0,
+	DMA_ID_UART0_RX,
+	DMA_ID_UART1_TX,
+	DMA_ID_UART1_RX,
+	DMA_ID_UART2_TX,
+	DMA_ID_UART2_RX,
+	DMA_ID_UART3_TX,
+	DMA_ID_UART3_RX,
+	DMA_ID_SSI_TX,
+	DMA_ID_SSI_RX,
+	DMA_ID_MSC_TX,
+	DMA_ID_MSC_RX,
+	DMA_ID_AIC_TX,
+	DMA_ID_AIC_RX,
+	DMA_ID_BLOCK,		/* DREQ */
+	DMA_ID_SINGLE,		/* DREQ */
+	DMA_ID_PCMCIA0_TX,
+	DMA_ID_PCMCIA0_RX,
+	DMA_ID_PCMCIA1_TX,
+	DMA_ID_PCMCIA2_RX,
+	DMA_ID_AUTO,
+	DMA_ID_RAW_SET,
+	NUM_DMA_DEV
+};
+
+/* dummy DCCSR bit, i386 style DMA macros compitable */
+#define DMA_MODE_READ		0	/* I/O to memory, no autoinit,
+					 * increment, single mode */
+#define DMA_MODE_WRITE		1	/* memory to I/O, no autoinit,
+					 * increment, single mode */
+#define DMA_MODE_CASCADE	2	/* pass thru DREQ->HRQ,
+					 * DACK<-HLDA only */
+#define DMA_AUTOINIT		3
+#define DMA_MODE_MASK		3
+
+struct jz_dma_chan {
+	int dev_id;		/* this channel is allocated if >=0,
+				 * free otherwise */
+	unsigned int io;
+	const char *dev_str;
+	int irq;
+	void *irq_dev;
+	unsigned int fifo_addr;
+	unsigned int mode;
+	unsigned int source;
+};
+
+extern struct jz_dma_chan jz_dma_table[];
+
+extern int jz_request_dma(int dev_id,
+			      const char *dev_str,
+			      irqreturn_t (*irqhandler)(int, void *),
+			      unsigned long irqflags,
+			      void *irq_dev_id);
+extern void jz_free_dma(unsigned int dmanr);
+
+extern int jz_dma_read_proc(char *buf, char **start, off_t fpos,
+			      int length, int *eof, void *data);
+extern void dump_jz_dma_channel(unsigned int dmanr);
+
+extern void enable_dma(unsigned int dmanr);
+extern void disable_dma(unsigned int dmanr);
+extern void set_dma_addr(unsigned int dmanr, unsigned int a);
+extern void set_dma_count(unsigned int dmanr, unsigned int count);
+extern void set_dma_mode(unsigned int dmanr, unsigned int mode);
+extern void jz_set_oss_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt);
+extern void jz_set_alsa_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt);
+extern int get_dma_residue(unsigned int dmanr);
+
+extern spinlock_t  dma_spin_lock;
+
+static __inline__ unsigned long claim_dma_lock(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dma_spin_lock, flags);
+	return flags;
+}
+
+static __inline__ void release_dma_lock(unsigned long flags)
+{
+	spin_unlock_irqrestore(&dma_spin_lock, flags);
+}
+
+/* Clear the 'DMA Pointer Flip Flop'.
+ * Write 0 for LSB/MSB, 1 for MSB/LSB access.
+ */
+#define clear_dma_ff(channel)
+
+static __inline__ struct jz_dma_chan *get_dma_chan(unsigned int dmanr)
+{
+	if (dmanr > NUM_DMA
+	    || jz_dma_table[dmanr].dev_id < 0)
+		return NULL;
+	return &jz_dma_table[dmanr];
+}
+
+static __inline__ int dma_halted(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 1;
+	return  __dmac_channel_transmit_halt_detected(dmanr) ? 1 : 0;
+}
+
+static __inline__ unsigned int get_dma_mode(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+	return chan->mode;
+}
+
+static __inline__ void clear_dma_done(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TC | DMAC_DCCSR_AR);
+}
+
+static __inline__ void clear_dma_halt(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT);
+	REG_DMAC_DMACR &= ~(DMAC_DMACR_HTR);
+}
+static __inline__ void clear_dma_flag(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TC | DMAC_DCCSR_AR);
+	REG_DMAC_DMACR &= ~(DMAC_DMACR_HTR | DMAC_DMACR_AER);
+}
+
+static __inline__ void set_dma_page(unsigned int dmanr, char pagenr)
+{
+}
+
+static __inline__ unsigned int get_dma_done_status(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	unsigned long dccsr;
+	if (!chan)
+		return 0;
+
+	dccsr = REG_DMAC_DCCSR(chan->io);
+	return dccsr & (DMAC_DCCSR_HLT | DMAC_DCCSR_TC | DMAC_DCCSR_AR);
+}
+
+static __inline__ int get_dma_done_irq(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return -1;
+
+	return chan->irq;
+}
+
+#endif  /* __ASM_JZ4730_DMA_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4730/jz4730.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4730/jz4730.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-mips/mach-jz4730/jz4730.h
+ *
+ *  JZ4730 common definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4730_H__
+#define __ASM_JZ4730_H__
+
+#include <asm/mach-jz4730/regs.h>
+#include <asm/mach-jz4730/ops.h>
+#include <asm/mach-jz4730/dma.h>
+#include <asm/mach-jz4730/misc.h>
+
+/*------------------------------------------------------------------
+ * Platform definitions
+ */
+#ifdef CONFIG_JZ4730_PMP
+#include <asm/mach-jz4730/board-pmp.h>
+#endif
+
+/* Add other platform definition here ... */
+
+
+/*------------------------------------------------------------------
+ * Follows are related to platform definitions
+ */
+
+#include <asm/mach-jz4730/clock.h>
+#include <asm/mach-jz4730/serial.h>
+
+#endif /* __ASM_JZ4730_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4730/misc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4730/misc.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,28 @@
+/*
+ *  linux/include/asm-mips/mach-jz4730/misc.h
+ *
+ *  JZ4730 miscillaneous definitions.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4730_MISC_H__
+#define __ASM_JZ4730_MISC_H__
+
+/*
+ * I2C routines
+ */
+
+extern void i2c_open(void);
+extern void i2c_close(void);
+extern void i2c_setclk(unsigned int i2cclk);
+extern int i2c_read(unsigned char, unsigned char *, unsigned char, int);
+extern int i2c_write(unsigned char, unsigned char *, unsigned char, int);
+
+#endif /* __ASM_JZ4730_MISC_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4730/ops.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4730/ops.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,2541 @@
+/*
+ *  linux/include/asm-mips/mach-jz4730/ops.h
+ *
+ *  JZ4730 module operations definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4730_OPS_H__
+#define __ASM_JZ4730_OPS_H__
+
+/***************************************************************************
+ * MSC
+ ***************************************************************************/
+
+#define __msc_start_op() \
+  ( REG_MSC_STRPCL = MSC_STRPCL_START_OP | MSC_STRPCL_CLOCK_CONTROL_START )
+
+#define __msc_set_resto(to) 	( REG_MSC_RESTO = to )
+#define __msc_set_rdto(to) 	( REG_MSC_RDTO = to )
+#define __msc_set_cmd(cmd) 	( REG_MSC_CMD = cmd )
+#define __msc_set_arg(arg) 	( REG_MSC_ARG = arg )
+#define __msc_set_nob(nob) 	( REG_MSC_NOB = nob )
+#define __msc_get_nob() 	( REG_MSC_NOB )
+#define __msc_set_blklen(len) 	( REG_MSC_BLKLEN = len )
+#define __msc_set_cmdat(cmdat) 	( REG_MSC_CMDAT = cmdat )
+#define __msc_set_cmdat_ioabort() 	( REG_MSC_CMDAT |= MSC_CMDAT_IO_ABORT )
+#define __msc_clear_cmdat_ioabort() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_IO_ABORT )
+
+#define __msc_set_cmdat_bus_width1() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_1BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_bus_width4() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_4BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_dma_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DMA_EN )
+#define __msc_set_cmdat_init() 	( REG_MSC_CMDAT |= MSC_CMDAT_INIT )
+#define __msc_set_cmdat_busy() 	( REG_MSC_CMDAT |= MSC_CMDAT_BUSY )
+#define __msc_set_cmdat_stream() ( REG_MSC_CMDAT |= MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_block() ( REG_MSC_CMDAT &= ~MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_read() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_write() ( REG_MSC_CMDAT |= MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_data_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DATA_EN )
+
+/* r is MSC_CMDAT_RESPONSE_FORMAT_Rx or MSC_CMDAT_RESPONSE_FORMAT_NONE */
+#define __msc_set_cmdat_res_format(r) 				\
+do { 								\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_RESPONSE_FORMAT_MASK; 	\
+	REG_MSC_CMDAT |= (r); 					\
+} while(0)
+
+#define __msc_clear_cmdat() \
+  REG_MSC_CMDAT &= ~( MSC_CMDAT_IO_ABORT | MSC_CMDAT_DMA_EN | MSC_CMDAT_INIT| \
+  MSC_CMDAT_BUSY | MSC_CMDAT_STREAM_BLOCK | MSC_CMDAT_WRITE_READ | \
+  MSC_CMDAT_DATA_EN | MSC_CMDAT_RESPONSE_FORMAT_MASK )
+
+#define __msc_get_imask() 		( REG_MSC_IMASK )
+#define __msc_mask_all_intrs() 		( REG_MSC_IMASK = 0xff )
+#define __msc_unmask_all_intrs() 	( REG_MSC_IMASK = 0x00 )
+#define __msc_mask_rd() 		( REG_MSC_IMASK |= MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_unmask_rd() 		( REG_MSC_IMASK &= ~MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_mask_wr() 		( REG_MSC_IMASK |= MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_unmask_wr() 		( REG_MSC_IMASK &= ~MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_mask_endcmdres() 		( REG_MSC_IMASK |= MSC_IMASK_END_CMD_RES )
+#define __msc_unmask_endcmdres() 	( REG_MSC_IMASK &= ~MSC_IMASK_END_CMD_RES )
+#define __msc_mask_datatrandone() 	( REG_MSC_IMASK |= MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_unmask_datatrandone() 	( REG_MSC_IMASK &= ~MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_mask_prgdone() 		( REG_MSC_IMASK |= MSC_IMASK_PRG_DONE )
+#define __msc_unmask_prgdone() 		( REG_MSC_IMASK &= ~MSC_IMASK_PRG_DONE )
+
+/* n=0,1,2,3,4,5,6,7 */
+#define __msc_set_clkrt(n) 	\
+do { 				\
+	REG_MSC_CLKRT = n;	\
+} while(0)
+
+#define __msc_get_ireg() 		( REG_MSC_IREG )
+#define __msc_ireg_rd() 		( REG_MSC_IREG & MSC_IREG_RXFIFO_RD_REQ )
+#define __msc_ireg_wr() 		( REG_MSC_IREG & MSC_IREG_TXFIFO_WR_REQ )
+#define __msc_ireg_end_cmd_res() 	( REG_MSC_IREG & MSC_IREG_END_CMD_RES )
+#define __msc_ireg_data_tran_done() 	( REG_MSC_IREG & MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_prg_done() 		( REG_MSC_IREG & MSC_IREG_PRG_DONE )
+#define __msc_ireg_clear_end_cmd_res() 	( REG_MSC_IREG = MSC_IREG_END_CMD_RES )
+#define __msc_ireg_clear_data_tran_done() ( REG_MSC_IREG = MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_clear_prg_done() 	( REG_MSC_IREG = MSC_IREG_PRG_DONE )
+
+#define __msc_get_stat() 		( REG_MSC_STAT )
+#define __msc_stat_not_end_cmd_res() 	( (REG_MSC_STAT & MSC_STAT_END_CMD_RES) == 0)
+#define __msc_stat_crc_err() \
+  ( REG_MSC_STAT & (MSC_STAT_CRC_RES_ERR | MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR_YES) )
+#define __msc_stat_res_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_RES_ERR )
+#define __msc_stat_rd_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_READ_ERROR )
+#define __msc_stat_wr_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_WRITE_ERROR_YES )
+#define __msc_stat_resto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_RES )
+#define __msc_stat_rdto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_READ )
+
+#define __msc_rd_resfifo() 		( REG_MSC_RES )
+#define __msc_rd_rxfifo()  		( REG_MSC_RXFIFO )
+#define __msc_wr_txfifo(v)  		( REG_MSC_TXFIFO = v )
+
+#define __msc_reset() 						\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_RESET;			\
+ 	while (REG_MSC_STAT & MSC_STAT_IS_RESETTING);		\
+} while (0)
+
+#define __msc_start_clk() 					\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_START;	\
+} while (0)
+
+#define __msc_stop_clk() 					\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_STOP;	\
+} while (0)
+
+#define MMC_CLK 19169200
+#define SD_CLK  24576000
+
+/* msc_clk should little than pclk and little than clk retrieve from card */
+#define __msc_calc_clk_divisor(type,dev_clk,msc_clk,lv)		\
+do {								\
+	unsigned int rate, pclk, i;				\
+	pclk = dev_clk;						\
+	rate = type?SD_CLK:MMC_CLK;				\
+  	if (msc_clk && msc_clk < pclk)				\
+    		pclk = msc_clk;					\
+	i = 0;							\
+  	while (pclk < rate)					\
+    	{							\
+      		i ++;						\
+      		rate >>= 1;					\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+/* divide rate to little than or equal to 400kHz */
+#define __msc_calc_slow_clk_divisor(type, lv)			\
+do {								\
+	unsigned int rate, i;					\
+	rate = (type?SD_CLK:MMC_CLK)/1000/400;			\
+	i = 0;							\
+	while (rate > 0)					\
+    	{							\
+      		rate >>= 1;					\
+      		i ++;						\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+/***************************************************************************
+ * RTC
+ ***************************************************************************/
+
+#define __rtc_start()	                ( REG_RTC_RCR |= RTC_RCR_START )
+#define __rtc_stop()	                ( REG_RTC_RCR &= ~RTC_RCR_START )
+
+#define __rtc_enable_alarm()	        ( REG_RTC_RCR |= RTC_RCR_AE )
+#define __rtc_disable_alarm()	        ( REG_RTC_RCR &= ~RTC_RCR_AE )
+#define __rtc_enable_alarm_irq()	( REG_RTC_RCR |= RTC_RCR_AIE )
+#define __rtc_disable_alarm_irq()	( REG_RTC_RCR &= ~RTC_RCR_AIE )
+
+#define __rtc_enable_1hz_irq()		( REG_RTC_RCR |= RTC_RCR_HZIE )
+#define __rtc_disable_1hz_irq()		( REG_RTC_RCR &= ~RTC_RCR_HZIE )
+
+#define __rtc_is_alarm_flag()		( REG_RTC_RCR & RTC_RCR_AF )
+#define __rtc_is_1hz_flag()		( REG_RTC_RCR & RTC_RCR_HZ )
+#define __rtc_clear_alarm_flag()	( REG_RTC_RCR &= ~RTC_RCR_AF )
+#define __rtc_clear_1hz_flag()		( REG_RTC_RCR &= ~RTC_RCR_HZ )
+
+#define __rtc_set_second(s)	        ( REG_RTC_RSR = (s) )
+#define __rtc_get_second()	        REG_RTC_RSR
+#define __rtc_set_alarm(s)	        ( REG_RTC_RSAR = (s) )
+#define __rtc_get_alarm()	        REG_RTC_RSAR
+
+#define __rtc_adjust_1hz(f32k) \
+  ( REG_RTC_RGR = (REG_RTC_RGR & ~(RTC_REG_DIV_MASK | RTC_RGR_ADJ_MASK)) | f32k | 0 )
+#define __rtc_lock_1hz()	( REG_RTC_RGR |= RTC_RGR_LOCK )
+
+
+/***************************************************************************
+ * FIR
+ ***************************************************************************/
+
+/* enable/disable fir unit */
+#define __fir_enable()		( REG_FIR_CR1 |= FIR_CR1_FIRUE )
+#define __fir_disable()		( REG_FIR_CR1 &= ~FIR_CR1_FIRUE )
+
+/* enable/disable address comparison */
+#define __fir_enable_ac()	( REG_FIR_CR1 |= FIR_CR1_ACE )
+#define __fir_disable_ac()	( REG_FIR_CR1 &= ~FIR_CR1_ACE )
+
+/* select frame end mode as underrun or normal */
+#define __fir_set_eous()	( REG_FIR_CR1 |= FIR_CR1_EOUS )
+#define __fir_clear_eous()	( REG_FIR_CR1 &= ~FIR_CR1_EOUS )
+
+/* enable/disable transmitter idle interrupt */
+#define __fir_enable_tii()	( REG_FIR_CR1 |= FIR_CR1_TIIE )
+#define __fir_disable_tii()	( REG_FIR_CR1 &= ~FIR_CR1_TIIE )
+
+/* enable/disable transmit FIFO service request interrupt */
+#define __fir_enable_tfi()	( REG_FIR_CR1 |= FIR_CR1_TFIE )
+#define __fir_disable_tfi()	( REG_FIR_CR1 &= ~FIR_CR1_TFIE )
+
+/* enable/disable receive FIFO service request interrupt */
+#define __fir_enable_rfi()	( REG_FIR_CR1 |= FIR_CR1_RFIE )
+#define __fir_disable_rfi()	( REG_FIR_CR1 &= ~FIR_CR1_RFIE )
+
+/* enable/disable tx function */
+#define __fir_tx_enable()	( REG_FIR_CR1 |= FIR_CR1_TXE )
+#define __fir_tx_disable()	( REG_FIR_CR1 &= ~FIR_CR1_TXE )
+
+/* enable/disable rx function */
+#define __fir_rx_enable()	( REG_FIR_CR1 |= FIR_CR1_RXE )
+#define __fir_rx_disable()	( REG_FIR_CR1 &= ~FIR_CR1_RXE )
+
+
+/* enable/disable serial infrared interaction pulse (SIP) */
+#define __fir_enable_sip()	( REG_FIR_CR2 |= FIR_CR2_SIPE )
+#define __fir_disable_sip()	( REG_FIR_CR2 &= ~FIR_CR2_SIPE )
+
+/* un-inverted CRC value is sent out */
+#define __fir_enable_bcrc()	( REG_FIR_CR2 |= FIR_CR2_BCRC )
+
+/* inverted CRC value is sent out */
+#define __fir_disable_bcrc()	( REG_FIR_CR2 &= ~FIR_CR2_BCRC )
+
+/* enable/disable Transmit Frame Length Register */
+#define __fir_enable_tflr()	( REG_FIR_CR2 |= FIR_CR2_TFLRS )
+#define __fir_disable_tflr()	( REG_FIR_CR2 &= ~FIR_CR2_TFLRS )
+
+/* Preamble is transmitted in idle state */
+#define __fir_set_iss()	( REG_FIR_CR2 |= FIR_CR2_ISS )
+
+/* Abort symbol is transmitted in idle state */
+#define __fir_clear_iss()	( REG_FIR_CR2 &= ~FIR_CR2_ISS )
+
+/* enable/disable loopback mode */
+#define __fir_enable_loopback()	( REG_FIR_CR2 |= FIR_CR2_LMS )
+#define __fir_disable_loopback()	( REG_FIR_CR2 &= ~FIR_CR2_LMS )
+
+/* select transmit pin polarity */
+#define __fir_tpp_negative()	( REG_FIR_CR2 |= FIR_CR2_TPPS )
+#define __fir_tpp_positive()	( REG_FIR_CR2 &= ~FIR_CR2_TPPS )
+
+/* select receive pin polarity */
+#define __fir_rpp_negative()	( REG_FIR_CR2 |= FIR_CR2_RPPS )
+#define __fir_rpp_positive()	( REG_FIR_CR2 &= ~FIR_CR2_RPPS )
+
+/* n=16,32,64,128 */
+#define __fir_set_txfifo_trigger(n) 		\
+do { 						\
+	REG_FIR_CR2 &= ~FIR_CR2_TTRG_MASK;	\
+	REG_FIR_CR2 |= FIR_CR2_TTRG_##n;	\
+} while (0)
+
+/* n=16,32,64,128 */
+#define __fir_set_rxfifo_trigger(n) 		\
+do { 						\
+	REG_FIR_CR2 &= ~FIR_CR2_RTRG_MASK;	\
+	REG_FIR_CR2 |= FIR_CR2_RTRG_##n;	\
+} while (0)
+
+
+/* FIR status checking */
+
+#define __fir_test_rfw()	( REG_FIR_SR & FIR_SR_RFW )
+#define __fir_test_rfa()	( REG_FIR_SR & FIR_SR_RFA )
+#define __fir_test_tfrtl()	( REG_FIR_SR & FIR_SR_TFRTL )
+#define __fir_test_rfrtl()	( REG_FIR_SR & FIR_SR_RFRTL )
+#define __fir_test_urun()	( REG_FIR_SR & FIR_SR_URUN )
+#define __fir_test_rfte()	( REG_FIR_SR & FIR_SR_RFTE )
+#define __fir_test_orun()	( REG_FIR_SR & FIR_SR_ORUN )
+#define __fir_test_crce()	( REG_FIR_SR & FIR_SR_CRCE )
+#define __fir_test_fend()	( REG_FIR_SR & FIR_SR_FEND )
+#define __fir_test_tff()	( REG_FIR_SR & FIR_SR_TFF )
+#define __fir_test_rfe()	( REG_FIR_SR & FIR_SR_RFE )
+#define __fir_test_tidle()	( REG_FIR_SR & FIR_SR_TIDLE )
+#define __fir_test_rb()		( REG_FIR_SR & FIR_SR_RB )
+
+#define __fir_clear_status()					\
+do { 								\
+	REG_FIR_SR |= FIR_SR_RFW | FIR_SR_RFA | FIR_SR_URUN;	\
+} while (0)
+
+#define __fir_clear_rfw()	( REG_FIR_SR |= FIR_SR_RFW )
+#define __fir_clear_rfa()	( REG_FIR_SR |= FIR_SR_RFA )
+#define __fir_clear_urun()	( REG_FIR_SR |= FIR_SR_URUN )
+
+#define __fir_set_tflr(len)			\
+do { 						\
+	REG_FIR_TFLR = len; 			\
+} while (0)
+
+#define __fir_set_addr(a)	( REG_FIR_AR = (a) )
+
+#define __fir_write_data(data)	( REG_FIR_TDR = data )
+#define __fir_read_data(data)	( data = REG_FIR_RDR )
+
+/***************************************************************************
+ * SCC
+ ***************************************************************************/
+
+#define __scc_enable(base)	( REG_SCC_CR(base) |= SCC_CR_SCCE )
+#define __scc_disable(base)	( REG_SCC_CR(base) &= ~SCC_CR_SCCE )
+
+#define __scc_set_tx_mode(base)	( REG_SCC_CR(base) |= SCC_CR_TRS )
+#define __scc_set_rx_mode(base)	( REG_SCC_CR(base) &= ~SCC_CR_TRS )
+
+#define __scc_enable_t2r(base)	( REG_SCC_CR(base) |= SCC_CR_T2R )
+#define __scc_disable_t2r(base)	( REG_SCC_CR(base) &= ~SCC_CR_T2R )
+
+#define __scc_clk_as_devclk(base)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_FDIV_MASK;	\
+  REG_SCC_CR(base) |= SCC_CR_FDIV_1;		\
+} while (0)
+
+#define __scc_clk_as_half_devclk(base)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_FDIV_MASK;	\
+  REG_SCC_CR(base) |= SCC_CR_FDIV_2;		\
+} while (0)
+
+/* n=1,4,8,14 */
+#define __scc_set_fifo_trigger(base, n)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_TRIG_MASK;	\
+  REG_SCC_CR(base) |= SCC_CR_TRIG_##n;		\
+} while (0)
+
+#define __scc_set_protocol(base, p)		\
+do {						\
+	if (p)					\
+	  	REG_SCC_CR(base) |= SCC_CR_TP;	\
+	else					\
+	 	REG_SCC_CR(base) &= ~SCC_CR_TP;	\
+} while (0)
+
+#define __scc_flush_fifo(base)	( REG_SCC_CR(base) |= SCC_CR_FLUSH )
+
+#define __scc_set_invert_mode(base)	( REG_SCC_CR(base) |= SCC_CR_CONV )
+#define __scc_set_direct_mode(base)	( REG_SCC_CR(base) &= ~SCC_CR_CONV )
+
+#define SCC_ERR_INTRS \
+    ( SCC_CR_ECIE | SCC_CR_EPIE | SCC_CR_RETIE | SCC_CR_EOIE )
+#define SCC_ALL_INTRS \
+    ( SCC_CR_TXIE | SCC_CR_RXIE | SCC_CR_TENDIE | SCC_CR_RTOIE | \
+      SCC_CR_ECIE | SCC_CR_EPIE | SCC_CR_RETIE | SCC_CR_EOIE )
+
+#define __scc_enable_err_intrs(base)	( REG_SCC_CR(base) |= SCC_ERR_INTRS )
+#define __scc_disable_err_intrs(base)	( REG_SCC_CR(base) &= ~SCC_ERR_INTRS )
+
+#define SCC_ALL_ERRORS \
+    ( SCC_SR_ORER | SCC_SR_RTO | SCC_SR_PER | SCC_SR_RETR_3 | SCC_SR_ECNTO)
+
+#define __scc_clear_errors(base)	( REG_SCC_SR(base) &= ~SCC_ALL_ERRORS )
+
+#define __scc_enable_all_intrs(base)	( REG_SCC_CR(base) |= SCC_ALL_INTRS )
+#define __scc_disable_all_intrs(base)	( REG_SCC_CR(base) &= ~SCC_ALL_INTRS )
+
+#define __scc_enable_tx_intr(base)	( REG_SCC_CR(base) |= SCC_CR_TXIE | SCC_CR_TENDIE )
+#define __scc_disable_tx_intr(base)	( REG_SCC_CR(base) &= ~(SCC_CR_TXIE | SCC_CR_TENDIE) )
+
+#define __scc_enable_rx_intr(base)	( REG_SCC_CR(base) |= SCC_CR_RXIE)
+#define __scc_disable_rx_intr(base)	( REG_SCC_CR(base) &= ~SCC_CR_RXIE)
+
+#define __scc_set_tsend(base)		( REG_SCC_CR(base) |= SCC_CR_TSEND )
+#define __scc_clear_tsend(base)		( REG_SCC_CR(base) &= ~SCC_CR_TSEND )
+
+#define __scc_set_clockstop(base)	( REG_SCC_CR(base) |= SCC_CR_CLKSTP )
+#define __scc_clear_clockstop(base)	( REG_SCC_CR(base) &= ~SCC_CR_CLKSTP )
+
+#define __scc_clockstop_low(base)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_PX_MASK;		\
+  REG_SCC_CR(base) |= SCC_CR_PX_STOP_LOW;	\
+} while (0)
+
+#define __scc_clockstop_high(base)		\
+do {						\
+  REG_SCC_CR(base) &= ~SCC_CR_PX_MASK;		\
+  REG_SCC_CR(base) |= SCC_CR_PX_STOP_HIGH;	\
+} while (0)
+
+
+/* SCC status checking */
+#define __scc_check_transfer_status(base)  ( REG_SCC_SR(base) & SCC_SR_TRANS )
+#define __scc_check_rx_overrun_error(base) ( REG_SCC_SR(base) & SCC_SR_ORER )
+#define __scc_check_rx_timeout(base)	   ( REG_SCC_SR(base) & SCC_SR_RTO )
+#define __scc_check_parity_error(base)	   ( REG_SCC_SR(base) & SCC_SR_PER )
+#define __scc_check_txfifo_trigger(base)   ( REG_SCC_SR(base) & SCC_SR_TFTG )
+#define __scc_check_rxfifo_trigger(base)   ( REG_SCC_SR(base) & SCC_SR_RFTG )
+#define __scc_check_tx_end(base)	   ( REG_SCC_SR(base) & SCC_SR_TEND )
+#define __scc_check_retx_3(base)	   ( REG_SCC_SR(base) & SCC_SR_RETR_3 )
+#define __scc_check_ecnt_overflow(base)	   ( REG_SCC_SR(base) & SCC_SR_ECNTO )
+
+
+/***************************************************************************
+ * WDT
+ ***************************************************************************/
+
+#define __wdt_set_count(count) ( REG_WDT_WTCNT = (count) )
+#define __wdt_start()          ( REG_WDT_WTCSR |= WDT_WTCSR_START )
+#define __wdt_stop()           ( REG_WDT_WTCSR &= ~WDT_WTCSR_START )
+
+
+/***************************************************************************
+ * OST
+ ***************************************************************************/
+
+#define __ost_enable_all()         ( REG_OST_TER |= 0x07 )
+#define __ost_disable_all()        ( REG_OST_TER &= ~0x07 )
+#define __ost_enable_channel(n)    ( REG_OST_TER |= (1 << (n)) )
+#define __ost_disable_channel(n)   ( REG_OST_TER &= ~(1 << (n)) )
+#define __ost_set_reload(n, val)   ( REG_OST_TRDR(n) = (val) )
+#define __ost_set_count(n, val)    ( REG_OST_TCNT(n) = (val) )
+#define __ost_get_count(n)         ( REG_OST_TCNT(n) )
+#define __ost_set_clock(n, cs)			\
+do {						\
+    REG_OST_TCSR(n) &= ~OST_TCSR_CKS_MASK; 	\
+    REG_OST_TCSR(n) |= cs; 			\
+} while (0)
+#define __ost_set_mode(n, val)     ( REG_OST_TCSR(n) = (val) )
+#define __ost_enable_interrupt(n)  ( REG_OST_TCSR(n) |= OST_TCSR_UIE )
+#define __ost_disable_interrupt(n) ( REG_OST_TCSR(n) &= ~OST_TCSR_UIE )
+#define __ost_uf_detected(n)       ( REG_OST_TCSR(n) & OST_TCSR_UF )
+#define __ost_clear_uf(n)          ( REG_OST_TCSR(n) &= ~OST_TCSR_UF )
+#define __ost_is_busy(n)           ( REG_OST_TCSR(n) & OST_TCSR_BUSY )
+#define __ost_clear_busy(n)        ( REG_OST_TCSR(n) &= ~OST_TCSR_BUSY )
+
+
+/***************************************************************************
+ * UART
+ ***************************************************************************/
+
+#define __uart_enable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) |= UARTFCR_UUE | UARTFCR_FE )
+#define __uart_disable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) = ~UARTFCR_UUE )
+
+#define __uart_enable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_TIE )
+#define __uart_disable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~UARTIER_TIE )
+
+#define __uart_enable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE )
+#define __uart_disable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~(UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE) )
+
+#define __uart_enable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) |= UARTMCR_LOOP )
+#define __uart_disable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) &= ~UARTMCR_LOOP )
+
+#define __uart_set_8n1(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) = UARTLCR_WLEN_8 )
+
+#define __uart_set_baud(n, devclk, baud)						\
+  do {											\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) |= UARTLCR_DLAB;			\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLLR) = (devclk / 16 / baud) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLHR) = ((devclk / 16 / baud) >> 8) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) &= ~UARTLCR_DLAB;			\
+  } while (0)
+
+#define __uart_parity_error(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_PER) != 0 )
+
+#define __uart_clear_errors(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) &= ~(UARTLSR_ORER | UARTLSR_BRK | UARTLSR_FER | UARTLSR_PER | UARTLSR_RFER) )
+
+#define __uart_transmit_fifo_empty(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TDRQ) != 0 )
+
+#define __uart_transmit_end(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TEMT) != 0 )
+
+#define __uart_transmit_char(n, ch) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_TDR) = (ch)
+
+#define __uart_receive_fifo_full(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_ready(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_char(n) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_RDR)
+
+#define __uart_disable_irda() \
+  ( REG8(IRDA_BASE + OFF_SIRCR) &= ~(SIRCR_TSIRE | SIRCR_RSIRE) )
+#define __uart_enable_irda() \
+  /* Tx high pulse as 0, Rx low pulse as 0 */ \
+  ( REG8(IRDA_BASE + OFF_SIRCR) = SIRCR_TSIRE | SIRCR_RSIRE | SIRCR_RXPL | SIRCR_TPWS )
+
+
+/***************************************************************************
+ * INTC
+ ***************************************************************************/
+#define __intc_unmask_irq(n)	( REG_INTC_IMCR = (1 << (n)) )
+#define __intc_mask_irq(n)	( REG_INTC_IMSR = (1 << (n)) )
+#define __intc_ack_irq(n)	( REG_INTC_IPR = (1 << (n)) )
+
+/***************************************************************************
+ * CIM
+ ***************************************************************************/
+
+#define __cim_enable()	( REG_CIM_CTRL |= CIM_CTRL_ENA )
+#define __cim_disable()	( REG_CIM_CTRL &= ~CIM_CTRL_ENA )
+
+#define __cim_input_data_inverse()	( REG_CIM_CFG |= CIM_CFG_INV_DAT )
+#define __cim_input_data_normal()	( REG_CIM_CFG &= ~CIM_CFG_INV_DAT )
+
+#define __cim_vsync_active_low()	( REG_CIM_CFG |= CIM_CFG_VSP )
+#define __cim_vsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_VSP )
+
+#define __cim_hsync_active_low()	( REG_CIM_CFG |= CIM_CFG_HSP )
+#define __cim_hsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_HSP )
+
+#define __cim_sample_data_at_pclk_falling_edge() \
+  ( REG_CIM_CFG |= CIM_CFG_PCP )
+#define __cim_sample_data_at_pclk_rising_edge() \
+  ( REG_CIM_CFG &= ~CIM_CFG_PCP )
+
+#define __cim_enable_dummy_zero()	( REG_CIM_CFG |= CIM_CFG_DUMMY_ZERO )
+#define __cim_disable_dummy_zero()	( REG_CIM_CFG &= ~CIM_CFG_DUMMY_ZERO )
+
+#define __cim_select_external_vsync()	( REG_CIM_CFG |= CIM_CFG_EXT_VSYNC )
+#define __cim_select_internal_vsync()	( REG_CIM_CFG &= ~CIM_CFG_EXT_VSYNC )
+
+/* n=0-7 */
+#define __cim_set_data_packing_mode(n) 		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_PACK_MASK; 		\
+    REG_CIM_CFG |= (CIM_CFG_PACK_##n); 		\
+} while (0)
+
+#define __cim_enable_ccir656_progressive_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CPM; 		\
+} while (0)
+
+#define __cim_enable_ccir656_interlace_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CIM; 		\
+} while (0)
+
+#define __cim_enable_gated_clock_mode()		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_GCM; 		\
+} while (0)
+
+#define __cim_enable_nongated_clock_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_NGCM; 		\
+} while (0)
+
+/* sclk:system bus clock
+ * mclk: CIM master clock
+ */
+#define __cim_set_master_clk(sclk, mclk)			\
+do {								\
+    REG_CIM_CTRL &= ~CIM_CTRL_MCLKDIV_MASK;			\
+    REG_CIM_CTRL |= (((sclk)/(mclk) - 1) << CIM_CTRL_MCLKDIV_BIT);	\
+} while (0)
+
+#define __cim_enable_sof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_SOFM )
+#define __cim_disable_sof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_SOFM )
+
+#define __cim_enable_eof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_EOFM )
+#define __cim_disable_eof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EOFM )
+
+#define __cim_enable_stop_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_STOPM )
+#define __cim_disable_stop_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_STOPM )
+
+#define __cim_enable_trig_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_TRIGM )
+#define __cim_disable_trig_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIGM )
+
+#define __cim_enable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_OFM )
+#define __cim_disable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_OFM )
+
+/* n=1-16 */
+#define __cim_set_frame_rate(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_FRC_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_FRC_##n; 		\
+} while (0)
+
+#define __cim_enable_dma()   ( REG_CIM_CTRL |= CIM_CTRL_DMA_EN )
+#define __cim_disable_dma()  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EN )
+
+#define __cim_reset_rxfifo() ( REG_CIM_CTRL |= CIM_CTRL_RXF_RST )
+#define __cim_unreset_rxfifo() ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_RST )
+
+/* n=4,8,12,16,20,24,28,32 */
+#define __cim_set_rxfifo_trigger(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIG_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_RXF_TRIG_##n; 	\
+} while (0)
+
+#define __cim_clear_state()   	     ( REG_CIM_STATE = 0 )
+
+#define __cim_disable_done()   	     ( REG_CIM_STATE & CIM_STATE_VDD )
+#define __cim_rxfifo_empty()   	     ( REG_CIM_STATE & CIM_STATE_RXF_EMPTY )
+#define __cim_rxfifo_reach_trigger() ( REG_CIM_STATE & CIM_STATE_RXF_TRIG )
+#define __cim_rxfifo_overflow()      ( REG_CIM_STATE & CIM_STATE_RXF_OF )
+#define __cim_clear_rxfifo_overflow() ( REG_CIM_STATE &= ~CIM_STATE_RXF_OF )
+#define __cim_dma_stop()   	     ( REG_CIM_STATE & CIM_STATE_DMA_STOP )
+#define __cim_dma_eof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_EOF )
+#define __cim_dma_sof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_SOF )
+
+#define __cim_get_iid()   	     ( REG_CIM_IID )
+#define __cim_get_image_data()       ( REG_CIM_RXFIFO )
+#define __cim_get_dam_cmd()          ( REG_CIM_CMD )
+
+#define __cim_set_da(a)              ( REG_CIM_DA = (a) )
+
+/***************************************************************************
+ * PWM
+ ***************************************************************************/
+
+/* n is the pwm channel (0,1,..) */
+#define __pwm_enable_module(n)		( REG_PWM_CTR(n) |= PWM_CTR_EN )
+#define __pwm_disable_module(n)		( REG_PWM_CTR(n) &= ~PWM_CTR_EN )
+#define __pwm_graceful_shutdown_mode(n)	( REG_PWM_CTR(n) &= ~PWM_CTR_SD )
+#define __pwm_abrupt_shutdown_mode(n)	( REG_PWM_CTR(n) |= PWM_CTR_SD )
+#define __pwm_set_full_duty(n)		( REG_PWM_DUT(n) |= PWM_DUT_FDUTY )
+
+#define __pwm_set_prescale(n, p) \
+  ( REG_PWM_CTR(n) = ((REG_PWM_CTR(n) & ~PWM_CTR_PRESCALE_MASK) | (p) ) )
+#define __pwm_set_period(n, p) \
+  ( REG_PWM_PER(n) = ( (REG_PWM_PER(n) & ~PWM_PER_PERIOD_MASK) | (p) ) )
+#define __pwm_set_duty(n, d) \
+  ( REG_PWM_DUT(n) = ( (REG_PWM_DUT(n) & ~(PWM_DUT_FDUTY | PWM_DUT_DUTY_MASK)) | (d) ) )
+
+/***************************************************************************
+ * EMC
+ ***************************************************************************/
+
+#define __emc_enable_split() ( REG_EMC_BCR = EMC_BCR_BRE )
+#define __emc_disable_split() ( REG_EMC_BCR = 0 )
+
+#define __emc_smem_bus_width(n) /* 8, 16 or 32*/		\
+	( REG_EMC_SMCR = (REG_EMC_SMCR & EMC_SMCR_BW_MASK) |	\
+			 EMC_SMCR_BW_##n##BIT )
+#define __emc_smem_byte_control() \
+	( REG_EMC_SMCR = (REG_EMC_SMCR | EMC_SMCR_BCM )
+#define __emc_normal_smem() \
+	( REG_EMC_SMCR = (REG_EMC_SMCR & ~EMC_SMCR_SMT )
+#define __emc_burst_smem() \
+	( REG_EMC_SMCR = (REG_EMC_SMCR | EMC_SMCR_SMT )
+#define __emc_smem_burstlen(n) /* 4, 8, 16 or 32 */ \
+	( REG_EMC_SMCR = (REG_EMC_SMCR & EMC_SMCR_BL_MASK) | (EMC_SMCR_BL_##n )
+
+/***************************************************************************
+ * GPIO
+ ***************************************************************************/
+
+/* p is the port number (0,1,2,3)
+ * o is the pin offset (0-31) inside the port
+ * n is the absolute number of a pin (0-124), regardless of the port
+ * m is the interrupt manner (low/high/falling/rising)
+ */
+
+#define __gpio_port_data(p)	( REG_GPIO_GPDR(p) )
+
+#define __gpio_port_as_output(p, o)		\
+do {						\
+    unsigned int tmp;				\
+    REG_GPIO_GPIER(p) &= ~(1 << (o));		\
+    REG_GPIO_GPDIR(p) |= (1 << (o));		\
+    if (o < 16) {				\
+	tmp = REG_GPIO_GPALR(p);		\
+	tmp &= ~(3 << ((o) << 1));		\
+	REG_GPIO_GPALR(p) = tmp;		\
+    } else {					\
+	tmp = REG_GPIO_GPAUR(p);		\
+	tmp &= ~(3 << (((o) - 16)<< 1));	\
+	REG_GPIO_GPAUR(p) = tmp;		\
+    }						\
+} while (0)
+
+#define __gpio_port_as_input(p, o)		\
+do {						\
+    unsigned int tmp;				\
+    REG_GPIO_GPIER(p) &= ~(1 << (o));		\
+    REG_GPIO_GPDIR(p) &= ~(1 << (o));		\
+    if (o < 16) {				\
+	tmp = REG_GPIO_GPALR(p);		\
+	tmp &= ~(3 << ((o) << 1));		\
+	REG_GPIO_GPALR(p) = tmp;		\
+    } else {					\
+	tmp = REG_GPIO_GPAUR(p);		\
+	tmp &= ~(3 << (((o) - 16)<< 1));	\
+	REG_GPIO_GPAUR(p) = tmp;		\
+    }						\
+} while (0)
+
+#define __gpio_as_output(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_output(p, o);		\
+} while (0)
+
+#define __gpio_as_input(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_input(p, o);		\
+} while (0)
+
+#define __gpio_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_data(p) |= (1 << o);	\
+} while (0)
+
+#define __gpio_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_data(p) &= ~(1 << o);	\
+} while (0)
+
+static __inline__ unsigned int __gpio_get_pin(unsigned int n)
+{
+	unsigned int p, o;
+	p = (n) / 32;
+	o = (n) % 32;
+	if (__gpio_port_data(p) & (1 << o))
+		return 1;
+	else
+		return 0;
+}
+
+#define __gpio_set_irq_detect_manner(p, o, m)	\
+do {						\
+    unsigned int tmp;				\
+    if (o < 16) {				\
+	tmp = REG_GPIO_GPIDLR(p);		\
+	tmp &= ~(3 << ((o) << 1));		\
+	tmp |= ((m) << ((o) << 1));		\
+	REG_GPIO_GPIDLR(p) = tmp;		\
+    } else {					\
+	tmp = REG_GPIO_GPIDUR(p);		\
+	tmp &= ~(3 << (((o)-16) << 1));		\
+	tmp |= ((m) << (((o)-16) << 1));		\
+	REG_GPIO_GPIDUR(p) = tmp;		\
+    }						\
+} while (0)
+
+#define __gpio_port_as_irq(p, o, m)		\
+do {						\
+    __gpio_port_as_input(p, o);			\
+    __gpio_set_irq_detect_manner(p, o, m);  	\
+} while (0)
+
+#define __gpio_as_irq(n, m)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+        __gpio_port_as_irq(p, o, m);  		\
+} while (0)
+
+
+#define __gpio_as_irq_high_level(n)	__gpio_as_irq(n, GPIO_IRQ_HILEVEL)
+#define __gpio_as_irq_low_level(n)	__gpio_as_irq(n, GPIO_IRQ_LOLEVEL)
+#define __gpio_as_irq_fall_edge(n)	__gpio_as_irq(n, GPIO_IRQ_FALLEDG)
+#define __gpio_as_irq_rise_edge(n)	__gpio_as_irq(n, GPIO_IRQ_RAISEDG)
+
+
+#define __gpio_mask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPIER(p) &= ~(1 << o);		\
+} while (0)
+
+#define __gpio_unmask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPIER(p) |= (1 << o);		\
+} while (0)
+
+#define __gpio_ack_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPFR(p) |= (1 << o);		\
+} while (0)
+
+
+static __inline__ unsigned int __gpio_get_irq(void)
+{
+	unsigned int tmp, i;
+
+	tmp = REG_GPIO_GPFR(3);
+	for (i=0; i<32; i++)
+		if (tmp & (1 << i))
+			return 0x60 + i;
+	tmp = REG_GPIO_GPFR(2);
+	for (i=0; i<32; i++)
+		if (tmp & (1 << i))
+			return 0x40 + i;
+	tmp = REG_GPIO_GPFR(1);
+	for (i=0; i<32; i++)
+		if (tmp & (1 << i))
+			return 0x20 + i;
+	tmp = REG_GPIO_GPFR(0);
+	for (i=0; i<32; i++)
+		if (tmp & (1 << i))
+			return i;
+	return 0;
+}
+
+#define __gpio_group_irq(n)			\
+({						\
+	register int tmp, i;			\
+	tmp = REG_GPIO_GPFR((n));		\
+	for (i=31;i>=0;i--)			\
+		if (tmp & (1 << i))		\
+			break;			\
+	i;					\
+})
+
+#define __gpio_enable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPPUR(p) |= (1 << o);		\
+} while (0)
+
+#define __gpio_disable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_GPPUR(p) &= ~(1 << o);		\
+} while (0)
+
+
+/* Init the alternate function pins */
+
+
+#define __gpio_as_ssi()				\
+do {						\
+	REG_GPIO_GPALR(2) &= 0xFC00FFFF;	\
+	REG_GPIO_GPALR(2) |= 0x01550000;	\
+} while (0)
+
+#define __gpio_as_uart3()			\
+do {						\
+	REG_GPIO_GPAUR(0) &= 0xFFFF0000;	\
+	REG_GPIO_GPAUR(0) |= 0x00005555;	\
+} while (0)
+
+#define __gpio_as_uart2()			\
+do {						\
+	REG_GPIO_GPALR(3) &= 0x3FFFFFFF;	\
+	REG_GPIO_GPALR(3) |= 0x40000000;	\
+	REG_GPIO_GPAUR(3) &= 0xF3FFFFFF;	\
+	REG_GPIO_GPAUR(3) |= 0x04000000;	\
+} while (0)
+
+#define __gpio_as_uart1()			\
+do {						\
+	REG_GPIO_GPAUR(0) &= 0xFFF0FFFF;	\
+	REG_GPIO_GPAUR(0) |= 0x00050000;	\
+} while (0)
+
+#define __gpio_as_uart0()			\
+do {						\
+	REG_GPIO_GPAUR(3) &= 0x0FFFFFFF;	\
+	REG_GPIO_GPAUR(3) |= 0x50000000;	\
+} while (0)
+
+
+#define __gpio_as_scc0()			\
+do {						\
+	REG_GPIO_GPALR(2) &= 0xFFFFFFCC;	\
+	REG_GPIO_GPALR(2) |= 0x00000011;	\
+} while (0)
+
+#define __gpio_as_scc1()			\
+do {						\
+	REG_GPIO_GPALR(2) &= 0xFFFFFF33;	\
+	REG_GPIO_GPALR(2) |= 0x00000044;	\
+} while (0)
+
+#define __gpio_as_scc()				\
+do {						\
+	__gpio_as_scc0();			\
+	__gpio_as_scc1();			\
+} while (0)
+
+#define __gpio_as_dma()				\
+do {						\
+	REG_GPIO_GPALR(0) &= 0x00FFFFFF;	\
+	REG_GPIO_GPALR(0) |= 0x55000000;	\
+	REG_GPIO_GPAUR(0) &= 0xFF0FFFFF;	\
+	REG_GPIO_GPAUR(0) |= 0x00500000;	\
+} while (0)
+
+#define __gpio_as_msc()				\
+do {						\
+	REG_GPIO_GPALR(1) &= 0xFFFF000F;	\
+	REG_GPIO_GPALR(1) |= 0x00005550;	\
+} while (0)
+
+#define __gpio_as_pcmcia()			\
+do {						\
+	REG_GPIO_GPAUR(2) &= 0xF000FFFF;	\
+	REG_GPIO_GPAUR(2) |= 0x05550000;	\
+} while (0)
+
+#define __gpio_as_emc(csmask)			\
+do {						\
+	REG_GPIO_GPALR(2) &= 0x3FFFFFFF;	\
+	REG_GPIO_GPALR(2) |= 0x40000000;	\
+	REG_GPIO_GPAUR(2) &= 0xFFFF0000;	\
+	REG_GPIO_GPAUR(2) |= 0x00005555;	\
+} while (0)
+
+#define __gpio_as_lcd_slave()			\
+do {						\
+	REG_GPIO_GPALR(1) &= 0x0000FFFF;	\
+	REG_GPIO_GPALR(1) |= 0x55550000;	\
+	REG_GPIO_GPAUR(1) &= 0x00000000;	\
+	REG_GPIO_GPAUR(1) |= 0x55555555;	\
+} while (0)
+
+#define __gpio_as_lcd_master()			\
+do {						\
+	REG_GPIO_GPALR(1) &= 0x0000FFFF;	\
+	REG_GPIO_GPALR(1) |= 0x55550000;	\
+	REG_GPIO_GPAUR(1) &= 0x00000000;	\
+	REG_GPIO_GPAUR(1) |= 0x556A5555;	\
+} while (0)
+
+#define __gpio_as_usb()				\
+do {						\
+	REG_GPIO_GPAUR(0) &= 0x00FFFFFF;	\
+	REG_GPIO_GPAUR(0) |= 0x55000000;	\
+} while (0)
+
+#define __gpio_as_ac97()			\
+do {						\
+	REG_GPIO_GPALR(2) &= 0xC3FF03FF;	\
+	REG_GPIO_GPALR(2) |= 0x24005400;	\
+} while (0)
+
+#define __gpio_as_i2s_slave()			\
+do {						\
+	REG_GPIO_GPALR(2) &= 0xC3FF0CFF;	\
+	REG_GPIO_GPALR(2) |= 0x14005100;	\
+} while (0)
+
+#define __gpio_as_i2s_master()			\
+do {						\
+	REG_GPIO_GPALR(2) &= 0xC3FF0CFF;	\
+	REG_GPIO_GPALR(2) |= 0x28005100;	\
+} while (0)
+
+#define __gpio_as_eth()				\
+do {						\
+	REG_GPIO_GPAUR(3) &= 0xFC000000;	\
+	REG_GPIO_GPAUR(3) |= 0x01555555;	\
+} while (0)
+
+#define __gpio_as_pwm()				\
+do {						\
+	REG_GPIO_GPAUR(2) &= 0x0FFFFFFF;	\
+	REG_GPIO_GPAUR(2) |= 0x50000000;	\
+} while (0)
+
+#define __gpio_as_ps2()				\
+do {						\
+	REG_GPIO_GPALR(1) &= 0xFFFFFFF0;	\
+	REG_GPIO_GPALR(1) |= 0x00000005;	\
+} while (0)
+
+#define __gpio_as_uprt()			\
+do {						\
+	REG_GPIO_GPALR(1) &= 0x0000000F;	\
+	REG_GPIO_GPALR(1) |= 0x55555550;	\
+	REG_GPIO_GPALR(3) &= 0xC0000000;	\
+	REG_GPIO_GPALR(3) |= 0x15555555;	\
+} while (0)
+
+#define __gpio_as_cim()				\
+do {						\
+	REG_GPIO_GPALR(0) &= 0xFF000000;	\
+	REG_GPIO_GPALR(0) |= 0x00555555;	\
+} while (0)
+
+/***************************************************************************
+ * HARB
+ ***************************************************************************/
+
+#define __harb_usb0_udc()			\
+do {						\
+  REG_HARB_HAPOR &= ~HARB_HAPOR_UCHSEL; 	\
+} while (0)
+
+#define __harb_usb0_uhc()			\
+do {						\
+  REG_HARB_HAPOR |= HARB_HAPOR_UCHSEL; 		\
+} while (0)
+
+#define __harb_set_priority(n)			\
+do {						\
+  REG_HARB_HAPOR = ((REG_HARB_HAPOR & ~HARB_HAPOR_PRIO_MASK) | n);	\
+} while (0)
+
+/***************************************************************************
+ * I2C
+ ***************************************************************************/
+
+#define __i2c_enable()		( REG_I2C_CR |= I2C_CR_I2CE )
+#define __i2c_disable()		( REG_I2C_CR &= ~I2C_CR_I2CE )
+
+#define __i2c_send_start()	( REG_I2C_CR |= I2C_CR_STA )
+#define __i2c_send_stop()	( REG_I2C_CR |= I2C_CR_STO )
+#define __i2c_send_ack()	( REG_I2C_CR &= ~I2C_CR_AC )
+#define __i2c_send_nack()	( REG_I2C_CR |= I2C_CR_AC )
+
+#define __i2c_set_drf()		( REG_I2C_SR |= I2C_SR_DRF )
+#define __i2c_clear_drf()	( REG_I2C_SR &= ~I2C_SR_DRF )
+#define __i2c_check_drf()	( REG_I2C_SR & I2C_SR_DRF )
+
+#define __i2c_received_ack()	( !(REG_I2C_SR & I2C_SR_ACKF) )
+#define __i2c_is_busy()		( REG_I2C_SR & I2C_SR_BUSY )
+#define __i2c_transmit_ended()	( REG_I2C_SR & I2C_SR_TEND )
+
+#define __i2c_set_clk(dev_clk, i2c_clk) \
+  ( REG_I2C_GR = (dev_clk) / (16*(i2c_clk)) - 1 )
+
+#define __i2c_read()		( REG_I2C_DR )
+#define __i2c_write(val)	( REG_I2C_DR = (val) )
+
+/***************************************************************************
+ * UDC
+ ***************************************************************************/
+
+#define __udc_set_16bit_phy()		( REG_UDC_DevCFGR |= UDC_DevCFGR_PI )
+#define __udc_set_8bit_phy()		( REG_UDC_DevCFGR &= ~UDC_DevCFGR_PI )
+
+#define __udc_enable_sync_frame()	( REG_UDC_DevCFGR |= UDC_DevCFGR_SS )
+#define __udc_disable_sync_frame()	( REG_UDC_DevCFGR &= ~UDC_DevCFGR_SS )
+
+#define __udc_self_powered()		( REG_UDC_DevCFGR |= UDC_DevCFGR_SP )
+#define __udc_bus_powered()		( REG_UDC_DevCFGR &= ~UDC_DevCFGR_SP )
+
+#define __udc_enable_remote_wakeup()	( REG_UDC_DevCFGR |= UDC_DevCFGR_RW )
+#define __udc_disable_remote_wakeup()	( REG_UDC_DevCFGR &= ~UDC_DevCFGR_RW )
+
+#define __udc_set_speed_high()				\
+do {							\
+	REG_UDC_DevCFGR &= ~UDC_DevCFGR_SPD_MASK;	\
+	REG_UDC_DevCFGR |= UDC_DevCFGR_SPD_HS;		\
+} while (0)
+
+#define __udc_set_speed_full()				\
+do {							\
+	REG_UDC_DevCFGR &= ~UDC_DevCFGR_SPD_MASK;	\
+	REG_UDC_DevCFGR |= UDC_DevCFGR_SPD_FS;		\
+} while (0)
+
+#define __udc_set_speed_low()				\
+do {							\
+	REG_UDC_DevCFGR &= ~UDC_DevCFGR_SPD_MASK;	\
+	REG_UDC_DevCFGR |= UDC_DevCFGR_SPD_LS;		\
+} while (0)
+
+
+#define __udc_set_dma_mode()		( REG_UDC_DevCR |= UDC_DevCR_DM )
+#define __udc_set_slave_mode()		( REG_UDC_DevCR &= ~UDC_DevCR_DM )
+#define __udc_set_big_endian()		( REG_UDC_DevCR |= UDC_DevCR_BE )
+#define __udc_set_little_endian()	( REG_UDC_DevCR &= ~UDC_DevCR_BE )
+#define __udc_generate_resume()		( REG_UDC_DevCR |= UDC_DevCR_RES )
+#define __udc_clear_resume()		( REG_UDC_DevCR &= ~UDC_DevCR_RES )
+
+
+#define __udc_get_enumarated_speed()	( REG_UDC_DevSR & UDC_DevSR_ENUMSPD_MASK )
+#define __udc_suspend_detected()	( REG_UDC_DevSR & UDC_DevSR_SUSP )
+#define __udc_get_alternate_setting()	( (REG_UDC_DevSR & UDC_DevSR_ALT_MASK) >> UDC_DevSR_ALT_BIT )
+#define __udc_get_interface_number()	( (REG_UDC_DevSR & UDC_DevSR_INTF_MASK) >> UDC_DevSR_INTF_BIT )
+#define __udc_get_config_number()	( (REG_UDC_DevSR & UDC_DevSR_CFG_MASK) >> UDC_DevSR_CFG_BIT )
+
+
+#define __udc_sof_detected(r)		( (r) & UDC_DevIntR_SOF )
+#define __udc_usb_suspend_detected(r)	( (r) & UDC_DevIntR_US )
+#define __udc_usb_reset_detected(r)	( (r) & UDC_DevIntR_UR )
+#define __udc_set_interface_detected(r)	( (r) & UDC_DevIntR_SI )
+#define __udc_set_config_detected(r)	( (r) & UDC_DevIntR_SC )
+
+#define __udc_clear_sof()		( REG_UDC_DevIntR |= UDC_DevIntR_SOF )
+#define __udc_clear_usb_suspend()	( REG_UDC_DevIntR |= UDC_DevIntR_US )
+#define __udc_clear_usb_reset()		( REG_UDC_DevIntR |= UDC_DevIntR_UR )
+#define __udc_clear_set_interface()	( REG_UDC_DevIntR |= UDC_DevIntR_SI )
+#define __udc_clear_set_config()	( REG_UDC_DevIntR |= UDC_DevIntR_SC )
+
+#define __udc_mask_sof()		( REG_UDC_DevIntMR |= UDC_DevIntR_SOF )
+#define __udc_mask_usb_suspend()	( REG_UDC_DevIntMR |= UDC_DevIntR_US )
+#define __udc_mask_usb_reset()		( REG_UDC_DevIntMR |= UDC_DevIntR_UR )
+#define __udc_mask_set_interface()	( REG_UDC_DevIntMR |= UDC_DevIntR_SI )
+#define __udc_mask_set_config()		( REG_UDC_DevIntMR |= UDC_DevIntR_SC )
+#define __udc_mask_all_dev_intrs() \
+  ( REG_UDC_DevIntMR = UDC_DevIntR_SOF | UDC_DevIntR_US | \
+      UDC_DevIntR_UR | UDC_DevIntR_SI | UDC_DevIntR_SC )
+
+#define __udc_unmask_sof()		( REG_UDC_DevIntMR &= ~UDC_DevIntR_SOF )
+#define __udc_unmask_usb_suspend()	( REG_UDC_DevIntMR &= ~UDC_DevIntR_US )
+#define __udc_unmask_usb_reset()	( REG_UDC_DevIntMR &= ~UDC_DevIntR_UR )
+#define __udc_unmask_set_interface()	( REG_UDC_DevIntMR &= ~UDC_DevIntR_SI )
+#define __udc_unmask_set_config()	( REG_UDC_DevIntMR &= ~UDC_DevIntR_SC )
+#if 0
+#define __udc_unmask_all_dev_intrs() \
+  ( REG_UDC_DevIntMR = ~(UDC_DevIntR_SOF | UDC_DevIntR_US | \
+      UDC_DevIntR_UR | UDC_DevIntR_SI | UDC_DevIntR_SC) )
+#else
+#define __udc_unmask_all_dev_intrs() \
+  ( REG_UDC_DevIntMR = 0x00000000 )
+#endif
+
+
+#define __udc_ep0out_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_OUTEP_MASK) >> (UDC_EPIntR_OUTEP_BIT + 0)) & 0x1 )
+#define __udc_ep5out_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_OUTEP_MASK) >> (UDC_EPIntR_OUTEP_BIT + 5)) & 0x1 )
+#define __udc_ep6out_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_OUTEP_MASK) >> (UDC_EPIntR_OUTEP_BIT + 6)) & 0x1 )
+#define __udc_ep7out_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_OUTEP_MASK) >> (UDC_EPIntR_OUTEP_BIT + 7)) & 0x1 )
+
+#define __udc_ep0in_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_INEP_MASK) >> (UDC_EPIntR_INEP_BIT + 0)) & 0x1 )
+#define __udc_ep1in_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_INEP_MASK) >> (UDC_EPIntR_INEP_BIT + 1)) & 0x1 )
+#define __udc_ep2in_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_INEP_MASK) >> (UDC_EPIntR_INEP_BIT + 2)) & 0x1 )
+#define __udc_ep3in_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_INEP_MASK) >> (UDC_EPIntR_INEP_BIT + 3)) & 0x1 )
+#define __udc_ep4in_irq_detected(epintr) \
+  ( (((epintr) & UDC_EPIntR_INEP_MASK) >> (UDC_EPIntR_INEP_BIT + 4)) & 0x1 )
+
+
+#define __udc_mask_ep0out_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_OUTEP_BIT + 0)) )
+#define __udc_mask_ep5out_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_OUTEP_BIT + 5)) )
+#define __udc_mask_ep6out_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_OUTEP_BIT + 6)) )
+#define __udc_mask_ep7out_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_OUTEP_BIT + 7)) )
+
+#define __udc_unmask_ep0out_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_OUTEP_BIT + 0)) )
+#define __udc_unmask_ep5out_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_OUTEP_BIT + 5)) )
+#define __udc_unmask_ep6out_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_OUTEP_BIT + 6)) )
+#define __udc_unmask_ep7out_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_OUTEP_BIT + 7)) )
+
+#define __udc_mask_ep0in_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_INEP_BIT + 0)) )
+#define __udc_mask_ep1in_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_INEP_BIT + 1)) )
+#define __udc_mask_ep2in_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_INEP_BIT + 2)) )
+#define __udc_mask_ep3in_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_INEP_BIT + 3)) )
+#define __udc_mask_ep4in_irq() \
+  ( REG_UDC_EPIntMR |= (1 << (UDC_EPIntMR_INEP_BIT + 4)) )
+
+#define __udc_unmask_ep0in_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_INEP_BIT + 0)) )
+#define __udc_unmask_ep1in_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_INEP_BIT + 1)) )
+#define __udc_unmask_ep2in_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_INEP_BIT + 2)) )
+#define __udc_unmask_ep3in_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_INEP_BIT + 3)) )
+#define __udc_unmask_ep4in_irq() \
+  ( REG_UDC_EPIntMR &= ~(1 << (UDC_EPIntMR_INEP_BIT + 4)) )
+
+#define __udc_mask_all_ep_intrs() \
+  ( REG_UDC_EPIntMR = 0xffffffff )
+#define __udc_unmask_all_ep_intrs() \
+  ( REG_UDC_EPIntMR = 0x00000000 )
+
+
+/* ep0 only CTRL, ep1 only INTR, ep2/3/5/6 only BULK, ep4/7 only ISO */
+#define __udc_config_endpoint_type()						\
+do {										\
+  REG_UDC_EP0InCR = (REG_UDC_EP0InCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_CTRL;	\
+  REG_UDC_EP0OutCR = (REG_UDC_EP0OutCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_CTRL;	\
+  REG_UDC_EP1InCR = (REG_UDC_EP1InCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_INTR;	\
+  REG_UDC_EP2InCR = (REG_UDC_EP2InCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_BULK;	\
+  REG_UDC_EP3InCR = (REG_UDC_EP3InCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_BULK;	\
+  REG_UDC_EP4InCR = (REG_UDC_EP4InCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_ISO;	\
+  REG_UDC_EP5OutCR = (REG_UDC_EP5OutCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_BULK;	\
+  REG_UDC_EP6OutCR = (REG_UDC_EP6OutCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_BULK;	\
+  REG_UDC_EP7OutCR = (REG_UDC_EP7OutCR & ~UDC_EPCR_ET_MASK) | UDC_EPCR_ET_ISO;	\
+} while (0)
+
+#define __udc_enable_ep0out_snoop_mode()  ( REG_UDC_EP0OutCR |= UDC_EPCR_SN )
+#define __udc_enable_ep5out_snoop_mode()  ( REG_UDC_EP5OutCR |= UDC_EPCR_SN )
+#define __udc_enable_ep6out_snoop_mode()  ( REG_UDC_EP6OutCR |= UDC_EPCR_SN )
+#define __udc_enable_ep7out_snoop_mode()  ( REG_UDC_EP7OutCR |= UDC_EPCR_SN )
+
+#define __udc_disable_ep0out_snoop_mode() ( REG_UDC_EP0OutCR &= ~UDC_EPCR_SN )
+#define __udc_disable_ep5out_snoop_mode() ( REG_UDC_EP5OutCR &= ~UDC_EPCR_SN )
+#define __udc_disable_ep6out_snoop_mode() ( REG_UDC_EP6OutCR &= ~UDC_EPCR_SN )
+#define __udc_disable_ep7out_snoop_mode() ( REG_UDC_EP7OutCR &= ~UDC_EPCR_SN )
+
+#define __udc_flush_ep0in_fifo()  ( REG_UDC_EP0InCR |= UDC_EPCR_F )
+#define __udc_flush_ep1in_fifo()  ( REG_UDC_EP1InCR |= UDC_EPCR_F )
+#define __udc_flush_ep2in_fifo()  ( REG_UDC_EP2InCR |= UDC_EPCR_F )
+#define __udc_flush_ep3in_fifo()  ( REG_UDC_EP3InCR |= UDC_EPCR_F )
+#define __udc_flush_ep4in_fifo()  ( REG_UDC_EP4InCR |= UDC_EPCR_F )
+
+#define __udc_unflush_ep0in_fifo()  ( REG_UDC_EP0InCR &= ~UDC_EPCR_F )
+#define __udc_unflush_ep1in_fifo()  ( REG_UDC_EP1InCR &= ~UDC_EPCR_F )
+#define __udc_unflush_ep2in_fifo()  ( REG_UDC_EP2InCR &= ~UDC_EPCR_F )
+#define __udc_unflush_ep3in_fifo()  ( REG_UDC_EP3InCR &= ~UDC_EPCR_F )
+#define __udc_unflush_ep4in_fifo()  ( REG_UDC_EP4InCR &= ~UDC_EPCR_F )
+
+#define __udc_enable_ep0in_stall()  ( REG_UDC_EP0InCR |= UDC_EPCR_S )
+#define __udc_enable_ep0out_stall() ( REG_UDC_EP0OutCR |= UDC_EPCR_S )
+#define __udc_enable_ep1in_stall()  ( REG_UDC_EP1InCR |= UDC_EPCR_S )
+#define __udc_enable_ep2in_stall()  ( REG_UDC_EP2InCR |= UDC_EPCR_S )
+#define __udc_enable_ep3in_stall()  ( REG_UDC_EP3InCR |= UDC_EPCR_S )
+#define __udc_enable_ep4in_stall()  ( REG_UDC_EP4InCR |= UDC_EPCR_S )
+#define __udc_enable_ep5out_stall() ( REG_UDC_EP5OutCR |= UDC_EPCR_S )
+#define __udc_enable_ep6out_stall() ( REG_UDC_EP6OutCR |= UDC_EPCR_S )
+#define __udc_enable_ep7out_stall() ( REG_UDC_EP7OutCR |= UDC_EPCR_S )
+
+#define __udc_disable_ep0in_stall()  ( REG_UDC_EP0InCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep0out_stall() ( REG_UDC_EP0OutCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep1in_stall()  ( REG_UDC_EP1InCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep2in_stall()  ( REG_UDC_EP2InCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep3in_stall()  ( REG_UDC_EP3InCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep4in_stall()  ( REG_UDC_EP4InCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep5out_stall() ( REG_UDC_EP5OutCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep6out_stall() ( REG_UDC_EP6OutCR &= ~UDC_EPCR_S )
+#define __udc_disable_ep7out_stall() ( REG_UDC_EP7OutCR &= ~UDC_EPCR_S )
+
+
+#define __udc_ep0out_packet_size() \
+  ( (REG_UDC_EP0OutSR & UDC_EPSR_RXPKTSIZE_MASK) >> UDC_EPSR_RXPKTSIZE_BIT )
+#define __udc_ep5out_packet_size() \
+  ( (REG_UDC_EP5OutSR & UDC_EPSR_RXPKTSIZE_MASK) >> UDC_EPSR_RXPKTSIZE_BIT )
+#define __udc_ep6out_packet_size() \
+  ( (REG_UDC_EP6OutSR & UDC_EPSR_RXPKTSIZE_MASK) >> UDC_EPSR_RXPKTSIZE_BIT )
+#define __udc_ep7out_packet_size() \
+  ( (REG_UDC_EP7OutSR & UDC_EPSR_RXPKTSIZE_MASK) >> UDC_EPSR_RXPKTSIZE_BIT )
+
+#define __udc_ep0in_received_intoken()   ( (REG_UDC_EP0InSR & UDC_EPSR_IN) )
+#define __udc_ep1in_received_intoken()   ( (REG_UDC_EP1InSR & UDC_EPSR_IN) )
+#define __udc_ep2in_received_intoken()   ( (REG_UDC_EP2InSR & UDC_EPSR_IN) )
+#define __udc_ep3in_received_intoken()   ( (REG_UDC_EP3InSR & UDC_EPSR_IN) )
+#define __udc_ep4in_received_intoken()   ( (REG_UDC_EP4InSR & UDC_EPSR_IN) )
+
+#define __udc_ep0out_received_none() \
+  ( (REG_UDC_EP0OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_NONE )
+#define __udc_ep0out_received_data() \
+  ( (REG_UDC_EP0OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVDATA )
+#define __udc_ep0out_received_setup() \
+  ( (REG_UDC_EP0OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVSETUP )
+
+#define __udc_ep5out_received_none() \
+  ( (REG_UDC_EP5OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_NONE )
+#define __udc_ep5out_received_data() \
+  ( (REG_UDC_EP5OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVDATA )
+#define __udc_ep5out_received_setup() \
+  ( (REG_UDC_EP5OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVSETUP )
+
+#define __udc_ep6out_received_none() \
+  ( (REG_UDC_EP6OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_NONE )
+#define __udc_ep6out_received_data() \
+  ( (REG_UDC_EP6OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVDATA )
+#define __udc_ep6out_received_setup() \
+  ( (REG_UDC_EP6OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVSETUP )
+
+#define __udc_ep7out_received_none() \
+  ( (REG_UDC_EP7OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_NONE )
+#define __udc_ep7out_received_data() \
+  ( (REG_UDC_EP7OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVDATA )
+#define __udc_ep7out_received_setup() \
+  ( (REG_UDC_EP7OutSR & UDC_EPSR_OUT_MASK) == UDC_EPSR_OUT_RCVSETUP )
+
+/* ep7out ISO only */
+#define __udc_ep7out_get_pid() \
+  ( (REG_UDC_EP7OutSR & UDC_EPSR_PID_MASK) >> UDC_EPSR_PID_BIT )
+
+
+#define __udc_ep0in_set_buffer_size(n) ( REG_UDC_EP0InBSR = (n) )
+#define __udc_ep1in_set_buffer_size(n) ( REG_UDC_EP1InBSR = (n) )
+#define __udc_ep2in_set_buffer_size(n) ( REG_UDC_EP2InBSR = (n) )
+#define __udc_ep3in_set_buffer_size(n) ( REG_UDC_EP3InBSR = (n) )
+#define __udc_ep4in_set_buffer_size(n) ( REG_UDC_EP4InBSR = (n) )
+
+#define __udc_ep0out_get_frame_number(n) ( UDC_EP0OutPFNR )
+#define __udc_ep5out_get_frame_number(n) ( UDC_EP5OutPFNR )
+#define __udc_ep6out_get_frame_number(n) ( UDC_EP6OutPFNR )
+#define __udc_ep7out_get_frame_number(n) ( UDC_EP7OutPFNR )
+
+
+#define __udc_ep0in_set_max_packet_size(n)  ( REG_UDC_EP0InMPSR = (n) )
+#define __udc_ep0out_set_max_packet_size(n) ( REG_UDC_EP0OutMPSR = (n) )
+#define __udc_ep1in_set_max_packet_size(n)  ( REG_UDC_EP1InMPSR = (n) )
+#define __udc_ep2in_set_max_packet_size(n)  ( REG_UDC_EP2InMPSR = (n) )
+#define __udc_ep3in_set_max_packet_size(n)  ( REG_UDC_EP3InMPSR = (n) )
+#define __udc_ep4in_set_max_packet_size(n)  ( REG_UDC_EP4InMPSR = (n) )
+#define __udc_ep5out_set_max_packet_size(n) ( REG_UDC_EP5OutMPSR = (n) )
+#define __udc_ep6out_set_max_packet_size(n) ( REG_UDC_EP6OutMPSR = (n) )
+#define __udc_ep7out_set_max_packet_size(n) ( REG_UDC_EP7OutMPSR = (n) )
+
+/* set to 0xFFFF for UDC */
+#define __udc_set_setup_command_address(n)  ( REG_UDC_STCMAR = (n) )
+
+/* Init and configure EPxInfR(x=0,1,2,3,4,5,6,7)
+ * c: Configuration number to which this endpoint belongs
+ * i: Interface number to which this endpoint belongs
+ * a: Alternate setting to which this endpoint belongs
+ * p: max Packet size of this endpoint
+ */
+
+#define __udc_ep0info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP0InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP0InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP0InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP0InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP0InfR |= UDC_EPInfR_EPT_CTRL; 		\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP0InfR |= UDC_EPInfR_EPD_OUT; 		\
+  REG_UDC_EP0InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP0InfR |= (0 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep1info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP1InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP1InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP1InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP1InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP1InfR |= UDC_EPInfR_EPT_INTR; 		\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP1InfR |= UDC_EPInfR_EPD_IN; 		\
+  REG_UDC_EP1InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP1InfR |= (1 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep2info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP2InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP2InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP2InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP2InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP2InfR |= UDC_EPInfR_EPT_BULK; 		\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP2InfR |= UDC_EPInfR_EPD_IN; 		\
+  REG_UDC_EP2InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP2InfR |= (2 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep3info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP3InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP3InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP3InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP3InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP3InfR |= UDC_EPInfR_EPT_BULK; 		\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP3InfR |= UDC_EPInfR_EPD_IN; 		\
+  REG_UDC_EP3InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP3InfR |= (3 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep4info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP4InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP4InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP4InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP4InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP4InfR |= UDC_EPInfR_EPT_ISO; 		\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP4InfR |= UDC_EPInfR_EPD_IN; 		\
+  REG_UDC_EP4InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP4InfR |= (4 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep5info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP5InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP5InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP5InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP5InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP5InfR |= UDC_EPInfR_EPT_BULK; 		\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP5InfR |= UDC_EPInfR_EPD_OUT; 		\
+  REG_UDC_EP5InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP5InfR |= (5 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep6info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP6InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP6InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP6InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP6InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP6InfR |= UDC_EPInfR_EPT_BULK; 		\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP6InfR |= UDC_EPInfR_EPD_OUT; 		\
+  REG_UDC_EP6InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP6InfR |= (6 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+#define __udc_ep7info_init(c,i,a,p) 			\
+do { 							\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_MPS_MASK; 		\
+  REG_UDC_EP7InfR |= ((p) << UDC_EPInfR_MPS_BIT); 	\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_ALTS_MASK; 		\
+  REG_UDC_EP7InfR |= ((a) << UDC_EPInfR_ALTS_BIT); 	\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_IFN_MASK; 		\
+  REG_UDC_EP7InfR |= ((i) << UDC_EPInfR_IFN_BIT); 	\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_CGN_MASK; 		\
+  REG_UDC_EP7InfR |= ((c) << UDC_EPInfR_CGN_BIT); 	\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_EPT_MASK; 		\
+  REG_UDC_EP7InfR |= UDC_EPInfR_EPT_ISO; 		\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_EPD; 			\
+  REG_UDC_EP7InfR |= UDC_EPInfR_EPD_OUT; 		\
+  REG_UDC_EP7InfR &= ~UDC_EPInfR_EPN_MASK;		\
+  REG_UDC_EP7InfR |= (7 << UDC_EPInfR_EPN_BIT);		\
+} while (0)
+
+
+/***************************************************************************
+ * DMAC
+ ***************************************************************************/
+
+/* n is the DMA channel (0 - 7) */
+
+#define __dmac_enable_all_channels() \
+  ( REG_DMAC_DMACR |= DMAC_DMACR_DME | DMAC_DMACR_PR_ROUNDROBIN )
+#define __dmac_disable_all_channels() \
+  ( REG_DMAC_DMACR &= ~DMAC_DMACR_DME )
+
+/* p=0,1,2,3 */
+#define __dmac_set_priority(p) 				\
+do {							\
+	REG_DMAC_DMACR &= ~DMAC_DMACR_PR_MASK;		\
+	REG_DMAC_DMACR |= ((p) << DMAC_DMACR_PR_BIT);	\
+} while (0)
+
+#define __dmac_test_halt_error() ( REG_DMAC_DMACR & DMAC_DMACR_HTR )
+#define __dmac_test_addr_error() ( REG_DMAC_DMACR & DMAC_DMACR_AER )
+
+#define __dmac_enable_channel(n) \
+  ( REG_DMAC_DCCSR(n) |= DMAC_DCCSR_CHDE )
+#define __dmac_disable_channel(n) \
+  ( REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_CHDE )
+#define __dmac_channel_enabled(n) \
+  ( REG_DMAC_DCCSR(n) & DMAC_DCCSR_CHDE )
+
+#define __dmac_channel_enable_irq(n) \
+  ( REG_DMAC_DCCSR(n) |= DMAC_DCCSR_TCIE )
+#define __dmac_channel_disable_irq(n) \
+  ( REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TCIE )
+
+#define __dmac_channel_transmit_halt_detected(n) \
+  (  REG_DMAC_DCCSR(n) & DMAC_DCCSR_HLT )
+#define __dmac_channel_transmit_end_detected(n) \
+  (  REG_DMAC_DCCSR(n) & DMAC_DCCSR_TC )
+#define __dmac_channel_address_error_detected(n) \
+  (  REG_DMAC_DCCSR(n) & DMAC_DCCSR_AR )
+
+#define __dmac_channel_clear_transmit_halt(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_HLT )
+#define __dmac_channel_clear_transmit_end(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TC )
+#define __dmac_channel_clear_address_error(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_AR )
+
+#define __dmac_channel_set_single_mode(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TM )
+#define __dmac_channel_set_block_mode(n) \
+  (  REG_DMAC_DCCSR(n) |= DMAC_DCCSR_TM )
+
+#define __dmac_channel_set_transfer_unit_32bit(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_32b;		\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16bit(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_16b;		\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_8bit(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_8b;		\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16byte(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_16B;		\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_32byte(n)	\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DS_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DS_32B;		\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_dest_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DWDH_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DWDH_##w;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_src_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_SWDH_MASK;	\
+	REG_DMAC_DCCSR(n) |= DMAC_DCCSR_SWDH_##w;	\
+} while (0)
+
+/* v=0-15 */
+#define __dmac_channel_set_rdil(n,v)				\
+do {								\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_RDIL_MASK;		\
+	REG_DMAC_DCCSR(n) |= ((v) << DMAC_DCCSR_RDIL_BIT);	\
+} while (0)
+
+#define __dmac_channel_dest_addr_fixed(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_DAM )
+#define __dmac_channel_dest_addr_increment(n) \
+  (  REG_DMAC_DCCSR(n) |= DMAC_DCCSR_DAM )
+
+#define __dmac_channel_src_addr_fixed(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_SAM )
+#define __dmac_channel_src_addr_increment(n) \
+  (  REG_DMAC_DCCSR(n) |= DMAC_DCCSR_SAM )
+
+#define __dmac_channel_set_eop_high(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_EOPM )
+#define __dmac_channel_set_eop_low(n) \
+  (  REG_DMAC_DCCSR(n) |= DMAC_DCCSR_EOPM )
+
+#define __dmac_channel_set_erdm(n,m)				\
+do {								\
+	REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_SWDH_MASK;		\
+	REG_DMAC_DCCSR(n) |= ((m) << DMAC_DCCSR_ERDM_BIT);	\
+} while (0)
+
+#define __dmac_channel_set_eackm(n) \
+  ( REG_DMAC_DCCSR(n) |= DMAC_DCCSR_EACKM )
+#define __dmac_channel_clear_eackm(n) \
+  ( REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_EACKM )
+
+#define __dmac_channel_set_eacks(n) \
+  ( REG_DMAC_DCCSR(n) |= DMAC_DCCSR_EACKS )
+#define __dmac_channel_clear_eacks(n) \
+  ( REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_EACKS )
+
+
+#define __dmac_channel_irq_detected(n) \
+  ( REG_DMAC_DCCSR(n) & (DMAC_DCCSR_TC | DMAC_DCCSR_AR) )
+
+static __inline__ int __dmac_get_irq(void)
+{
+	int i;
+	for (i=0;i<NUM_DMA;i++)
+		if (__dmac_channel_irq_detected(i))
+			return i;
+	return -1;
+}
+
+/***************************************************************************
+ * AIC (AC'97 & I2S Controller)
+ ***************************************************************************/
+
+#define __aic_enable()		( REG_AIC_FR |= AIC_FR_ENB )
+#define __aic_disable()		( REG_AIC_FR &= ~AIC_FR_ENB )
+#define __aic_reset()		( REG_AIC_FR |= AIC_FR_RST )
+#define __aic_select_ac97()	( REG_AIC_FR &= ~AIC_FR_AUSEL )
+#define __aic_select_i2s()	( REG_AIC_FR |= AIC_FR_AUSEL )
+
+#define __i2s_as_master()	( REG_AIC_FR |= AIC_FR_BCKD | AIC_FR_SYNCD )
+#define __i2s_as_slave()	( REG_AIC_FR &= ~(AIC_FR_BCKD | AIC_FR_SYNCD) )
+
+#define __aic_set_transmit_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_TFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_TFTH_BIT);		\
+} while(0)
+
+#define __aic_set_receive_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_RFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_RFTH_BIT);		\
+} while(0)
+
+#define __aic_enable_record()	( REG_AIC_CR |= AIC_CR_EREC )
+#define __aic_disable_record()	( REG_AIC_CR &= ~AIC_CR_EREC )
+#define __aic_enable_replay()	( REG_AIC_CR |= AIC_CR_ERPL )
+#define __aic_disable_replay()	( REG_AIC_CR &= ~AIC_CR_ERPL )
+#define __aic_enable_loopback()	( REG_AIC_CR |= AIC_CR_ENLBF )
+#define __aic_disable_loopback() ( REG_AIC_CR &= ~AIC_CR_ENLBF )
+
+#define __aic_flush_fifo()	( REG_AIC_CR |= AIC_CR_FLUSH )
+#define __aic_unflush_fifo()	( REG_AIC_CR &= ~AIC_CR_FLUSH )
+
+#define __aic_enable_transmit_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_disable_transmit_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_enable_receive_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ERFS | AIC_CR_EROR) )
+#define __aic_disable_receive_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ERFS | AIC_CR_EROR) )
+
+#define __aic_enable_transmit_dma()  ( REG_AIC_CR |= AIC_CR_TDMS )
+#define __aic_disable_transmit_dma() ( REG_AIC_CR &= ~AIC_CR_TDMS )
+#define __aic_enable_receive_dma()   ( REG_AIC_CR |= AIC_CR_RDMS )
+#define __aic_disable_receive_dma()  ( REG_AIC_CR &= ~AIC_CR_RDMS )
+
+#define __aic_enable_mono2stereo()
+#define __aic_disable_mono2stereo()
+#define __aic_enable_byteswap()
+#define __aic_disable_byteswap()
+#define __aic_enable_unsignadj()
+#define __aic_disable_unsignadj()
+
+#define AC97_PCM_XS_L_FRONT   	AIC_ACCR1_XS_SLOT3
+#define AC97_PCM_XS_R_FRONT   	AIC_ACCR1_XS_SLOT4
+#define AC97_PCM_XS_CENTER    	AIC_ACCR1_XS_SLOT6
+#define AC97_PCM_XS_L_SURR    	AIC_ACCR1_XS_SLOT7
+#define AC97_PCM_XS_R_SURR    	AIC_ACCR1_XS_SLOT8
+#define AC97_PCM_XS_LFE       	AIC_ACCR1_XS_SLOT9
+
+#define AC97_PCM_RS_L_FRONT   	AIC_ACCR1_RS_SLOT3
+#define AC97_PCM_RS_R_FRONT   	AIC_ACCR1_RS_SLOT4
+#define AC97_PCM_RS_CENTER    	AIC_ACCR1_RS_SLOT6
+#define AC97_PCM_RS_L_SURR    	AIC_ACCR1_RS_SLOT7
+#define AC97_PCM_RS_R_SURR    	AIC_ACCR1_RS_SLOT8
+#define AC97_PCM_RS_LFE       	AIC_ACCR1_RS_SLOT9
+
+#define __ac97_set_xs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK )
+#define __ac97_set_xs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_R_FRONT;				\
+} while(0)
+#define __ac97_set_xs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_L_FRONT | AC97_PCM_XS_R_FRONT;	\
+} while(0)
+
+/* In fact, only stereo is support now. */ 
+#define __ac97_set_rs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK )
+#define __ac97_set_rs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_R_FRONT;				\
+} while(0)
+#define __ac97_set_rs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_L_FRONT | AC97_PCM_RS_R_FRONT;	\
+} while(0)
+
+#define __ac97_warm_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SS;		\
+	udelay(1);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+
+#define Jz_AC97_RESET_BUG 1
+
+#ifndef Jz_AC97_RESET_BUG
+#define __ac97_cold_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 |=  AIC_ACCR2_SR;		\
+	udelay(1);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SR;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+#else
+#define __ac97_cold_reset_codec()		\
+ do {						\
+        __gpio_as_output(70); /* SDATA_OUT */	\
+        __gpio_as_output(71); /* SDATA_IN */	\
+        __gpio_as_output(78); /* SYNC */	\
+        __gpio_as_output(69); /* RESET# */	\
+	__gpio_clear_pin(70);			\
+	__gpio_clear_pin(71);			\
+	__gpio_clear_pin(78);			\
+	__gpio_clear_pin(69);			\
+	udelay(10);				\
+	__gpio_set_pin(69);			\
+	udelay(1);				\
+	__gpio_as_ac97();			\
+ } while (0)
+#endif
+
+/* n=8,16,18,20 */
+#define __ac97_set_iass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_IASS_MASK) | AIC_ACCR2_IASS_##n##BIT )
+#define __ac97_set_oass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_OASS_MASK) | AIC_ACCR2_OASS_##n##BIT )
+
+#define __i2s_select_i2s()            ( REG_AIC_I2SCR &= ~AIC_I2SCR_AMSL )
+#define __i2s_select_left_justified() ( REG_AIC_I2SCR |= AIC_I2SCR_AMSL )
+
+/* n=8,16,18,20,24 */
+#define __i2s_set_sample_size(n) \
+ ( REG_AIC_I2SCR = (REG_AIC_I2SCR & ~AIC_I2SCR_WL_MASK) | AIC_I2SCR_WL_##n##BIT )
+
+#define __i2s_stop_clock()   ( REG_AIC_I2SCR |= AIC_I2SCR_STPBK )
+#define __i2s_start_clock()  ( REG_AIC_I2SCR &= ~AIC_I2SCR_STPBK )
+
+#define __aic_transmit_request()  ( REG_AIC_SR & AIC_SR_TFS )
+#define __aic_receive_request()   ( REG_AIC_SR & AIC_SR_RFS )
+#define __aic_transmit_underrun() ( REG_AIC_SR & AIC_SR_TUR )
+#define __aic_receive_overrun()   ( REG_AIC_SR & AIC_SR_ROR )
+
+#define __aic_clear_errors()      ( REG_AIC_SR &= ~(AIC_SR_TUR | AIC_SR_ROR) )
+
+#define __aic_get_transmit_resident() \
+  ( (REG_AIC_SR & AIC_SR_TFL_MASK) >> AIC_SR_TFL_BIT )
+#define __aic_get_receive_count() \
+  ( (REG_AIC_SR & AIC_SR_RFL_MASK) >> AIC_SR_RFL_BIT )
+
+#define __ac97_command_transmitted()     ( REG_AIC_ACSR & AIC_ACSR_CADT )
+#define __ac97_status_received()         ( REG_AIC_ACSR & AIC_ACSR_SADR )
+#define __ac97_status_receive_timeout()  ( REG_AIC_ACSR & AIC_ACSR_RSTO )
+#define __ac97_codec_is_low_power_mode() ( REG_AIC_ACSR & AIC_ACSR_CLPM )
+#define __ac97_codec_is_ready()          ( REG_AIC_ACSR & AIC_ACSR_CRDY )
+
+#define __i2s_is_busy() ( REG_AIC_I2SSR & AIC_I2SSR_BSY )
+
+#define CODEC_READ_CMD	        (1 << 19)
+#define CODEC_WRITE_CMD	        (0 << 19)
+#define CODEC_REG_INDEX_BIT     12
+#define CODEC_REG_INDEX_MASK	(0x7f << CODEC_REG_INDEX_BIT)	/* 18:12 */
+#define CODEC_REG_DATA_BIT      4
+#define CODEC_REG_DATA_MASK	(0x0ffff << 4)	/* 19:4 */
+
+#define __ac97_out_rcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_READ_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_wcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_WRITE_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_data(value) 						\
+do { 									\
+    REG_AIC_ACCDR = ((value) << CODEC_REG_DATA_BIT); 			\
+} while (0)
+
+#define __ac97_in_data() \
+ ( (REG_AIC_ACSDR & CODEC_REG_DATA_MASK) >> CODEC_REG_DATA_BIT )
+
+#define __ac97_in_status_addr() \
+ ( (REG_AIC_ACSAR & CODEC_REG_INDEX_MASK) >> CODEC_REG_INDEX_BIT )
+
+#define __i2s_set_sample_rate(i2sclk, sync) \
+  ( REG_AIC_I2SDIV = ((i2sclk) / (4*64)) / (sync) )
+
+#define __aic_write_tfifo(v)  ( REG_AIC_DR = (v) )
+#define __aic_read_rfifo()    ( REG_AIC_DR )
+
+//
+// Define next ops for AC97 compatible
+//
+
+#define AC97_ACSR	AIC_ACSR
+
+#define __ac97_enable()		__aic_enable(); __aic_select_ac97()
+#define __ac97_disable()	__aic_disable()
+#define __ac97_reset()		__aic_reset()
+
+#define __ac97_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __ac97_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __ac97_enable_record()		__aic_enable_record()
+#define __ac97_disable_record()		__aic_disable_record()
+#define __ac97_enable_replay()		__aic_enable_replay()
+#define __ac97_disable_replay()		__aic_disable_replay()
+#define __ac97_enable_loopback()	__aic_enable_loopback()
+#define __ac97_disable_loopback()	__aic_disable_loopback()
+
+#define __ac97_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __ac97_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __ac97_enable_receive_dma()	__aic_enable_receive_dma()
+#define __ac97_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __ac97_transmit_request()	__aic_transmit_request()
+#define __ac97_receive_request()	__aic_receive_request()
+#define __ac97_transmit_underrun()	__aic_transmit_underrun()
+#define __ac97_receive_overrun()	__aic_receive_overrun()
+
+#define __ac97_clear_errors()		__aic_clear_errors()
+
+#define __ac97_get_transmit_resident()	__aic_get_transmit_resident()
+#define __ac97_get_receive_count()	__aic_get_receive_count()
+
+#define __ac97_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __ac97_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __ac97_enable_receive_intr()	__aic_enable_receive_intr()
+#define __ac97_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __ac97_write_tfifo(v)		__aic_write_tfifo(v)
+#define __ac97_read_rfifo()		__aic_read_rfifo()
+
+//
+// Define next ops for I2S compatible
+//
+
+#define I2S_ACSR	AIC_I2SSR
+
+#define __i2s_enable()		 __aic_enable(); __aic_select_i2s()
+#define __i2s_disable()		__aic_disable()
+#define __i2s_reset()		__aic_reset()
+
+#define __i2s_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __i2s_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __i2s_enable_record()		__aic_enable_record()
+#define __i2s_disable_record()		__aic_disable_record()
+#define __i2s_enable_replay()		__aic_enable_replay()
+#define __i2s_disable_replay()		__aic_disable_replay()
+#define __i2s_enable_loopback()		__aic_enable_loopback()
+#define __i2s_disable_loopback()	__aic_disable_loopback()
+
+#define __i2s_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __i2s_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __i2s_enable_receive_dma()	__aic_enable_receive_dma()
+#define __i2s_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __i2s_transmit_request()	__aic_transmit_request()
+#define __i2s_receive_request()		__aic_receive_request()
+#define __i2s_transmit_underrun()	__aic_transmit_underrun()
+#define __i2s_receive_overrun()		__aic_receive_overrun()
+
+#define __i2s_clear_errors()		__aic_clear_errors()
+
+#define __i2s_get_transmit_resident()	__aic_get_transmit_resident()
+#define __i2s_get_receive_count()	__aic_get_receive_count()
+
+#define __i2s_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __i2s_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __i2s_enable_receive_intr()	__aic_enable_receive_intr()
+#define __i2s_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __i2s_write_tfifo(v)		__aic_write_tfifo(v)
+#define __i2s_read_rfifo()		__aic_read_rfifo()
+
+#define __i2s_reset_codec()			\
+ do {						\
+        __gpio_as_output(70); /* SDATA_OUT */	\
+        __gpio_as_input(71);  /* SDATA_IN */	\
+        __gpio_as_output(78); /* SYNC */	\
+        __gpio_as_output(69); /* RESET# */	\
+	__gpio_clear_pin(70);			\
+	__gpio_clear_pin(71);			\
+	__gpio_clear_pin(78);			\
+	__gpio_clear_pin(69);			\
+        __gpio_as_i2s_master();			\
+ } while (0)
+
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+
+#define __lcd_set_dis()			( REG_LCD_CTRL |= LCD_CTRL_DIS )
+#define __lcd_clr_dis()			( REG_LCD_CTRL &= ~LCD_CTRL_DIS )
+
+#define __lcd_set_ena()			( REG_LCD_CTRL |= LCD_CTRL_ENA )
+#define __lcd_clr_ena()			( REG_LCD_CTRL &= ~LCD_CTRL_ENA )
+
+/* n=1,2,4,8,16 */
+#define __lcd_set_bpp(n) \
+  ( REG_LCD_CTRL = (REG_LCD_CTRL & ~LCD_CTRL_BPP_MASK) | LCD_CTRL_BPP_##n )
+
+/* n=4,8,16 */
+#define __lcd_set_burst_length(n) 		\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_BST_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_BST_n##;	\
+} while (0)
+
+#define __lcd_select_rgb565()		( REG_LCD_CTRL &= ~LCD_CTRL_RGB555 )
+#define __lcd_select_rgb555()		( REG_LCD_CTRL |= LCD_CTRL_RGB555 )
+
+#define __lcd_set_ofup()		( REG_LCD_CTRL |= LCD_CTRL_OFUP )
+#define __lcd_clr_ofup()		( REG_LCD_CTRL &= ~LCD_CTRL_OFUP )
+
+/* n=2,4,16 */
+#define __lcd_set_stn_frc(n) 			\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_FRC_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_FRC_n##;	\
+} while (0)
+
+
+#define __lcd_pixel_endian_little()	( REG_LCD_CTRL |= LCD_CTRL_PEDN )
+#define __lcd_pixel_endian_big()	( REG_LCD_CTRL &= ~LCD_CTRL_PEDN )
+
+#define __lcd_reverse_byte_endian()	( REG_LCD_CTRL |= LCD_CTRL_BEDN )
+#define __lcd_normal_byte_endian()	( REG_LCD_CTRL &= ~LCD_CTRL_BEDN )
+
+#define __lcd_enable_eof_intr()		( REG_LCD_CTRL |= LCD_CTRL_EOFM )
+#define __lcd_disable_eof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_EOFM )
+
+#define __lcd_enable_sof_intr()		( REG_LCD_CTRL |= LCD_CTRL_SOFM )
+#define __lcd_disable_sof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_SOFM )
+
+#define __lcd_enable_ofu_intr()		( REG_LCD_CTRL |= LCD_CTRL_OFUM )
+#define __lcd_disable_ofu_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_OFUM )
+
+#define __lcd_enable_ifu0_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM0 )
+#define __lcd_disable_ifu0_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM0 )
+
+#define __lcd_enable_ifu1_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM1 )
+#define __lcd_disable_ifu1_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM1 )
+
+#define __lcd_enable_ldd_intr()		( REG_LCD_CTRL |= LCD_CTRL_LDDM )
+#define __lcd_disable_ldd_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_LDDM )
+
+#define __lcd_enable_qd_intr()		( REG_LCD_CTRL |= LCD_CTRL_QDM )
+#define __lcd_disable_qd_intr()		( REG_LCD_CTRL &= ~LCD_CTRL_QDM )
+
+
+/* LCD status register indication */
+
+#define __lcd_quick_disable_done()	( REG_LCD_STATE & LCD_STATE_QD )
+#define __lcd_disable_done()		( REG_LCD_STATE & LCD_STATE_LDD )
+#define __lcd_infifo0_underrun()	( REG_LCD_STATE & LCD_STATE_IFU0 )
+#define __lcd_infifo1_underrun()	( REG_LCD_STATE & LCD_STATE_IFU1 )
+#define __lcd_outfifo_underrun()	( REG_LCD_STATE & LCD_STATE_OFU )
+#define __lcd_start_of_frame()		( REG_LCD_STATE & LCD_STATE_SOF )
+#define __lcd_end_of_frame()		( REG_LCD_STATE & LCD_STATE_EOF )
+
+#define __lcd_clr_outfifounderrun()	( REG_LCD_STATE &= ~LCD_STATE_OFU )
+#define __lcd_clr_sof()			( REG_LCD_STATE &= ~LCD_STATE_SOF )
+#define __lcd_clr_eof()			( REG_LCD_STATE &= ~LCD_STATE_EOF )
+
+#define __lcd_panel_white()		( REG_LCD_DEV |= LCD_DEV_WHITE )
+#define __lcd_panel_black()		( REG_LCD_DEV &= ~LCD_DEV_WHITE )
+
+/* n=1,2,4,8 for single mono-STN 
+ * n=4,8 for dual mono-STN
+ */
+#define __lcd_set_panel_datawidth(n) 		\
+do { 						\
+	REG_LCD_DEV &= ~LCD_DEV_PDW_MASK; 	\
+	REG_LCD_DEV |= LCD_DEV_PDW_n##;		\
+} while (0)
+
+/* m=LCD_DEV_MODE_GENERUIC_TFT_xxx */
+#define __lcd_set_panel_mode(m) 		\
+do {						\
+	REG_LCD_DEV &= ~LCD_DEV_MODE_MASK;	\
+	REG_LCD_DEV |= (m);			\
+} while(0)
+
+/* n = 0-255 */
+#define __lcd_disable_ac_bias()		( REG_LCD_IO = 0xff )
+#define __lcd_set_ac_bias(n) 			\
+do {						\
+	REG_LCD_IO &= ~LCD_IO_ACB_MASK;		\
+	REG_LCD_IO |= ((n) << LCD_IO_ACB_BIT);	\
+} while(0)
+
+#define __lcd_io_set_dir()		( REG_LCD_IO |= LCD_IO_DIR )
+#define __lcd_io_clr_dir()		( REG_LCD_IO &= ~LCD_IO_DIR )
+
+#define __lcd_io_set_dep()		( REG_LCD_IO |= LCD_IO_DEP )
+#define __lcd_io_clr_dep()		( REG_LCD_IO &= ~LCD_IO_DEP )
+
+#define __lcd_io_set_vsp()		( REG_LCD_IO |= LCD_IO_VSP )
+#define __lcd_io_clr_vsp()		( REG_LCD_IO &= ~LCD_IO_VSP )
+
+#define __lcd_io_set_hsp()		( REG_LCD_IO |= LCD_IO_HSP )
+#define __lcd_io_clr_hsp()		( REG_LCD_IO &= ~LCD_IO_HSP )
+
+#define __lcd_io_set_pcp()		( REG_LCD_IO |= LCD_IO_PCP )
+#define __lcd_io_clr_pcp()		( REG_LCD_IO &= ~LCD_IO_PCP )
+
+#define __lcd_vsync_get_vps() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPS_MASK) >> LCD_VSYNC_VPS_BIT )
+
+#define __lcd_vsync_get_vpe() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPE_MASK) >> LCD_VSYNC_VPE_BIT )
+#define __lcd_vsync_set_vpe(n) 				\
+do {							\
+	REG_LCD_VSYNC &= ~LCD_VSYNC_VPE_MASK;		\
+	REG_LCD_VSYNC |= (n) << LCD_VSYNC_VPE_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hps() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPS_MASK) >> LCD_HSYNC_HPS_BIT )
+#define __lcd_hsync_set_hps(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPS_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPS_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hpe() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPE_MASK) >> LCD_VSYNC_HPE_BIT )
+#define __lcd_hsync_set_hpe(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPE_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPE_BIT;	\
+} while (0)
+
+#define __lcd_vat_get_ht() \
+  ( (REG_LCD_VAT & LCD_VAT_HT_MASK) >> LCD_VAT_HT_BIT )
+#define __lcd_vat_set_ht(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_HT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_HT_BIT;		\
+} while (0)
+
+#define __lcd_vat_get_vt() \
+  ( (REG_LCD_VAT & LCD_VAT_VT_MASK) >> LCD_VAT_VT_BIT )
+#define __lcd_vat_set_vt(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_VT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_VT_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hds() \
+  ( (REG_LCD_DAH & LCD_DAH_HDS_MASK) >> LCD_DAH_HDS_BIT )
+#define __lcd_dah_set_hds(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDS_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDS_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hde() \
+  ( (REG_LCD_DAH & LCD_DAH_HDE_MASK) >> LCD_DAH_HDE_BIT )
+#define __lcd_dah_set_hde(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDE_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDE_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vds() \
+  ( (REG_LCD_DAV & LCD_DAV_VDS_MASK) >> LCD_DAV_VDS_BIT )
+#define __lcd_dav_set_vds(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDS_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDS_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vde() \
+  ( (REG_LCD_DAV & LCD_DAV_VDE_MASK) >> LCD_DAV_VDE_BIT )
+#define __lcd_dav_set_vde(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDE_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDE_BIT;		\
+} while (0)
+
+#define __lcd_cmd0_set_sofint()		( REG_LCD_CMD0 |= LCD_CMD_SOFINT )
+#define __lcd_cmd0_clr_sofint()		( REG_LCD_CMD0 &= ~LCD_CMD_SOFINT )
+#define __lcd_cmd1_set_sofint()		( REG_LCD_CMD1 |= LCD_CMD_SOFINT )
+#define __lcd_cmd1_clr_sofint()		( REG_LCD_CMD1 &= ~LCD_CMD_SOFINT )
+
+#define __lcd_cmd0_set_eofint()		( REG_LCD_CMD0 |= LCD_CMD_EOFINT )
+#define __lcd_cmd0_clr_eofint()		( REG_LCD_CMD0 &= ~LCD_CMD_EOFINT )
+#define __lcd_cmd1_set_eofint()		( REG_LCD_CMD1 |= LCD_CMD_EOFINT )
+#define __lcd_cmd1_clr_eofint()		( REG_LCD_CMD1 &= ~LCD_CMD_EOFINT )
+
+#define __lcd_cmd0_set_pal()		( REG_LCD_CMD0 |= LCD_CMD_PAL )
+#define __lcd_cmd0_clr_pal()		( REG_LCD_CMD0 &= ~LCD_CMD_PAL )
+
+#define __lcd_cmd0_get_len() \
+  ( (REG_LCD_CMD0 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+#define __lcd_cmd1_get_len() \
+  ( (REG_LCD_CMD1 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+
+
+
+/***************************************************************************
+ * DES
+ ***************************************************************************/
+
+
+/***************************************************************************
+ * CPM
+ ***************************************************************************/
+#define __cpm_plcr1_fd() \
+	((REG_CPM_PLCR1 & CPM_PLCR1_PLL1FD_MASK) >> CPM_PLCR1_PLL1FD_BIT)
+#define __cpm_plcr1_rd() \
+	((REG_CPM_PLCR1 & CPM_PLCR1_PLL1RD_MASK) >> CPM_PLCR1_PLL1RD_BIT)
+#define __cpm_plcr1_od() \
+	((REG_CPM_PLCR1 & CPM_PLCR1_PLL1OD_MASK) >> CPM_PLCR1_PLL1OD_BIT)
+#define __cpm_cfcr_mfr() \
+	((REG_CPM_CFCR & CPM_CFCR_MFR_MASK) >> CPM_CFCR_MFR_BIT)
+#define __cpm_cfcr_pfr() \
+	((REG_CPM_CFCR & CPM_CFCR_PFR_MASK) >> CPM_CFCR_PFR_BIT)
+#define __cpm_cfcr_sfr() \
+	((REG_CPM_CFCR & CPM_CFCR_SFR_MASK) >> CPM_CFCR_SFR_BIT)
+#define __cpm_cfcr_ifr() \
+	((REG_CPM_CFCR & CPM_CFCR_IFR_MASK) >> CPM_CFCR_IFR_BIT)
+
+static __inline__ unsigned int __cpm_divisor_encode(unsigned int n)
+{
+	unsigned int encode[10] = {1,2,3,4,6,8,12,16,24,32};
+	int i;
+	for (i=0;i<10;i++)
+		if (n < encode[i])
+			break;
+	return i;
+}
+
+#define __cpm_set_mclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_MFR_MASK) | \
+		       ((n) << (CPM_CFCR_MFR_BIT)); \
+} while (0)
+
+#define __cpm_set_pclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_PFR_MASK) | \
+		       ((n) << (CPM_CFCR_PFR_BIT)); \
+} while (0)
+
+#define __cpm_set_sclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_SFR_MASK) | \
+		       ((n) << (CPM_CFCR_SFR_BIT)); \
+} while (0)
+
+#define __cpm_set_iclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_IFR_MASK) | \
+		       ((n) << (CPM_CFCR_IFR_BIT)); \
+} while (0)
+
+#define __cpm_set_lcdclk_div(n) \
+do { \
+	REG_CPM_CFCR = (REG_CPM_CFCR & ~CPM_CFCR_LFR_MASK) | \
+		       ((n) << (CPM_CFCR_LFR_BIT)); \
+} while (0)
+
+#define __cpm_enable_cko1()  (REG_CPM_CFCR |= CPM_CFCR_CKOEN1)
+#define __cpm_enable_cko2()  (REG_CPM_CFCR |= CPM_CFCR_CKOEN2)
+#define __cpm_disable_cko1()  (REG_CPM_CFCR &= ~CPM_CFCR_CKOEN1)
+#define __cpm_disable_cko2()  (REG_CPM_CFCR &= ~CPM_CFCR_CKOEN2)
+
+#define __cpm_select_msc_clk(type) \
+do {                               \
+  if (type == 0)                   \
+    REG_CPM_CFCR &= ~CPM_CFCR_MSC; \
+  else                             \
+    REG_CPM_CFCR |= CPM_CFCR_MSC;  \
+  REG_CPM_CFCR |= CPM_CFCR_UPE;    \
+} while(0)
+
+#define __cpm_idle_mode()					\
+	(REG_CPM_LPCR = (REG_CPM_LPCR & ~CPM_LPCR_LPM_MASK) |	\
+			CPM_LPCR_LPM_IDLE)
+#define __cpm_sleep_mode()					\
+	(REG_CPM_LPCR = (REG_CPM_LPCR & ~CPM_LPCR_LPM_MASK) |	\
+			CPM_LPCR_LPM_SLEEP)
+#define __cpm_hibernate_mode()					\
+	(REG_CPM_LPCR = (REG_CPM_LPCR & ~CPM_LPCR_LPM_MASK) |	\
+			CPM_LPCR_LPM_HIBERNATE)
+
+#define __cpm_start_uart0() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UART0))
+#define __cpm_start_uart1() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UART1))
+#define __cpm_start_uart2() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UART2))
+#define __cpm_start_uart3() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UART3))
+#define __cpm_start_ost() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_OST))
+#define __cpm_start_dmac() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_DMAC))
+#define __cpm_start_uhc() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UHC))
+#define __cpm_start_lcd() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_LCD))
+#define __cpm_start_i2c() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_I2C))
+#define __cpm_start_aic_pclk() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_AICPCLK))
+#define __cpm_start_aic_bitclk() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_AICBCLK))
+#define __cpm_start_pwm0() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_PWM0))
+#define __cpm_start_pwm1() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_PWM1))
+#define __cpm_start_ssi() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_SSI))
+#define __cpm_start_msc() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_MSC))
+#define __cpm_start_scc() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_SCC))
+#define __cpm_start_eth() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_ETH))
+#define __cpm_start_kbc() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_KBC))
+#define __cpm_start_cim() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_CIM))
+#define __cpm_start_udc() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UDC))
+#define __cpm_start_uprt() \
+	(REG_CPM_MSCR &= ~(1 << CPM_MSCR_MSTP_UPRT))
+#define __cpm_start_all() (REG_CPM_MSCR = 0)
+
+#define __cpm_stop_uart0() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UART0))
+#define __cpm_stop_uart1() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UART1))
+#define __cpm_stop_uart2() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UART2))
+#define __cpm_stop_uart3() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UART3))
+#define __cpm_stop_ost() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_OST))
+#define __cpm_stop_dmac() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_DMAC))
+#define __cpm_stop_uhc() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UHC))
+#define __cpm_stop_lcd() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_LCD))
+#define __cpm_stop_i2c() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_I2C))
+#define __cpm_stop_aic_pclk() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_AICPCLK))
+#define __cpm_stop_aic_bitclk() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_AICBCLK))
+#define __cpm_stop_pwm0() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_PWM0))
+#define __cpm_stop_pwm1() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_PWM1))
+#define __cpm_stop_ssi() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_SSI))
+#define __cpm_stop_msc() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_MSC))
+#define __cpm_stop_scc() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_SCC))
+#define __cpm_stop_eth() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_ETH))
+#define __cpm_stop_kbc() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_KBC))
+#define __cpm_stop_cim() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_CIM))
+#define __cpm_stop_udc() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UDC))
+#define __cpm_stop_uprt() \
+	(REG_CPM_MSCR |= (1 << CPM_MSCR_MSTP_UPRT))
+#define __cpm_stop_all() (REG_CPM_MSCR = 0xffffffff)
+
+#define __cpm_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	if (p == 0)				\
+		REG_CPM_GSR0 |= (1 << o);	\
+	else if (p == 1)			\
+		REG_CPM_GSR1 |= (1 << o);	\
+	else if (p == 2)			\
+		REG_CPM_GSR2 |= (1 << o);	\
+	else if (p == 3)			\
+		REG_CPM_GSR3 |= (1 << o);	\
+} while (0)
+
+#define __cpm_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	if (p == 0)				\
+		REG_CPM_GSR0 &= ~(1 << o);	\
+	else if (p == 1)			\
+		REG_CPM_GSR1 &= ~(1 << o);	\
+	else if (p == 2)			\
+		REG_CPM_GSR2 &= ~(1 << o);	\
+	else if (p == 3)			\
+		REG_CPM_GSR3 &= ~(1 << o);	\
+} while (0)
+
+
+/***************************************************************************
+ * SSI
+ ***************************************************************************/
+
+#define __ssi_enable()    ( REG_SSI_CR0 |= SSI_CR0_SSIE )
+#define __ssi_disable()   ( REG_SSI_CR0 &= ~SSI_CR0_SSIE )
+#define __ssi_select_ce() ( REG_SSI_CR0 &= ~SSI_CR0_FSEL )
+
+#define __ssi_normal_mode() ( REG_SSI_ITR &= ~SSI_ITR_IVLTM_MASK )
+
+#define __ssi_select_ce2() 		\
+do { 					\
+	REG_SSI_CR0 |= SSI_CR0_FSEL; 	\
+	REG_SSI_CR1 &= ~SSI_CR1_MULTS; 	\
+} while (0)
+
+#define __ssi_select_gpc() 		\
+do { 					\
+	REG_SSI_CR0 &= ~SSI_CR0_FSEL; 	\
+	REG_SSI_CR1 |= SSI_CR1_MULTS; 	\
+} while (0)
+
+#define __ssi_enable_tx_intr() 	\
+  ( REG_SSI_CR0 |= SSI_CR0_TIE | SSI_CR0_TEIE )
+
+#define __ssi_disable_tx_intr() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_TIE | SSI_CR0_TEIE) )
+
+#define __ssi_enable_rx_intr() 	\
+  ( REG_SSI_CR0 |= SSI_CR0_RIE | SSI_CR0_REIE )
+
+#define __ssi_disable_rx_intr() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_RIE | SSI_CR0_REIE) )
+
+#define __ssi_enable_loopback()  ( REG_SSI_CR0 |= SSI_CR0_LOOP )
+#define __ssi_disable_loopback() ( REG_SSI_CR0 &= ~SSI_CR0_LOOP )
+
+#define __ssi_enable_receive()   ( REG_SSI_CR0 &= ~SSI_CR0_DISREV )
+#define __ssi_disable_receive()  ( REG_SSI_CR0 |= SSI_CR0_DISREV )
+
+#define __ssi_finish_receive() 	\
+  ( REG_SSI_CR0 |= (SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_disable_recvfinish() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_flush_txfifo()   ( REG_SSI_CR0 |= SSI_CR0_TFLUSH )
+#define __ssi_flush_rxfifo()   ( REG_SSI_CR0 |= SSI_CR0_RFLUSH )
+
+#define __ssi_flush_fifo() \
+  ( REG_SSI_CR0 |= SSI_CR0_TFLUSH | SSI_CR0_RFLUSH )
+
+#define __ssi_finish_transmit() ( REG_SSI_CR1 &= ~SSI_CR1_UNFIN )
+
+#define __ssi_spi_format() 					\
+do { 								\
+	REG_SSI_CR1 &= ~SSI_CR1_FMAT_MASK; 			\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_SPI; 			\
+	REG_SSI_CR1 &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK);\
+	REG_SSI_CR1 |= (SSI_CR1_TFVCK_1 | SSI_CR1_TCKFI_1);	\
+} while (0)
+
+/* TI's SSP format, must clear SSI_CR1.UNFIN */
+#define __ssi_ssp_format() 					\
+do { 								\
+	REG_SSI_CR1 &= ~(SSI_CR1_FMAT_MASK | SSI_CR1_UNFIN); 	\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_SSP; 			\
+} while (0)
+
+/* National's Microwire format, must clear SSI_CR0.RFINE, and set max delay */
+#define __ssi_microwire_format() 				\
+do { 								\
+	REG_SSI_CR1 &= ~SSI_CR1_FMAT_MASK; 			\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_MW1; 			\
+	REG_SSI_CR1 &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK);\
+	REG_SSI_CR1 |= (SSI_CR1_TFVCK_3 | SSI_CR1_TCKFI_3);	\
+	REG_SSI_CR0 &= ~SSI_CR0_RFINE; 				\
+} while (0)
+
+/* CE# level (FRMHL), CE# in interval time (ITFRM),
+   clock phase and polarity (PHA POL),
+   interval time (SSIITR), interval characters/frame (SSIICR) */
+
+ /* frmhl,endian,mcom,flen,pha,pol MASK */
+#define SSICR1_MISC_MASK 					\
+	( SSI_CR1_FRMHL_MASK | SSI_CR1_LFST | SSI_CR1_MCOM_MASK	\
+	| SSI_CR1_FLEN_MASK | SSI_CR1_PHA | SSI_CR1_POL )	\
+
+#define __ssi_spi_set_misc(frmhl,endian,flen,mcom,pha,pol)	\
+do { 								\
+	REG_SSI_CR1 &= ~SSICR1_MISC_MASK; 			\
+	REG_SSI_CR1 |= ((frmhl) << 30) | ((endian) << 25) | 	\
+		 (((mcom) - 1) << 12) | (((flen) - 2) << 4) | 	\
+	         ((pha) << 1) | (pol); 				\
+} while(0)
+
+/* Transfer with MSB or LSB first */
+#define __ssi_set_msb() ( REG_SSI_CR1 &= ~SSI_CR1_LFST )
+#define __ssi_set_lsb() ( REG_SSI_CR1 |= SSI_CR1_LFST )
+
+#define __ssi_set_frame_length(n) \
+    REG_SSI_CR1 = (REG_SSI_CR1 & ~SSI_CR1_FLEN_MASK) | (((n) - 2) << 4) 
+
+/* n = 1 - 16 */
+#define __ssi_set_microwire_command_length(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_MCOM_MASK) | SSI_CR1_MCOM_##n##BIT) )
+
+/* Set the clock phase for SPI */
+#define __ssi_set_spi_clock_phase(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_PHA) | ((n&0x1) << 1 )))
+
+/* Set the clock polarity for SPI */
+#define __ssi_set_spi_clock_polarity(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_POL) | ((n&0x1) << 0 )))
+
+/* n = 1,4,8,14 */
+#define __ssi_set_tx_trigger(n) 		\
+do { 						\
+	REG_SSI_CR1 &= ~SSI_CR1_TTRG_MASK; 	\
+	REG_SSI_CR1 |= SSI_CR1_TTRG_##n; 	\
+} while (0)
+
+/* n = 1,4,8,14 */
+#define __ssi_set_rx_trigger(n) 		\
+do { 						\
+	REG_SSI_CR1 &= ~SSI_CR1_RTRG_MASK; 	\
+	REG_SSI_CR1 |= SSI_CR1_RTRG_##n; 	\
+} while (0)
+
+#define __ssi_get_txfifo_count() \
+    ( (REG_SSI_SR & SSI_SR_TFIFONUM_MASK) >> SSI_SR_TFIFONUM_BIT )
+
+#define __ssi_get_rxfifo_count() \
+    ( (REG_SSI_SR & SSI_SR_RFIFONUM_MASK) >> SSI_SR_RFIFONUM_BIT )
+
+#define __ssi_clear_errors() \
+    ( REG_SSI_SR &= ~(SSI_SR_UNDR | SSI_SR_OVER) )
+
+#define __ssi_transfer_end()	( REG_SSI_SR & SSI_SR_END )
+#define __ssi_is_busy()		( REG_SSI_SR & SSI_SR_BUSY )
+
+#define __ssi_txfifo_full()	( REG_SSI_SR & SSI_SR_TFF )
+#define __ssi_rxfifo_empty()	( REG_SSI_SR & SSI_SR_RFE )
+#define __ssi_rxfifo_noempty()	( REG_SSI_SR & SSI_SR_RFHF )
+#define __ssi_rxfifo_half_full()	( REG_SSI_SR & SSI_SR_RFHF )
+#define __ssi_txfifo_half_empty()	( REG_SSI_SR & SSI_SR_TFHE )
+#define __ssi_underrun()	( REG_SSI_SR & SSI_SR_UNDR )
+#define __ssi_overrun()	( REG_SSI_SR & SSI_SR_OVER )
+
+#define __ssi_set_clk(dev_clk, ssi_clk) \
+  ( REG_SSI_GR = (dev_clk) / (2*(ssi_clk)) - 1 )
+
+#define __ssi_receive_data()    REG_SSI_DR
+#define __ssi_transmit_data(v)  ( REG_SSI_DR = (v) )
+
+#endif /* __ASM_JZ4730_OPS_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4730/regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4730/regs.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,2550 @@
+/*
+ *  linux/include/asm-mips/mach-jz4730/regs.h
+ *
+ *  JZ4730 registers definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4730_REGS_H__
+#define __ASM_JZ4730_REGS_H__
+
+#if defined(__ASSEMBLY__) || defined(__LANGUAGE_ASSEMBLY)
+#define REG8(addr)	(addr)
+#define REG16(addr)	(addr)
+#define REG32(addr)	(addr)
+#else
+#define REG8(addr)	*((volatile unsigned char *)(addr))
+#define REG16(addr)	*((volatile unsigned short *)(addr))
+#define REG32(addr)	*((volatile unsigned int *)(addr))
+#endif
+
+#define	HARB_BASE	0xB3000000
+#define	EMC_BASE	0xB3010000
+#define	DMAC_BASE	0xB3020000
+#define	UHC_BASE	0xB3030000
+#define	UDC_BASE	0xB3040000
+#define	LCD_BASE	0xB3050000
+#define	CIM_BASE	0xB3060000
+#define	ETH_BASE	0xB3100000
+#define	NBM_BASE	0xB3F00000
+
+#define	CPM_BASE	0xB0000000
+#define	INTC_BASE	0xB0001000
+#define	OST_BASE	0xB0002000
+#define	RTC_BASE	0xB0003000
+#define	WDT_BASE	0xB0004000
+#define	GPIO_BASE	0xB0010000
+#define	AIC_BASE	0xB0020000
+#define	MSC_BASE	0xB0021000
+#define	UART0_BASE	0xB0030000
+#define	UART1_BASE	0xB0031000
+#define	UART2_BASE	0xB0032000
+#define	UART3_BASE	0xB0033000
+#define	FIR_BASE	0xB0040000
+#define	SCC_BASE	0xB0041000
+#define	SCC0_BASE	0xB0041000
+#define	I2C_BASE	0xB0042000
+#define	SSI_BASE	0xB0043000
+#define	SCC1_BASE	0xB0044000
+#define	PWM0_BASE	0xB0050000
+#define	PWM1_BASE	0xB0051000
+#define	DES_BASE	0xB0060000
+#define	UPRT_BASE	0xB0061000
+#define KBC_BASE	0xB0062000
+
+
+
+
+/*************************************************************************
+ * MSC
+ *************************************************************************/
+#define	MSC_STRPCL		(MSC_BASE + 0x000)
+#define	MSC_STAT		(MSC_BASE + 0x004)
+#define	MSC_CLKRT		(MSC_BASE + 0x008)
+#define	MSC_CMDAT		(MSC_BASE + 0x00C)
+#define	MSC_RESTO		(MSC_BASE + 0x010)
+#define	MSC_RDTO		(MSC_BASE + 0x014)
+#define	MSC_BLKLEN		(MSC_BASE + 0x018)
+#define	MSC_NOB			(MSC_BASE + 0x01C)
+#define	MSC_SNOB		(MSC_BASE + 0x020)
+#define	MSC_IMASK		(MSC_BASE + 0x024)
+#define	MSC_IREG		(MSC_BASE + 0x028)
+#define	MSC_CMD			(MSC_BASE + 0x02C)
+#define	MSC_ARG			(MSC_BASE + 0x030)
+#define	MSC_RES			(MSC_BASE + 0x034)
+#define	MSC_RXFIFO		(MSC_BASE + 0x038)
+#define	MSC_TXFIFO		(MSC_BASE + 0x03C)
+
+#define	REG_MSC_STRPCL		REG16(MSC_STRPCL)
+#define	REG_MSC_STAT		REG32(MSC_STAT)
+#define	REG_MSC_CLKRT		REG16(MSC_CLKRT)
+#define	REG_MSC_CMDAT		REG32(MSC_CMDAT)
+#define	REG_MSC_RESTO		REG16(MSC_RESTO)
+#define	REG_MSC_RDTO		REG16(MSC_RDTO)
+#define	REG_MSC_BLKLEN		REG16(MSC_BLKLEN)
+#define	REG_MSC_NOB		REG16(MSC_NOB)
+#define	REG_MSC_SNOB		REG16(MSC_SNOB)
+#define	REG_MSC_IMASK		REG16(MSC_IMASK)
+#define	REG_MSC_IREG		REG16(MSC_IREG)
+#define	REG_MSC_CMD		REG8(MSC_CMD)
+#define	REG_MSC_ARG		REG32(MSC_ARG)
+#define	REG_MSC_RES		REG16(MSC_RES)
+#define	REG_MSC_RXFIFO		REG32(MSC_RXFIFO)
+#define	REG_MSC_TXFIFO		REG32(MSC_TXFIFO)
+
+/* MSC Clock and Control Register (MSC_STRPCL) */
+
+#define MSC_STRPCL_EXIT_MULTIPLE	(1 << 7)
+#define MSC_STRPCL_EXIT_TRANSFER	(1 << 6)
+#define MSC_STRPCL_START_READWAIT	(1 << 5)
+#define MSC_STRPCL_STOP_READWAIT	(1 << 4)
+#define MSC_STRPCL_RESET		(1 << 3)
+#define MSC_STRPCL_START_OP		(1 << 2)
+#define MSC_STRPCL_CLOCK_CONTROL_BIT	0
+#define MSC_STRPCL_CLOCK_CONTROL_MASK	(0x3 << MSC_STRPCL_CLOCK_CONTROL_BIT)
+  #define MSC_STRPCL_CLOCK_CONTROL_STOP	  (0x1 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Stop MMC/SD clock */
+  #define MSC_STRPCL_CLOCK_CONTROL_START  (0x2 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Start MMC/SD clock */
+
+/* MSC Status Register (MSC_STAT) */
+
+#define MSC_STAT_IS_RESETTING		(1 << 15)
+#define MSC_STAT_SDIO_INT_ACTIVE	(1 << 14)
+#define MSC_STAT_PRG_DONE		(1 << 13)
+#define MSC_STAT_DATA_TRAN_DONE		(1 << 12)
+#define MSC_STAT_END_CMD_RES		(1 << 11)
+#define MSC_STAT_DATA_FIFO_AFULL	(1 << 10)
+#define MSC_STAT_IS_READWAIT		(1 << 9)
+#define MSC_STAT_CLK_EN			(1 << 8)
+#define MSC_STAT_DATA_FIFO_FULL		(1 << 7)
+#define MSC_STAT_DATA_FIFO_EMPTY	(1 << 6)
+#define MSC_STAT_CRC_RES_ERR		(1 << 5)
+#define MSC_STAT_CRC_READ_ERROR		(1 << 4)
+#define MSC_STAT_CRC_WRITE_ERROR_BIT	2
+#define MSC_STAT_CRC_WRITE_ERROR_MASK	(0x3 << MSC_STAT_CRC_WRITE_ERROR_BIT)
+  #define MSC_STAT_CRC_WRITE_ERROR_NO		(0 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No error on transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR		(1 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* Card observed erroneous transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR_NOSTS	(2 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No CRC status is sent back */
+#define MSC_STAT_TIME_OUT_RES		(1 << 1)
+#define MSC_STAT_TIME_OUT_READ		(1 << 0)
+
+/* MSC Bus Clock Control Register (MSC_CLKRT) */
+
+#define	MSC_CLKRT_CLK_RATE_BIT		0
+#define	MSC_CLKRT_CLK_RATE_MASK		(0x7 << MSC_CLKRT_CLK_RATE_BIT)
+  #define MSC_CLKRT_CLK_RATE_DIV_1	  (0x0 << MSC_CLKRT_CLK_RATE_BIT) /* CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_2	  (0x1 << MSC_CLKRT_CLK_RATE_BIT) /* 1/2 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_4	  (0x2 << MSC_CLKRT_CLK_RATE_BIT) /* 1/4 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_8	  (0x3 << MSC_CLKRT_CLK_RATE_BIT) /* 1/8 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_16	  (0x4 << MSC_CLKRT_CLK_RATE_BIT) /* 1/16 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_32	  (0x5 << MSC_CLKRT_CLK_RATE_BIT) /* 1/32 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_64	  (0x6 << MSC_CLKRT_CLK_RATE_BIT) /* 1/64 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_128	  (0x7 << MSC_CLKRT_CLK_RATE_BIT) /* 1/128 of CLK_SRC */
+
+/* MSC Command Sequence Control Register (MSC_CMDAT) */
+
+#define	MSC_CMDAT_IO_ABORT		(1 << 11)
+#define	MSC_CMDAT_BUS_WIDTH_BIT		9
+#define	MSC_CMDAT_BUS_WIDTH_MASK	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define MSC_CMDAT_BUS_WIDTH_1BIT	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT) /* 1-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_4BIT	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT) /* 4-bit data bus */
+  #define CMDAT_BUS_WIDTH1	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define CMDAT_BUS_WIDTH4	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT)
+#define	MSC_CMDAT_DMA_EN		(1 << 8)
+#define	MSC_CMDAT_INIT			(1 << 7)
+#define	MSC_CMDAT_BUSY			(1 << 6)
+#define	MSC_CMDAT_STREAM_BLOCK		(1 << 5)
+#define	MSC_CMDAT_WRITE			(1 << 4)
+#define	MSC_CMDAT_READ			(0 << 4)
+#define	MSC_CMDAT_DATA_EN		(1 << 3)
+#define	MSC_CMDAT_RESPONSE_BIT	0
+#define	MSC_CMDAT_RESPONSE_MASK	(0x7 << MSC_CMDAT_RESPONSE_BIT)
+  #define MSC_CMDAT_RESPONSE_NONE  (0x0 << MSC_CMDAT_RESPONSE_BIT) /* No response */
+  #define MSC_CMDAT_RESPONSE_R1	  (0x1 << MSC_CMDAT_RESPONSE_BIT) /* Format R1 and R1b */
+  #define MSC_CMDAT_RESPONSE_R2	  (0x2 << MSC_CMDAT_RESPONSE_BIT) /* Format R2 */
+  #define MSC_CMDAT_RESPONSE_R3	  (0x3 << MSC_CMDAT_RESPONSE_BIT) /* Format R3 */
+  #define MSC_CMDAT_RESPONSE_R4	  (0x4 << MSC_CMDAT_RESPONSE_BIT) /* Format R4 */
+  #define MSC_CMDAT_RESPONSE_R5	  (0x5 << MSC_CMDAT_RESPONSE_BIT) /* Format R5 */
+  #define MSC_CMDAT_RESPONSE_R6	  (0x6 << MSC_CMDAT_RESPONSE_BIT) /* Format R6 */
+
+#define	CMDAT_DMA_EN	(1 << 8)
+#define	CMDAT_INIT	(1 << 7)
+#define	CMDAT_BUSY	(1 << 6)
+#define	CMDAT_STREAM	(1 << 5)
+#define	CMDAT_WRITE	(1 << 4)
+#define	CMDAT_DATA_EN	(1 << 3)
+
+/* MSC Interrupts Mask Register (MSC_IMASK) */
+
+#define	MSC_IMASK_SDIO			(1 << 7)
+#define	MSC_IMASK_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IMASK_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IMASK_END_CMD_RES		(1 << 2)
+#define	MSC_IMASK_PRG_DONE		(1 << 1)
+#define	MSC_IMASK_DATA_TRAN_DONE	(1 << 0)
+
+
+/* MSC Interrupts Status Register (MSC_IREG) */
+
+#define	MSC_IREG_SDIO			(1 << 7)
+#define	MSC_IREG_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IREG_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IREG_END_CMD_RES		(1 << 2)
+#define	MSC_IREG_PRG_DONE		(1 << 1)
+#define	MSC_IREG_DATA_TRAN_DONE		(1 << 0)
+
+
+
+
+/*************************************************************************
+ * RTC
+ *************************************************************************/
+#define RTC_RCR		(RTC_BASE + 0x00)
+#define RTC_RSR		(RTC_BASE + 0x04)
+#define RTC_RSAR	(RTC_BASE + 0x08)
+#define RTC_RGR		(RTC_BASE + 0x0c)
+
+#define REG_RTC_RCR	REG32(RTC_RCR)
+#define REG_RTC_RSR	REG32(RTC_RSR)
+#define REG_RTC_RSAR	REG32(RTC_RSAR)
+#define REG_RTC_RGR	REG32(RTC_RGR)
+
+#define RTC_RCR_HZ	(1 << 6)
+#define RTC_RCR_HZIE	(1 << 5)
+#define RTC_RCR_AF	(1 << 4)
+#define RTC_RCR_AIE	(1 << 3)
+#define RTC_RCR_AE	(1 << 2)
+#define RTC_RCR_START	(1 << 0)
+
+#define RTC_RGR_LOCK		(1 << 31)
+#define RTC_RGR_ADJ_BIT		16
+#define RTC_RGR_ADJ_MASK	(0x3ff << RTC_RGR_ADJ_BIT)
+#define RTC_RGR_DIV_BIT		0
+#define RTC_REG_DIV_MASK	(0xff << RTC_RGR_DIV_BIT)
+
+
+
+
+/*************************************************************************
+ * FIR
+ *************************************************************************/
+#define	FIR_TDR			(FIR_BASE + 0x000)
+#define	FIR_RDR			(FIR_BASE + 0x004)
+#define	FIR_TFLR		(FIR_BASE + 0x008)
+#define	FIR_AR			(FIR_BASE + 0x00C)
+#define	FIR_CR1			(FIR_BASE + 0x010)
+#define	FIR_CR2			(FIR_BASE + 0x014)
+#define	FIR_SR			(FIR_BASE + 0x018)
+
+#define	REG_FIR_TDR		REG8(FIR_TDR)
+#define	REG_FIR_RDR		REG8(FIR_RDR)
+#define REG_FIR_TFLR		REG16(FIR_TFLR)
+#define REG_FIR_AR		REG8(FIR_AR)
+#define	REG_FIR_CR1		REG8(FIR_CR1)
+#define	REG_FIR_CR2		REG16(FIR_CR2)
+#define REG_FIR_SR		REG16(FIR_SR)
+
+/* FIR Control Register 1 (FIR_CR1) */
+
+#define FIR_CR1_FIRUE		(1 << 7)
+#define FIR_CR1_ACE		(1 << 6)
+#define FIR_CR1_EOUS		(1 << 5)
+#define FIR_CR1_TIIE		(1 << 4)
+#define FIR_CR1_TFIE		(1 << 3)
+#define FIR_CR1_RFIE		(1 << 2)
+#define FIR_CR1_TXE		(1 << 1)
+#define FIR_CR1_RXE		(1 << 0)
+
+/* FIR Control Register 2 (FIR_CR2) */
+
+#define FIR_CR2_SIPE		(1 << 10)
+#define FIR_CR2_BCRC		(1 << 9)
+#define FIR_CR2_TFLRS		(1 << 8)
+#define FIR_CR2_ISS		(1 << 7)
+#define FIR_CR2_LMS		(1 << 6)
+#define FIR_CR2_TPPS		(1 << 5)
+#define FIR_CR2_RPPS		(1 << 4)
+#define FIR_CR2_TTRG_BIT	2
+#define FIR_CR2_TTRG_MASK	(0x3 << FIR_CR2_TTRG_BIT)
+  #define FIR_CR2_TTRG_16	  (0 << FIR_CR2_TTRG_BIT) /* Transmit Trigger Level is 16 */
+  #define FIR_CR2_TTRG_32	  (1 << FIR_CR2_TTRG_BIT) /* Transmit Trigger Level is 32 */
+  #define FIR_CR2_TTRG_64	  (2 << FIR_CR2_TTRG_BIT) /* Transmit Trigger Level is 64 */
+  #define FIR_CR2_TTRG_128	  (3 << FIR_CR2_TTRG_BIT) /* Transmit Trigger Level is 128 */
+#define FIR_CR2_RTRG_BIT	0
+#define FIR_CR2_RTRG_MASK	(0x3 << FIR_CR2_RTRG_BIT)
+  #define FIR_CR2_RTRG_16	  (0 << FIR_CR2_RTRG_BIT) /* Receive Trigger Level is 16 */
+  #define FIR_CR2_RTRG_32	  (1 << FIR_CR2_RTRG_BIT) /* Receive Trigger Level is 32 */
+  #define FIR_CR2_RTRG_64	  (2 << FIR_CR2_RTRG_BIT) /* Receive Trigger Level is 64 */
+  #define FIR_CR2_RTRG_128	  (3 << FIR_CR2_RTRG_BIT) /* Receive Trigger Level is 128 */
+
+/* FIR Status Register (FIR_SR) */
+
+#define FIR_SR_RFW		(1 << 12)
+#define FIR_SR_RFA		(1 << 11)
+#define FIR_SR_TFRTL		(1 << 10)
+#define FIR_SR_RFRTL		(1 << 9)
+#define FIR_SR_URUN		(1 << 8)
+#define FIR_SR_RFTE		(1 << 7)
+#define FIR_SR_ORUN		(1 << 6)
+#define FIR_SR_CRCE		(1 << 5)
+#define FIR_SR_FEND		(1 << 4)
+#define FIR_SR_TFF		(1 << 3)
+#define FIR_SR_RFE		(1 << 2)
+#define FIR_SR_TIDLE		(1 << 1)
+#define FIR_SR_RB		(1 << 0)
+
+
+
+
+/*************************************************************************
+ * SCC
+ *************************************************************************/
+#define	SCC_DR(base)		((base) + 0x000)
+#define	SCC_FDR(base)		((base) + 0x004)
+#define	SCC_CR(base)		((base) + 0x008)
+#define	SCC1_CR(base)		((base) + 0x008)
+#define	SCC_SR(base)		((base) + 0x00C)
+#define	SCC_TFR(base)		((base) + 0x010)
+#define	SCC_EGTR(base)		((base) + 0x014)
+#define	SCC_ECR(base)		((base) + 0x018)
+#define	SCC_RTOR(base)		((base) + 0x01C)
+
+#define REG_SCC_DR(base)	REG8(SCC_DR(base))
+#define REG_SCC_FDR(base)	REG8(SCC_FDR(base))
+#define REG_SCC_CR(base)	REG32(SCC_CR(base))
+#define REG_SCC1_CR(base)	REG32(SCC1_CR(base))
+#define REG_SCC_SR(base)	REG16(SCC_SR(base))
+#define REG_SCC_TFR(base)	REG16(SCC_TFR(base))
+#define REG_SCC_EGTR(base)	REG8(SCC_EGTR(base))
+#define REG_SCC_ECR(base)	REG32(SCC_ECR(base))
+#define REG_SCC_RTOR(base)	REG8(SCC_RTOR(base))
+
+/* SCC FIFO Data Count Register (SCC_FDR) */
+
+#define SCC_FDR_EMPTY		0x00
+#define SCC_FDR_FULL		0x10
+
+/* SCC Control Register (SCC_CR) */
+
+#define SCC_CR_SCCE		(1 << 31)
+#define SCC_CR_TRS		(1 << 30)
+#define SCC_CR_T2R		(1 << 29)
+#define SCC_CR_FDIV_BIT		24
+#define SCC_CR_FDIV_MASK	(0x3 << SCC_CR_FDIV_BIT)
+  #define SCC_CR_FDIV_1		  (0 << SCC_CR_FDIV_BIT) /* SCC_CLK frequency is the same as device clock */
+  #define SCC_CR_FDIV_2		  (1 << SCC_CR_FDIV_BIT) /* SCC_CLK frequency is half of device clock */
+#define SCC_CR_FLUSH		(1 << 23)
+#define SCC_CR_TRIG_BIT		16
+#define SCC_CR_TRIG_MASK	(0x3 << SCC_CR_TRIG_BIT)
+  #define SCC_CR_TRIG_1		  (0 << SCC_CR_TRIG_BIT) /* Receive/Transmit-FIFO Trigger is 1 */
+  #define SCC_CR_TRIG_4		  (1 << SCC_CR_TRIG_BIT) /* Receive/Transmit-FIFO Trigger is 4 */
+  #define SCC_CR_TRIG_8		  (2 << SCC_CR_TRIG_BIT) /* Receive/Transmit-FIFO Trigger is 8 */
+  #define SCC_CR_TRIG_14	  (3 << SCC_CR_TRIG_BIT) /* Receive/Transmit-FIFO Trigger is 14 */
+#define SCC_CR_TP		(1 << 15)
+#define SCC_CR_CONV		(1 << 14)
+#define SCC_CR_TXIE		(1 << 13)
+#define SCC_CR_RXIE		(1 << 12)
+#define SCC_CR_TENDIE		(1 << 11)
+#define SCC_CR_RTOIE		(1 << 10)
+#define SCC_CR_ECIE		(1 << 9)
+#define SCC_CR_EPIE		(1 << 8)
+#define SCC_CR_RETIE		(1 << 7)
+#define SCC_CR_EOIE		(1 << 6)
+#define SCC_CR_TSEND		(1 << 3)
+#define SCC_CR_PX_BIT		1
+#define SCC_CR_PX_MASK		(0x3 << SCC_CR_PX_BIT)
+  #define SCC_CR_PX_NOT_SUPPORT	  (0 << SCC_CR_PX_BIT) /* SCC does not support clock stop */
+  #define SCC_CR_PX_STOP_LOW	  (1 << SCC_CR_PX_BIT) /* SCC_CLK stops at state low */
+  #define SCC_CR_PX_STOP_HIGH	  (2 << SCC_CR_PX_BIT) /* SCC_CLK stops at state high */
+#define SCC_CR_CLKSTP		(1 << 0)
+
+/* SCC Status Register (SCC_SR) */
+
+#define SCC_SR_TRANS		(1 << 15)
+#define SCC_SR_ORER		(1 << 12)
+#define SCC_SR_RTO		(1 << 11)
+#define SCC_SR_PER		(1 << 10)
+#define SCC_SR_TFTG		(1 << 9)
+#define SCC_SR_RFTG		(1 << 8)
+#define SCC_SR_TEND		(1 << 7)
+#define SCC_SR_RETR_3		(1 << 4)
+#define SCC_SR_ECNTO		(1 << 0)
+
+
+
+
+/*************************************************************************
+ * ETH
+ *************************************************************************/
+#define ETH_BMR		(ETH_BASE + 0x1000)
+#define ETH_TPDR	(ETH_BASE + 0x1004)
+#define ETH_RPDR	(ETH_BASE + 0x1008)
+#define ETH_RAR		(ETH_BASE + 0x100C)
+#define ETH_TAR		(ETH_BASE + 0x1010)
+#define ETH_SR		(ETH_BASE + 0x1014)
+#define ETH_CR		(ETH_BASE + 0x1018)
+#define ETH_IER		(ETH_BASE + 0x101C)
+#define ETH_MFCR	(ETH_BASE + 0x1020)
+#define ETH_CTAR	(ETH_BASE + 0x1050)
+#define ETH_CRAR	(ETH_BASE + 0x1054)
+#define ETH_MCR		(ETH_BASE + 0x0000)
+#define ETH_MAHR	(ETH_BASE + 0x0004)
+#define ETH_MALR	(ETH_BASE + 0x0008)
+#define ETH_HTHR	(ETH_BASE + 0x000C)
+#define ETH_HTLR	(ETH_BASE + 0x0010)
+#define ETH_MIAR	(ETH_BASE + 0x0014)
+#define ETH_MIDR	(ETH_BASE + 0x0018)
+#define ETH_FCR		(ETH_BASE + 0x001C)
+#define ETH_VTR1	(ETH_BASE + 0x0020)
+#define ETH_VTR2	(ETH_BASE + 0x0024)
+#define ETH_WKFR	(ETH_BASE + 0x0028)
+#define ETH_PMTR	(ETH_BASE + 0x002C)
+
+#define REG_ETH_BMR	REG32(ETH_BMR)
+#define REG_ETH_TPDR	REG32(ETH_TPDR)
+#define REG_ETH_RPDR	REG32(ETH_RPDR)
+#define REG_ETH_RAR	REG32(ETH_RAR)
+#define REG_ETH_TAR	REG32(ETH_TAR)
+#define REG_ETH_SR	REG32(ETH_SR)
+#define REG_ETH_CR	REG32(ETH_CR)
+#define REG_ETH_IER	REG32(ETH_IER)
+#define REG_ETH_MFCR	REG32(ETH_MFCR)
+#define REG_ETH_CTAR	REG32(ETH_CTAR)
+#define REG_ETH_CRAR	REG32(ETH_CRAR)
+#define REG_ETH_MCR	REG32(ETH_MCR)
+#define REG_ETH_MAHR	REG32(ETH_MAHR)
+#define REG_ETH_MALR	REG32(ETH_MALR)
+#define REG_ETH_HTHR	REG32(ETH_HTHR)
+#define REG_ETH_HTLR	REG32(ETH_HTLR)
+#define REG_ETH_MIAR	REG32(ETH_MIAR)
+#define REG_ETH_MIDR	REG32(ETH_MIDR)
+#define REG_ETH_FCR	REG32(ETH_FCR)
+#define REG_ETH_VTR1	REG32(ETH_VTR1)
+#define REG_ETH_VTR2	REG32(ETH_VTR2)
+#define REG_ETH_WKFR	REG32(ETH_WKFR)
+#define REG_ETH_PMTR	REG32(ETH_PMTR)
+
+/* Bus Mode Register (ETH_BMR) */
+
+#define ETH_BMR_DBO		(1 << 20)
+#define ETH_BMR_PBL_BIT		8
+#define ETH_BMR_PBL_MASK	(0x3f << ETH_BMR_PBL_BIT)
+  #define ETH_BMR_PBL_1		  (0x1 << ETH_BMR_PBL_BIT)
+  #define ETH_BMR_PBL_4		  (0x4 << ETH_BMR_PBL_BIT)
+#define ETH_BMR_BLE		(1 << 7)
+#define ETH_BMR_DSL_BIT		2
+#define ETH_BMR_DSL_MASK	(0x1f << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_0		  (0x0 << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_1		  (0x1 << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_2		  (0x2 << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_4		  (0x4 << ETH_BMR_DSL_BIT)
+  #define ETH_BMR_DSL_8		  (0x8 << ETH_BMR_DSL_BIT)
+#define ETH_BMR_SWR		(1 << 0)
+
+/* DMA Status Register (ETH_SR) */
+
+#define ETH_SR_EB_BIT		23
+#define ETH_SR_EB_MASK		(0x7 << ETH_SR_EB_BIT)
+  #define ETH_SR_EB_TX_ABORT	  (0x1 << ETH_SR_EB_BIT)
+  #define ETH_SR_EB_RX_ABORT	  (0x2 << ETH_SR_EB_BIT)
+#define ETH_SR_TS_BIT		20
+#define ETH_SR_TS_MASK		(0x7 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_STOP	  (0x0 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_FTD		  (0x1 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_WEOT	  (0x2 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_QDAT	  (0x3 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_SUSPEND	  (0x6 << ETH_SR_TS_BIT)
+  #define ETH_SR_TS_CTD		  (0x7 << ETH_SR_TS_BIT)
+#define ETH_SR_RS_BIT		17
+#define ETH_SR_RS_MASK		(0x7 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_STOP	  (0x0 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_FRD		  (0x1 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_CEOR	  (0x2 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_WRP		  (0x3 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_SUSPEND	  (0x4 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_CRD		  (0x5 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_FCF		  (0x6 << ETH_SR_RS_BIT)
+  #define ETH_SR_RS_QRF		  (0x7 << ETH_SR_RS_BIT)
+#define ETH_SR_NIS		(1 << 16)
+#define ETH_SR_AIS		(1 << 15)
+#define ETH_SR_ERI		(1 << 14)
+#define ETH_SR_FBE		(1 << 13)
+#define ETH_SR_ETI		(1 << 10)
+#define ETH_SR_RWT		(1 << 9)
+#define ETH_SR_RPS		(1 << 8)
+#define ETH_SR_RU		(1 << 7)
+#define ETH_SR_RI		(1 << 6)
+#define ETH_SR_UNF		(1 << 5)
+#define ETH_SR_TJT		(1 << 3)
+#define ETH_SR_TU		(1 << 2)
+#define ETH_SR_TPS		(1 << 1)
+#define ETH_SR_TI		(1 << 0)
+
+/* Control (Operation Mode) Register (ETH_CR) */
+
+#define ETH_CR_TTM		(1 << 22)
+#define ETH_CR_SF		(1 << 21)
+#define ETH_CR_TR_BIT		14
+#define ETH_CR_TR_MASK		(0x3 << ETH_CR_TR_BIT)
+#define ETH_CR_ST		(1 << 13)
+#define ETH_CR_OSF		(1 << 2)
+#define ETH_CR_SR		(1 << 1)
+
+/* Interrupt Enable Register (ETH_IER) */
+
+#define ETH_IER_NI		(1 << 16)
+#define ETH_IER_AI		(1 << 15)
+#define ETH_IER_ERE		(1 << 14)
+#define ETH_IER_FBE		(1 << 13)
+#define ETH_IER_ET		(1 << 10)
+#define ETH_IER_RWE		(1 << 9)
+#define ETH_IER_RS		(1 << 8)
+#define ETH_IER_RU		(1 << 7)
+#define ETH_IER_RI		(1 << 6)
+#define ETH_IER_UN		(1 << 5)
+#define ETH_IER_TJ		(1 << 3)
+#define ETH_IER_TU		(1 << 2)
+#define ETH_IER_TS		(1 << 1)
+#define ETH_IER_TI		(1 << 0)
+
+/* Missed Frame and Buffer Overflow Counter Register (ETH_MFCR) */
+
+#define ETH_MFCR_OVERFLOW_BIT	17
+#define ETH_MFCR_OVERFLOW_MASK	(0x7ff << ETH_MFCR_OVERFLOW_BIT)
+#define ETH_MFCR_MFC_BIT	0
+#define ETH_MFCR_MFC_MASK	(0xffff << ETH_MFCR_MFC_BIT)
+
+/* MAC Control Register (ETH_MCR) */
+
+#define ETH_MCR_RA		(1 << 31)
+#define ETH_MCR_HBD		(1 << 28)
+#define ETH_MCR_PS		(1 << 27)
+#define ETH_MCR_DRO		(1 << 23)
+#define ETH_MCR_OM_BIT		21
+#define ETH_MCR_OM_MASK		(0x3 << ETH_MCR_OM_BIT)
+  #define ETH_MCR_OM_NORMAL	  (0x0 << ETH_MCR_OM_BIT)
+  #define ETH_MCR_OM_INTERNAL	  (0x1 << ETH_MCR_OM_BIT)
+  #define ETH_MCR_OM_EXTERNAL	  (0x2 << ETH_MCR_OM_BIT)
+#define ETH_MCR_F		(1 << 20)
+#define ETH_MCR_PM		(1 << 19)
+#define ETH_MCR_PR		(1 << 18)
+#define ETH_MCR_IF		(1 << 17)
+#define ETH_MCR_PB		(1 << 16)
+#define ETH_MCR_HO		(1 << 15)
+#define ETH_MCR_HP		(1 << 13)
+#define ETH_MCR_LCC		(1 << 12)
+#define ETH_MCR_DBF		(1 << 11)
+#define ETH_MCR_DTRY		(1 << 10)
+#define ETH_MCR_ASTP		(1 << 8)
+#define ETH_MCR_BOLMT_BIT	6
+#define ETH_MCR_BOLMT_MASK	(0x3 << ETH_MCR_BOLMT_BIT)
+  #define ETH_MCR_BOLMT_10	  (0 << ETH_MCR_BOLMT_BIT)
+  #define ETH_MCR_BOLMT_8	  (1 << ETH_MCR_BOLMT_BIT)
+  #define ETH_MCR_BOLMT_4	  (2 << ETH_MCR_BOLMT_BIT)
+  #define ETH_MCR_BOLMT_1	  (3 << ETH_MCR_BOLMT_BIT)
+#define ETH_MCR_DC		(1 << 5)
+#define ETH_MCR_TE		(1 << 3)
+#define ETH_MCR_RE		(1 << 2)
+
+/* MII Address Register (ETH_MIAR) */
+
+#define ETH_MIAR_PHY_ADDR_BIT	11
+#define ETH_MIAR_PHY_ADDR_MASK	(0x1f << ETH_MIAR_PHY_ADDR_BIT)
+#define ETH_MIAR_MII_REG_BIT	6
+#define ETH_MIAR_MII_REG_MASK	(0x1f << ETH_MIAR_MII_REG_BIT)
+#define ETH_MIAR_MII_WRITE	(1 << 1)
+#define ETH_MIAR_MII_BUSY	(1 << 0)
+
+/* Flow Control Register (ETH_FCR) */
+
+#define	ETH_FCR_PAUSE_TIME_BIT	16
+#define	ETH_FCR_PAUSE_TIME_MASK	(0xffff << ETH_FCR_PAUSE_TIME_BIT)
+#define	ETH_FCR_PCF		(1 << 2)
+#define	ETH_FCR_FCE		(1 << 1)
+#define	ETH_FCR_BUSY		(1 << 0)
+
+/* PMT Control and Status Register (ETH_PMTR) */
+
+#define ETH_PMTR_GU		(1 << 9)
+#define ETH_PMTR_RF		(1 << 6)
+#define ETH_PMTR_MF		(1 << 5)
+#define ETH_PMTR_RWK		(1 << 2)
+#define ETH_PMTR_MPK		(1 << 1)
+
+/* Receive Descriptor 0 (ETH_RD0) Bits */
+
+#define ETH_RD0_OWN		(1 << 31)
+#define ETH_RD0_FF		(1 << 30)
+#define ETH_RD0_FL_BIT		16
+#define ETH_RD0_FL_MASK		(0x3fff << ETH_RD0_FL_BIT)
+#define ETH_RD0_ES		(1 << 15)
+#define ETH_RD0_DE		(1 << 14)
+#define ETH_RD0_LE		(1 << 12)
+#define ETH_RD0_RF		(1 << 11)
+#define ETH_RD0_MF		(1 << 10)
+#define ETH_RD0_FD		(1 << 9)
+#define ETH_RD0_LD		(1 << 8)
+#define ETH_RD0_TL		(1 << 7)
+#define ETH_RD0_CS		(1 << 6)
+#define ETH_RD0_FT		(1 << 5)
+#define ETH_RD0_WT		(1 << 4)
+#define ETH_RD0_ME		(1 << 3)
+#define ETH_RD0_DB		(1 << 2)
+#define ETH_RD0_CE		(1 << 1)
+
+/* Receive Descriptor 1 (ETH_RD1) Bits */
+
+#define ETH_RD1_RER		(1 << 25)
+#define ETH_RD1_RCH		(1 << 24)
+#define ETH_RD1_RBS2_BIT	11
+#define ETH_RD1_RBS2_MASK	(0x7ff << ETH_RD1_RBS2_BIT)
+#define ETH_RD1_RBS1_BIT	0
+#define ETH_RD1_RBS1_MASK	(0x7ff << ETH_RD1_RBS1_BIT)
+
+/* Transmit Descriptor 0 (ETH_TD0) Bits */
+
+#define ETH_TD0_OWN		(1 << 31)
+#define ETH_TD0_FA		(1 << 15)
+#define ETH_TD0_LOC		(1 << 11)
+#define ETH_TD0_NC		(1 << 10)
+#define ETH_TD0_LC		(1 << 9)
+#define ETH_TD0_EC		(1 << 8)
+#define ETH_TD0_HBF		(1 << 7)
+#define ETH_TD0_CC_BIT		3
+#define ETH_TD0_CC_MASK		(0xf << ETH_TD0_CC_BIT)
+#define ETH_TD0_ED		(1 << 2)
+#define ETH_TD0_UF		(1 << 1)
+#define ETH_TD0_DF		(1 << 0)
+
+/* Transmit Descriptor 1 (ETH_TD1) Bits */
+
+#define ETH_TD1_IC		(1 << 31)
+#define ETH_TD1_LS		(1 << 30)
+#define ETH_TD1_FS		(1 << 29)
+#define ETH_TD1_AC		(1 << 26)
+#define ETH_TD1_TER		(1 << 25)
+#define ETH_TD1_TCH		(1 << 24)
+#define ETH_TD1_DPD		(1 << 23)
+#define ETH_TD1_TBS2_BIT	11
+#define ETH_TD1_TBS2_MASK	(0x7ff << ETH_TD1_TBS2_BIT)
+#define ETH_TD1_TBS1_BIT	0
+#define ETH_TD1_TBS1_MASK	(0x7ff << ETH_TD1_TBS1_BIT)
+
+
+
+
+/*************************************************************************
+ * WDT
+ *************************************************************************/
+#define WDT_WTCSR	(WDT_BASE + 0x00)
+#define WDT_WTCNT	(WDT_BASE + 0x04)
+
+#define REG_WDT_WTCSR	REG8(WDT_WTCSR)
+#define REG_WDT_WTCNT	REG32(WDT_WTCNT)
+
+#define WDT_WTCSR_START	(1 << 4)
+
+
+
+
+/*************************************************************************
+ * OST
+ *************************************************************************/
+#define OST_TER		(OST_BASE + 0x00)
+#define OST_TRDR(n)	(OST_BASE + 0x10 + ((n) * 0x20))
+#define OST_TCNT(n)	(OST_BASE + 0x14 + ((n) * 0x20))
+#define OST_TCSR(n)	(OST_BASE + 0x18 + ((n) * 0x20))
+#define OST_TCRB(n)	(OST_BASE + 0x1c + ((n) * 0x20))
+
+#define REG_OST_TER	REG8(OST_TER)
+#define REG_OST_TRDR(n)	REG32(OST_TRDR((n)))
+#define REG_OST_TCNT(n)	REG32(OST_TCNT((n)))
+#define REG_OST_TCSR(n)	REG16(OST_TCSR((n)))
+#define REG_OST_TCRB(n)	REG32(OST_TCRB((n)))
+
+#define OST_TCSR_BUSY		(1 << 7)
+#define OST_TCSR_UF		(1 << 6)
+#define OST_TCSR_UIE		(1 << 5)
+#define OST_TCSR_CKS_BIT	0
+#define OST_TCSR_CKS_MASK	(0x07 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_PCLK_4	(0 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_PCLK_16	(1 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_PCLK_64	(2 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_PCLK_256	(3 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_RTCCLK	(4 << OST_TCSR_CKS_BIT)
+  #define OST_TCSR_CKS_EXTAL	(5 << OST_TCSR_CKS_BIT)
+
+#define OST_TCSR0       OST_TCSR(0)
+#define OST_TCSR1       OST_TCSR(1)
+#define OST_TCSR2       OST_TCSR(2)
+#define OST_TRDR0       OST_TRDR(0)
+#define OST_TRDR1       OST_TRDR(1)
+#define OST_TRDR2       OST_TRDR(2)
+#define OST_TCNT0       OST_TCNT(0)
+#define OST_TCNT1       OST_TCNT(1)
+#define OST_TCNT2       OST_TCNT(2)
+#define OST_TCRB0       OST_TCRB(0)
+#define OST_TCRB1       OST_TCRB(1)
+#define OST_TCRB2       OST_TCRB(2)
+
+/*************************************************************************
+ * UART
+ *************************************************************************/
+
+#define IRDA_BASE	UART0_BASE
+#define UART_BASE	UART0_BASE
+#define UART_OFF	0x1000
+
+/* register offset */
+#define OFF_RDR		(0x00)	/* R  8b H'xx */
+#define OFF_TDR		(0x00)	/* W  8b H'xx */
+#define OFF_DLLR	(0x00)	/* RW 8b H'00 */
+#define OFF_DLHR	(0x04)	/* RW 8b H'00 */
+#define OFF_IER		(0x04)	/* RW 8b H'00 */
+#define OFF_ISR		(0x08)	/* R  8b H'01 */
+#define OFF_FCR		(0x08)	/* W  8b H'00 */
+#define OFF_LCR		(0x0C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_LSR		(0x14)	/* R  8b H'00 */
+#define OFF_MSR		(0x18)	/* R  8b H'00 */
+#define OFF_SPR		(0x1C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_SIRCR	(0x20)	/* RW 8b H'00, UART0 */
+
+/* register address */
+#define UART0_RDR	(UART0_BASE + OFF_RDR)
+#define UART0_TDR	(UART0_BASE + OFF_TDR)
+#define UART0_DLLR	(UART0_BASE + OFF_DLLR)
+#define UART0_DLHR	(UART0_BASE + OFF_DLHR)
+#define UART0_IER	(UART0_BASE + OFF_IER)
+#define UART0_ISR	(UART0_BASE + OFF_ISR)
+#define UART0_FCR	(UART0_BASE + OFF_FCR)
+#define UART0_LCR	(UART0_BASE + OFF_LCR)
+#define UART0_MCR	(UART0_BASE + OFF_MCR)
+#define UART0_LSR	(UART0_BASE + OFF_LSR)
+#define UART0_MSR	(UART0_BASE + OFF_MSR)
+#define UART0_SPR	(UART0_BASE + OFF_SPR)
+#define UART0_SIRCR	(UART0_BASE + OFF_SIRCR)
+
+#define UART1_RDR	(UART1_BASE + OFF_RDR)
+#define UART1_TDR	(UART1_BASE + OFF_TDR)
+#define UART1_DLLR	(UART1_BASE + OFF_DLLR)
+#define UART1_DLHR	(UART1_BASE + OFF_DLHR)
+#define UART1_IER	(UART1_BASE + OFF_IER)
+#define UART1_ISR	(UART1_BASE + OFF_ISR)
+#define UART1_FCR	(UART1_BASE + OFF_FCR)
+#define UART1_LCR	(UART1_BASE + OFF_LCR)
+#define UART1_MCR	(UART1_BASE + OFF_MCR)
+#define UART1_LSR	(UART1_BASE + OFF_LSR)
+#define UART1_MSR	(UART1_BASE + OFF_MSR)
+#define UART1_SPR	(UART1_BASE + OFF_SPR)
+#define UART1_SIRCR	(UART1_BASE + OFF_SIRCR)
+
+#define UART2_RDR	(UART2_BASE + OFF_RDR)
+#define UART2_TDR	(UART2_BASE + OFF_TDR)
+#define UART2_DLLR	(UART2_BASE + OFF_DLLR)
+#define UART2_DLHR	(UART2_BASE + OFF_DLHR)
+#define UART2_IER	(UART2_BASE + OFF_IER)
+#define UART2_ISR	(UART2_BASE + OFF_ISR)
+#define UART2_FCR	(UART2_BASE + OFF_FCR)
+#define UART2_LCR	(UART2_BASE + OFF_LCR)
+#define UART2_MCR	(UART2_BASE + OFF_MCR)
+#define UART2_LSR	(UART2_BASE + OFF_LSR)
+#define UART2_MSR	(UART2_BASE + OFF_MSR)
+#define UART2_SPR	(UART2_BASE + OFF_SPR)
+#define UART2_SIRCR	(UART2_BASE + OFF_SIRCR)
+
+#define UART3_RDR	(UART3_BASE + OFF_RDR)
+#define UART3_TDR	(UART3_BASE + OFF_TDR)
+#define UART3_DLLR	(UART3_BASE + OFF_DLLR)
+#define UART3_DLHR	(UART3_BASE + OFF_DLHR)
+#define UART3_IER	(UART3_BASE + OFF_IER)
+#define UART3_ISR	(UART3_BASE + OFF_ISR)
+#define UART3_FCR	(UART3_BASE + OFF_FCR)
+#define UART3_LCR	(UART3_BASE + OFF_LCR)
+#define UART3_MCR	(UART3_BASE + OFF_MCR)
+#define UART3_LSR	(UART3_BASE + OFF_LSR)
+#define UART3_MSR	(UART3_BASE + OFF_MSR)
+#define UART3_SPR	(UART3_BASE + OFF_SPR)
+#define UART3_SIRCR	(UART3_BASE + OFF_SIRCR)
+
+/*
+ * Define macros for UARTIER
+ * UART Interrupt Enable Register
+ */
+#define UARTIER_RIE	(1 << 0)	/* 0: receive fifo "full" interrupt disable */
+#define UARTIER_TIE	(1 << 1)	/* 0: transmit fifo "empty" interrupt disable */
+#define UARTIER_RLIE	(1 << 2)	/* 0: receive line status interrupt disable */
+#define UARTIER_MIE	(1 << 3)	/* 0: modem status interrupt disable */
+#define UARTIER_RTIE	(1 << 4)	/* 0: receive timeout interrupt disable */
+
+/*
+ * Define macros for UARTISR
+ * UART Interrupt Status Register
+ */
+#define UARTISR_IP	(1 << 0)	/* 0: interrupt is pending  1: no interrupt */
+#define UARTISR_IID	(7 << 1)	/* Source of Interrupt */
+#define UARTISR_IID_MSI		(0 << 1)	/* Modem status interrupt */
+#define UARTISR_IID_THRI	(1 << 1)	/* Transmitter holding register empty */
+#define UARTISR_IID_RDI		(2 << 1)	/* Receiver data interrupt */
+#define UARTISR_IID_RLSI	(3 << 1)	/* Receiver line status interrupt */
+#define UARTISR_FFMS	(3 << 6)	/* FIFO mode select, set when UARTFCR.FE is set to 1 */
+#define UARTISR_FFMS_NO_FIFO	(0 << 6)
+#define UARTISR_FFMS_FIFO_MODE	(3 << 6)
+
+/*
+ * Define macros for UARTFCR
+ * UART FIFO Control Register
+ */
+#define UARTFCR_FE	(1 << 0)	/* 0: non-FIFO mode  1: FIFO mode */
+#define UARTFCR_RFLS	(1 << 1)	/* write 1 to flush receive FIFO */
+#define UARTFCR_TFLS	(1 << 2)	/* write 1 to flush transmit FIFO */
+#define UARTFCR_DMS	(1 << 3)	/* 0: disable DMA mode */
+#define UARTFCR_UUE	(1 << 4)	/* 0: disable UART */
+#define UARTFCR_RTRG	(3 << 6)	/* Receive FIFO Data Trigger */
+#define UARTFCR_RTRG_1	(0 << 6)
+#define UARTFCR_RTRG_4	(1 << 6)
+#define UARTFCR_RTRG_8	(2 << 6)
+#define UARTFCR_RTRG_15	(3 << 6)
+
+/*
+ * Define macros for UARTLCR
+ * UART Line Control Register
+ */
+#define UARTLCR_WLEN	(3 << 0)	/* word length */
+#define UARTLCR_WLEN_5	(0 << 0)
+#define UARTLCR_WLEN_6	(1 << 0)
+#define UARTLCR_WLEN_7	(2 << 0)
+#define UARTLCR_WLEN_8	(3 << 0)
+#define UARTLCR_STOP	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UARTLCR_PE	(1 << 3)	/* 0: parity disable */
+#define UARTLCR_PROE	(1 << 4)	/* 0: even parity  1: odd parity */
+#define UARTLCR_SPAR	(1 << 5)	/* 0: sticky parity disable */
+#define UARTLCR_SBRK	(1 << 6)	/* write 0 normal, write 1 send break */
+#define UARTLCR_DLAB	(1 << 7)	/* 0: access UARTRDR/TDR/IER  1: access UARTDLLR/DLHR */
+
+/*
+ * Define macros for UARTLSR
+ * UART Line Status Register
+ */
+#define UARTLSR_DR	(1 << 0)	/* 0: receive FIFO is empty  1: receive data is ready */
+#define UARTLSR_ORER	(1 << 1)	/* 0: no overrun error */
+#define UARTLSR_PER	(1 << 2)	/* 0: no parity error */
+#define UARTLSR_FER	(1 << 3)	/* 0; no framing error */
+#define UARTLSR_BRK	(1 << 4)	/* 0: no break detected  1: receive a break signal */
+#define UARTLSR_TDRQ	(1 << 5)	/* 1: transmit FIFO half "empty" */
+#define UARTLSR_TEMT	(1 << 6)	/* 1: transmit FIFO and shift registers empty */
+#define UARTLSR_RFER	(1 << 7)	/* 0: no receive error  1: receive error in FIFO mode */
+
+/*
+ * Define macros for UARTMCR
+ * UART Modem Control Register
+ */
+#define UARTMCR_DTR	(1 << 0)	/* 0: DTR_ ouput high */
+#define UARTMCR_RTS	(1 << 1)	/* 0: RTS_ output high */
+#define UARTMCR_OUT1	(1 << 2)	/* 0: UARTMSR.RI is set to 0 and RI_ input high */
+#define UARTMCR_OUT2	(1 << 3)	/* 0: UARTMSR.DCD is set to 0 and DCD_ input high */
+#define UARTMCR_LOOP	(1 << 4)	/* 0: normal  1: loopback mode */
+#define UARTMCR_MCE	(1 << 7)	/* 0: modem function is disable */
+
+/*
+ * Define macros for UARTMSR
+ * UART Modem Status Register
+ */
+#define UARTMSR_DCTS	(1 << 0)	/* 0: no change on CTS_ pin since last read of UARTMSR */
+#define UARTMSR_DDSR	(1 << 1)	/* 0: no change on DSR_ pin since last read of UARTMSR */
+#define UARTMSR_DRI	(1 << 2)	/* 0: no change on RI_ pin since last read of UARTMSR */
+#define UARTMSR_DDCD	(1 << 3)	/* 0: no change on DCD_ pin since last read of UARTMSR */
+#define UARTMSR_CTS	(1 << 4)	/* 0: CTS_ pin is high */
+#define UARTMSR_DSR	(1 << 5)	/* 0: DSR_ pin is high */
+#define UARTMSR_RI	(1 << 6)	/* 0: RI_ pin is high */
+#define UARTMSR_DCD	(1 << 7)	/* 0: DCD_ pin is high */
+
+/*
+ * Define macros for SIRCR
+ * Slow IrDA Control Register
+ */
+#define SIRCR_TSIRE	(1 << 0)	/* 0: transmitter is in UART mode  1: IrDA mode */
+#define SIRCR_RSIRE	(1 << 1)	/* 0: receiver is in UART mode  1: IrDA mode */
+#define SIRCR_TPWS	(1 << 2)	/* 0: transmit 0 pulse width is 3/16 of bit length
+					   1: 0 pulse width is 1.6us for 115.2Kbps */
+#define SIRCR_TXPL	(1 << 3)	/* 0: encoder generates a positive pulse for 0 */
+#define SIRCR_RXPL	(1 << 4)	/* 0: decoder interprets positive pulse as 0 */
+
+
+
+/*************************************************************************
+ * INTC
+ *************************************************************************/
+#define INTC_ISR	(INTC_BASE + 0x00)
+#define INTC_IMR	(INTC_BASE + 0x04)
+#define INTC_IMSR	(INTC_BASE + 0x08)
+#define INTC_IMCR	(INTC_BASE + 0x0c)
+#define INTC_IPR	(INTC_BASE + 0x10)
+
+#define REG_INTC_ISR	REG32(INTC_ISR)
+#define REG_INTC_IMR	REG32(INTC_IMR)
+#define REG_INTC_IMSR	REG32(INTC_IMSR)
+#define REG_INTC_IMCR	REG32(INTC_IMCR)
+#define REG_INTC_IPR	REG32(INTC_IPR)
+
+#define IRQ_I2C		1
+#define IRQ_PS2		2
+#define IRQ_UPRT	3
+#define IRQ_CORE	4
+#define IRQ_UART3	6
+#define IRQ_UART2	7
+#define IRQ_UART1	8
+#define IRQ_UART0	9
+#define IRQ_SCC1	10
+#define IRQ_SCC0	11
+#define IRQ_UDC		12
+#define IRQ_UHC		13
+#define IRQ_MSC		14
+#define IRQ_RTC		15
+#define IRQ_FIR		16
+#define IRQ_SSI		17
+#define IRQ_CIM		18
+#define IRQ_ETH		19
+#define IRQ_AIC		20
+#define IRQ_DMAC	21
+#define IRQ_OST2	22
+#define IRQ_OST1	23
+#define IRQ_OST0	24
+#define IRQ_GPIO3	25
+#define IRQ_GPIO2	26
+#define IRQ_GPIO1	27
+#define IRQ_GPIO0	28
+#define IRQ_LCD		30
+
+
+
+
+/*************************************************************************
+ * CIM
+ *************************************************************************/
+#define	CIM_CFG			(CIM_BASE + 0x0000)
+#define	CIM_CTRL		(CIM_BASE + 0x0004)
+#define	CIM_STATE		(CIM_BASE + 0x0008)
+#define	CIM_IID			(CIM_BASE + 0x000C)
+#define	CIM_RXFIFO		(CIM_BASE + 0x0010)
+#define	CIM_DA			(CIM_BASE + 0x0020)
+#define	CIM_FA			(CIM_BASE + 0x0024)
+#define	CIM_FID			(CIM_BASE + 0x0028)
+#define	CIM_CMD			(CIM_BASE + 0x002C)
+
+#define	REG_CIM_CFG		REG32(CIM_CFG)
+#define	REG_CIM_CTRL		REG32(CIM_CTRL)
+#define	REG_CIM_STATE		REG32(CIM_STATE)
+#define	REG_CIM_IID		REG32(CIM_IID)
+#define	REG_CIM_RXFIFO		REG32(CIM_RXFIFO)
+#define	REG_CIM_DA		REG32(CIM_DA)
+#define	REG_CIM_FA		REG32(CIM_FA)
+#define	REG_CIM_FID		REG32(CIM_FID)
+#define	REG_CIM_CMD		REG32(CIM_CMD)
+
+/* CIM Configuration Register  (CIM_CFG) */
+
+#define	CIM_CFG_INV_DAT		(1 << 15)
+#define	CIM_CFG_VSP		(1 << 14)
+#define	CIM_CFG_HSP		(1 << 13)
+#define	CIM_CFG_PCP		(1 << 12)
+#define	CIM_CFG_DUMMY_ZERO	(1 << 9)
+#define	CIM_CFG_EXT_VSYNC	(1 << 8)
+#define	CIM_CFG_PACK_BIT	4
+#define	CIM_CFG_PACK_MASK	(0x7 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_0	  (0 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_1	  (1 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_2	  (2 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_3	  (3 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_4	  (4 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_5	  (5 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_6	  (6 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_7	  (7 << CIM_CFG_PACK_BIT)
+#define	CIM_CFG_DSM_BIT		0
+#define	CIM_CFG_DSM_MASK	(0x3 << CIM_CFG_DSM_BIT)
+  #define CIM_CFG_DSM_CPM	  (0 << CIM_CFG_DSM_BIT) /* CCIR656 Progressive Mode */
+  #define CIM_CFG_DSM_CIM	  (1 << CIM_CFG_DSM_BIT) /* CCIR656 Interlace Mode */
+  #define CIM_CFG_DSM_GCM	  (2 << CIM_CFG_DSM_BIT) /* Gated Clock Mode */
+  #define CIM_CFG_DSM_NGCM	  (3 << CIM_CFG_DSM_BIT) /* Non-Gated Clock Mode */
+
+/* CIM Control Register  (CIM_CTRL) */
+
+#define	CIM_CTRL_MCLKDIV_BIT	24
+#define	CIM_CTRL_MCLKDIV_MASK	(0xff << CIM_CTRL_MCLKDIV_BIT)
+#define	CIM_CTRL_FRC_BIT	16
+#define	CIM_CTRL_FRC_MASK	(0xf << CIM_CTRL_FRC_BIT)
+  #define CIM_CTRL_FRC_1	  (0x0 << CIM_CTRL_FRC_BIT) /* Sample every frame */
+  #define CIM_CTRL_FRC_2	  (0x1 << CIM_CTRL_FRC_BIT) /* Sample 1/2 frame */
+  #define CIM_CTRL_FRC_3	  (0x2 << CIM_CTRL_FRC_BIT) /* Sample 1/3 frame */
+  #define CIM_CTRL_FRC_4	  (0x3 << CIM_CTRL_FRC_BIT) /* Sample 1/4 frame */
+  #define CIM_CTRL_FRC_5	  (0x4 << CIM_CTRL_FRC_BIT) /* Sample 1/5 frame */
+  #define CIM_CTRL_FRC_6	  (0x5 << CIM_CTRL_FRC_BIT) /* Sample 1/6 frame */
+  #define CIM_CTRL_FRC_7	  (0x6 << CIM_CTRL_FRC_BIT) /* Sample 1/7 frame */
+  #define CIM_CTRL_FRC_8	  (0x7 << CIM_CTRL_FRC_BIT) /* Sample 1/8 frame */
+  #define CIM_CTRL_FRC_9	  (0x8 << CIM_CTRL_FRC_BIT) /* Sample 1/9 frame */
+  #define CIM_CTRL_FRC_10	  (0x9 << CIM_CTRL_FRC_BIT) /* Sample 1/10 frame */
+  #define CIM_CTRL_FRC_11	  (0xA << CIM_CTRL_FRC_BIT) /* Sample 1/11 frame */
+  #define CIM_CTRL_FRC_12	  (0xB << CIM_CTRL_FRC_BIT) /* Sample 1/12 frame */
+  #define CIM_CTRL_FRC_13	  (0xC << CIM_CTRL_FRC_BIT) /* Sample 1/13 frame */
+  #define CIM_CTRL_FRC_14	  (0xD << CIM_CTRL_FRC_BIT) /* Sample 1/14 frame */
+  #define CIM_CTRL_FRC_15	  (0xE << CIM_CTRL_FRC_BIT) /* Sample 1/15 frame */
+  #define CIM_CTRL_FRC_16	  (0xF << CIM_CTRL_FRC_BIT) /* Sample 1/16 frame */
+#define	CIM_CTRL_VDDM		(1 << 13)
+#define	CIM_CTRL_DMA_SOFM	(1 << 12)
+#define	CIM_CTRL_DMA_EOFM	(1 << 11)
+#define	CIM_CTRL_DMA_STOPM	(1 << 10)
+#define	CIM_CTRL_RXF_TRIGM	(1 << 9)
+#define	CIM_CTRL_RXF_OFM	(1 << 8)
+#define	CIM_CTRL_RXF_TRIG_BIT	4
+#define	CIM_CTRL_RXF_TRIG_MASK	(0x7 << CIM_CTRL_RXF_TRIG_BIT)
+  #define CIM_CTRL_RXF_TRIG_4	  (0 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 4 */
+  #define CIM_CTRL_RXF_TRIG_8	  (1 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 8 */
+  #define CIM_CTRL_RXF_TRIG_12	  (2 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 12 */
+  #define CIM_CTRL_RXF_TRIG_16	  (3 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 16 */
+  #define CIM_CTRL_RXF_TRIG_20	  (4 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 20 */
+  #define CIM_CTRL_RXF_TRIG_24	  (5 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 24 */
+  #define CIM_CTRL_RXF_TRIG_28	  (6 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 28 */
+  #define CIM_CTRL_RXF_TRIG_32	  (7 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 32 */
+#define	CIM_CTRL_DMA_EN		(1 << 2)
+#define	CIM_CTRL_RXF_RST	(1 << 1)
+#define	CIM_CTRL_ENA		(1 << 0)
+
+/* CIM State Register  (CIM_STATE) */
+
+#define	CIM_STATE_DMA_SOF	(1 << 6)
+#define	CIM_STATE_DMA_EOF	(1 << 5)
+#define	CIM_STATE_DMA_STOP	(1 << 4)
+#define	CIM_STATE_RXF_OF	(1 << 3)
+#define	CIM_STATE_RXF_TRIG	(1 << 2)
+#define	CIM_STATE_RXF_EMPTY	(1 << 1)
+#define	CIM_STATE_VDD		(1 << 0)
+
+/* CIM DMA Command Register (CIM_CMD) */
+
+#define	CIM_CMD_SOFINT		(1 << 31)
+#define	CIM_CMD_EOFINT		(1 << 30)
+#define	CIM_CMD_STOP		(1 << 28)
+#define	CIM_CMD_LEN_BIT		0
+#define	CIM_CMD_LEN_MASK	(0xffffff << CIM_CMD_LEN_BIT)
+
+
+
+
+/*************************************************************************
+ * PWM
+ *************************************************************************/
+#define	PWM_CTR(n)		(PWM##n##_BASE + 0x000)
+#define	PWM_PER(n)		(PWM##n##_BASE + 0x004)
+#define	PWM_DUT(n)		(PWM##n##_BASE + 0x008)
+
+#define	REG_PWM_CTR(n)		REG8(PWM_CTR(n))
+#define	REG_PWM_PER(n)		REG16(PWM_PER(n))
+#define REG_PWM_DUT(n)		REG16(PWM_DUT(n))
+
+/* PWM Control Register (PWM_CTR) */
+
+#define	PWM_CTR_EN		(1 << 7)
+#define	PWM_CTR_SD		(1 << 6)
+#define	PWM_CTR_PRESCALE_BIT	0
+#define	PWM_CTR_PRESCALE_MASK	(0x3f << PWM_CTR_PRESCALE_BIT)
+
+/* PWM Period Register (PWM_PER) */
+
+#define	PWM_PER_PERIOD_BIT	0
+#define	PWM_PER_PERIOD_MASK	(0x3ff << PWM_PER_PERIOD_BIT)
+
+/* PWM Duty Register (PWM_DUT) */
+
+#define PWM_DUT_FDUTY		(1 << 10)
+#define PWM_DUT_DUTY_BIT	0
+#define PWM_DUT_DUTY_MASK	(0x3ff << PWM_DUT_DUTY_BIT)
+
+
+
+
+/*************************************************************************
+ * EMC
+ *************************************************************************/
+#define EMC_BCR		(EMC_BASE + 0x00)
+#define EMC_SMCR0	(EMC_BASE + 0x10)
+#define EMC_SMCR1	(EMC_BASE + 0x14)
+#define EMC_SMCR2	(EMC_BASE + 0x18)
+#define EMC_SMCR3	(EMC_BASE + 0x1c)
+#define EMC_SMCR4	(EMC_BASE + 0x20)
+#define EMC_SMCR5	(EMC_BASE + 0x24)
+#define EMC_SMCR6	(EMC_BASE + 0x28)
+#define EMC_SMCR7	(EMC_BASE + 0x2c)
+#define EMC_SACR0	(EMC_BASE + 0x30)
+#define EMC_SACR1	(EMC_BASE + 0x34)
+#define EMC_SACR2	(EMC_BASE + 0x38)
+#define EMC_SACR3	(EMC_BASE + 0x3c)
+#define EMC_SACR4	(EMC_BASE + 0x40)
+#define EMC_SACR5	(EMC_BASE + 0x44)
+#define EMC_SACR6	(EMC_BASE + 0x48)
+#define EMC_SACR7	(EMC_BASE + 0x4c)
+#define EMC_NFCSR	(EMC_BASE + 0x50)
+#define EMC_NFECC	(EMC_BASE + 0x54)
+#define EMC_PCCR1	(EMC_BASE + 0x60)
+#define EMC_PCCR2	(EMC_BASE + 0x64)
+#define EMC_PCCR3	(EMC_BASE + 0x68)
+#define EMC_PCCR4	(EMC_BASE + 0x6c)
+#define EMC_DMCR	(EMC_BASE + 0x80)
+#define EMC_RTCSR	(EMC_BASE + 0x84)
+#define EMC_RTCNT	(EMC_BASE + 0x88)
+#define EMC_RTCOR	(EMC_BASE + 0x8c)
+#define EMC_DMAR1	(EMC_BASE + 0x90)
+#define EMC_DMAR2	(EMC_BASE + 0x94)
+#define EMC_DMAR3	(EMC_BASE + 0x98)
+#define EMC_DMAR4	(EMC_BASE + 0x9c)
+
+#define EMC_SDMR0	(EMC_BASE + 0xa000)
+#define EMC_SDMR1	(EMC_BASE + 0xb000)
+#define EMC_SDMR2	(EMC_BASE + 0xc000)
+#define EMC_SDMR3	(EMC_BASE + 0xd000)
+
+#define REG_EMC_BCR	REG32(EMC_BCR)
+#define REG_EMC_SMCR0	REG32(EMC_SMCR0)
+#define REG_EMC_SMCR1	REG32(EMC_SMCR1)
+#define REG_EMC_SMCR2	REG32(EMC_SMCR2)
+#define REG_EMC_SMCR3	REG32(EMC_SMCR3)
+#define REG_EMC_SMCR4	REG32(EMC_SMCR4)
+#define REG_EMC_SMCR5	REG32(EMC_SMCR5)
+#define REG_EMC_SMCR6	REG32(EMC_SMCR6)
+#define REG_EMC_SMCR7	REG32(EMC_SMCR7)
+#define REG_EMC_SACR0	REG32(EMC_SACR0)
+#define REG_EMC_SACR1	REG32(EMC_SACR1)
+#define REG_EMC_SACR2	REG32(EMC_SACR2)
+#define REG_EMC_SACR3	REG32(EMC_SACR3)
+#define REG_EMC_SACR4	REG32(EMC_SACR4)
+#define REG_EMC_SACR5	REG32(EMC_SACR5)
+#define REG_EMC_SACR6	REG32(EMC_SACR6)
+#define REG_EMC_SACR7	REG32(EMC_SACR7)
+#define REG_EMC_NFCSR	REG32(EMC_NFCSR)
+#define REG_EMC_NFECC	REG32(EMC_NFECC)
+#define REG_EMC_DMCR	REG32(EMC_DMCR)
+#define REG_EMC_RTCSR	REG16(EMC_RTCSR)
+#define REG_EMC_RTCNT	REG16(EMC_RTCNT)
+#define REG_EMC_RTCOR	REG16(EMC_RTCOR)
+#define REG_EMC_DMAR1	REG32(EMC_DMAR1)
+#define REG_EMC_DMAR2	REG32(EMC_DMAR2)
+#define REG_EMC_DMAR3	REG32(EMC_DMAR3)
+#define REG_EMC_DMAR4	REG32(EMC_DMAR4)
+#define REG_EMC_PCCR1	REG32(EMC_PCCR1)
+#define REG_EMC_PCCR2	REG32(EMC_PCCR2)
+#define REG_EMC_PCCR3	REG32(EMC_PCCR3)
+#define REG_EMC_PCCR4	REG32(EMC_PCCR4)
+
+
+#define EMC_BCR_BRE		(1 << 1)
+
+#define EMC_SMCR_STRV_BIT	24
+#define EMC_SMCR_STRV_MASK	(0x0f << EMC_SMCR_STRV_BIT)
+#define EMC_SMCR_TAW_BIT	20
+#define EMC_SMCR_TAW_MASK	(0x0f << EMC_SMCR_TAW_BIT)
+#define EMC_SMCR_TBP_BIT	16
+#define EMC_SMCR_TBP_MASK	(0x0f << EMC_SMCR_TBP_BIT)
+#define EMC_SMCR_TAH_BIT	12
+#define EMC_SMCR_TAH_MASK	(0x07 << EMC_SMCR_TAH_BIT)
+#define EMC_SMCR_TAS_BIT	8
+#define EMC_SMCR_TAS_MASK	(0x07 << EMC_SMCR_TAS_BIT)
+#define EMC_SMCR_BW_BIT		6
+#define EMC_SMCR_BW_MASK	(0x03 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_8BIT	(0 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_16BIT	(1 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_32BIT	(2 << EMC_SMCR_BW_BIT)
+#define EMC_SMCR_BCM		(1 << 3)
+#define EMC_SMCR_BL_BIT		1
+#define EMC_SMCR_BL_MASK	(0x03 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_4		(0 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_8		(1 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_16	(2 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_32	(3 << EMC_SMCR_BL_BIT)
+#define EMC_SMCR_SMT		(1 << 0)
+
+#define EMC_SACR_BASE_BIT	8
+#define EMC_SACR_BASE_MASK	(0xff << EMC_SACR_BASE_BIT)
+#define EMC_SACR_MASK_BIT	0
+#define EMC_SACR_MASK_MASK	(0xff << EMC_SACR_MASK_BIT)
+
+#define EMC_NFCSR_RB		(1 << 7)
+#define EMC_NFCSR_BOOT_SEL_BIT	4
+#define EMC_NFCSR_BOOT_SEL_MASK	(0x07 << EMC_NFCSR_BOOT_SEL_BIT)
+#define EMC_NFCSR_ERST		(1 << 3)
+#define EMC_NFCSR_ECCE		(1 << 2)
+#define EMC_NFCSR_FCE		(1 << 1)
+#define EMC_NFCSR_NFE		(1 << 0)
+
+#define EMC_NFECC_ECC2_BIT	16
+#define EMC_NFECC_ECC2_MASK	(0xff << EMC_NFECC_ECC2_BIT)
+#define EMC_NFECC_ECC1_BIT	8
+#define EMC_NFECC_ECC1_MASK	(0xff << EMC_NFECC_ECC1_BIT)
+#define EMC_NFECC_ECC0_BIT	0
+#define EMC_NFECC_ECC0_MASK	(0xff << EMC_NFECC_ECC0_BIT)
+
+#define EMC_DMCR_BW_BIT		31
+#define EMC_DMCR_BW		(1 << EMC_DMCR_BW_BIT)
+#define EMC_DMCR_CA_BIT		26
+#define EMC_DMCR_CA_MASK	(0x07 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_8		(0 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_9		(1 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_10	(2 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_11	(3 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_12	(4 << EMC_DMCR_CA_BIT)
+#define EMC_DMCR_RMODE		(1 << 25)
+#define EMC_DMCR_RFSH		(1 << 24)
+#define EMC_DMCR_MRSET		(1 << 23)
+#define EMC_DMCR_RA_BIT		20
+#define EMC_DMCR_RA_MASK	(0x03 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_11	(0 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_12	(1 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_13	(2 << EMC_DMCR_RA_BIT)
+#define EMC_DMCR_BA_BIT		19
+#define EMC_DMCR_BA		(1 << EMC_DMCR_BA_BIT)
+#define EMC_DMCR_PDM		(1 << 18)
+#define EMC_DMCR_EPIN		(1 << 17)
+#define EMC_DMCR_TRAS_BIT	13
+#define EMC_DMCR_TRAS_MASK	(0x07 << EMC_DMCR_TRAS_BIT)
+#define EMC_DMCR_RCD_BIT	11
+#define EMC_DMCR_RCD_MASK	(0x03 << EMC_DMCR_RCD_BIT)
+#define EMC_DMCR_TPC_BIT	8
+#define EMC_DMCR_TPC_MASK	(0x07 << EMC_DMCR_TPC_BIT)
+#define EMC_DMCR_TRWL_BIT	5
+#define EMC_DMCR_TRWL_MASK	(0x03 << EMC_DMCR_TRWL_BIT)
+#define EMC_DMCR_TRC_BIT	2
+#define EMC_DMCR_TRC_MASK	(0x07 << EMC_DMCR_TRC_BIT)
+#define EMC_DMCR_TCL_BIT	0
+#define EMC_DMCR_TCL_MASK	(0x03 << EMC_DMCR_TCL_BIT)
+
+#define EMC_RTCSR_CMF		(1 << 7)
+#define EMC_RTCSR_CKS_BIT	0
+#define EMC_RTCSR_CKS_MASK	(0x07 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_DISABLE	(0 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4	(1 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_16	(2 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_64	(3 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_256	(4 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_1024	(5 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_2048	(6 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4096	(7 << EMC_RTCSR_CKS_BIT)
+
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_BIT	0
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+#define EMC_SDMR_BM		(1 << 9)
+#define EMC_SDMR_OM_BIT		7
+#define EMC_SDMR_OM_MASK	(3 << EMC_SDMR_OM_BIT)
+  #define EMC_SDMR_OM_NORMAL	(0 << EMC_SDMR_OM_BIT)
+#define EMC_SDMR_CAS_BIT	4
+#define EMC_SDMR_CAS_MASK	(7 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_1	(1 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_2	(2 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_3	(3 << EMC_SDMR_CAS_BIT)
+#define EMC_SDMR_BT_BIT		3
+#define EMC_SDMR_BT_MASK	(1 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_SEQ	(0 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_INTR	(1 << EMC_SDMR_BT_BIT)
+#define EMC_SDMR_BL_BIT		0
+#define EMC_SDMR_BL_MASK	(7 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_1		(0 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_2		(1 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_4		(2 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_8		(3 << EMC_SDMR_BL_BIT)
+
+#define EMC_SDMR_CAS2_16BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS2_32BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+#define EMC_SDMR_CAS3_16BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS3_32BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+
+#define EMC_PCCR12_AMW		(1 << 31)
+#define EMC_PCCR12_AMAS_BIT	28
+#define EMC_PCCR12_AMAS_MASK	(0x07 << EMC_PCCR12_AMAS_BIT)
+#define EMC_PCCR12_AMAH_BIT	24
+#define EMC_PCCR12_AMAH_MASK	(0x07 << EMC_PCCR12_AMAH_BIT)
+#define EMC_PCCR12_AMPW_BIT	20
+#define EMC_PCCR12_AMPW_MASK	(0x0f << EMC_PCCR12_AMPW_BIT)
+#define EMC_PCCR12_AMRT_BIT	16
+#define EMC_PCCR12_AMRT_MASK	(0x0f << EMC_PCCR12_AMRT_BIT)
+#define EMC_PCCR12_CMW		(1 << 15)
+#define EMC_PCCR12_CMAS_BIT	12
+#define EMC_PCCR12_CMAS_MASK	(0x07 << EMC_PCCR12_CMAS_BIT)
+#define EMC_PCCR12_CMAH_BIT	8
+#define EMC_PCCR12_CMAH_MASK	(0x07 << EMC_PCCR12_CMAH_BIT)
+#define EMC_PCCR12_CMPW_BIT	4
+#define EMC_PCCR12_CMPW_MASK	(0x0f << EMC_PCCR12_CMPW_BIT)
+#define EMC_PCCR12_CMRT_BIT	0
+#define EMC_PCCR12_CMRT_MASK	(0x07 << EMC_PCCR12_CMRT_BIT)
+
+#define EMC_PCCR34_DRS_BIT	16
+#define EMC_PCCR34_DRS_MASK	(0x03 << EMC_PCCR34_DRS_BIT)
+  #define EMC_PCCR34_DRS_SPKR	(1 << EMC_PCCR34_DRS_BIT)
+  #define EMC_PCCR34_DRS_IOIS16	(2 << EMC_PCCR34_DRS_BIT)
+  #define EMC_PCCR34_DRS_INPACK	(3 << EMC_PCCR34_DRS_BIT)
+#define EMC_PCCR34_IOIS16	(1 << 15)
+#define EMC_PCCR34_IOW		(1 << 14)
+#define EMC_PCCR34_TCB_BIT	12
+#define EMC_PCCR34_TCB_MASK	(0x03 << EMC_PCCR34_TCB_BIT)
+#define EMC_PCCR34_IORT_BIT	8
+#define EMC_PCCR34_IORT_MASK	(0x07 << EMC_PCCR34_IORT_BIT)
+#define EMC_PCCR34_IOAE_BIT	6
+#define EMC_PCCR34_IOAE_MASK	(0x03 << EMC_PCCR34_IOAE_BIT)
+  #define EMC_PCCR34_IOAE_NONE	(0 << EMC_PCCR34_IOAE_BIT)
+  #define EMC_PCCR34_IOAE_1	(1 << EMC_PCCR34_IOAE_BIT)
+  #define EMC_PCCR34_IOAE_2	(2 << EMC_PCCR34_IOAE_BIT)
+  #define EMC_PCCR34_IOAE_5	(3 << EMC_PCCR34_IOAE_BIT)
+#define EMC_PCCR34_IOAH_BIT	4
+#define EMC_PCCR34_IOAH_MASK	(0x03 << EMC_PCCR34_IOAH_BIT)
+  #define EMC_PCCR34_IOAH_NONE	(0 << EMC_PCCR34_IOAH_BIT)
+  #define EMC_PCCR34_IOAH_1	(1 << EMC_PCCR34_IOAH_BIT)
+  #define EMC_PCCR34_IOAH_2	(2 << EMC_PCCR34_IOAH_BIT)
+  #define EMC_PCCR34_IOAH_5	(3 << EMC_PCCR34_IOAH_BIT)
+#define EMC_PCCR34_IOPW_BIT	0
+#define EMC_PCCR34_IOPW_MASK	(0x0f << EMC_PCCR34_IOPW_BIT)
+
+
+
+
+/*************************************************************************
+ * GPIO
+ *************************************************************************/
+#define GPIO_GPDR(n)	(GPIO_BASE + (0x00 + (n)*0x30))
+#define GPIO_GPDIR(n)	(GPIO_BASE + (0x04 + (n)*0x30))
+#define GPIO_GPODR(n)	(GPIO_BASE + (0x08 + (n)*0x30))
+#define GPIO_GPPUR(n)	(GPIO_BASE + (0x0c + (n)*0x30))
+#define GPIO_GPALR(n)	(GPIO_BASE + (0x10 + (n)*0x30))
+#define GPIO_GPAUR(n)	(GPIO_BASE + (0x14 + (n)*0x30))
+#define GPIO_GPIDLR(n)	(GPIO_BASE + (0x18 + (n)*0x30))
+#define GPIO_GPIDUR(n)	(GPIO_BASE + (0x1c + (n)*0x30))
+#define GPIO_GPIER(n)	(GPIO_BASE + (0x20 + (n)*0x30))
+#define GPIO_GPIMR(n)	(GPIO_BASE + (0x24 + (n)*0x30))
+#define GPIO_GPFR(n)	(GPIO_BASE + (0x28 + (n)*0x30))
+
+#define REG_GPIO_GPDR(n)	REG32(GPIO_GPDR((n)))
+#define REG_GPIO_GPDIR(n)	REG32(GPIO_GPDIR((n)))
+#define REG_GPIO_GPODR(n)	REG32(GPIO_GPODR((n)))
+#define REG_GPIO_GPPUR(n)	REG32(GPIO_GPPUR((n)))
+#define REG_GPIO_GPALR(n)	REG32(GPIO_GPALR((n)))
+#define REG_GPIO_GPAUR(n)	REG32(GPIO_GPAUR((n)))
+#define REG_GPIO_GPIDLR(n)	REG32(GPIO_GPIDLR((n)))
+#define REG_GPIO_GPIDUR(n)	REG32(GPIO_GPIDUR((n)))
+#define REG_GPIO_GPIER(n)	REG32(GPIO_GPIER((n)))
+#define REG_GPIO_GPIMR(n)	REG32(GPIO_GPIMR((n)))
+#define REG_GPIO_GPFR(n)	REG32(GPIO_GPFR((n)))
+
+#define GPIO_IRQ_LOLEVEL  0
+#define GPIO_IRQ_HILEVEL  1
+#define GPIO_IRQ_FALLEDG  2
+#define GPIO_IRQ_RAISEDG  3
+
+#define IRQ_GPIO_0	48
+#define NUM_GPIO	128
+
+#define GPIO_GPDR0      GPIO_GPDR(0)
+#define GPIO_GPDR1      GPIO_GPDR(1)
+#define GPIO_GPDR2      GPIO_GPDR(2)
+#define GPIO_GPDR3      GPIO_GPDR(3)
+#define GPIO_GPDIR0     GPIO_GPDIR(0)
+#define GPIO_GPDIR1     GPIO_GPDIR(1)
+#define GPIO_GPDIR2     GPIO_GPDIR(2)
+#define GPIO_GPDIR3     GPIO_GPDIR(3)
+#define GPIO_GPODR0     GPIO_GPODR(0)
+#define GPIO_GPODR1     GPIO_GPODR(1)
+#define GPIO_GPODR2     GPIO_GPODR(2)
+#define GPIO_GPODR3     GPIO_GPODR(3)
+#define GPIO_GPPUR0     GPIO_GPPUR(0)
+#define GPIO_GPPUR1     GPIO_GPPUR(1)
+#define GPIO_GPPUR2     GPIO_GPPUR(2)
+#define GPIO_GPPUR3     GPIO_GPPUR(3)
+#define GPIO_GPALR0     GPIO_GPALR(0)
+#define GPIO_GPALR1     GPIO_GPALR(1)
+#define GPIO_GPALR2     GPIO_GPALR(2)
+#define GPIO_GPALR3     GPIO_GPALR(3)
+#define GPIO_GPAUR0     GPIO_GPAUR(0)
+#define GPIO_GPAUR1     GPIO_GPAUR(1)
+#define GPIO_GPAUR2     GPIO_GPAUR(2)
+#define GPIO_GPAUR3     GPIO_GPAUR(3)
+#define GPIO_GPIDLR0    GPIO_GPIDLR(0)
+#define GPIO_GPIDLR1    GPIO_GPIDLR(1)
+#define GPIO_GPIDLR2    GPIO_GPIDLR(2)
+#define GPIO_GPIDLR3    GPIO_GPIDLR(3)
+#define GPIO_GPIDUR0    GPIO_GPIDUR(0)
+#define GPIO_GPIDUR1    GPIO_GPIDUR(1)
+#define GPIO_GPIDUR2    GPIO_GPIDUR(2)
+#define GPIO_GPIDUR3    GPIO_GPIDUR(3)
+#define GPIO_GPIER0     GPIO_GPIER(0)
+#define GPIO_GPIER1     GPIO_GPIER(1)
+#define GPIO_GPIER2     GPIO_GPIER(2)
+#define GPIO_GPIER3     GPIO_GPIER(3)
+#define GPIO_GPIMR0     GPIO_GPIMR(0)
+#define GPIO_GPIMR1     GPIO_GPIMR(1)
+#define GPIO_GPIMR2     GPIO_GPIMR(2)
+#define GPIO_GPIMR3     GPIO_GPIMR(3)
+#define GPIO_GPFR0      GPIO_GPFR(0)
+#define GPIO_GPFR1      GPIO_GPFR(1)
+#define GPIO_GPFR2      GPIO_GPFR(2)
+#define GPIO_GPFR3      GPIO_GPFR(3)
+
+
+/*************************************************************************
+ * HARB
+ *************************************************************************/
+#define	HARB_HAPOR		(HARB_BASE + 0x000)
+#define	HARB_HMCTR		(HARB_BASE + 0x010)
+#define	HARB_HME8H		(HARB_BASE + 0x014)
+#define	HARB_HMCR1		(HARB_BASE + 0x018)
+#define	HARB_HMER2		(HARB_BASE + 0x01C)
+#define	HARB_HMER3		(HARB_BASE + 0x020)
+#define	HARB_HMLTR		(HARB_BASE + 0x024)
+
+#define	REG_HARB_HAPOR		REG32(HARB_HAPOR)
+#define	REG_HARB_HMCTR		REG32(HARB_HMCTR)
+#define	REG_HARB_HME8H		REG32(HARB_HME8H)
+#define	REG_HARB_HMCR1		REG32(HARB_HMCR1)
+#define	REG_HARB_HMER2		REG32(HARB_HMER2)
+#define	REG_HARB_HMER3		REG32(HARB_HMER3)
+#define	REG_HARB_HMLTR		REG32(HARB_HMLTR)
+
+/* HARB Priority Order Register (HARB_HAPOR) */
+
+#define	HARB_HAPOR_UCHSEL 		(1 << 7)
+#define	HARB_HAPOR_PRIO_BIT		0
+#define	HARB_HAPOR_PRIO_MASK		(0xf << HARB_HAPOR_PRIO_BIT)
+
+/* AHB Monitor Control Register (HARB_HMCTR) */
+
+#define	HARB_HMCTR_HET3_BIT		20
+#define	HARB_HMCTR_HET3_MASK		(0xf << HARB_HMCTR_HET3_BIT)
+#define	HARB_HMCTR_HMS3_BIT		16
+#define	HARB_HMCTR_HMS3_MASK		(0xf << HARB_HMCTR_HMS3_BIT)
+#define	HARB_HMCTR_HET2_BIT		12
+#define	HARB_HMCTR_HET2_MASK		(0xf << HARB_HMCTR_HET2_BIT)
+#define	HARB_HMCTR_HMS2_BIT		8
+#define	HARB_HMCTR_HMS2_MASK		(0xf << HARB_HMCTR_HMS2_BIT)
+#define	HARB_HMCTR_HOVF3		(1 << 7)
+#define	HARB_HMCTR_HOVF2		(1 << 6)
+#define	HARB_HMCTR_HOVF1		(1 << 5)
+#define	HARB_HMCTR_HRST			(1 << 4)
+#define	HARB_HMCTR_HEE3			(1 << 2)
+#define	HARB_HMCTR_HEE2			(1 << 1)
+#define	HARB_HMCTR_HEE1			(1 << 0)
+
+/* AHB Monitor Event 8bits High Register (HARB_HME8H) */
+
+#define HARB_HME8H_HC8H1_BIT		16
+#define HARB_HME8H_HC8H1_MASK		(0xff << HARB_HME8H_HC8H1_BIT)
+#define HARB_HME8H_HC8H2_BIT		8
+#define HARB_HME8H_HC8H2_MASK		(0xff << HARB_HME8H_HC8H2_BIT)
+#define HARB_HME8H_HC8H3_BIT		0
+#define HARB_HME8H_HC8H3_MASK		(0xff << HARB_HME8H_HC8H3_BIT)
+
+/* AHB Monitor Latency Register (HARB_HMLTR) */
+
+#define HARB_HMLTR_HLT2_BIT		16
+#define HARB_HMLTR_HLT2_MASK		(0xffff << HARB_HMLTR_HLT2_BIT)
+#define HARB_HMLTR_HLT3_BIT		0
+#define HARB_HMLTR_HLT3_MASK		(0xffff << HARB_HMLTR_HLT3_BIT)
+
+
+
+
+/*************************************************************************
+ * I2C
+ *************************************************************************/
+#define	I2C_DR			(I2C_BASE + 0x000)
+#define	I2C_CR			(I2C_BASE + 0x004)
+#define	I2C_SR			(I2C_BASE + 0x008)
+#define	I2C_GR			(I2C_BASE + 0x00C)
+
+#define	REG_I2C_DR		REG8(I2C_DR)
+#define	REG_I2C_CR		REG8(I2C_CR)
+#define REG_I2C_SR		REG8(I2C_SR)
+#define REG_I2C_GR		REG16(I2C_GR)
+
+/* I2C Control Register (I2C_CR) */
+
+#define I2C_CR_IEN		(1 << 4)
+#define I2C_CR_STA		(1 << 3)
+#define I2C_CR_STO		(1 << 2)
+#define I2C_CR_AC		(1 << 1)
+#define I2C_CR_I2CE		(1 << 0)
+
+/* I2C Status Register (I2C_SR) */
+
+#define I2C_SR_STX		(1 << 4)
+#define I2C_SR_BUSY		(1 << 3)
+#define I2C_SR_TEND		(1 << 2)
+#define I2C_SR_DRF		(1 << 1)
+#define I2C_SR_ACKF		(1 << 0)
+
+
+
+
+/*************************************************************************
+ * UDC
+ *************************************************************************/
+#define UDC_EP0InCR	(UDC_BASE + 0x00)
+#define UDC_EP0InSR	(UDC_BASE + 0x04)
+#define UDC_EP0InBSR	(UDC_BASE + 0x08)
+#define UDC_EP0InMPSR	(UDC_BASE + 0x0c)
+#define UDC_EP0InDesR	(UDC_BASE + 0x14)
+#define UDC_EP1InCR	(UDC_BASE + 0x20)
+#define UDC_EP1InSR	(UDC_BASE + 0x24)
+#define UDC_EP1InBSR	(UDC_BASE + 0x28)
+#define UDC_EP1InMPSR	(UDC_BASE + 0x2c)
+#define UDC_EP1InDesR	(UDC_BASE + 0x34)
+#define UDC_EP2InCR	(UDC_BASE + 0x40)
+#define UDC_EP2InSR	(UDC_BASE + 0x44)
+#define UDC_EP2InBSR	(UDC_BASE + 0x48)
+#define UDC_EP2InMPSR	(UDC_BASE + 0x4c)
+#define UDC_EP2InDesR	(UDC_BASE + 0x54)
+#define UDC_EP3InCR	(UDC_BASE + 0x60)
+#define UDC_EP3InSR	(UDC_BASE + 0x64)
+#define UDC_EP3InBSR	(UDC_BASE + 0x68)
+#define UDC_EP3InMPSR	(UDC_BASE + 0x6c)
+#define UDC_EP3InDesR	(UDC_BASE + 0x74)
+#define UDC_EP4InCR	(UDC_BASE + 0x80)
+#define UDC_EP4InSR	(UDC_BASE + 0x84)
+#define UDC_EP4InBSR	(UDC_BASE + 0x88)
+#define UDC_EP4InMPSR	(UDC_BASE + 0x8c)
+#define UDC_EP4InDesR	(UDC_BASE + 0x94)
+
+#define UDC_EP0OutCR	(UDC_BASE + 0x200)
+#define UDC_EP0OutSR	(UDC_BASE + 0x204)
+#define UDC_EP0OutPFNR	(UDC_BASE + 0x208)
+#define UDC_EP0OutMPSR	(UDC_BASE + 0x20c)
+#define UDC_EP0OutSBPR	(UDC_BASE + 0x210)
+#define UDC_EP0OutDesR	(UDC_BASE + 0x214)
+#define UDC_EP5OutCR	(UDC_BASE + 0x2a0)
+#define UDC_EP5OutSR	(UDC_BASE + 0x2a4)
+#define UDC_EP5OutPFNR	(UDC_BASE + 0x2a8)
+#define UDC_EP5OutMPSR	(UDC_BASE + 0x2ac)
+#define UDC_EP5OutDesR	(UDC_BASE + 0x2b4)
+#define UDC_EP6OutCR	(UDC_BASE + 0x2c0)
+#define UDC_EP6OutSR	(UDC_BASE + 0x2c4)
+#define UDC_EP6OutPFNR	(UDC_BASE + 0x2c8)
+#define UDC_EP6OutMPSR	(UDC_BASE + 0x2cc)
+#define UDC_EP6OutDesR	(UDC_BASE + 0x2d4)
+#define UDC_EP7OutCR	(UDC_BASE + 0x2e0)
+#define UDC_EP7OutSR	(UDC_BASE + 0x2e4)
+#define UDC_EP7OutPFNR	(UDC_BASE + 0x2e8)
+#define UDC_EP7OutMPSR	(UDC_BASE + 0x2ec)
+#define UDC_EP7OutDesR	(UDC_BASE + 0x2f4)
+
+#define UDC_DevCFGR	(UDC_BASE + 0x400)
+#define UDC_DevCR	(UDC_BASE + 0x404)
+#define UDC_DevSR	(UDC_BASE + 0x408)
+#define UDC_DevIntR	(UDC_BASE + 0x40c)
+#define UDC_DevIntMR	(UDC_BASE + 0x410)
+#define UDC_EPIntR	(UDC_BASE + 0x414)
+#define UDC_EPIntMR	(UDC_BASE + 0x418)
+
+#define UDC_STCMAR	(UDC_BASE + 0x500)
+#define UDC_EP0InfR	(UDC_BASE + 0x504)
+#define UDC_EP1InfR	(UDC_BASE + 0x508)
+#define UDC_EP2InfR	(UDC_BASE + 0x50c)
+#define UDC_EP3InfR	(UDC_BASE + 0x510)
+#define UDC_EP4InfR	(UDC_BASE + 0x514)
+#define UDC_EP5InfR	(UDC_BASE + 0x518)
+#define UDC_EP6InfR	(UDC_BASE + 0x51c)
+#define UDC_EP7InfR	(UDC_BASE + 0x520)
+
+#define UDC_TXCONFIRM	(UDC_BASE + 0x41C)
+#define UDC_TXZLP	(UDC_BASE + 0x420)
+#define UDC_RXCONFIRM	(UDC_BASE + 0x41C)
+
+#define UDC_RXFIFO	(UDC_BASE + 0x800)
+#define UDC_TXFIFOEP0	(UDC_BASE + 0x840)
+
+#define REG_UDC_EP0InCR		REG32(UDC_EP0InCR)
+#define REG_UDC_EP0InSR		REG32(UDC_EP0InSR)
+#define REG_UDC_EP0InBSR	REG32(UDC_EP0InBSR)
+#define REG_UDC_EP0InMPSR	REG32(UDC_EP0InMPSR)
+#define REG_UDC_EP0InDesR	REG32(UDC_EP0InDesR)
+#define REG_UDC_EP1InCR		REG32(UDC_EP1InCR)
+#define REG_UDC_EP1InSR		REG32(UDC_EP1InSR)
+#define REG_UDC_EP1InBSR	REG32(UDC_EP1InBSR)
+#define REG_UDC_EP1InMPSR	REG32(UDC_EP1InMPSR)
+#define REG_UDC_EP1InDesR	REG32(UDC_EP1InDesR)
+#define REG_UDC_EP2InCR		REG32(UDC_EP2InCR)
+#define REG_UDC_EP2InSR		REG32(UDC_EP2InSR)
+#define REG_UDC_EP2InBSR	REG32(UDC_EP2InBSR)
+#define REG_UDC_EP2InMPSR	REG32(UDC_EP2InMPSR)
+#define REG_UDC_EP2InDesR	REG32(UDC_EP2InDesR)
+#define REG_UDC_EP3InCR		REG32(UDC_EP3InCR)
+#define REG_UDC_EP3InSR		REG32(UDC_EP3InSR)
+#define REG_UDC_EP3InBSR	REG32(UDC_EP3InBSR)
+#define REG_UDC_EP3InMPSR	REG32(UDC_EP3InMPSR)
+#define REG_UDC_EP3InDesR	REG32(UDC_EP3InDesR)
+#define REG_UDC_EP4InCR		REG32(UDC_EP4InCR)
+#define REG_UDC_EP4InSR		REG32(UDC_EP4InSR)
+#define REG_UDC_EP4InBSR	REG32(UDC_EP4InBSR)
+#define REG_UDC_EP4InMPSR	REG32(UDC_EP4InMPSR)
+#define REG_UDC_EP4InDesR	REG32(UDC_EP4InDesR)
+
+#define REG_UDC_EP0OutCR	REG32(UDC_EP0OutCR)
+#define REG_UDC_EP0OutSR	REG32(UDC_EP0OutSR)
+#define REG_UDC_EP0OutPFNR	REG32(UDC_EP0OutPFNR)
+#define REG_UDC_EP0OutMPSR	REG32(UDC_EP0OutMPSR)
+#define REG_UDC_EP0OutSBPR	REG32(UDC_EP0OutSBPR)
+#define REG_UDC_EP0OutDesR	REG32(UDC_EP0OutDesR)
+#define REG_UDC_EP5OutCR	REG32(UDC_EP5OutCR)
+#define REG_UDC_EP5OutSR	REG32(UDC_EP5OutSR)
+#define REG_UDC_EP5OutPFNR	REG32(UDC_EP5OutPFNR)
+#define REG_UDC_EP5OutMPSR	REG32(UDC_EP5OutMPSR)
+#define REG_UDC_EP5OutDesR	REG32(UDC_EP5OutDesR)
+#define REG_UDC_EP6OutCR	REG32(UDC_EP6OutCR)
+#define REG_UDC_EP6OutSR	REG32(UDC_EP6OutSR)
+#define REG_UDC_EP6OutPFNR	REG32(UDC_EP6OutPFNR)
+#define REG_UDC_EP6OutMPSR	REG32(UDC_EP6OutMPSR)
+#define REG_UDC_EP6OutDesR	REG32(UDC_EP6OutDesR)
+#define REG_UDC_EP7OutCR	REG32(UDC_EP7OutCR)
+#define REG_UDC_EP7OutSR	REG32(UDC_EP7OutSR)
+#define REG_UDC_EP7OutPFNR	REG32(UDC_EP7OutPFNR)
+#define REG_UDC_EP7OutMPSR	REG32(UDC_EP7OutMPSR)
+#define REG_UDC_EP7OutDesR	REG32(UDC_EP7OutDesR)
+
+#define REG_UDC_DevCFGR		REG32(UDC_DevCFGR)
+#define REG_UDC_DevCR		REG32(UDC_DevCR)
+#define REG_UDC_DevSR		REG32(UDC_DevSR)
+#define REG_UDC_DevIntR		REG32(UDC_DevIntR)
+#define REG_UDC_DevIntMR	REG32(UDC_DevIntMR)
+#define REG_UDC_EPIntR		REG32(UDC_EPIntR)
+#define REG_UDC_EPIntMR		REG32(UDC_EPIntMR)
+
+#define REG_UDC_STCMAR		REG32(UDC_STCMAR)
+#define REG_UDC_EP0InfR		REG32(UDC_EP0InfR)
+#define REG_UDC_EP1InfR		REG32(UDC_EP1InfR)
+#define REG_UDC_EP2InfR		REG32(UDC_EP2InfR)
+#define REG_UDC_EP3InfR		REG32(UDC_EP3InfR)
+#define REG_UDC_EP4InfR		REG32(UDC_EP4InfR)
+#define REG_UDC_EP5InfR		REG32(UDC_EP5InfR)
+#define REG_UDC_EP6InfR		REG32(UDC_EP6InfR)
+#define REG_UDC_EP7InfR		REG32(UDC_EP7InfR)
+
+#define UDC_DevCFGR_PI		(1 << 5)
+#define UDC_DevCFGR_SS		(1 << 4)
+#define UDC_DevCFGR_SP		(1 << 3)
+#define UDC_DevCFGR_RW		(1 << 2)
+#define UDC_DevCFGR_SPD_BIT	0
+#define UDC_DevCFGR_SPD_MASK	(0x03 << UDC_DevCFGR_SPD_BIT)
+  #define UDC_DevCFGR_SPD_HS	(0 << UDC_DevCFGR_SPD_BIT)
+  #define UDC_DevCFGR_SPD_LS	(2 << UDC_DevCFGR_SPD_BIT)
+  #define UDC_DevCFGR_SPD_FS	(3 << UDC_DevCFGR_SPD_BIT)
+
+#define UDC_DevCR_DM		(1 << 9)
+#define UDC_DevCR_BE		(1 << 5)
+#define UDC_DevCR_RES		(1 << 0)
+
+#define UDC_DevSR_ENUMSPD_BIT	13
+#define UDC_DevSR_ENUMSPD_MASK	(0x03 << UDC_DevSR_ENUMSPD_BIT)
+  #define UDC_DevSR_ENUMSPD_HS	(0 << UDC_DevSR_ENUMSPD_BIT)
+  #define UDC_DevSR_ENUMSPD_LS	(2 << UDC_DevSR_ENUMSPD_BIT)
+  #define UDC_DevSR_ENUMSPD_FS	(3 << UDC_DevSR_ENUMSPD_BIT)
+#define UDC_DevSR_SUSP		(1 << 12)
+#define UDC_DevSR_ALT_BIT	8
+#define UDC_DevSR_ALT_MASK	(0x0f << UDC_DevSR_ALT_BIT)
+#define UDC_DevSR_INTF_BIT	4
+#define UDC_DevSR_INTF_MASK	(0x0f << UDC_DevSR_INTF_BIT)
+#define UDC_DevSR_CFG_BIT	0
+#define UDC_DevSR_CFG_MASK	(0x0f << UDC_DevSR_CFG_BIT)
+
+#define UDC_DevIntR_ENUM	(1 << 6)
+#define UDC_DevIntR_SOF		(1 << 5)
+#define UDC_DevIntR_US		(1 << 4)
+#define UDC_DevIntR_UR		(1 << 3)
+#define UDC_DevIntR_SI		(1 << 1)
+#define UDC_DevIntR_SC		(1 << 0)
+
+#define UDC_EPIntR_OUTEP_BIT	16
+#define UDC_EPIntR_OUTEP_MASK	(0xffff << UDC_EPIntR_OUTEP_BIT)
+#define UDC_EPIntR_OUTEP0       0x00010000
+#define UDC_EPIntR_OUTEP5       0x00200000
+#define UDC_EPIntR_OUTEP6       0x00400000
+#define UDC_EPIntR_OUTEP7       0x00800000
+#define UDC_EPIntR_INEP_BIT	0
+#define UDC_EPIntR_INEP_MASK	(0xffff << UDC_EPIntR_INEP_BIT)
+#define UDC_EPIntR_INEP0        0x00000001
+#define UDC_EPIntR_INEP1        0x00000002
+#define UDC_EPIntR_INEP2        0x00000004
+#define UDC_EPIntR_INEP3        0x00000008
+#define UDC_EPIntR_INEP4        0x00000010
+
+
+#define UDC_EPIntMR_OUTEP_BIT	16
+#define UDC_EPIntMR_OUTEP_MASK	(0xffff << UDC_EPIntMR_OUTEP_BIT)
+#define UDC_EPIntMR_INEP_BIT	0
+#define UDC_EPIntMR_INEP_MASK	(0xffff << UDC_EPIntMR_INEP_BIT)
+
+#define UDC_EPCR_ET_BIT		4
+#define UDC_EPCR_ET_MASK	(0x03 << UDC_EPCR_ET_BIT)
+  #define UDC_EPCR_ET_CTRL	(0 << UDC_EPCR_ET_BIT)
+  #define UDC_EPCR_ET_ISO	(1 << UDC_EPCR_ET_BIT)
+  #define UDC_EPCR_ET_BULK	(2 << UDC_EPCR_ET_BIT)
+  #define UDC_EPCR_ET_INTR	(3 << UDC_EPCR_ET_BIT)
+#define UDC_EPCR_SN		(1 << 2)
+#define UDC_EPCR_F		(1 << 1)
+#define UDC_EPCR_S		(1 << 0)
+
+#define UDC_EPSR_RXPKTSIZE_BIT	11
+#define UDC_EPSR_RXPKTSIZE_MASK	(0x7ff << UDC_EPSR_RXPKTSIZE_BIT)
+#define UDC_EPSR_IN		(1 << 6)
+#define UDC_EPSR_OUT_BIT	4
+#define UDC_EPSR_OUT_MASK	(0x03 << UDC_EPSR_OUT_BIT)
+  #define UDC_EPSR_OUT_NONE	(0 << UDC_EPSR_OUT_BIT)
+  #define UDC_EPSR_OUT_RCVDATA	(1 << UDC_EPSR_OUT_BIT)
+  #define UDC_EPSR_OUT_RCVSETUP	(2 << UDC_EPSR_OUT_BIT)
+#define UDC_EPSR_PID_BIT	0
+#define UDC_EPSR_PID_MASK	(0x0f << UDC_EPSR_PID_BIT)
+
+#define UDC_EPInfR_MPS_BIT	19
+#define UDC_EPInfR_MPS_MASK	(0x3ff << UDC_EPInfR_MPS_BIT)
+#define UDC_EPInfR_ALTS_BIT	15
+#define UDC_EPInfR_ALTS_MASK	(0x0f << UDC_EPInfR_ALTS_BIT)
+#define UDC_EPInfR_IFN_BIT	11
+#define UDC_EPInfR_IFN_MASK	(0x0f << UDC_EPInfR_IFN_BIT)
+#define UDC_EPInfR_CGN_BIT	7
+#define UDC_EPInfR_CGN_MASK	(0x0f << UDC_EPInfR_CGN_BIT)
+#define UDC_EPInfR_EPT_BIT	5
+#define UDC_EPInfR_EPT_MASK	(0x03 << UDC_EPInfR_EPT_BIT)
+  #define UDC_EPInfR_EPT_CTRL	(0 << UDC_EPInfR_EPT_BIT)
+  #define UDC_EPInfR_EPT_ISO	(1 << UDC_EPInfR_EPT_BIT)
+  #define UDC_EPInfR_EPT_BULK	(2 << UDC_EPInfR_EPT_BIT)
+  #define UDC_EPInfR_EPT_INTR	(3 << UDC_EPInfR_EPT_BIT)
+#define UDC_EPInfR_EPD		(1 << 4)
+  #define UDC_EPInfR_EPD_OUT	(0 << 4)
+  #define UDC_EPInfR_EPD_IN	(1 << 4)
+
+#define UDC_EPInfR_EPN_BIT	0
+#define UDC_EPInfR_EPN_MASK	(0xf << UDC_EPInfR_EPN_BIT)
+
+
+
+
+/*************************************************************************
+ * DMAC 
+ *************************************************************************/
+#define DMAC_DSAR(n)	(DMAC_BASE + (0x00 + (n) * 0x20))
+#define DMAC_DDAR(n)	(DMAC_BASE + (0x04 + (n) * 0x20))
+#define DMAC_DTCR(n)	(DMAC_BASE + (0x08 + (n) * 0x20))
+#define DMAC_DRSR(n)	(DMAC_BASE + (0x0c + (n) * 0x20))
+#define DMAC_DCCSR(n)	(DMAC_BASE + (0x10 + (n) * 0x20))
+#define DMAC_DMAIPR	(DMAC_BASE + 0xf8)
+#define DMAC_DMACR	(DMAC_BASE + 0xfc)
+
+#define REG_DMAC_DSAR(n)	REG32(DMAC_DSAR((n)))
+#define REG_DMAC_DDAR(n)	REG32(DMAC_DDAR((n)))
+#define REG_DMAC_DTCR(n)	REG32(DMAC_DTCR((n)))
+#define REG_DMAC_DRSR(n)	REG32(DMAC_DRSR((n)))
+#define REG_DMAC_DCCSR(n)	REG32(DMAC_DCCSR((n)))
+#define REG_DMAC_DMAIPR		REG32(DMAC_DMAIPR)
+#define REG_DMAC_DMACR		REG32(DMAC_DMACR)
+
+#define DMAC_DRSR_RS_BIT	0
+#define DMAC_DRSR_RS_MASK	(0x1f << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_EXTREXTR		(0 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PCMCIAOUT	(4 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PCMCIAIN		(5 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AUTO		(8 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_DESOUT		(10 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_DESIN		(11 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3OUT		(14 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3IN		(15 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2OUT		(16 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2IN		(17 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1OUT		(18 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1IN		(19 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0OUT		(20 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0IN		(21 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSIOUT		(22 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSIIN		(23 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICOUT		(24 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICIN		(25 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSCOUT		(26 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSCIN		(27 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_OST2		(28 << DMAC_DRSR_RS_BIT)
+
+#define DMAC_DCCSR_EACKS	(1 << 31)
+#define DMAC_DCCSR_EACKM	(1 << 30)
+#define DMAC_DCCSR_ERDM_BIT	28
+#define DMAC_DCCSR_ERDM_MASK	(0x03 << DMAC_DCCSR_ERDM_BIT)
+  #define DMAC_DCCSR_ERDM_LLEVEL	(0 << DMAC_DCCSR_ERDM_BIT)
+  #define DMAC_DCCSR_ERDM_FEDGE		(1 << DMAC_DCCSR_ERDM_BIT)
+  #define DMAC_DCCSR_ERDM_HLEVEL	(2 << DMAC_DCCSR_ERDM_BIT)
+  #define DMAC_DCCSR_ERDM_REDGE		(3 << DMAC_DCCSR_ERDM_BIT)
+#define DMAC_DCCSR_EOPM		(1 << 27)
+#define DMAC_DCCSR_SAM		(1 << 23)
+#define DMAC_DCCSR_DAM		(1 << 22)
+#define DMAC_DCCSR_RDIL_BIT	16
+#define DMAC_DCCSR_RDIL_MASK	(0x0f << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_IGN	(0 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_2	(1 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_4	(2 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_8	(3 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_12	(4 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_16	(5 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_20	(6 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_24	(7 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_28	(8 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_32	(9 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_48	(10 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_60	(11 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_64	(12 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_124	(13 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_128	(14 << DMAC_DCCSR_RDIL_BIT)
+  #define DMAC_DCCSR_RDIL_200	(15 << DMAC_DCCSR_RDIL_BIT)
+#define DMAC_DCCSR_SWDH_BIT	14
+#define DMAC_DCCSR_SWDH_MASK	(0x03 << DMAC_DCCSR_SWDH_BIT)
+  #define DMAC_DCCSR_SWDH_32	(0 << DMAC_DCCSR_SWDH_BIT)
+  #define DMAC_DCCSR_SWDH_8	(1 << DMAC_DCCSR_SWDH_BIT)
+  #define DMAC_DCCSR_SWDH_16	(2 << DMAC_DCCSR_SWDH_BIT)
+#define DMAC_DCCSR_DWDH_BIT	12
+#define DMAC_DCCSR_DWDH_MASK	(0x03 << DMAC_DCCSR_DWDH_BIT)
+  #define DMAC_DCCSR_DWDH_32	(0 << DMAC_DCCSR_DWDH_BIT)
+  #define DMAC_DCCSR_DWDH_8	(1 << DMAC_DCCSR_DWDH_BIT)
+  #define DMAC_DCCSR_DWDH_16	(2 << DMAC_DCCSR_DWDH_BIT)
+#define DMAC_DCCSR_DS_BIT	8
+#define DMAC_DCCSR_DS_MASK	(0x07 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_32b	(0 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_8b	(1 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_16b	(2 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_16B	(3 << DMAC_DCCSR_DS_BIT)
+  #define DMAC_DCCSR_DS_32B	(4 << DMAC_DCCSR_DS_BIT)
+#define DMAC_DCCSR_TM		(1 << 7)
+#define DMAC_DCCSR_AR		(1 << 4)
+#define DMAC_DCCSR_TC		(1 << 3)
+#define DMAC_DCCSR_HLT		(1 << 2)
+#define DMAC_DCCSR_TCIE		(1 << 1)
+#define DMAC_DCCSR_CHDE		(1 << 0)
+
+#define DMAC_DMAIPR_CINT_BIT	8
+#define DMAC_DMAIPR_CINT_MASK	(0xff << DMAC_DMAIPR_CINT_BIT)
+
+#define DMAC_DMACR_PR_BIT	8
+#define DMAC_DMACR_PR_MASK	(0x03 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_01234567	(0 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_02314675	(1 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_20136457	(2 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_ROUNDROBIN	(3 << DMAC_DMACR_PR_BIT)
+#define DMAC_DMACR_HTR		(1 << 3)
+#define DMAC_DMACR_AER		(1 << 2)
+#define DMAC_DMACR_DME		(1 << 0)
+
+#define IRQ_DMA_0	32
+#define NUM_DMA		6
+
+#define DMAC_DSAR0      DMAC_DSAR(0)
+#define DMAC_DDAR0      DMAC_DDAR(0)
+#define DMAC_DTCR0      DMAC_DTCR(0)
+#define DMAC_DRSR0      DMAC_DRSR(0)
+#define DMAC_DCCSR0     DMAC_DCCSR(0)
+
+#define DMAC_DSAR1      DMAC_DSAR(1)
+#define DMAC_DDAR1      DMAC_DDAR(1)
+#define DMAC_DTCR1      DMAC_DTCR(1)
+#define DMAC_DRSR1      DMAC_DRSR(1)
+#define DMAC_DCCSR1     DMAC_DCCSR(1)
+
+#define DMAC_DSAR2      DMAC_DSAR(2)
+#define DMAC_DDAR2      DMAC_DDAR(2)
+#define DMAC_DTCR2      DMAC_DTCR(2)
+#define DMAC_DRSR2      DMAC_DRSR(2)
+#define DMAC_DCCSR2     DMAC_DCCSR(2)
+
+#define DMAC_DSAR3      DMAC_DSAR(3)
+#define DMAC_DDAR3      DMAC_DDAR(3)
+#define DMAC_DTCR3      DMAC_DTCR(3)
+#define DMAC_DRSR3      DMAC_DRSR(3)
+#define DMAC_DCCSR3     DMAC_DCCSR(3)
+
+#define DMAC_DSAR4      DMAC_DSAR(4)
+#define DMAC_DDAR4      DMAC_DDAR(4)
+#define DMAC_DTCR4      DMAC_DTCR(4)
+#define DMAC_DRSR4      DMAC_DRSR(4)
+#define DMAC_DCCSR4     DMAC_DCCSR(4)
+
+#define DMAC_DSAR5      DMAC_DSAR(5)
+#define DMAC_DDAR5      DMAC_DDAR(5)
+#define DMAC_DTCR5      DMAC_DTCR(5)
+#define DMAC_DRSR5      DMAC_DRSR(5)
+#define DMAC_DCCSR5     DMAC_DCCSR(5)
+
+#define DMAC_DSAR6      DMAC_DSAR(6)
+#define DMAC_DDAR6      DMAC_DDAR(6)
+#define DMAC_DTCR6      DMAC_DTCR(6)
+#define DMAC_DRSR6      DMAC_DRSR(6)
+#define DMAC_DCCSR6     DMAC_DCCSR(6)
+
+#define DMAC_DSAR7      DMAC_DSAR(7)
+#define DMAC_DDAR7      DMAC_DDAR(7)
+#define DMAC_DTCR7      DMAC_DTCR(7)
+#define DMAC_DRSR7      DMAC_DRSR(7)
+#define DMAC_DCCSR7     DMAC_DCCSR(7)
+
+
+
+/*************************************************************************
+ * AIC 
+ *************************************************************************/
+#define	AIC_FR			(AIC_BASE + 0x000)
+#define	AIC_CR			(AIC_BASE + 0x004)
+#define	AIC_ACCR1		(AIC_BASE + 0x008)
+#define	AIC_ACCR2		(AIC_BASE + 0x00C)
+#define	AIC_I2SCR		(AIC_BASE + 0x010)
+#define	AIC_SR			(AIC_BASE + 0x014)
+#define	AIC_ACSR		(AIC_BASE + 0x018)
+#define	AIC_I2SSR		(AIC_BASE + 0x01C)
+#define	AIC_ACCAR		(AIC_BASE + 0x020)
+#define	AIC_ACCDR		(AIC_BASE + 0x024)
+#define	AIC_ACSAR		(AIC_BASE + 0x028)
+#define	AIC_ACSDR		(AIC_BASE + 0x02C)
+#define	AIC_I2SDIV		(AIC_BASE + 0x030)
+#define	AIC_DR			(AIC_BASE + 0x034)
+
+#define	REG_AIC_FR		REG32(AIC_FR)
+#define	REG_AIC_CR		REG32(AIC_CR)
+#define	REG_AIC_ACCR1		REG32(AIC_ACCR1)
+#define	REG_AIC_ACCR2		REG32(AIC_ACCR2)
+#define	REG_AIC_I2SCR		REG32(AIC_I2SCR)
+#define	REG_AIC_SR		REG32(AIC_SR)
+#define	REG_AIC_ACSR		REG32(AIC_ACSR)
+#define	REG_AIC_I2SSR		REG32(AIC_I2SSR)
+#define	REG_AIC_ACCAR		REG32(AIC_ACCAR)
+#define	REG_AIC_ACCDR		REG32(AIC_ACCDR)
+#define	REG_AIC_ACSAR		REG32(AIC_ACSAR)
+#define	REG_AIC_ACSDR		REG32(AIC_ACSDR)
+#define	REG_AIC_I2SDIV		REG32(AIC_I2SDIV)
+#define	REG_AIC_DR		REG32(AIC_DR)
+
+/* AIC Controller Configuration Register (AIC_FR) */
+
+#define	AIC_FR_RFTH_BIT		12
+#define	AIC_FR_RFTH_MASK	(0xf << AIC_FR_RFTH_BIT)
+#define	AIC_FR_TFTH_BIT		8
+#define	AIC_FR_TFTH_MASK	(0xf << AIC_FR_TFTH_BIT)
+#define	AIC_FR_AUSEL		(1 << 4)
+#define	AIC_FR_RST		(1 << 3)
+#define	AIC_FR_BCKD		(1 << 2)
+#define	AIC_FR_SYNCD		(1 << 1)
+#define	AIC_FR_ENB		(1 << 0)
+
+/* AIC Controller Common Control Register (AIC_CR) */
+
+#define	AIC_CR_RDMS		(1 << 15)
+#define	AIC_CR_TDMS		(1 << 14)
+#define	AIC_CR_FLUSH		(1 << 8)
+#define	AIC_CR_EROR		(1 << 6)
+#define	AIC_CR_ETUR		(1 << 5)
+#define	AIC_CR_ERFS		(1 << 4)
+#define	AIC_CR_ETFS		(1 << 3)
+#define	AIC_CR_ENLBF		(1 << 2)
+#define	AIC_CR_ERPL		(1 << 1)
+#define	AIC_CR_EREC		(1 << 0)
+
+/* AIC Controller AC-link Control Register 1 (AIC_ACCR1) */
+
+#define	AIC_ACCR1_RS_BIT	16
+#define	AIC_ACCR1_RS_MASK	(0x3ff << AIC_ACCR1_RS_BIT)
+  #define AIC_ACCR1_RS_SLOT12	  (1 << 25) /* Slot 12 valid bit */
+  #define AIC_ACCR1_RS_SLOT11	  (1 << 24) /* Slot 11 valid bit */
+  #define AIC_ACCR1_RS_SLOT10	  (1 << 23) /* Slot 10 valid bit */
+  #define AIC_ACCR1_RS_SLOT9	  (1 << 22) /* Slot 9 valid bit */
+  #define AIC_ACCR1_RS_SLOT8	  (1 << 21) /* Slot 8 valid bit */
+  #define AIC_ACCR1_RS_SLOT7	  (1 << 20) /* Slot 7 valid bit */
+  #define AIC_ACCR1_RS_SLOT6	  (1 << 19) /* Slot 6 valid bit */
+  #define AIC_ACCR1_RS_SLOT5	  (1 << 18) /* Slot 5 valid bit */
+  #define AIC_ACCR1_RS_SLOT4	  (1 << 17) /* Slot 4 valid bit */
+  #define AIC_ACCR1_RS_SLOT3	  (1 << 16) /* Slot 3 valid bit */
+#define	AIC_ACCR1_XS_BIT	0
+#define	AIC_ACCR1_XS_MASK	(0x3ff << AIC_ACCR1_XS_BIT)
+  #define AIC_ACCR1_XS_SLOT12	  (1 << 9) /* Slot 12 valid bit */
+  #define AIC_ACCR1_XS_SLOT11	  (1 << 8) /* Slot 11 valid bit */
+  #define AIC_ACCR1_XS_SLOT10	  (1 << 7) /* Slot 10 valid bit */
+  #define AIC_ACCR1_XS_SLOT9	  (1 << 6) /* Slot 9 valid bit */
+  #define AIC_ACCR1_XS_SLOT8	  (1 << 5) /* Slot 8 valid bit */
+  #define AIC_ACCR1_XS_SLOT7	  (1 << 4) /* Slot 7 valid bit */
+  #define AIC_ACCR1_XS_SLOT6	  (1 << 3) /* Slot 6 valid bit */
+  #define AIC_ACCR1_XS_SLOT5	  (1 << 2) /* Slot 5 valid bit */
+  #define AIC_ACCR1_XS_SLOT4	  (1 << 1) /* Slot 4 valid bit */
+  #define AIC_ACCR1_XS_SLOT3	  (1 << 0) /* Slot 3 valid bit */
+
+/* AIC Controller AC-link Control Register 2 (AIC_ACCR2) */
+
+#define	AIC_ACCR2_ERSTO		(1 << 18)
+#define	AIC_ACCR2_ESADR		(1 << 17)
+#define	AIC_ACCR2_ECADT		(1 << 16)
+#define	AIC_ACCR2_OASS_BIT	8
+#define	AIC_ACCR2_OASS_MASK	(0x3 << AIC_ACCR2_OASS_BIT)
+  #define AIC_ACCR2_OASS_20BIT	  (0 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_OASS_18BIT	  (1 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_OASS_16BIT	  (2 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_OASS_8BIT	  (3 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_IASS_BIT	6
+#define	AIC_ACCR2_IASS_MASK	(0x3 << AIC_ACCR2_IASS_BIT)
+  #define AIC_ACCR2_IASS_20BIT	  (0 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_IASS_18BIT	  (1 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_IASS_16BIT	  (2 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_IASS_8BIT	  (3 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_SO		(1 << 3)
+#define	AIC_ACCR2_SR		(1 << 2)
+#define	AIC_ACCR2_SS		(1 << 1)
+#define	AIC_ACCR2_SA		(1 << 0)
+
+/* AIC Controller I2S/MSB-justified Control Register (AIC_I2SCR) */
+
+#define	AIC_I2SCR_STPBK		(1 << 12)
+#define	AIC_I2SCR_WL_BIT	1
+#define	AIC_I2SCR_WL_MASK	(0x7 << AIC_I2SCR_WL_BIT)
+  #define AIC_I2SCR_WL_24BIT	  (0 << AIC_I2SCR_WL_BIT) /* Word Length is 24 bit */
+  #define AIC_I2SCR_WL_20BIT	  (1 << AIC_I2SCR_WL_BIT) /* Word Length is 20 bit */
+  #define AIC_I2SCR_WL_18BIT	  (2 << AIC_I2SCR_WL_BIT) /* Word Length is 18 bit */
+  #define AIC_I2SCR_WL_16BIT	  (3 << AIC_I2SCR_WL_BIT) /* Word Length is 16 bit */
+  #define AIC_I2SCR_WL_8BIT	  (4 << AIC_I2SCR_WL_BIT) /* Word Length is 8 bit */
+#define	AIC_I2SCR_AMSL		(1 << 0)
+
+/* AIC Controller FIFO Status Register (AIC_SR) */
+
+#define	AIC_SR_RFL_BIT		24
+#define	AIC_SR_RFL_MASK		(0x1f << AIC_SR_RFL_BIT)
+#define	AIC_SR_TFL_BIT		8
+#define	AIC_SR_TFL_MASK		(0x1f << AIC_SR_TFL_BIT)
+#define	AIC_SR_ROR		(1 << 6)
+#define	AIC_SR_TUR		(1 << 5)
+#define	AIC_SR_RFS		(1 << 4)
+#define	AIC_SR_TFS		(1 << 3)
+
+/* AIC Controller AC-link Status Register (AIC_ACSR) */
+
+#define	AIC_ACSR_CRDY		(1 << 20)
+#define	AIC_ACSR_CLPM		(1 << 19)
+#define	AIC_ACSR_RSTO		(1 << 18)
+#define	AIC_ACSR_SADR		(1 << 17)
+#define	AIC_ACSR_CADT		(1 << 16)
+
+/* AIC Controller I2S/MSB-justified Status Register (AIC_I2SSR) */
+
+#define	AIC_I2SSR_BSY		(1 << 2)
+
+/* AIC Controller AC97 codec Command Address Register (AIC_ACCAR) */
+
+#define	AIC_ACCAR_CAR_BIT	0
+#define	AIC_ACCAR_CAR_MASK	(0xfffff << AIC_ACCAR_CAR_BIT)
+
+/* AIC Controller AC97 codec Command Data Register (AIC_ACCDR) */
+
+#define	AIC_ACCDR_CDR_BIT	0
+#define	AIC_ACCDR_CDR_MASK	(0xfffff << AIC_ACCDR_CDR_BIT)
+
+/* AIC Controller AC97 codec Status Address Register (AIC_ACSAR) */
+
+#define	AIC_ACSAR_SAR_BIT	0
+#define	AIC_ACSAR_SAR_MASK	(0xfffff << AIC_ACSAR_SAR_BIT)
+
+/* AIC Controller AC97 codec Status Data Register (AIC_ACSDR) */
+
+#define	AIC_ACSDR_SDR_BIT	0
+#define	AIC_ACSDR_SDR_MASK	(0xfffff << AIC_ACSDR_SDR_BIT)
+
+/* AIC Controller I2S/MSB-justified Clock Divider Register (AIC_I2SDIV) */
+
+#define	AIC_I2SDIV_DIV_BIT	0
+#define	AIC_I2SDIV_DIV_MASK	(0x7f << AIC_I2SDIV_DIV_BIT)
+  #define AIC_I2SDIV_BITCLK_3072KHZ	(0x0C << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 3.072MHz */
+  #define AIC_I2SDIV_BITCLK_2836KHZ	(0x0D << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 2.836MHz */
+  #define AIC_I2SDIV_BITCLK_1418KHZ	(0x1A << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.418MHz */
+  #define AIC_I2SDIV_BITCLK_1024KHZ	(0x24 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.024MHz */
+  #define AIC_I2SDIV_BITCLK_7089KHZ	(0x34 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 708.92KHz */
+  #define AIC_I2SDIV_BITCLK_512KHZ	(0x48 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 512.00KHz */
+
+
+
+
+/*************************************************************************
+ * LCD 
+ *************************************************************************/
+#define LCD_CFG		(LCD_BASE + 0x00)
+#define LCD_VSYNC	(LCD_BASE + 0x04)
+#define LCD_HSYNC	(LCD_BASE + 0x08)
+#define LCD_VAT		(LCD_BASE + 0x0c)
+#define LCD_DAH		(LCD_BASE + 0x10)
+#define LCD_DAV		(LCD_BASE + 0x14)
+#define LCD_PS		(LCD_BASE + 0x18)
+#define LCD_CLS		(LCD_BASE + 0x1c)
+#define LCD_SPL		(LCD_BASE + 0x20)
+#define LCD_REV		(LCD_BASE + 0x24)
+#define LCD_CTRL	(LCD_BASE + 0x30)
+#define LCD_STATE	(LCD_BASE + 0x34)
+#define LCD_IID		(LCD_BASE + 0x38)
+#define LCD_DA0		(LCD_BASE + 0x40)
+#define LCD_SA0		(LCD_BASE + 0x44)
+#define LCD_FID0	(LCD_BASE + 0x48)
+#define LCD_CMD0	(LCD_BASE + 0x4c)
+#define LCD_DA1		(LCD_BASE + 0x50)
+#define LCD_SA1		(LCD_BASE + 0x54)
+#define LCD_FID1	(LCD_BASE + 0x58)
+#define LCD_CMD1	(LCD_BASE + 0x5c)
+
+#define REG_LCD_CFG	REG32(LCD_CFG)
+#define REG_LCD_VSYNC	REG32(LCD_VSYNC)
+#define REG_LCD_HSYNC	REG32(LCD_HSYNC)
+#define REG_LCD_VAT	REG32(LCD_VAT)
+#define REG_LCD_DAH	REG32(LCD_DAH)
+#define REG_LCD_DAV	REG32(LCD_DAV)
+#define REG_LCD_PS	REG32(LCD_PS)
+#define REG_LCD_CLS	REG32(LCD_CLS)
+#define REG_LCD_SPL	REG32(LCD_SPL)
+#define REG_LCD_REV	REG32(LCD_REV)
+#define REG_LCD_CTRL	REG32(LCD_CTRL)
+#define REG_LCD_STATE	REG32(LCD_STATE)
+#define REG_LCD_IID	REG32(LCD_IID)
+#define REG_LCD_DA0	REG32(LCD_DA0)
+#define REG_LCD_SA0	REG32(LCD_SA0)
+#define REG_LCD_FID0	REG32(LCD_FID0)
+#define REG_LCD_CMD0	REG32(LCD_CMD0)
+#define REG_LCD_DA1	REG32(LCD_DA1)
+#define REG_LCD_SA1	REG32(LCD_SA1)
+#define REG_LCD_FID1	REG32(LCD_FID1)
+#define REG_LCD_CMD1	REG32(LCD_CMD1)
+
+#define LCD_CFG_PDW_BIT		4
+#define LCD_CFG_PDW_MASK	(0x03 << LCD_DEV_PDW_BIT)
+  #define LCD_CFG_PDW_1		(0 << LCD_DEV_PDW_BIT)
+  #define LCD_CFG_PDW_2		(1 << LCD_DEV_PDW_BIT)
+  #define LCD_CFG_PDW_4		(2 << LCD_DEV_PDW_BIT)
+  #define LCD_CFG_PDW_8		(3 << LCD_DEV_PDW_BIT)
+#define LCD_CFG_MODE_BIT	0
+#define LCD_CFG_MODE_MASK	(0x0f << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_GENERIC_TFT	(0 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_SHARP_HR		(1 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_CASIO_TFT	(2 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_SAMSUNG_ALPHA	(3 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_NONINTER_CCIR656	(4 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_INTER_CCIR656	(6 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_CSTN	(8 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_MSTN	(9 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_CSTN	(10 << LCD_DEV_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_MSTN	(11 << LCD_DEV_MODE_BIT)
+
+#define LCD_VSYNC_VPS_BIT	16
+#define LCD_VSYNC_VPS_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+#define LCD_VSYNC_VPE_BIT	0
+#define LCD_VSYNC_VPE_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+
+#define LCD_HSYNC_HPS_BIT	16
+#define LCD_HSYNC_HPS_MASK	(0xffff << LCD_HSYNC_HPS_BIT)
+#define LCD_HSYNC_HPE_BIT	0
+#define LCD_HSYNC_HPE_MASK	(0xffff << LCD_HSYNC_HPE_BIT)
+
+#define LCD_VAT_HT_BIT		16
+#define LCD_VAT_HT_MASK		(0xffff << LCD_VAT_HT_BIT)
+#define LCD_VAT_VT_BIT		0
+#define LCD_VAT_VT_MASK		(0xffff << LCD_VAT_VT_BIT)
+
+#define LCD_DAH_HDS_BIT		16
+#define LCD_DAH_HDS_MASK	(0xffff << LCD_DAH_HDS_BIT)
+#define LCD_DAH_HDE_BIT		0
+#define LCD_DAH_HDE_MASK	(0xffff << LCD_DAH_HDE_BIT)
+
+#define LCD_DAV_VDS_BIT		16
+#define LCD_DAV_VDS_MASK	(0xffff << LCD_DAV_VDS_BIT)
+#define LCD_DAV_VDE_BIT		0
+#define LCD_DAV_VDE_MASK	(0xffff << LCD_DAV_VDE_BIT)
+
+#define LCD_CTRL_BST_BIT	28
+#define LCD_CTRL_BST_MASK	(0x03 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_4	(0 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_8	(1 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_16	(2 << LCD_CTRL_BST_BIT)
+#define LCD_CTRL_RGB555		(1 << 27)
+#define LCD_CTRL_OFUP		(1 << 26)
+#define LCD_CTRL_FRC_BIT	24
+#define LCD_CTRL_FRC_MASK	(0x03 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_16	(0 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_4	(1 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_2	(2 << LCD_CTRL_FRC_BIT)
+#define LCD_CTRL_PDD_BIT	16
+#define LCD_CTRL_PDD_MASK	(0xff << LCD_CTRL_PDD_BIT)
+#define LCD_CTRL_EOFM		(1 << 13)
+#define LCD_CTRL_SOFM		(1 << 12)
+#define LCD_CTRL_OFUM		(1 << 11)
+#define LCD_CTRL_IFUM0		(1 << 10)
+#define LCD_CTRL_IFUM1		(1 << 9)
+#define LCD_CTRL_LDDM		(1 << 8)
+#define LCD_CTRL_QDM		(1 << 7)
+#define LCD_CTRL_BEDN		(1 << 6)
+#define LCD_CTRL_PEDN		(1 << 5)
+#define LCD_CTRL_DIS		(1 << 4)
+#define LCD_CTRL_ENA		(1 << 3)
+#define LCD_CTRL_BPP_BIT	0
+#define LCD_CTRL_BPP_MASK	(0x07 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_1	(0 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_2	(1 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_4	(2 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_8	(3 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_16	(4 << LCD_CTRL_BPP_BIT)
+
+#define LCD_STATE_QD		(1 << 7)
+#define LCD_STATE_EOF		(1 << 5)
+#define LCD_STATE_SOF		(1 << 4)
+#define LCD_STATE_OFU		(1 << 3)
+#define LCD_STATE_IFU0		(1 << 2)
+#define LCD_STATE_IFU1		(1 << 1)
+#define LCD_STATE_LDD		(1 << 0)
+
+#define LCD_CMD_SOFINT		(1 << 31)
+#define LCD_CMD_EOFINT		(1 << 30)
+#define LCD_CMD_PAL		(1 << 28)
+#define LCD_CMD_LEN_BIT		0
+#define LCD_CMD_LEN_MASK	(0xffffff << LCD_CMD_LEN_BIT)
+
+
+
+
+/*************************************************************************
+ * DES
+ *************************************************************************/
+#define	DES_CR1			(DES_BASE + 0x000)
+#define	DES_CR2			(DES_BASE + 0x004)
+#define	DES_SR			(DES_BASE + 0x008)
+#define	DES_K1L			(DES_BASE + 0x010)
+#define	DES_K1R			(DES_BASE + 0x014)
+#define	DES_K2L			(DES_BASE + 0x018)
+#define	DES_K2R			(DES_BASE + 0x01C)
+#define	DES_K3L			(DES_BASE + 0x020)
+#define	DES_K3R			(DES_BASE + 0x024)
+#define	DES_IVL			(DES_BASE + 0x028)
+#define	DES_IVR			(DES_BASE + 0x02C)
+#define	DES_DIN			(DES_BASE + 0x030)
+#define	DES_DOUT		(DES_BASE + 0x034)
+
+#define REG_DES_CR1		REG32(DES_CR1)
+#define REG_DES_CR2		REG32(DES_CR2)
+#define REG_DES_SR		REG32(DES_SR)
+#define REG_DES_K1L		REG32(DES_K1L)
+#define REG_DES_K1R		REG32(DES_K1R)
+#define REG_DES_K2L		REG32(DES_K2L)
+#define REG_DES_K2R		REG32(DES_K2R)
+#define REG_DES_K3L		REG32(DES_K3L)
+#define REG_DES_K3R		REG32(DES_K3R)
+#define REG_DES_IVL		REG32(DES_IVL)
+#define REG_DES_IVR		REG32(DES_IVR)
+#define REG_DES_DIN		REG32(DES_DIN)
+#define REG_DES_DOUT		REG32(DES_DOUT)
+
+/* DES Control Register 1 (DES_CR1) */
+
+#define	DES_CR1_EN 		(1 << 0)
+
+/* DES Control Register 2 (DES_CR2) */
+
+#define	DES_CR2_ENDEC 		(1 << 3)
+#define	DES_CR2_MODE 		(1 << 2)
+#define	DES_CR2_ALG 		(1 << 1)
+#define	DES_CR2_DMAE		(1 << 0)
+
+/* DES State Register (DES_SR) */
+
+#define DES_SR_IN_FULL		(1 << 5)
+#define DES_SR_IN_LHF		(1 << 4)
+#define DES_SR_IN_EMPTY		(1 << 3)
+#define DES_SR_OUT_FULL		(1 << 2)
+#define DES_SR_OUT_GHF		(1 << 1)
+#define DES_SR_OUT_EMPTY	(1 << 0)
+
+
+
+
+/*************************************************************************
+ * CPM
+ *************************************************************************/
+#define CPM_CFCR	(CPM_BASE+0x00)
+#define CPM_PLCR1	(CPM_BASE+0x10)
+#define CPM_OCR		(CPM_BASE+0x1c)
+#define CPM_CFCR2	(CPM_BASE+0x60)
+#define CPM_LPCR	(CPM_BASE+0x04)
+#define CPM_RSTR	(CPM_BASE+0x08)
+#define CPM_MSCR	(CPM_BASE+0x20)
+#define CPM_SCR		(CPM_BASE+0x24)
+#define CPM_WRER	(CPM_BASE+0x28)
+#define CPM_WFER	(CPM_BASE+0x2c)
+#define CPM_WER		(CPM_BASE+0x30)
+#define CPM_WSR		(CPM_BASE+0x34)
+#define CPM_GSR0	(CPM_BASE+0x38)
+#define CPM_GSR1	(CPM_BASE+0x3c)
+#define CPM_GSR2	(CPM_BASE+0x40)
+#define CPM_SPR		(CPM_BASE+0x44)
+#define CPM_GSR3	(CPM_BASE+0x48)
+
+#define REG_CPM_CFCR	REG32(CPM_CFCR)
+#define REG_CPM_PLCR1	REG32(CPM_PLCR1)
+#define REG_CPM_OCR	REG32(CPM_OCR)
+#define REG_CPM_CFCR2	REG32(CPM_CFCR2)
+#define REG_CPM_LPCR	REG32(CPM_LPCR)
+#define REG_CPM_RSTR	REG32(CPM_RSTR)
+#define REG_CPM_MSCR	REG32(CPM_MSCR)
+#define REG_CPM_SCR	REG32(CPM_SCR)
+#define REG_CPM_WRER	REG32(CPM_WRER)
+#define REG_CPM_WFER	REG32(CPM_WFER)
+#define REG_CPM_WER	REG32(CPM_WER)
+#define REG_CPM_WSR	REG32(CPM_WSR)
+#define REG_CPM_GSR0	REG32(CPM_GSR0)
+#define REG_CPM_GSR1	REG32(CPM_GSR1)
+#define REG_CPM_GSR2	REG32(CPM_GSR2)
+#define REG_CPM_SPR	REG32(CPM_SPR)
+#define REG_CPM_GSR3	REG32(CPM_GSR3)
+
+#define CPM_CFCR_SSI		(1 << 31)
+#define CPM_CFCR_LCD		(1 << 30)
+#define CPM_CFCR_I2S		(1 << 29)
+#define CPM_CFCR_UCS		(1 << 28)
+#define CPM_CFCR_UFR_BIT	25
+#define CPM_CFCR_UFR_MASK	(0x07 << CPM_CFCR_UFR_BIT)
+#define CPM_CFCR_MSC		(1 << 24)
+#define CPM_CFCR_CKOEN2		(1 << 23)
+#define CPM_CFCR_CKOEN1		(1 << 22)
+#define CPM_CFCR_UPE		(1 << 20)
+#define CPM_CFCR_MFR_BIT	16
+#define CPM_CFCR_MFR_MASK	(0x0f << CPM_CFCR_MFR_BIT)
+#define CPM_CFCR_LFR_BIT	12
+#define CPM_CFCR_LFR_MASK	(0x0f << CPM_CFCR_LFR_BIT)
+#define CPM_CFCR_PFR_BIT	8
+#define CPM_CFCR_PFR_MASK	(0x0f << CPM_CFCR_PFR_BIT)
+#define CPM_CFCR_SFR_BIT	4
+#define CPM_CFCR_SFR_MASK	(0x0f << CPM_CFCR_SFR_BIT)
+#define CPM_CFCR_IFR_BIT	0
+#define CPM_CFCR_IFR_MASK	(0x0f << CPM_CFCR_IFR_BIT)
+
+#define CPM_PLCR1_PLL1FD_BIT	23
+#define CPM_PLCR1_PLL1FD_MASK	(0x1ff << CPM_PLCR1_PLL1FD_BIT)
+#define CPM_PLCR1_PLL1RD_BIT	18
+#define CPM_PLCR1_PLL1RD_MASK	(0x1f << CPM_PLCR1_PLL1RD_BIT)
+#define CPM_PLCR1_PLL1OD_BIT	16
+#define CPM_PLCR1_PLL1OD_MASK	(0x03 << CPM_PLCR1_PLL1OD_BIT)
+#define CPM_PLCR1_PLL1S		(1 << 10)
+#define CPM_PLCR1_PLL1BP	(1 << 9)
+#define CPM_PLCR1_PLL1EN	(1 << 8)
+#define CPM_PLCR1_PLL1ST_BIT	0
+#define CPM_PLCR1_PLL1ST_MASK	(0xff << CPM_PLCR1_PLL1ST_BIT)
+
+#define CPM_OCR_O1ST_BIT	16
+#define CPM_OCR_O1ST_MASK	(0xff << CPM_OCR_O1ST_BIT)
+#define CPM_OCR_EXT_RTC_CLK	(1<<8)
+#define CPM_OCR_SUSPEND_PHY1	(1<<7)
+#define CPM_OCR_SUSPEND_PHY0	(1<<6)
+
+#define CPM_CFCR2_PXFR_BIT	0
+#define CPM_CFCR2_PXFR_MASK	(0x1ff << CPM_CFCR2_PXFR_BIT)
+
+#define CPM_LPCR_DUTY_BIT	3
+#define CPM_LPCR_DUTY_MASK	(0x1f << CPM_LPCR_DUTY_BIT)
+#define CPM_LPCR_DOZE		(1 << 2)
+#define CPM_LPCR_LPM_BIT	0
+#define CPM_LPCR_LPM_MASK	(0x03 << CPM_LPCR_LPM_BIT)
+  #define CPM_LPCR_LPM_IDLE		(0 << CPM_LPCR_LPM_BIT)
+  #define CPM_LPCR_LPM_SLEEP		(1 << CPM_LPCR_LPM_BIT)
+  #define CPM_LPCR_LPM_HIBERNATE	(2 << CPM_LPCR_LPM_BIT)
+
+#define CPM_RSTR_SR		(1 << 2)
+#define CPM_RSTR_WR		(1 << 1)
+#define CPM_RSTR_HR		(1 << 0)
+
+#define CPM_MSCR_MSTP_BIT	0
+#define CPM_MSCR_MSTP_MASK	(0x1ffffff << CPM_MSCR_MSTP_BIT)
+  #define CPM_MSCR_MSTP_UART0	0
+  #define CPM_MSCR_MSTP_UART1	1
+  #define CPM_MSCR_MSTP_UART2	2
+  #define CPM_MSCR_MSTP_OST	3
+  #define CPM_MSCR_MSTP_DMAC	5
+  #define CPM_MSCR_MSTP_UHC	6
+  #define CPM_MSCR_MSTP_LCD	7
+  #define CPM_MSCR_MSTP_I2C	8
+  #define CPM_MSCR_MSTP_AICPCLK 9
+  #define CPM_MSCR_MSTP_PWM0	10
+  #define CPM_MSCR_MSTP_PWM1	11
+  #define CPM_MSCR_MSTP_SSI	12
+  #define CPM_MSCR_MSTP_MSC	13
+  #define CPM_MSCR_MSTP_SCC	14
+  #define CPM_MSCR_MSTP_AICBCLK	18
+  #define CPM_MSCR_MSTP_UART3	20
+  #define CPM_MSCR_MSTP_ETH	21
+  #define CPM_MSCR_MSTP_KBC	22
+  #define CPM_MSCR_MSTP_CIM	23
+  #define CPM_MSCR_MSTP_UDC	24
+  #define CPM_MSCR_MSTP_UPRT	25
+
+#define CPM_SCR_O1SE		(1 << 4)
+#define CPM_SCR_HGP		(1 << 3)
+#define CPM_SCR_HZP		(1 << 2)
+#define CPM_SCR_HZM		(1 << 1)
+
+#define CPM_WRER_RE_BIT		0
+#define CPM_WRER_RE_MASK	(0xffff << CPM_WRER_RE_BIT)
+
+#define CPM_WFER_FE_BIT		0
+#define CPM_WFER_FE_MASK	(0xffff << CPM_WFER_FE_BIT)
+
+#define CPM_WER_WERTC		(1 << 31)
+#define CPM_WER_WEETH		(1 << 30)
+#define CPM_WER_WE_BIT		0
+#define CPM_WER_WE_MASK		(0xffff << CPM_WER_WE_BIT)
+
+#define CPM_WSR_WSRTC		(1 << 31)
+#define CPM_WSR_WSETH		(1 << 30)
+#define CPM_WSR_WS_BIT		0
+#define CPM_WSR_WS_MASK		(0xffff << CPM_WSR_WS_BIT)
+
+
+
+
+/*************************************************************************
+ * SSI
+ *************************************************************************/
+#define	SSI_DR			(SSI_BASE + 0x000)
+#define	SSI_CR0			(SSI_BASE + 0x004)
+#define	SSI_CR1			(SSI_BASE + 0x008)
+#define	SSI_SR			(SSI_BASE + 0x00C)
+#define	SSI_ITR			(SSI_BASE + 0x010)
+#define	SSI_ICR			(SSI_BASE + 0x014)
+#define	SSI_GR			(SSI_BASE + 0x018)
+
+#define	REG_SSI_DR		REG32(SSI_DR)
+#define	REG_SSI_CR0		REG16(SSI_CR0)
+#define	REG_SSI_CR1		REG32(SSI_CR1)
+#define	REG_SSI_SR		REG32(SSI_SR)
+#define	REG_SSI_ITR		REG16(SSI_ITR)
+#define	REG_SSI_ICR		REG8(SSI_ICR)
+#define	REG_SSI_GR		REG16(SSI_GR)
+
+/* SSI Data Register (SSI_DR) */
+
+#define	SSI_DR_GPC_BIT		0
+#define	SSI_DR_GPC_MASK		(0x1ff << SSI_DR_GPC_BIT)
+
+/* SSI Control Register 0 (SSI_CR0) */
+
+#define SSI_CR0_SSIE		(1 << 15)
+#define SSI_CR0_TIE		(1 << 14)
+#define SSI_CR0_RIE		(1 << 13)
+#define SSI_CR0_TEIE		(1 << 12)
+#define SSI_CR0_REIE		(1 << 11)
+#define SSI_CR0_LOOP		(1 << 10)
+#define SSI_CR0_RFINE		(1 << 9)
+#define SSI_CR0_RFINC		(1 << 8)
+#define SSI_CR0_FSEL		(1 << 6)
+#define SSI_CR0_TFLUSH		(1 << 2)
+#define SSI_CR0_RFLUSH		(1 << 1)
+#define SSI_CR0_DISREV		(1 << 0)
+
+/* SSI Control Register 1 (SSI_CR1) */
+
+#define SSI_CR1_FRMHL_BIT	30
+#define SSI_CR1_FRMHL_MASK	(0x3 << SSI_CR1_FRMHL_BIT)
+  #define SSI_CR1_FRMHL_CELOW_CE2LOW	(0 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2LOW	(1 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CELOW_CE2HIGH	(2 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid  and SSI_CE2_ is high valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2HIGH	(3 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is high valid */
+#define SSI_CR1_TFVCK_BIT	28
+#define SSI_CR1_TFVCK_MASK	(0x3 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_0	  (0 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_1	  (1 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_2	  (2 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_3	  (3 << SSI_CR1_TFVCK_BIT)
+#define SSI_CR1_TCKFI_BIT	26
+#define SSI_CR1_TCKFI_MASK	(0x3 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_0	  (0 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_1	  (1 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_2	  (2 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_3	  (3 << SSI_CR1_TCKFI_BIT)
+#define SSI_CR1_LFST		(1 << 25)
+#define SSI_CR1_ITFRM		(1 << 24)
+#define SSI_CR1_UNFIN		(1 << 23)
+#define SSI_CR1_MULTS		(1 << 22)
+#define SSI_CR1_FMAT_BIT	20
+#define SSI_CR1_FMAT_MASK	(0x3 << SSI_CR1_FMAT_BIT)
+  #define SSI_CR1_FMAT_SPI	  (0 << SSI_CR1_FMAT_BIT) /* Motorolas SPI format */
+  #define SSI_CR1_FMAT_SSP	  (1 << SSI_CR1_FMAT_BIT) /* TI's SSP format */
+  #define SSI_CR1_FMAT_MW1	  (2 << SSI_CR1_FMAT_BIT) /* National Microwire 1 format */
+  #define SSI_CR1_FMAT_MW2	  (3 << SSI_CR1_FMAT_BIT) /* National Microwire 2 format */
+#define SSI_CR1_MCOM_BIT	12
+#define SSI_CR1_MCOM_MASK	(0xf << SSI_CR1_MCOM_BIT)
+  #define SSI_CR1_MCOM_1BIT	  (0x0 << SSI_CR1_MCOM_BIT) /* 1-bit command selected */
+  #define SSI_CR1_MCOM_2BIT	  (0x1 << SSI_CR1_MCOM_BIT) /* 2-bit command selected */
+  #define SSI_CR1_MCOM_3BIT	  (0x2 << SSI_CR1_MCOM_BIT) /* 3-bit command selected */
+  #define SSI_CR1_MCOM_4BIT	  (0x3 << SSI_CR1_MCOM_BIT) /* 4-bit command selected */
+  #define SSI_CR1_MCOM_5BIT	  (0x4 << SSI_CR1_MCOM_BIT) /* 5-bit command selected */
+  #define SSI_CR1_MCOM_6BIT	  (0x5 << SSI_CR1_MCOM_BIT) /* 6-bit command selected */
+  #define SSI_CR1_MCOM_7BIT	  (0x6 << SSI_CR1_MCOM_BIT) /* 7-bit command selected */
+  #define SSI_CR1_MCOM_8BIT	  (0x7 << SSI_CR1_MCOM_BIT) /* 8-bit command selected */
+  #define SSI_CR1_MCOM_9BIT	  (0x8 << SSI_CR1_MCOM_BIT) /* 9-bit command selected */
+  #define SSI_CR1_MCOM_10BIT	  (0x9 << SSI_CR1_MCOM_BIT) /* 10-bit command selected */
+  #define SSI_CR1_MCOM_11BIT	  (0xA << SSI_CR1_MCOM_BIT) /* 11-bit command selected */
+  #define SSI_CR1_MCOM_12BIT	  (0xB << SSI_CR1_MCOM_BIT) /* 12-bit command selected */
+  #define SSI_CR1_MCOM_13BIT	  (0xC << SSI_CR1_MCOM_BIT) /* 13-bit command selected */
+  #define SSI_CR1_MCOM_14BIT	  (0xD << SSI_CR1_MCOM_BIT) /* 14-bit command selected */
+  #define SSI_CR1_MCOM_15BIT	  (0xE << SSI_CR1_MCOM_BIT) /* 15-bit command selected */
+  #define SSI_CR1_MCOM_16BIT	  (0xF << SSI_CR1_MCOM_BIT) /* 16-bit command selected */
+#define SSI_CR1_TTRG_BIT	10
+#define SSI_CR1_TTRG_MASK	(0x3 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_1	  (0 << SSI_CR1_TTRG_BIT)/* Less than or equal to 1 */
+  #define SSI_CR1_TTRG_4	  (1 << SSI_CR1_TTRG_BIT) /* Less than or equal to 4 */
+  #define SSI_CR1_TTRG_8	  (2 << SSI_CR1_TTRG_BIT) /* Less than or equal to 8 */
+  #define SSI_CR1_TTRG_14	  (3 << SSI_CR1_TTRG_BIT) /* Less than or equal to 14 */
+#define SSI_CR1_RTRG_BIT	8
+#define SSI_CR1_RTRG_MASK	(0x3 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_1	  (0 << SSI_CR1_RTRG_BIT) /* More than or equal to 1 */
+  #define SSI_CR1_RTRG_4	  (1 << SSI_CR1_RTRG_BIT) /* More than or equal to 4 */
+  #define SSI_CR1_RTRG_8	  (2 << SSI_CR1_RTRG_BIT) /* More than or equal to 8 */
+  #define SSI_CR1_RTRG_14	  (3 << SSI_CR1_RTRG_BIT) /* More than or equal to 14 */
+#define SSI_CR1_FLEN_BIT	4
+#define SSI_CR1_FLEN_MASK	(0xf << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_2BIT	  (0x0 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_3BIT	  (0x1 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_4BIT	  (0x2 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_5BIT	  (0x3 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_6BIT	  (0x4 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_7BIT	  (0x5 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_8BIT	  (0x6 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_9BIT	  (0x7 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_10BIT	  (0x8 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_11BIT	  (0x9 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_12BIT	  (0xA << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_13BIT	  (0xB << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_14BIT	  (0xC << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_15BIT	  (0xD << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_16BIT	  (0xE << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_17BIT	  (0xF << SSI_CR1_FLEN_BIT)
+#define SSI_CR1_PHA		(1 << 1)
+#define SSI_CR1_POL		(1 << 0)
+
+/* SSI Status Register (SSI_SR) */
+
+#define SSI_SR_TFIFONUM_BIT	13
+#define SSI_SR_TFIFONUM_MASK	(0x1f << SSI_SR_TFIFONUM_BIT)
+#define SSI_SR_RFIFONUM_BIT	8
+#define SSI_SR_RFIFONUM_MASK	(0x1f << SSI_SR_RFIFONUM_BIT)
+#define SSI_SR_END		(1 << 7)
+#define SSI_SR_BUSY		(1 << 6)
+#define SSI_SR_TFF		(1 << 5)
+#define SSI_SR_RFE		(1 << 4)
+#define SSI_SR_TFHE		(1 << 3)
+#define SSI_SR_RFHF		(1 << 2)
+#define SSI_SR_UNDR		(1 << 1)
+#define SSI_SR_OVER		(1 << 0)
+
+/* SSI Interval Time Control Register (SSI_ITR) */
+
+#define	SSI_ITR_CNTCLK		(1 << 15)
+#define SSI_ITR_IVLTM_BIT	0
+#define SSI_ITR_IVLTM_MASK	(0x7fff << SSI_ITR_IVLTM_BIT)
+
+#endif /* __ASM_JZ4730_REGS_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4730/serial.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4730/serial.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,33 @@
+/*
+ *  linux/include/asm-mips/mach-jz4730/serial.h
+ *
+ *  JZ4730 serial port definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4730_SERIAL_H__
+#define __ASM_JZ4730_SERIAL_H__
+
+#define JZ_BASE_BAUD	(JZ_EXTAL/16)
+#define JZ_SERIAL_PORT_DEFNS \
+	{ .baud_base = JZ_BASE_BAUD, .irq = IRQ_UART0, \
+	  .flags = STD_COM_FLAGS, .iomem_base = (u8 *)UART0_BASE, \
+	  .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM }, \
+	{ .baud_base = JZ_BASE_BAUD, .irq = IRQ_UART1, \
+	  .flags = STD_COM_FLAGS, .iomem_base = (u8 *)UART1_BASE, \
+	  .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM }, \
+	{ .baud_base = JZ_BASE_BAUD, .irq = IRQ_UART2, \
+	  .flags = STD_COM_FLAGS, .iomem_base = (u8 *)UART2_BASE, \
+	  .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM }, \
+	{ .baud_base = JZ_BASE_BAUD, .irq = IRQ_UART3, \
+	  .flags = STD_COM_FLAGS, .iomem_base = (u8 *)UART3_BASE, \
+	  .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM },
+
+#endif /* __ASM_JZ4730_SERIAL_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4730/war.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4730/war.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_JZ4740_WAR_H
+#define __ASM_MIPS_MACH_JZ4740_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_JZ4740_WAR_H */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/board-dipper.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/board-dipper.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,69 @@
+/*
+ *  linux/include/asm-mips/mach-jz4740/board-dipper.h
+ *
+ *  JZ4725-based (16bit) Dipper board ver 1.x definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4725_DIPPER_H__
+#define __ASM_JZ4725_DIPPER_H__
+
+/*====================================================================== 
+ * Frequencies of on-board oscillators
+ */
+#define JZ_EXTAL		12000000  /* Main extal freq: 12 MHz */
+#define JZ_EXTAL2		32768     /* RTC extal freq: 32.768 KHz */
+
+/*====================================================================== 
+ * GPIO JZ4725
+ */
+#define GPIO_SD_VCC_EN_N	85  /* GPC21 */
+#define GPIO_SD_CD_N		91  /* GPC27 */
+#define GPIO_SD_WP		112 /* GPD16 */
+#define GPIO_USB_DETE		124 /* GPD28 */
+#define GPIO_DC_DETE_N		103 /* GPD7 */
+#define GPIO_CHARG_STAT_N	86 /* GPC22 */
+#define GPIO_DISP_OFF_N		118 /* GPD22 */
+
+#define GPIO_UDC_HOTPLUG	GPIO_USB_DETE
+
+/*====================================================================== 
+ * MMC/SD
+ */
+
+#define MSC_WP_PIN		GPIO_SD_WP
+#define MSC_HOTPLUG_PIN		GPIO_SD_CD_N
+#define MSC_HOTPLUG_IRQ		(IRQ_GPIO_0 + GPIO_SD_CD_N)
+
+#define __msc_init_io()				\
+do {						\
+	__gpio_as_output(GPIO_SD_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD_CD_N);		\
+} while (0)
+
+#define __msc_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_card_detected(s)			\
+({						\
+	int detected = 1;			\
+	if (__gpio_get_pin(GPIO_SD_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+
+#endif /* __ASM_JZ4740_DIPPER_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/board-leo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/board-leo.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,56 @@
+#ifndef __ASM_JZ4740_LEO_H__
+#define __ASM_JZ4740_LEO_H__
+
+/*
+ * Define your board specific codes here !!!
+ */
+
+/*====================================================================== 
+ * Frequencies of on-board oscillators
+ */
+#define JZ_EXTAL		12000000  /* Main extal freq: 12 MHz */
+#define JZ_EXTAL2		32768     /* RTC extal freq: 32.768 KHz */
+
+
+/*====================================================================== 
+ * GPIO
+ */
+#define GPIO_DISP_OFF_N		100
+#define GPIO_SD_VCC_EN_N	119
+#define GPIO_SD_CD_N		120
+#define GPIO_SD_WP		111
+
+/*====================================================================== 
+ * MMC/SD
+ */
+
+#define MSC_WP_PIN		GPIO_SD_WP
+#define MSC_HOTPLUG_PIN		GPIO_SD_CD_N
+#define MSC_HOTPLUG_IRQ		(IRQ_GPIO_0 + GPIO_SD_CD_N)
+
+#define __msc_init_io()				\
+do {						\
+	__gpio_as_output(GPIO_SD_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD_CD_N);		\
+} while (0)
+
+#define __msc_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_card_detected(s)			\
+({						\
+	int detected = 1;			\
+	__gpio_as_input(GPIO_SD_CD_N);		\
+	if (__gpio_get_pin(GPIO_SD_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+
+#endif /* __ASM_JZ4740_BOARD_LEO_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/board-lyra.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/board-lyra.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,70 @@
+/*
+ *  linux/include/asm-mips/mach-jz4740/board-lyra.h
+ *
+ *  JZ4740-based LYRA board ver 2.x definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4740_LYRA_H__
+#define __ASM_JZ4740_LYRA_H__
+
+/*====================================================================== 
+ * Frequencies of on-board oscillators
+ */
+#define JZ_EXTAL		12000000  /* Main extal freq: 12 MHz */
+#define JZ_EXTAL2		32768     /* RTC extal freq: 32.768 KHz */
+
+
+/*====================================================================== 
+ * GPIO
+ */
+#define GPIO_SD_VCC_EN_N	113 /* GPD17 */
+#define GPIO_SD_CD_N		110 /* GPD14 */
+#define GPIO_SD_WP		112 /* GPD16 */
+#define GPIO_USB_DETE		102 /* GPD6 */
+#define GPIO_DC_DETE_N		103 /* GPD7 */
+#define GPIO_CHARG_STAT_N	111 /* GPD15 */
+#define GPIO_DISP_OFF_N		118 /* GPD22 */
+#define GPIO_LED_EN       	124 /* GPD28 */
+
+#define GPIO_UDC_HOTPLUG	GPIO_USB_DETE
+/*====================================================================== 
+ * MMC/SD
+ */
+
+#define MSC_WP_PIN		GPIO_SD_WP
+#define MSC_HOTPLUG_PIN		GPIO_SD_CD_N
+#define MSC_HOTPLUG_IRQ		(IRQ_GPIO_0 + GPIO_SD_CD_N)
+
+#define __msc_init_io()				\
+do {						\
+	__gpio_as_output(GPIO_SD_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD_CD_N);		\
+} while (0)
+
+#define __msc_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_card_detected(s)			\
+({						\
+	int detected = 1;			\
+	if (!(__gpio_get_pin(GPIO_SD_CD_N)))	\
+		detected = 0;			\
+	detected;				\
+})
+
+#endif /* __ASM_JZ4740_LYRA_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/board-pavo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/board-pavo.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,70 @@
+/*
+ *  linux/include/asm-mips/mach-jz4740/board-pavo.h
+ *
+ *  JZ4730-based PAVO board ver 2.x definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4740_PAVO_H__
+#define __ASM_JZ4740_PAVO_H__
+
+/*====================================================================== 
+ * Frequencies of on-board oscillators
+ */
+#define JZ_EXTAL		12000000  /* Main extal freq: 12 MHz */
+#define JZ_EXTAL2		32768     /* RTC extal freq: 32.768 KHz */
+
+
+/*====================================================================== 
+ * GPIO
+ */
+#define GPIO_SD_VCC_EN_N	113 /* GPD17 */
+#define GPIO_SD_CD_N		110 /* GPD14 */
+#define GPIO_SD_WP		112 /* GPD16 */
+#define GPIO_USB_DETE		102 /* GPD6 */
+#define GPIO_DC_DETE_N		103 /* GPD7 */
+#define GPIO_CHARG_STAT_N	111 /* GPD15 */
+#define GPIO_DISP_OFF_N		118 /* GPD22 */
+#define GPIO_LED_EN       	124 /* GPD28 */
+
+#define GPIO_UDC_HOTPLUG	GPIO_USB_DETE
+/*====================================================================== 
+ * MMC/SD
+ */
+
+#define MSC_WP_PIN		GPIO_SD_WP
+#define MSC_HOTPLUG_PIN		GPIO_SD_CD_N
+#define MSC_HOTPLUG_IRQ		(IRQ_GPIO_0 + GPIO_SD_CD_N)
+
+#define __msc_init_io()				\
+do {						\
+	__gpio_as_output(GPIO_SD_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD_CD_N);		\
+} while (0)
+
+#define __msc_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_card_detected(s)			\
+({						\
+	int detected = 1;			\
+	if (__gpio_get_pin(GPIO_SD_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+
+#endif /* __ASM_JZ4740_PAVO_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/board-virgo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/board-virgo.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,67 @@
+/*
+ *  linux/include/asm-mips/mach-jz4740/board-virgo.h
+ *
+ *  JZ4720-based VIRGO board ver 1.x definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4720_VIRGO_H__
+#define __ASM_JZ4720_VIRGO_H__
+
+/*====================================================================== 
+ * Frequencies of on-board oscillators
+ */
+#define JZ_EXTAL		12000000  /* Main extal freq: 12 MHz */
+#define JZ_EXTAL2		32768     /* RTC extal freq: 32.768 KHz */
+
+/*====================================================================== 
+ * GPIO VIRGO(JZ4720)
+ */
+#define GPIO_SD_VCC_EN_N	115 /* GPD19 */	
+#define GPIO_SD_CD_N		116 /* GPD20 */
+#define GPIO_USB_DETE		114 /* GPD18 */
+#define GPIO_DC_DETE_N		120 /* GPD24 */
+#define GPIO_DISP_OFF_N		118 /* GPD22 */
+#define GPIO_LED_EN       	117 /* GPD21 */
+
+#define GPIO_UDC_HOTPLUG	GPIO_USB_DETE
+
+/*====================================================================== 
+ * MMC/SD
+ */
+
+#define MSC_HOTPLUG_PIN		GPIO_SD_CD_N
+#define MSC_HOTPLUG_IRQ		(IRQ_GPIO_0 + GPIO_SD_CD_N)
+
+#define __msc_init_io()				\
+do {						\
+	__gpio_as_output(GPIO_SD_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD_CD_N);		\
+} while (0)
+
+#define __msc_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_card_detected(s)			\
+({						\
+	int detected = 1;			\
+	if (__gpio_get_pin(GPIO_SD_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+
+#endif /* __ASM_JZ4720_VIRGO_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/clock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/clock.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,173 @@
+/*
+ *  linux/include/asm-mips/mach-jz4740/clock.h
+ *
+ *  JZ4740 clocks definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4740_CLOCK_H__
+#define __ASM_JZ4740_CLOCK_H__
+
+#ifndef JZ_EXTAL
+//#define JZ_EXTAL		3686400   /* 3.6864 MHz */
+#define JZ_EXTAL		12000000   /* 3.6864 MHz */
+#endif
+#ifndef JZ_EXTAL2
+#define JZ_EXTAL2		32768     /* 32.768 KHz */
+#endif
+
+/*
+ * JZ4740 clocks structure
+ */
+typedef struct {
+	unsigned int cclk;      /* CPU clock */
+	unsigned int hclk;      /* System bus clock */
+	unsigned int pclk;      /* Peripheral bus clock */
+	unsigned int mclk;      /* Flash/SRAM/SDRAM clock */
+	unsigned int lcdclk;    /* LCDC module clock */
+	unsigned int pixclk;    /* LCD pixel clock */
+	unsigned int i2sclk;    /* AIC module clock */
+	unsigned int usbclk;    /* USB module clock */
+	unsigned int mscclk;    /* MSC module clock */
+	unsigned int extalclk;  /* EXTAL clock for UART,I2C,SSI,TCU,USB-PHY */
+	unsigned int rtcclk;    /* RTC clock for CPM,INTC,RTC,TCU,WDT */
+} jz_clocks_t;
+
+extern jz_clocks_t jz_clocks;
+
+
+/* PLL output frequency */
+static __inline__ unsigned int __cpm_get_pllout(void)
+{
+	unsigned long m, n, no, pllout;
+	unsigned long cppcr = REG_CPM_CPPCR;
+	unsigned long od[4] = {1, 2, 2, 4};
+	if ((cppcr & CPM_CPPCR_PLLEN) && !(cppcr & CPM_CPPCR_PLLBP)) {
+		m = __cpm_get_pllm() + 2;
+		n = __cpm_get_plln() + 2;
+		no = od[__cpm_get_pllod()];
+		pllout = ((JZ_EXTAL) / (n * no)) * m;
+	} else
+		pllout = JZ_EXTAL;
+	return pllout;
+}
+
+/* PLL output frequency for MSC/I2S/LCD/USB */
+static __inline__ unsigned int __cpm_get_pllout2(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_PCS)
+		return __cpm_get_pllout();
+	else
+		return __cpm_get_pllout()/2;
+}
+
+/* CPU core clock */
+static __inline__ unsigned int __cpm_get_cclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_cdiv()];
+}
+
+/* AHB system bus clock */
+static __inline__ unsigned int __cpm_get_hclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_hdiv()];
+}
+
+/* Memory bus clock */
+static __inline__ unsigned int __cpm_get_mclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_mdiv()];
+}
+
+/* APB peripheral bus clock */
+static __inline__ unsigned int __cpm_get_pclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_pdiv()];
+}
+
+/* LCDC module clock */
+static __inline__ unsigned int __cpm_get_lcdclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_ldiv() + 1);
+}
+
+/* LCD pixel clock */
+static __inline__ unsigned int __cpm_get_pixclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_pixdiv() + 1);
+}
+
+/* I2S clock */
+static __inline__ unsigned int __cpm_get_i2sclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_I2CS) {
+		return __cpm_get_pllout2() / (__cpm_get_i2sdiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* USB clock */
+static __inline__ unsigned int __cpm_get_usbclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_UCS) {
+		return __cpm_get_pllout2() / (__cpm_get_udiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* MSC clock */
+static __inline__ unsigned int __cpm_get_mscclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_mscdiv() + 1);
+}
+
+/* EXTAL clock for UART,I2C,SSI,TCU,USB-PHY */
+static __inline__ unsigned int __cpm_get_extalclk(void)
+{
+	return JZ_EXTAL;
+}
+
+/* RTC clock for CPM,INTC,RTC,TCU,WDT */
+static __inline__ unsigned int __cpm_get_rtcclk(void)
+{
+	return JZ_EXTAL2;
+}
+
+/*
+ * Output 24MHz for SD and 16MHz for MMC.
+ */
+static inline void __cpm_select_msc_clk(int sd)
+{
+	unsigned int pllout2 = __cpm_get_pllout2();
+	unsigned int div = 0;
+
+	if (sd) {
+		div = pllout2 / 24000000;
+	}
+	else {
+		div = pllout2 / 16000000;
+	}
+
+	REG_CPM_MSCCDR = div - 1;
+}
+
+#endif /* __ASM_JZ4740_CLOCK_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/dma.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,265 @@
+/*
+ *  linux/include/asm-mips/mach-jz4740/dma.h
+ *
+ *  JZ4740 DMA definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4740_DMA_H__
+#define __ASM_JZ4740_DMA_H__
+
+#include <linux/interrupt.h>
+#include <asm/io.h>			/* need byte IO */
+#include <linux/spinlock.h>		/* And spinlocks */
+#include <linux/delay.h>
+#include <asm/system.h>
+
+/*
+ * Descriptor structure for JZ4740 DMA engine
+ * Note: this structure must always be aligned to a 16-bytes boundary.
+ */
+
+typedef struct {
+	volatile u32 dcmd;	/* DCMD value for the current transfer */
+	volatile u32 dsadr;	/* DSAR value for the current transfer */
+	volatile u32 dtadr;	/* DTAR value for the current transfer */
+	volatile u32 ddadr;	/* Points to the next descriptor + transfer count */
+} jz_dma_desc;
+
+
+/* DMA Device ID's follow */
+enum {
+	DMA_ID_UART0_TX = 0,
+	DMA_ID_UART0_RX,
+	DMA_ID_SSI_TX,
+	DMA_ID_SSI_RX,
+	DMA_ID_AIC_TX,
+	DMA_ID_AIC_RX,
+	DMA_ID_MSC_TX,
+	DMA_ID_MSC_RX,
+	DMA_ID_TCU_OVERFLOW,
+	DMA_ID_AUTO,
+	DMA_ID_RAW_SET,
+	DMA_ID_MAX
+};
+
+/* DMA modes, simulated by sw */
+#define DMA_MODE_READ	0x0  /* I/O to memory, no autoinit, increment, single mode */
+#define DMA_MODE_WRITE	0x1  /* memory to I/O, no autoinit, increment, single mode */
+#define DMA_AUTOINIT	0x2
+#define DMA_MODE_MASK	0x3
+
+struct jz_dma_chan {
+	int dev_id;	/* DMA ID: this channel is allocated if >=0, free otherwise */ 
+	unsigned int io;        /* DMA channel number */
+	const char *dev_str;    /* string describes the DMA channel */
+	int irq;                /* DMA irq number */
+	void *irq_dev;          /* DMA private device structure */
+	unsigned int fifo_addr; /* physical fifo address of the requested device */
+	unsigned int cntl;	/* DMA controll */
+	unsigned int mode;      /* DMA configuration */
+	unsigned int source;    /* DMA request source */
+};
+
+extern struct jz_dma_chan jz_dma_table[];
+
+
+#define DMA_8BIT_RX_CMD					\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_8 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_8BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_8BIT_TX_CMD					\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_8 |		\
+	DMAC_DCMD_DS_8BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BIT_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BIT_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BIT_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BIT_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_8 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_8 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_8 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_8 |		\
+	DMAC_DCMD_DS_32BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_32_16BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_32_16BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BIT_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BIT_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+extern int jz_request_dma(int dev_id,
+			  const char *dev_str,
+			  irqreturn_t (*irqhandler)(int, void *),
+			  unsigned long irqflags,
+			  void *irq_dev_id);
+extern void jz_free_dma(unsigned int dmanr);
+
+extern int jz_dma_read_proc(char *buf, char **start, off_t fpos,
+			      int length, int *eof, void *data);
+extern void dump_jz_dma_channel(unsigned int dmanr);
+
+extern void enable_dma(unsigned int dmanr);
+extern void disable_dma(unsigned int dmanr);
+extern void set_dma_addr(unsigned int dmanr, unsigned int phyaddr);
+extern void set_dma_count(unsigned int dmanr, unsigned int bytecnt);
+extern void set_dma_mode(unsigned int dmanr, unsigned int mode);
+extern void jz_set_oss_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt);
+extern void jz_set_alsa_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt);
+extern unsigned int get_dma_residue(unsigned int dmanr);
+
+extern spinlock_t  dma_spin_lock;
+
+static __inline__ unsigned long claim_dma_lock(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dma_spin_lock, flags);
+	return flags;
+}
+
+static __inline__ void release_dma_lock(unsigned long flags)
+{
+	spin_unlock_irqrestore(&dma_spin_lock, flags);
+}
+
+/* Clear the 'DMA Pointer Flip Flop'.
+ * Write 0 for LSB/MSB, 1 for MSB/LSB access.
+ */
+#define clear_dma_ff(channel)
+
+static __inline__ struct jz_dma_chan *get_dma_chan(unsigned int dmanr)
+{
+	if (dmanr > MAX_DMA_NUM
+	    || jz_dma_table[dmanr].dev_id < 0)
+		return NULL;
+	return &jz_dma_table[dmanr];
+}
+
+static __inline__ int dma_halted(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 1;
+	return  __dmac_channel_transmit_halt_detected(dmanr) ? 1 : 0;
+}
+
+static __inline__ unsigned int get_dma_mode(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+	return chan->mode;
+}
+
+static __inline__ void clear_dma_done(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+}
+
+static __inline__ void clear_dma_halt(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT);
+	REG_DMAC_DMACR &= ~(DMAC_DMACR_HLT);
+}
+
+static __inline__ void clear_dma_flag(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+	REG_DMAC_DMACR &= ~(DMAC_DMACR_HLT | DMAC_DMACR_AR);
+}
+
+static __inline__ void set_dma_page(unsigned int dmanr, char pagenr)
+{
+}
+
+static __inline__ unsigned int get_dma_done_status(unsigned int dmanr)
+{
+	unsigned long dccsr;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+	dccsr = REG_DMAC_DCCSR(chan->io);
+	return dccsr & (DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+}
+
+static __inline__ int get_dma_done_irq(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return -1;
+	return chan->irq;
+}
+
+#endif  /* __ASM_JZ4740_DMA_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/jz4740.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/jz4740.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ *  linux/include/asm-mips/mach-jz4740/jz4740.h
+ *
+ *  JZ4740 common definition.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4740_H__
+#define __ASM_JZ4740_H__
+
+#include <asm/mach-jz4740/regs.h>
+#include <asm/mach-jz4740/ops.h>
+#include <asm/mach-jz4740/dma.h>
+#include <asm/mach-jz4740/misc.h>
+
+/*------------------------------------------------------------------
+ * Platform definitions
+ */
+#ifdef CONFIG_JZ4740_PAVO
+#include <asm/mach-jz4740/board-pavo.h>
+#endif
+
+#ifdef CONFIG_JZ4740_LEO
+#include <asm/mach-jz4740/board-leo.h>
+#endif
+
+#ifdef CONFIG_JZ4740_LYRA
+#include <asm/mach-jz4740/board-lyra.h>
+#endif
+
+#ifdef CONFIG_JZ4725_DIPPER
+#include <asm/mach-jz4740/board-dipper.h>
+#endif
+
+#ifdef CONFIG_JZ4720_VIRGO
+#include <asm/mach-jz4740/board-virgo.h>
+#endif
+
+/* Add other platform definition here ... */
+
+
+/*------------------------------------------------------------------
+ * Follows are related to platform definitions
+ */
+
+#include <asm/mach-jz4740/clock.h>
+#include <asm/mach-jz4740/serial.h>
+
+#endif /* __ASM_JZ4740_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/misc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/misc.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,43 @@
+/*
+ *  linux/include/asm-mips/mach-jz4740/misc.h
+ *
+ *  Ingenic's JZ4740 common include.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <yliu@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4740_MISC_H__
+#define __ASM_JZ4740_MISC_H__
+
+/*==========================================================
+ * I2C
+ *===========================================================*/
+
+#define I2C_EEPROM_DEV	0xA	/* b'1010 */
+#define I2C_RTC_DEV	0xD	/* b'1101 */
+#define DIMM0_SPD_ADDR	0
+#define DIMM1_SPD_ADDR	1
+#define DIMM2_SPD_ADDR	2
+#define DIMM3_SPD_ADDR	3
+#define JZ_HCI_ADDR	7
+
+#define DIMM_SPD_LEN	128
+#define JZ_HCI_LEN	512    /* 4K bits E2PROM */
+#define I2C_RTC_LEN	16
+#define HCI_MAC_OFFSET	64
+
+extern void i2c_open(void);
+extern void i2c_close(void);
+extern void i2c_setclk(unsigned int i2cclk);
+extern int i2c_read(unsigned char device, unsigned char *buf,
+		    unsigned char address, int count);
+extern int i2c_write(unsigned char device, unsigned char *buf,
+		     unsigned char address, int count);
+
+#endif /* __ASM_JZ4740_MISC_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/ops.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/ops.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,2224 @@
+/*
+ *  linux/include/asm-mips/mach-jz4740/ops.h
+ *
+ *  Ingenic's JZ4740 common include.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <yliu@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef __JZ4740_OPS_H__
+#define __JZ4740_OPS_H__
+
+/*
+ * Definition of Module Operations
+ */
+
+/***************************************************************************
+ * GPIO
+ ***************************************************************************/
+
+//------------------------------------------------------
+// GPIO Pins Description
+//
+// PORT 0:
+//
+// PIN/BIT N		FUNC0		FUNC1
+//	0		D0		-
+//	1		D1		-
+//	2		D2		-
+//	3		D3		-
+//	4		D4		-
+//	5		D5		-
+//	6		D6		-
+//	7		D7		-
+//	8		D8		-
+//	9		D9		-
+//	10		D10		-
+//	11		D11		-
+//	12		D12		-
+//	13		D13		-
+//	14		D14		-
+//	15		D15		-
+//	16		D16		-
+//	17		D17		-
+//	18		D18		-
+//	19		D19		-
+//	20		D20		-
+//	21		D21		-
+//	22		D22		-
+//	23		D23		-
+//	24		D24		-
+//	25		D25		-
+//	26		D26		-
+//	27		D27		-
+//	28		D28		-
+//	29		D29		-
+//	30		D30		-
+//	31		D31		-
+//
+//------------------------------------------------------
+// PORT 1:
+//
+// PIN/BIT N		FUNC0		FUNC1
+//	0		A0		-
+//	1		A1		-
+//	2		A2		-
+//	3		A3		-
+//	4		A4		-
+//	5		A5		-
+//	6		A6		-
+//	7		A7		-
+//	8		A8		-
+//	9		A9		-
+//	10		A10		-
+//	11		A11		-
+//	12		A12		-
+//	13		A13		-
+//	14		A14		-
+//	15		A15/CL		-
+//	16		A16/AL		-
+//	17		LCD_CLS		A21
+//	18		LCD_SPL		A22
+//	19		DCS#		-
+//	20		RAS#		-
+//	21		CAS#		-
+//	22		RDWE#/BUFD#	-
+//	23		CKE		-
+//	24		CKO		-
+//	25		CS1#		-
+//	26		CS2#		-
+//	27		CS3#		-
+//	28		CS4#		-
+//	29		RD#		-
+//	30		WR#		-
+//	31		WE0#		-
+//
+// Note: PIN15&16 are CL&AL when connecting to NAND flash.
+//------------------------------------------------------
+// PORT 2:
+//
+// PIN/BIT N		FUNC0		FUNC1
+//	0		LCD_D0		-
+//	1		LCD_D1		-
+//	2		LCD_D2		-
+//	3		LCD_D3		-
+//	4		LCD_D4		-
+//	5		LCD_D5		-
+//	6		LCD_D6		-
+//	7		LCD_D7		-
+//	8		LCD_D8		-
+//	9		LCD_D9		-
+//	10		LCD_D10		-
+//	11		LCD_D11		-
+//	12		LCD_D12		-
+//	13		LCD_D13		-
+//	14		LCD_D14		-
+//	15		LCD_D15		-
+//	16		LCD_D16		-
+//	17		LCD_D17		-
+//	18		LCD_PCLK	-
+//	19		LCD_HSYNC	-
+//	20		LCD_VSYNC	-
+//	21		LCD_DE		-
+//	22		LCD_PS		A19
+//	23		LCD_REV		A20
+//	24		WE1#		-
+//	25		WE2#		-
+//	26		WE3#		-
+//	27		WAIT#		-
+//	28		FRE#		-
+//	29		FWE#		-
+//	30(NOTE:FRB#)	-		-
+//	31		-		-
+//
+// NOTE(1): PIN30 is used for FRB# when connecting to NAND flash.
+//------------------------------------------------------
+// PORT 3:
+//
+// PIN/BIT N		FUNC0		FUNC1
+//	0		CIM_D0		-
+//	1		CIM_D1		-
+//	2		CIM_D2		-
+//	3		CIM_D3		-
+//	4		CIM_D4		-
+//	5		CIM_D5		-
+//	6		CIM_D6		-
+//	7		CIM_D7		-
+//	8		MSC_CMD		-
+//	9		MSC_CLK		-
+//	10		MSC_D0		-
+//	11		MSC_D1		-
+//	12		MSC_D2		-
+//	13		MSC_D3		-
+//	14		CIM_MCLK	-
+//	15		CIM_PCLK	-
+//	16		CIM_VSYNC	-
+//	17		CIM_HSYNC	-
+//	18		SSI_CLK		SCLK_RSTN
+//	19		SSI_CE0#	BIT_CLK(AIC)
+//	20		SSI_DT		SDATA_OUT(AIC)
+//	21		SSI_DR		SDATA_IN(AIC)
+//	22		SSI_CE1#&GPC	SYNC(AIC)
+//	23		PWM0		I2C_SDA
+//	24		PWM1		I2C_SCK
+//	25		PWM2		UART0_TxD
+//	26		PWM3		UART0_RxD
+//	27		PWM4		A17
+//	28		PWM5		A18
+//	29		-		-
+//	30		PWM6		UART0_CTS/UART1_RxD
+//	31		PWM7		UART0_RTS/UART1_TxD
+//
+//////////////////////////////////////////////////////////
+
+/* 
+ * p is the port number (0,1,2,3)
+ * o is the pin offset (0-31) inside the port
+ * n is the absolute number of a pin (0-127), regardless of the port
+ */
+
+//-------------------------------------------
+// Function Pins Mode
+
+#define __gpio_as_func0(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXSELC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_func1(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+} while (0)
+
+/*
+ * D0 ~ D31, A0 ~ A16, DCS#, RAS#, CAS#, CKE#, 
+ * RDWE#, CKO#, WE0#, WE1#, WE2#, WE3#
+ */
+#define __gpio_as_sdram_32bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0xffffffff;	\
+	REG_GPIO_PXSELC(0) = 0xffffffff;	\
+	REG_GPIO_PXPES(0) = 0xffffffff;		\
+	REG_GPIO_PXFUNS(1) = 0x81f9ffff;	\
+	REG_GPIO_PXSELC(1) = 0x81f9ffff;	\
+	REG_GPIO_PXPES(1) = 0x81f9ffff;		\
+	REG_GPIO_PXFUNS(2) = 0x07000000;	\
+	REG_GPIO_PXSELC(2) = 0x07000000;	\
+	REG_GPIO_PXPES(2) = 0x07000000;		\
+} while (0)
+
+/*
+ * D0 ~ D15, A0 ~ A16, DCS#, RAS#, CAS#, CKE#, 
+ * RDWE#, CKO#, WE0#, WE1#
+ */
+#define __gpio_as_sdram_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x5442bfaa;	\
+	REG_GPIO_PXSELC(0) = 0x5442bfaa;	\
+	REG_GPIO_PXPES(0) = 0x5442bfaa;		\
+	REG_GPIO_PXFUNS(1) = 0x81f9ffff;	\
+	REG_GPIO_PXSELC(1) = 0x81f9ffff;	\
+	REG_GPIO_PXPES(1) = 0x81f9ffff;		\
+	REG_GPIO_PXFUNS(2) = 0x01000000;	\
+	REG_GPIO_PXSELC(2) = 0x01000000;	\
+	REG_GPIO_PXPES(2) = 0x01000000;		\
+} while (0)
+
+/*
+ * CS1#, CLE, ALE, FRE#, FWE#, FRB#, RDWE#/BUFD#
+ */
+#define __gpio_as_nand()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0x02018000;	\
+	REG_GPIO_PXSELC(1) = 0x02018000;	\
+	REG_GPIO_PXPES(1) = 0x02018000;		\
+	REG_GPIO_PXFUNS(2) = 0x30000000;	\
+	REG_GPIO_PXSELC(2) = 0x30000000;	\
+	REG_GPIO_PXPES(2) = 0x30000000;		\
+	REG_GPIO_PXFUNC(2) = 0x40000000;	\
+	REG_GPIO_PXSELC(2) = 0x40000000;	\
+	REG_GPIO_PXDIRC(2) = 0x40000000;	\
+	REG_GPIO_PXPES(2) = 0x40000000;		\
+	REG_GPIO_PXFUNS(1) = 0x00400000;	\
+	REG_GPIO_PXSELC(1) = 0x00400000;	\
+} while (0)
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D7
+ */
+#define __gpio_as_nor_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x000000ff;	\
+	REG_GPIO_PXSELC(0) = 0x000000ff;	\
+	REG_GPIO_PXPES(0) = 0x000000ff;		\
+	REG_GPIO_PXFUNS(1) = 0x7041ffff;	\
+	REG_GPIO_PXSELC(1) = 0x7041ffff;	\
+	REG_GPIO_PXPES(1) = 0x7041ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x00060000;	\
+	REG_GPIO_PXSELS(1) = 0x00060000;	\
+	REG_GPIO_PXPES(1) = 0x00060000;		\
+	REG_GPIO_PXFUNS(2) = 0x08000000;	\
+	REG_GPIO_PXSELC(2) = 0x08000000;	\
+	REG_GPIO_PXPES(2) = 0x08000000;		\
+	REG_GPIO_PXFUNS(2) = 0x00c00000;	\
+	REG_GPIO_PXSELS(2) = 0x00c00000;	\
+	REG_GPIO_PXPES(2) = 0x00c00000;		\
+	REG_GPIO_PXFUNS(3) = 0x18000000;	\
+	REG_GPIO_PXSELS(3) = 0x18000000;	\
+	REG_GPIO_PXPES(3) = 0x18000000;		\
+} while (0)
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D15
+ */
+#define __gpio_as_nor_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;	\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;	\
+	REG_GPIO_PXPES(0) = 0x0000ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x7041ffff;	\
+	REG_GPIO_PXSELC(1) = 0x7041ffff;	\
+	REG_GPIO_PXPES(1) = 0x7041ffff;		\
+	REG_GPIO_PXFUNS(1) = 0x00060000;	\
+	REG_GPIO_PXSELS(1) = 0x00060000;	\
+	REG_GPIO_PXPES(1) = 0x00060000;		\
+	REG_GPIO_PXFUNS(2) = 0x08000000;	\
+	REG_GPIO_PXSELC(2) = 0x08000000;	\
+	REG_GPIO_PXPES(2) = 0x08000000;		\
+	REG_GPIO_PXFUNS(2) = 0x00c00000;	\
+	REG_GPIO_PXSELS(2) = 0x00c00000;	\
+	REG_GPIO_PXPES(2) = 0x00c00000;		\
+	REG_GPIO_PXFUNS(3) = 0x18000000;	\
+	REG_GPIO_PXSELS(3) = 0x18000000;	\
+	REG_GPIO_PXPES(3) = 0x18000000;		\
+} while (0)
+
+/*
+ * UART0_TxD, UART_RxD0
+ */
+#define __gpio_as_uart0()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x06000000;	\
+	REG_GPIO_PXSELS(3) = 0x06000000;	\
+	REG_GPIO_PXPES(3) = 0x06000000;		\
+} while (0)
+
+/*
+ * UART0_CTS, UART0_RTS
+ */
+#define __gpio_as_ctsrts()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0xc0000000;	\
+	REG_GPIO_PXSELS(3) = 0xc0000000;	\
+	REG_GPIO_PXTRGC(3) = 0xc0000000;	\
+	REG_GPIO_PXPES(3) = 0xc0000000;		\
+} while (0)
+
+/*
+ * UART1_TxD, UART1_RxD1
+ */
+#define __gpio_as_uart1()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0xc0000000;	\
+	REG_GPIO_PXSELC(3) = 0xc0000000;	\
+	REG_GPIO_PXTRGS(3) = 0xc0000000;	\
+	REG_GPIO_PXPES(3) = 0xc0000000;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D15, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x003cffff;	\
+	REG_GPIO_PXSELC(2) = 0x003cffff;	\
+	REG_GPIO_PXPES(2) = 0x003cffff;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D17, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_18bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x003fffff;	\
+	REG_GPIO_PXSELC(2) = 0x003fffff;	\
+	REG_GPIO_PXPES(2) = 0x003fffff;		\
+} while (0)
+
+/*
+ * LCD_PS, LCD_REV, LCD_CLS, LCD_SPL
+ */
+#define __gpio_as_lcd_special()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0x00060000;	\
+	REG_GPIO_PXSELC(1) = 0x00060000;	\
+	REG_GPIO_PXPES(1)  = 0x00060000;	\
+	REG_GPIO_PXFUNS(2) = 0x00c00000;	\
+	REG_GPIO_PXSELC(2) = 0x00c00000;	\
+	REG_GPIO_PXPES(2)  = 0x00c00000;	\
+} while (0)
+
+/* LCD_D0~LCD_D7, SLCD_RS, SLCD_CS */
+#define __gpio_as_slcd_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x001800ff;	\
+	REG_GPIO_PXSELC(2) = 0x001800ff;	\
+} while (0)
+
+/* LCD_D0~LCD_D7, SLCD_RS, SLCD_CS */
+#define __gpio_as_slcd_9bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x001801ff;	\
+	REG_GPIO_PXSELC(2) = 0x001801ff;	\
+} while (0)
+
+/* LCD_D0~LCD_D15, SLCD_RS, SLCD_CS */
+#define __gpio_as_slcd_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x0018ffff;	\
+	REG_GPIO_PXSELC(2) = 0x0018ffff;	\
+} while (0)
+
+/* LCD_D0~LCD_D17, SLCD_RS, SLCD_CS */
+#define __gpio_as_slcd_18bit()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x001bffff;	\
+	REG_GPIO_PXSELC(2) = 0x001bffff;	\
+} while (0)
+
+/*
+ * CIM_D0~CIM_D7, CIM_MCLK, CIM_PCLK, CIM_VSYNC, CIM_HSYNC
+ */
+#define __gpio_as_cim()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x0003c0ff;	\
+	REG_GPIO_PXSELC(3) = 0x0003c0ff;	\
+	REG_GPIO_PXPES(3) = 0x0003c0ff;		\
+} while (0)
+
+/*
+ * SDATA_OUT, SDATA_IN, BIT_CLK, SYNC, SCLK_RESET
+ */
+#define __gpio_as_aic()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x007c0000;	\
+	REG_GPIO_PXSELS(3) = 0x007c0000;	\
+	REG_GPIO_PXPES(3) = 0x007c0000;		\
+} while (0)
+
+/*
+ * MSC_CMD, MSC_CLK, MSC_D0 ~ MSC_D3
+ */
+#define __gpio_as_msc()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x00003f00;	\
+	REG_GPIO_PXSELC(3) = 0x00003f00;	\
+	REG_GPIO_PXPES(3) = 0x00003f00;		\
+} while (0)
+
+/*
+ * SSI_CS0, SSI_CLK, SSI_DT, SSI_DR
+ */
+#define __gpio_as_ssi()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003c0000;	\
+	REG_GPIO_PXSELC(3) = 0x003c0000;	\
+	REG_GPIO_PXPES(3) = 0x003c0000;		\
+} while (0)
+
+/*
+ * I2C_SCK, I2C_SDA
+ */
+#define __gpio_as_i2c()				\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x01800000;	\
+	REG_GPIO_PXSELS(3) = 0x01800000;	\
+	REG_GPIO_PXPES(3) = 0x01800000;		\
+} while (0)
+
+/*
+ * PWM0
+ */
+#define __gpio_as_pwm0()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x00800000;	\
+	REG_GPIO_PXSELC(3) = 0x00800000;	\
+	REG_GPIO_PXPES(3) = 0x00800000;		\
+} while (0)
+
+/*
+ * PWM1
+ */
+#define __gpio_as_pwm1()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x01000000;	\
+	REG_GPIO_PXSELC(3) = 0x01000000;	\
+	REG_GPIO_PXPES(3) = 0x01000000;		\
+} while (0)
+
+/*
+ * PWM2
+ */
+#define __gpio_as_pwm2()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x02000000;	\
+	REG_GPIO_PXSELC(3) = 0x02000000;	\
+	REG_GPIO_PXPES(3) = 0x02000000;		\
+} while (0)
+
+/*
+ * PWM3
+ */
+#define __gpio_as_pwm3()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x04000000;	\
+	REG_GPIO_PXSELC(3) = 0x04000000;	\
+	REG_GPIO_PXPES(3) = 0x04000000;		\
+} while (0)
+
+/*
+ * PWM4
+ */
+#define __gpio_as_pwm4()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x08000000;	\
+	REG_GPIO_PXSELC(3) = 0x08000000;	\
+	REG_GPIO_PXPES(3) = 0x08000000;		\
+} while (0)
+
+/*
+ * PWM5
+ */
+#define __gpio_as_pwm5()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x10000000;	\
+	REG_GPIO_PXSELC(3) = 0x10000000;	\
+	REG_GPIO_PXPES(3) = 0x10000000;		\
+} while (0)
+
+/*
+ * PWM6
+ */
+#define __gpio_as_pwm6()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x40000000;	\
+	REG_GPIO_PXSELC(3) = 0x40000000;	\
+	REG_GPIO_PXPES(3) = 0x40000000;		\
+} while (0)
+
+/*
+ * PWM7
+ */
+#define __gpio_as_pwm7()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x80000000;	\
+	REG_GPIO_PXSELC(3) = 0x80000000;	\
+	REG_GPIO_PXPES(3) = 0x80000000;		\
+} while (0)
+
+/*
+ * n = 0 ~ 7
+ */
+#define __gpio_as_pwm(n)	__gpio_as_pwm##n()
+
+//-------------------------------------------
+// GPIO or Interrupt Mode
+
+#define __gpio_get_port(p)	(REG_GPIO_PXPIN(p))
+
+#define __gpio_port_as_output(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRS(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_port_as_input(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRC(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_as_output(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_output(p, o);		\
+} while (0)
+
+#define __gpio_as_input(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_input(p, o);		\
+} while (0)
+
+#define __gpio_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_pin(n)			\
+({						\
+	unsigned int p, o, v;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	if (__gpio_get_port(p) & (1 << o))	\
+		v = 1;				\
+	else					\
+		v = 0;				\
+	v;					\
+})
+
+#define __gpio_as_irq_high_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_low_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_rise_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_fall_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_mask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_unmask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_ack_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_irq()			\
+({						\
+	unsigned int p, i, tmp, v = 0;		\
+	for (p = 3; p >= 0; p--) {		\
+		tmp = REG_GPIO_PXFLG(p);	\
+		for (i = 0; i < 32; i++)	\
+			if (tmp & (1 << i))	\
+				v = (32*p + i);	\
+	}					\
+	v;					\
+})
+
+#define __gpio_group_irq(n)			\
+({						\
+	register int tmp, i;			\
+	tmp = REG_GPIO_PXFLG((n));		\
+	for (i=31;i>=0;i--)			\
+		if (tmp & (1 << i))		\
+			break;			\
+	i;					\
+})
+
+#define __gpio_enable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPEC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_disable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPES(p) = (1 << o);		\
+} while (0)
+
+
+/***************************************************************************
+ * CPM
+ ***************************************************************************/
+#define __cpm_get_pllm() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLM_MASK) >> CPM_CPPCR_PLLM_BIT)
+#define __cpm_get_plln() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLN_MASK) >> CPM_CPPCR_PLLN_BIT)
+#define __cpm_get_pllod() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLOD_MASK) >> CPM_CPPCR_PLLOD_BIT)
+
+#define __cpm_get_cdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_CDIV_MASK) >> CPM_CPCCR_CDIV_BIT)
+#define __cpm_get_hdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_HDIV_MASK) >> CPM_CPCCR_HDIV_BIT)
+#define __cpm_get_pdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_PDIV_MASK) >> CPM_CPCCR_PDIV_BIT)
+#define __cpm_get_mdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_MDIV_MASK) >> CPM_CPCCR_MDIV_BIT)
+#define __cpm_get_ldiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_LDIV_MASK) >> CPM_CPCCR_LDIV_BIT)
+#define __cpm_get_udiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_UDIV_MASK) >> CPM_CPCCR_UDIV_BIT)
+#define __cpm_get_i2sdiv() \
+	((REG_CPM_I2SCDR & CPM_I2SCDR_I2SDIV_MASK) >> CPM_I2SCDR_I2SDIV_BIT)
+#define __cpm_get_pixdiv() \
+	((REG_CPM_LPCDR & CPM_LPCDR_PIXDIV_MASK) >> CPM_LPCDR_PIXDIV_BIT)
+#define __cpm_get_mscdiv() \
+	((REG_CPM_MSCCDR & CPM_MSCCDR_MSCDIV_MASK) >> CPM_MSCCDR_MSCDIV_BIT)
+#define __cpm_get_uhcdiv() \
+	((REG_CPM_UHCCDR & CPM_UHCCDR_UHCDIV_MASK) >> CPM_UHCCDR_UHCDIV_BIT)
+#define __cpm_get_ssidiv() \
+	((REG_CPM_SSICCDR & CPM_SSICDR_SSICDIV_MASK) >> CPM_SSICDR_SSIDIV_BIT)
+
+#define __cpm_set_cdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_CDIV_MASK) | ((v) << (CPM_CPCCR_CDIV_BIT)))
+#define __cpm_set_hdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_HDIV_MASK) | ((v) << (CPM_CPCCR_HDIV_BIT)))
+#define __cpm_set_pdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_PDIV_MASK) | ((v) << (CPM_CPCCR_PDIV_BIT)))
+#define __cpm_set_mdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_MDIV_MASK) | ((v) << (CPM_CPCCR_MDIV_BIT)))
+#define __cpm_set_ldiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_LDIV_MASK) | ((v) << (CPM_CPCCR_LDIV_BIT)))
+#define __cpm_set_udiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_UDIV_MASK) | ((v) << (CPM_CPCCR_UDIV_BIT)))
+#define __cpm_set_i2sdiv(v) \
+	(REG_CPM_I2SCDR = (REG_CPM_I2SCDR & ~CPM_I2SCDR_I2SDIV_MASK) | ((v) << (CPM_I2SCDR_I2SDIV_BIT)))
+#define __cpm_set_pixdiv(v) \
+	(REG_CPM_LPCDR = (REG_CPM_LPCDR & ~CPM_LPCDR_PIXDIV_MASK) | ((v) << (CPM_LPCDR_PIXDIV_BIT)))
+#define __cpm_set_mscdiv(v) \
+	(REG_CPM_MSCCDR = (REG_CPM_MSCCDR & ~CPM_MSCCDR_MSCDIV_MASK) | ((v) << (CPM_MSCCDR_MSCDIV_BIT)))
+#define __cpm_set_uhcdiv(v) \
+	(REG_CPM_UHCCDR = (REG_CPM_UHCCDR & ~CPM_UHCCDR_UHCDIV_MASK) | ((v) << (CPM_UHCCDR_UHCDIV_BIT)))
+#define __cpm_ssiclk_select_exclk() \
+	(REG_CPM_SSICDR &= ~CPM_SSICDR_SCS)
+#define __cpm_ssiclk_select_pllout() \
+	(REG_CPM_SSICDR |= CPM_SSICDR_SCS)
+#define __cpm_set_ssidiv(v) \
+	(REG_CPM_SSICDR = (REG_CPM_SSICDR & ~CPM_SSICDR_SSIDIV_MASK) | ((v) << (CPM_SSICDR_SSIDIV_BIT)))
+
+#define __cpm_select_i2sclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_I2CS)
+#define __cpm_select_i2sclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_I2CS)
+#define __cpm_enable_cko()		(REG_CPM_CPCCR |= CPM_CPCCR_CLKOEN)
+#define __cpm_select_usbclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_UCS)
+#define __cpm_select_usbclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_UCS)
+#define __cpm_enable_pll_change()	(REG_CPM_CPCCR |= CPM_CPCCR_CE)
+#define __cpm_pllout_direct()		(REG_CPM_CPCCR |= CPM_CPCCR_PCS)
+#define __cpm_pllout_div2()		(REG_CPM_CPCCR &= ~CPM_CPCCR_PCS)
+
+#define __cpm_pll_is_on()		(REG_CPM_CPPCR & CPM_CPPCR_PLLS)
+#define __cpm_pll_bypass()		(REG_CPM_CPPCR |= CPM_CPPCR_PLLBP)
+#define __cpm_pll_enable()		(REG_CPM_CPPCR |= CPM_CPPCR_PLLEN)
+
+#define __cpm_get_cclk_doze_duty() \
+	((REG_CPM_LCR & CPM_LCR_DOZE_DUTY_MASK) >> CPM_LCR_DOZE_DUTY_BIT)
+#define __cpm_set_cclk_doze_duty(v) \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_DOZE_DUTY_MASK) | ((v) << (CPM_LCR_DOZE_DUTY_BIT)))
+
+#define __cpm_doze_mode()		(REG_CPM_LCR |= CPM_LCR_DOZE_ON)
+#define __cpm_idle_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_IDLE)
+#define __cpm_sleep_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_SLEEP)
+
+#define __cpm_stop_all() 	(REG_CPM_CLKGR = 0x7fff)
+#define __cpm_stop_uart1()	(REG_CPM_CLKGR |= CPM_CLKGR_UART1)
+#define __cpm_stop_uhc()	(REG_CPM_CLKGR |= CPM_CLKGR_UHC)
+#define __cpm_stop_ipu()	(REG_CPM_CLKGR |= CPM_CLKGR_IPU)
+#define __cpm_stop_dmac()	(REG_CPM_CLKGR |= CPM_CLKGR_DMAC)
+#define __cpm_stop_udc()	(REG_CPM_CLKGR |= CPM_CLKGR_UDC)
+#define __cpm_stop_lcd()	(REG_CPM_CLKGR |= CPM_CLKGR_LCD)
+#define __cpm_stop_cim()	(REG_CPM_CLKGR |= CPM_CLKGR_CIM)
+#define __cpm_stop_sadc()	(REG_CPM_CLKGR |= CPM_CLKGR_SADC)
+#define __cpm_stop_msc()	(REG_CPM_CLKGR |= CPM_CLKGR_MSC)
+#define __cpm_stop_aic1()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC1)
+#define __cpm_stop_aic2()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC2)
+#define __cpm_stop_ssi()	(REG_CPM_CLKGR |= CPM_CLKGR_SSI)
+#define __cpm_stop_i2c()	(REG_CPM_CLKGR |= CPM_CLKGR_I2C)
+#define __cpm_stop_rtc()	(REG_CPM_CLKGR |= CPM_CLKGR_RTC)
+#define __cpm_stop_tcu()	(REG_CPM_CLKGR |= CPM_CLKGR_TCU)
+#define __cpm_stop_uart0()	(REG_CPM_CLKGR |= CPM_CLKGR_UART0)
+
+#define __cpm_start_all() 	(REG_CPM_CLKGR = 0x0)
+#define __cpm_start_uart1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART1)
+#define __cpm_start_uhc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UHC)
+#define __cpm_start_ipu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IPU)
+#define __cpm_start_dmac()	(REG_CPM_CLKGR &= ~CPM_CLKGR_DMAC)
+#define __cpm_start_udc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UDC)
+#define __cpm_start_lcd()	(REG_CPM_CLKGR &= ~CPM_CLKGR_LCD)
+#define __cpm_start_cim()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIM)
+#define __cpm_start_sadc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_SADC)
+#define __cpm_start_msc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_MSC)
+#define __cpm_start_aic1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC1)
+#define __cpm_start_aic2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC2)
+#define __cpm_start_ssi()	(REG_CPM_CLKGR &= ~CPM_CLKGR_SSI)
+#define __cpm_start_i2c()	(REG_CPM_CLKGR &= ~CPM_CLKGR_I2C)
+#define __cpm_start_rtc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_RTC)
+#define __cpm_start_tcu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_TCU)
+#define __cpm_start_uart0()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART0)
+
+#define __cpm_get_o1st() \
+	((REG_CPM_SCR & CPM_SCR_O1ST_MASK) >> CPM_SCR_O1ST_BIT)
+#define __cpm_set_o1st(v) \
+	(REG_CPM_SCR = (REG_CPM_SCR & ~CPM_SCR_O1ST_MASK) | ((v) << (CPM_SCR_O1ST_BIT)))
+#define __cpm_suspend_usbphy()		(REG_CPM_SCR |= CPM_SCR_USBPHY_SUSPEND)
+#define __cpm_enable_osc_in_sleep()	(REG_CPM_SCR |= CPM_SCR_OSC_ENABLE)
+
+
+/***************************************************************************
+ * TCU
+ ***************************************************************************/
+// where 'n' is the TCU channel
+#define __tcu_select_extalclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_EXT_EN)
+#define __tcu_select_rtcclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_RTC_EN)
+#define __tcu_select_pclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_PCK_EN)
+
+#define __tcu_select_clk_div1(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1)
+#define __tcu_select_clk_div4(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE4)
+#define __tcu_select_clk_div16(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE16)
+#define __tcu_select_clk_div64(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE64)
+#define __tcu_select_clk_div256(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE256)
+#define __tcu_select_clk_div1024(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1024)
+
+#define __tcu_enable_pwm_output(n)	( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_EN )
+#define __tcu_disable_pwm_output(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_EN )
+
+#define __tcu_init_pwm_output_high(n)	( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_INITL_HIGH )
+#define __tcu_init_pwm_output_low(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_INITL_HIGH )
+
+#define __tcu_set_pwm_output_shutdown_graceful(n)	( REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_SD )
+#define __tcu_set_pwm_output_shutdown_abrupt(n)		( REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_SD )
+
+#define __tcu_start_counter(n)		( REG_TCU_TESR |= (1 << (n)) )
+#define __tcu_stop_counter(n)		( REG_TCU_TECR |= (1 << (n)) )
+
+#define __tcu_half_match_flag(n)	( REG_TCU_TFR & (1 << ((n) + 16)) )
+#define __tcu_full_match_flag(n)	( REG_TCU_TFR & (1 << (n)) )
+#define __tcu_set_half_match_flag(n)	( REG_TCU_TFSR = (1 << ((n) + 16)) )
+#define __tcu_set_full_match_flag(n)	( REG_TCU_TFSR = (1 << (n)) )
+#define __tcu_clear_half_match_flag(n)	( REG_TCU_TFCR = (1 << ((n) + 16)) )
+#define __tcu_clear_full_match_flag(n)	( REG_TCU_TFCR = (1 << (n)) )
+#define __tcu_mask_half_match_irq(n)	( REG_TCU_TMSR = (1 << ((n) + 16)) )
+#define __tcu_mask_full_match_irq(n)	( REG_TCU_TMSR = (1 << (n)) )
+#define __tcu_unmask_half_match_irq(n)	( REG_TCU_TMCR = (1 << ((n) + 16)) )
+#define __tcu_unmask_full_match_irq(n)	( REG_TCU_TMCR = (1 << (n)) )
+
+#define __tcu_wdt_clock_stopped()	( REG_TCU_TSR & TCU_TSSR_WDTSC )
+#define __tcu_timer_clock_stopped(n)	( REG_TCU_TSR & (1 << (n)) )
+
+#define __tcu_start_wdt_clock()		( REG_TCU_TSCR = TCU_TSSR_WDTSC )
+#define __tcu_start_timer_clock(n)	( REG_TCU_TSCR = (1 << (n)) )
+
+#define __tcu_stop_wdt_clock()		( REG_TCU_TSSR = TCU_TSSR_WDTSC )
+#define __tcu_stop_timer_clock(n)	( REG_TCU_TSSR = (1 << (n)) )
+
+#define __tcu_get_count(n)		( REG_TCU_TCNT((n)) )
+#define __tcu_set_count(n,v)		( REG_TCU_TCNT((n)) = (v) )
+#define __tcu_set_full_data(n,v)	( REG_TCU_TDFR((n)) = (v) )
+#define __tcu_set_half_data(n,v)	( REG_TCU_TDHR((n)) = (v) )
+
+
+/***************************************************************************
+ * WDT
+ ***************************************************************************/
+#define __wdt_start()			( REG_WDT_TCER |= WDT_TCER_TCEN )
+#define __wdt_stop()			( REG_WDT_TCER &= ~WDT_TCER_TCEN )
+#define __wdt_set_count(v)		( REG_WDT_TCNT = (v) )
+#define __wdt_set_data(v)		( REG_WDT_TDR = (v) )
+
+#define __wdt_select_extalclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_EXT_EN)
+#define __wdt_select_rtcclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_RTC_EN)
+#define __wdt_select_pclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_PCK_EN)
+
+#define __wdt_select_clk_div1() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1)
+#define __wdt_select_clk_div4() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE4)
+#define __wdt_select_clk_div16() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE16)
+#define __wdt_select_clk_div64() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE64)
+#define __wdt_select_clk_div256() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE256)
+#define __wdt_select_clk_div1024() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1024)
+
+
+/***************************************************************************
+ * UART
+ ***************************************************************************/
+
+#define __uart_enable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) |= UARTFCR_UUE | UARTFCR_FE )
+#define __uart_disable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) = ~UARTFCR_UUE )
+
+#define __uart_enable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_TIE )
+#define __uart_disable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~UARTIER_TIE )
+
+#define __uart_enable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE )
+#define __uart_disable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~(UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE) )
+
+#define __uart_enable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) |= UARTMCR_LOOP )
+#define __uart_disable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) &= ~UARTMCR_LOOP )
+
+#define __uart_set_8n1(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) = UARTLCR_WLEN_8 )
+
+#define __uart_set_baud(n, devclk, baud)						\
+  do {											\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) |= UARTLCR_DLAB;			\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLLR) = (devclk / 16 / baud) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLHR) = ((devclk / 16 / baud) >> 8) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) &= ~UARTLCR_DLAB;			\
+  } while (0)
+
+#define __uart_parity_error(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_PER) != 0 )
+
+#define __uart_clear_errors(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) &= ~(UARTLSR_ORER | UARTLSR_BRK | UARTLSR_FER | UARTLSR_PER | UARTLSR_RFER) )
+
+#define __uart_transmit_fifo_empty(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TDRQ) != 0 )
+
+#define __uart_transmit_end(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TEMT) != 0 )
+
+#define __uart_transmit_char(n, ch) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_TDR) = (ch)
+
+#define __uart_receive_fifo_full(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_ready(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_char(n) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_RDR)
+
+#define __uart_disable_irda() \
+  ( REG8(IRDA_BASE + OFF_SIRCR) &= ~(SIRCR_TSIRE | SIRCR_RSIRE) )
+#define __uart_enable_irda() \
+  /* Tx high pulse as 0, Rx low pulse as 0 */ \
+  ( REG8(IRDA_BASE + OFF_SIRCR) = SIRCR_TSIRE | SIRCR_RSIRE | SIRCR_RXPL | SIRCR_TPWS )
+
+
+/***************************************************************************
+ * DMAC
+ ***************************************************************************/
+
+/* n is the DMA channel (0 - 5) */
+
+#define __dmac_enable_module() \
+  ( REG_DMAC_DMACR |= DMAC_DMACR_DMAE | DMAC_DMACR_PR_RR )
+#define __dmac_disable_module() \
+  ( REG_DMAC_DMACR &= ~DMAC_DMACR_DMAE )
+
+/* p=0,1,2,3 */
+#define __dmac_set_priority(p) 				\
+do {							\
+	REG_DMAC_DMACR &= ~DMAC_DMACR_PR_MASK;		\
+	REG_DMAC_DMACR |= ((p) << DMAC_DMACR_PR_BIT);	\
+} while (0)
+
+#define __dmac_test_halt_error() ( REG_DMAC_DMACR & DMAC_DMACR_HLT )
+#define __dmac_test_addr_error() ( REG_DMAC_DMACR & DMAC_DMACR_AR )
+
+#define __dmac_enable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_NDES )
+#define __dmac_disable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_NDES )
+
+#define __dmac_enable_channel(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_EN )
+#define __dmac_disable_channel(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_EN )
+#define __dmac_channel_enabled(n) \
+  ( REG_DMAC_DCCSR((n)) & DMAC_DCCSR_EN )
+
+#define __dmac_channel_enable_irq(n) \
+  ( REG_DMAC_DCMD((n)) |= DMAC_DCMD_TIE )
+#define __dmac_channel_disable_irq(n) \
+  ( REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_TIE )
+
+#define __dmac_channel_transmit_halt_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_HLT )
+#define __dmac_channel_transmit_end_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_TT )
+#define __dmac_channel_address_error_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_AR )
+#define __dmac_channel_count_terminated_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_CT )
+#define __dmac_channel_descriptor_invalid_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_INV )
+
+#define __dmac_channel_clear_transmit_halt(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_HLT )
+#define __dmac_channel_clear_transmit_end(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TT )
+#define __dmac_channel_clear_address_error(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_AR )
+#define __dmac_channel_clear_count_terminated(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_CT )
+#define __dmac_channel_clear_descriptor_invalid(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_INV )
+
+#define __dmac_channel_set_single_mode(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_TM )
+#define __dmac_channel_set_block_mode(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_TM )
+
+#define __dmac_channel_set_transfer_unit_32bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_8bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_8BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BYTE;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_32byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BYTE;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_dest_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DWDH_##w;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_src_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_SWDH_##w;	\
+} while (0)
+
+/* v=0-15 */
+#define __dmac_channel_set_rdil(n,v)				\
+do {								\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_RDIL_MASK;		\
+	REG_DMAC_DCMD((n) |= ((v) << DMAC_DCMD_RDIL_BIT);	\
+} while (0)
+
+#define __dmac_channel_dest_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DAI )
+#define __dmac_channel_dest_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_DAI )
+
+#define __dmac_channel_src_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SAI )
+#define __dmac_channel_src_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_SAI )
+
+#define __dmac_channel_set_doorbell(n) \
+  (  REG_DMAC_DMADBSR = (1 << (n)) )
+
+#define __dmac_channel_irq_detected(n)  ( REG_DMAC_DMAIPR & (1 << (n)) )
+#define __dmac_channel_ack_irq(n)       ( REG_DMAC_DMAIPR &= ~(1 << (n)) )
+
+static __inline__ int __dmac_get_irq(void)
+{
+	int i;
+	for (i = 0; i < MAX_DMA_NUM; i++)
+		if (__dmac_channel_irq_detected(i))
+			return i;
+	return -1;
+}
+
+
+/***************************************************************************
+ * AIC (AC'97 & I2S Controller)
+ ***************************************************************************/
+
+#define __aic_enable()		( REG_AIC_FR |= AIC_FR_ENB )
+#define __aic_disable()		( REG_AIC_FR &= ~AIC_FR_ENB )
+
+#define __aic_select_ac97()	( REG_AIC_FR &= ~AIC_FR_AUSEL )
+#define __aic_select_i2s()	( REG_AIC_FR |= AIC_FR_AUSEL )
+
+#define __aic_play_zero()	( REG_AIC_FR &= ~AIC_FR_LSMP )
+#define __aic_play_lastsample()	( REG_AIC_FR |= AIC_FR_LSMP )
+
+#define __i2s_as_master()	( REG_AIC_FR |= AIC_FR_BCKD | AIC_FR_SYNCD )
+#define __i2s_as_slave()	( REG_AIC_FR &= ~(AIC_FR_BCKD | AIC_FR_SYNCD) )
+#define __aic_reset_status()          ( REG_AIC_FR & AIC_FR_RST )
+
+#define __aic_reset()                                   \
+do {                                                    \
+        REG_AIC_FR |= AIC_FR_RST;                       \
+} while(0)
+
+
+#define __aic_set_transmit_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_TFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_TFTH_BIT);		\
+} while(0)
+
+#define __aic_set_receive_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_RFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_RFTH_BIT);		\
+} while(0)
+
+#define __aic_enable_record()	( REG_AIC_CR |= AIC_CR_EREC )
+#define __aic_disable_record()	( REG_AIC_CR &= ~AIC_CR_EREC )
+#define __aic_enable_replay()	( REG_AIC_CR |= AIC_CR_ERPL )
+#define __aic_disable_replay()	( REG_AIC_CR &= ~AIC_CR_ERPL )
+#define __aic_enable_loopback()	( REG_AIC_CR |= AIC_CR_ENLBF )
+#define __aic_disable_loopback() ( REG_AIC_CR &= ~AIC_CR_ENLBF )
+
+#define __aic_flush_fifo()	( REG_AIC_CR |= AIC_CR_FLUSH )
+#define __aic_unflush_fifo()	( REG_AIC_CR &= ~AIC_CR_FLUSH )
+
+#define __aic_enable_transmit_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_disable_transmit_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_enable_receive_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ERFS | AIC_CR_EROR) )
+#define __aic_disable_receive_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ERFS | AIC_CR_EROR) )
+
+#define __aic_enable_transmit_dma()  ( REG_AIC_CR |= AIC_CR_TDMS )
+#define __aic_disable_transmit_dma() ( REG_AIC_CR &= ~AIC_CR_TDMS )
+#define __aic_enable_receive_dma()   ( REG_AIC_CR |= AIC_CR_RDMS )
+#define __aic_disable_receive_dma()  ( REG_AIC_CR &= ~AIC_CR_RDMS )
+
+#define __aic_enable_mono2stereo()   ( REG_AIC_CR |= AIC_CR_M2S )
+#define __aic_disable_mono2stereo()  ( REG_AIC_CR &= ~AIC_CR_M2S )
+#define __aic_enable_byteswap()      ( REG_AIC_CR |= AIC_CR_ENDSW )
+#define __aic_disable_byteswap()     ( REG_AIC_CR &= ~AIC_CR_ENDSW )
+#define __aic_enable_unsignadj()     ( REG_AIC_CR |= AIC_CR_AVSTSU )
+#define __aic_disable_unsignadj()    ( REG_AIC_CR &= ~AIC_CR_AVSTSU )
+
+#define AC97_PCM_XS_L_FRONT   	AIC_ACCR1_XS_SLOT3
+#define AC97_PCM_XS_R_FRONT   	AIC_ACCR1_XS_SLOT4
+#define AC97_PCM_XS_CENTER    	AIC_ACCR1_XS_SLOT6
+#define AC97_PCM_XS_L_SURR    	AIC_ACCR1_XS_SLOT7
+#define AC97_PCM_XS_R_SURR    	AIC_ACCR1_XS_SLOT8
+#define AC97_PCM_XS_LFE       	AIC_ACCR1_XS_SLOT9
+
+#define AC97_PCM_RS_L_FRONT   	AIC_ACCR1_RS_SLOT3
+#define AC97_PCM_RS_R_FRONT   	AIC_ACCR1_RS_SLOT4
+#define AC97_PCM_RS_CENTER    	AIC_ACCR1_RS_SLOT6
+#define AC97_PCM_RS_L_SURR    	AIC_ACCR1_RS_SLOT7
+#define AC97_PCM_RS_R_SURR    	AIC_ACCR1_RS_SLOT8
+#define AC97_PCM_RS_LFE       	AIC_ACCR1_RS_SLOT9
+
+#define __ac97_set_xs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK )
+#define __ac97_set_xs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_R_FRONT;				\
+} while(0)
+#define __ac97_set_xs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_L_FRONT | AC97_PCM_XS_R_FRONT;	\
+} while(0)
+
+/* In fact, only stereo is support now. */ 
+#define __ac97_set_rs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK )
+#define __ac97_set_rs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_R_FRONT;				\
+} while(0)
+#define __ac97_set_rs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_L_FRONT | AC97_PCM_RS_R_FRONT;	\
+} while(0)
+
+#define __ac97_warm_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SS;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+
+#define __ac97_cold_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |=  AIC_ACCR2_SR;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SR;		\
+ } while (0)
+
+/* n=8,16,18,20 */
+#define __ac97_set_iass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_IASS_MASK) | AIC_ACCR2_IASS_##n##BIT )
+#define __ac97_set_oass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_OASS_MASK) | AIC_ACCR2_OASS_##n##BIT )
+
+#define __i2s_select_i2s()            ( REG_AIC_I2SCR &= ~AIC_I2SCR_AMSL )
+#define __i2s_select_msbjustified()   ( REG_AIC_I2SCR |= AIC_I2SCR_AMSL )
+
+/* n=8,16,18,20,24 */
+/*#define __i2s_set_sample_size(n) \
+ ( REG_AIC_I2SCR |= (REG_AIC_I2SCR & ~AIC_I2SCR_WL_MASK) | AIC_I2SCR_WL_##n##BIT )*/
+
+#define __i2s_set_oss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_OSS_MASK) | AIC_CR_OSS_##n##BIT )
+#define __i2s_set_iss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_ISS_MASK) | AIC_CR_ISS_##n##BIT )
+
+#define __i2s_stop_bitclk()   ( REG_AIC_I2SCR |= AIC_I2SCR_STPBK )
+#define __i2s_start_bitclk()  ( REG_AIC_I2SCR &= ~AIC_I2SCR_STPBK )
+
+#define __aic_transmit_request()  ( REG_AIC_SR & AIC_SR_TFS )
+#define __aic_receive_request()   ( REG_AIC_SR & AIC_SR_RFS )
+#define __aic_transmit_underrun() ( REG_AIC_SR & AIC_SR_TUR )
+#define __aic_receive_overrun()   ( REG_AIC_SR & AIC_SR_ROR )
+
+#define __aic_clear_errors()      ( REG_AIC_SR &= ~(AIC_SR_TUR | AIC_SR_ROR) )
+
+#define __aic_get_transmit_resident() \
+  ( (REG_AIC_SR & AIC_SR_TFL_MASK) >> AIC_SR_TFL_BIT )
+#define __aic_get_receive_count() \
+  ( (REG_AIC_SR & AIC_SR_RFL_MASK) >> AIC_SR_RFL_BIT )
+
+#define __ac97_command_transmitted()     ( REG_AIC_ACSR & AIC_ACSR_CADT )
+#define __ac97_status_received()         ( REG_AIC_ACSR & AIC_ACSR_SADR )
+#define __ac97_status_receive_timeout()  ( REG_AIC_ACSR & AIC_ACSR_RSTO )
+#define __ac97_codec_is_low_power_mode() ( REG_AIC_ACSR & AIC_ACSR_CLPM )
+#define __ac97_codec_is_ready()          ( REG_AIC_ACSR & AIC_ACSR_CRDY )
+#define __ac97_slot_error_detected()     ( REG_AIC_ACSR & AIC_ACSR_SLTERR )
+#define __ac97_clear_slot_error()        ( REG_AIC_ACSR &= ~AIC_ACSR_SLTERR )
+
+#define __i2s_is_busy()         ( REG_AIC_I2SSR & AIC_I2SSR_BSY )
+
+#define CODEC_READ_CMD	        (1 << 19)
+#define CODEC_WRITE_CMD	        (0 << 19)
+#define CODEC_REG_INDEX_BIT     12
+#define CODEC_REG_INDEX_MASK	(0x7f << CODEC_REG_INDEX_BIT)	/* 18:12 */
+#define CODEC_REG_DATA_BIT      4
+#define CODEC_REG_DATA_MASK	(0x0ffff << 4)	/* 19:4 */
+
+#define __ac97_out_rcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_READ_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_wcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_WRITE_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_data(value) 						\
+do { 									\
+    REG_AIC_ACCDR = ((value) << CODEC_REG_DATA_BIT); 			\
+} while (0)
+
+#define __ac97_in_data() \
+ ( (REG_AIC_ACSDR & CODEC_REG_DATA_MASK) >> CODEC_REG_DATA_BIT )
+
+#define __ac97_in_status_addr() \
+ ( (REG_AIC_ACSAR & CODEC_REG_INDEX_MASK) >> CODEC_REG_INDEX_BIT )
+
+#define __i2s_set_sample_rate(i2sclk, sync) \
+  ( REG_AIC_I2SDIV = ((i2sclk) / (4*64)) / (sync) )
+
+#define __aic_write_tfifo(v)  ( REG_AIC_DR = (v) )
+#define __aic_read_rfifo()    ( REG_AIC_DR )
+
+#define __aic_internal_codec()  ( REG_AIC_FR |= AIC_FR_ICDC ) 
+#define __aic_external_codec()  ( REG_AIC_FR &= ~AIC_FR_ICDC )
+
+//
+// Define next ops for AC97 compatible
+//
+
+#define AC97_ACSR	AIC_ACSR
+
+#define __ac97_enable()		__aic_enable(); __aic_select_ac97()
+#define __ac97_disable()	__aic_disable()
+#define __ac97_reset()		__aic_reset()
+
+#define __ac97_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __ac97_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __ac97_enable_record()		__aic_enable_record()
+#define __ac97_disable_record()		__aic_disable_record()
+#define __ac97_enable_replay()		__aic_enable_replay()
+#define __ac97_disable_replay()		__aic_disable_replay()
+#define __ac97_enable_loopback()	__aic_enable_loopback()
+#define __ac97_disable_loopback()	__aic_disable_loopback()
+
+#define __ac97_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __ac97_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __ac97_enable_receive_dma()	__aic_enable_receive_dma()
+#define __ac97_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __ac97_transmit_request()	__aic_transmit_request()
+#define __ac97_receive_request()	__aic_receive_request()
+#define __ac97_transmit_underrun()	__aic_transmit_underrun()
+#define __ac97_receive_overrun()	__aic_receive_overrun()
+
+#define __ac97_clear_errors()		__aic_clear_errors()
+
+#define __ac97_get_transmit_resident()	__aic_get_transmit_resident()
+#define __ac97_get_receive_count()	__aic_get_receive_count()
+
+#define __ac97_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __ac97_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __ac97_enable_receive_intr()	__aic_enable_receive_intr()
+#define __ac97_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __ac97_write_tfifo(v)		__aic_write_tfifo(v)
+#define __ac97_read_rfifo()		__aic_read_rfifo()
+
+//
+// Define next ops for I2S compatible
+//
+
+#define I2S_ACSR	AIC_I2SSR
+
+#define __i2s_enable()		 __aic_enable(); __aic_select_i2s()
+#define __i2s_disable()		__aic_disable()
+#define __i2s_reset()		__aic_reset()
+
+#define __i2s_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __i2s_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __i2s_enable_record()		__aic_enable_record()
+#define __i2s_disable_record()		__aic_disable_record()
+#define __i2s_enable_replay()		__aic_enable_replay()
+#define __i2s_disable_replay()		__aic_disable_replay()
+#define __i2s_enable_loopback()		__aic_enable_loopback()
+#define __i2s_disable_loopback()	__aic_disable_loopback()
+
+#define __i2s_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __i2s_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __i2s_enable_receive_dma()	__aic_enable_receive_dma()
+#define __i2s_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __i2s_transmit_request()	__aic_transmit_request()
+#define __i2s_receive_request()		__aic_receive_request()
+#define __i2s_transmit_underrun()	__aic_transmit_underrun()
+#define __i2s_receive_overrun()		__aic_receive_overrun()
+
+#define __i2s_clear_errors()		__aic_clear_errors()
+
+#define __i2s_get_transmit_resident()	__aic_get_transmit_resident()
+#define __i2s_get_receive_count()	__aic_get_receive_count()
+
+#define __i2s_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __i2s_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __i2s_enable_receive_intr()	__aic_enable_receive_intr()
+#define __i2s_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __i2s_write_tfifo(v)		__aic_write_tfifo(v)
+#define __i2s_read_rfifo()		__aic_read_rfifo()
+
+#define __i2s_reset_codec()			\
+ do {						\
+ } while (0)
+
+
+/***************************************************************************
+ * ICDC
+ ***************************************************************************/
+#define __i2s_internal_codec()         __aic_internal_codec()
+#define __i2s_external_codec()         __aic_external_codec()
+
+/***************************************************************************
+ * INTC
+ ***************************************************************************/
+#define __intc_unmask_irq(n)	( REG_INTC_IMCR = (1 << (n)) )
+#define __intc_mask_irq(n)	( REG_INTC_IMSR = (1 << (n)) )
+#define __intc_ack_irq(n)	( REG_INTC_IPR = (1 << (n)) )
+
+
+/***************************************************************************
+ * I2C
+ ***************************************************************************/
+
+#define __i2c_enable()		( REG_I2C_CR |= I2C_CR_I2CE )
+#define __i2c_disable()		( REG_I2C_CR &= ~I2C_CR_I2CE )
+
+#define __i2c_send_start()	( REG_I2C_CR |= I2C_CR_STA )
+#define __i2c_send_stop()	( REG_I2C_CR |= I2C_CR_STO )
+#define __i2c_send_ack()	( REG_I2C_CR &= ~I2C_CR_AC )
+#define __i2c_send_nack()	( REG_I2C_CR |= I2C_CR_AC )
+
+#define __i2c_set_drf()		( REG_I2C_SR |= I2C_SR_DRF )
+#define __i2c_clear_drf()	( REG_I2C_SR &= ~I2C_SR_DRF )
+#define __i2c_check_drf()	( REG_I2C_SR & I2C_SR_DRF )
+
+#define __i2c_received_ack()	( !(REG_I2C_SR & I2C_SR_ACKF) )
+#define __i2c_is_busy()		( REG_I2C_SR & I2C_SR_BUSY )
+#define __i2c_transmit_ended()	( REG_I2C_SR & I2C_SR_TEND )
+
+#define __i2c_set_clk(dev_clk, i2c_clk) \
+  ( REG_I2C_GR = (dev_clk) / (16*(i2c_clk)) - 1 )
+
+#define __i2c_read()		( REG_I2C_DR )
+#define __i2c_write(val)	( REG_I2C_DR = (val) )
+
+
+/***************************************************************************
+ * MSC
+ ***************************************************************************/
+
+#define __msc_start_op() \
+  ( REG_MSC_STRPCL = MSC_STRPCL_START_OP | MSC_STRPCL_CLOCK_CONTROL_START )
+
+#define __msc_set_resto(to) 	( REG_MSC_RESTO = to )
+#define __msc_set_rdto(to) 	( REG_MSC_RDTO = to )
+#define __msc_set_cmd(cmd) 	( REG_MSC_CMD = cmd )
+#define __msc_set_arg(arg) 	( REG_MSC_ARG = arg )
+#define __msc_set_nob(nob) 	( REG_MSC_NOB = nob )
+#define __msc_get_nob() 	( REG_MSC_NOB )
+#define __msc_set_blklen(len) 	( REG_MSC_BLKLEN = len )
+#define __msc_set_cmdat(cmdat) 	( REG_MSC_CMDAT = cmdat )
+#define __msc_set_cmdat_ioabort() 	( REG_MSC_CMDAT |= MSC_CMDAT_IO_ABORT )
+#define __msc_clear_cmdat_ioabort() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_IO_ABORT )
+
+#define __msc_set_cmdat_bus_width1() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_1BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_bus_width4() 			\
+do { 							\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT |= MSC_CMDAT_BUS_WIDTH_4BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_dma_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DMA_EN )
+#define __msc_set_cmdat_init() 	( REG_MSC_CMDAT |= MSC_CMDAT_INIT )
+#define __msc_set_cmdat_busy() 	( REG_MSC_CMDAT |= MSC_CMDAT_BUSY )
+#define __msc_set_cmdat_stream() ( REG_MSC_CMDAT |= MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_block() ( REG_MSC_CMDAT &= ~MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_read() 	( REG_MSC_CMDAT &= ~MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_write() ( REG_MSC_CMDAT |= MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_data_en() ( REG_MSC_CMDAT |= MSC_CMDAT_DATA_EN )
+
+/* r is MSC_CMDAT_RESPONSE_FORMAT_Rx or MSC_CMDAT_RESPONSE_FORMAT_NONE */
+#define __msc_set_cmdat_res_format(r) 				\
+do { 								\
+	REG_MSC_CMDAT &= ~MSC_CMDAT_RESPONSE_FORMAT_MASK; 	\
+	REG_MSC_CMDAT |= (r); 					\
+} while(0)
+
+#define __msc_clear_cmdat() \
+  REG_MSC_CMDAT &= ~( MSC_CMDAT_IO_ABORT | MSC_CMDAT_DMA_EN | MSC_CMDAT_INIT| \
+  MSC_CMDAT_BUSY | MSC_CMDAT_STREAM_BLOCK | MSC_CMDAT_WRITE_READ | \
+  MSC_CMDAT_DATA_EN | MSC_CMDAT_RESPONSE_FORMAT_MASK )
+
+#define __msc_get_imask() 		( REG_MSC_IMASK )
+#define __msc_mask_all_intrs() 		( REG_MSC_IMASK = 0xff )
+#define __msc_unmask_all_intrs() 	( REG_MSC_IMASK = 0x00 )
+#define __msc_mask_rd() 		( REG_MSC_IMASK |= MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_unmask_rd() 		( REG_MSC_IMASK &= ~MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_mask_wr() 		( REG_MSC_IMASK |= MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_unmask_wr() 		( REG_MSC_IMASK &= ~MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_mask_endcmdres() 		( REG_MSC_IMASK |= MSC_IMASK_END_CMD_RES )
+#define __msc_unmask_endcmdres() 	( REG_MSC_IMASK &= ~MSC_IMASK_END_CMD_RES )
+#define __msc_mask_datatrandone() 	( REG_MSC_IMASK |= MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_unmask_datatrandone() 	( REG_MSC_IMASK &= ~MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_mask_prgdone() 		( REG_MSC_IMASK |= MSC_IMASK_PRG_DONE )
+#define __msc_unmask_prgdone() 		( REG_MSC_IMASK &= ~MSC_IMASK_PRG_DONE )
+
+/* n=0,1,2,3,4,5,6,7 */
+#define __msc_set_clkrt(n) 	\
+do { 				\
+	REG_MSC_CLKRT = n;	\
+} while(0)
+
+#define __msc_get_ireg() 		( REG_MSC_IREG )
+#define __msc_ireg_rd() 		( REG_MSC_IREG & MSC_IREG_RXFIFO_RD_REQ )
+#define __msc_ireg_wr() 		( REG_MSC_IREG & MSC_IREG_TXFIFO_WR_REQ )
+#define __msc_ireg_end_cmd_res() 	( REG_MSC_IREG & MSC_IREG_END_CMD_RES )
+#define __msc_ireg_data_tran_done() 	( REG_MSC_IREG & MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_prg_done() 		( REG_MSC_IREG & MSC_IREG_PRG_DONE )
+#define __msc_ireg_clear_end_cmd_res() 	( REG_MSC_IREG = MSC_IREG_END_CMD_RES )
+#define __msc_ireg_clear_data_tran_done() ( REG_MSC_IREG = MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_clear_prg_done() 	( REG_MSC_IREG = MSC_IREG_PRG_DONE )
+
+#define __msc_get_stat() 		( REG_MSC_STAT )
+#define __msc_stat_not_end_cmd_res() 	( (REG_MSC_STAT & MSC_STAT_END_CMD_RES) == 0)
+#define __msc_stat_crc_err() \
+  ( REG_MSC_STAT & (MSC_STAT_CRC_RES_ERR | MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR_YES) )
+#define __msc_stat_res_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_RES_ERR )
+#define __msc_stat_rd_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_READ_ERROR )
+#define __msc_stat_wr_crc_err() 	( REG_MSC_STAT & MSC_STAT_CRC_WRITE_ERROR_YES )
+#define __msc_stat_resto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_RES )
+#define __msc_stat_rdto_err() 		( REG_MSC_STAT & MSC_STAT_TIME_OUT_READ )
+
+#define __msc_rd_resfifo() 		( REG_MSC_RES )
+#define __msc_rd_rxfifo()  		( REG_MSC_RXFIFO )
+#define __msc_wr_txfifo(v)  		( REG_MSC_TXFIFO = v )
+
+#define __msc_reset() 						\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_RESET;			\
+ 	while (REG_MSC_STAT & MSC_STAT_IS_RESETTING);		\
+} while (0)
+
+#define __msc_start_clk() 					\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_START;	\
+} while (0)
+
+#define __msc_stop_clk() 					\
+do { 								\
+	REG_MSC_STRPCL = MSC_STRPCL_CLOCK_CONTROL_STOP;	\
+} while (0)
+
+#define MMC_CLK 19169200
+#define SD_CLK  24576000
+
+/* msc_clk should little than pclk and little than clk retrieve from card */
+#define __msc_calc_clk_divisor(type,dev_clk,msc_clk,lv)		\
+do {								\
+	unsigned int rate, pclk, i;				\
+	pclk = dev_clk;						\
+	rate = type?SD_CLK:MMC_CLK;				\
+  	if (msc_clk && msc_clk < pclk)				\
+    		pclk = msc_clk;					\
+	i = 0;							\
+  	while (pclk < rate)					\
+    	{							\
+      		i ++;						\
+      		rate >>= 1;					\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+/* divide rate to little than or equal to 400kHz */
+#define __msc_calc_slow_clk_divisor(type, lv)			\
+do {								\
+	unsigned int rate, i;					\
+	rate = (type?SD_CLK:MMC_CLK)/1000/400;			\
+	i = 0;							\
+	while (rate > 0)					\
+    	{							\
+      		rate >>= 1;					\
+      		i ++;						\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+
+/***************************************************************************
+ * SSI
+ ***************************************************************************/
+
+#define __ssi_enable()    ( REG_SSI_CR0 |= SSI_CR0_SSIE )
+#define __ssi_disable()   ( REG_SSI_CR0 &= ~SSI_CR0_SSIE )
+#define __ssi_select_ce() ( REG_SSI_CR0 &= ~SSI_CR0_FSEL )
+
+#define __ssi_normal_mode() ( REG_SSI_ITR &= ~SSI_ITR_IVLTM_MASK )
+
+#define __ssi_select_ce2() 		\
+do { 					\
+	REG_SSI_CR0 |= SSI_CR0_FSEL; 	\
+	REG_SSI_CR1 &= ~SSI_CR1_MULTS; 	\
+} while (0)
+
+#define __ssi_select_gpc() 		\
+do { 					\
+	REG_SSI_CR0 &= ~SSI_CR0_FSEL; 	\
+	REG_SSI_CR1 |= SSI_CR1_MULTS; 	\
+} while (0)
+
+#define __ssi_enable_tx_intr() 	\
+  ( REG_SSI_CR0 |= SSI_CR0_TIE | SSI_CR0_TEIE )
+
+#define __ssi_disable_tx_intr() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_TIE | SSI_CR0_TEIE) )
+
+#define __ssi_enable_rx_intr() 	\
+  ( REG_SSI_CR0 |= SSI_CR0_RIE | SSI_CR0_REIE )
+
+#define __ssi_disable_rx_intr() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_RIE | SSI_CR0_REIE) )
+
+#define __ssi_enable_txfifo_half_empty_intr()  \
+	( REG_SSI_CR0 |= SSI_CR0_TIE )
+#define __ssi_disable_txfifo_half_empty_intr()  \
+	( REG_SSI_CR0 &= ~SSI_CR0_TIE )
+#define __ssi_enable_tx_error_intr()  \
+	( REG_SSI_CR0 |= SSI_CR0_TEIE )
+#define __ssi_disable_tx_error_intr()  \
+	( REG_SSI_CR0 &= ~SSI_CR0_TEIE )
+
+#define __ssi_enable_rxfifo_half_full_intr()  \
+	( REG_SSI_CR0 |= SSI_CR0_RIE )
+#define __ssi_disable_rxfifo_half_full_intr()  \
+	( REG_SSI_CR0 &= ~SSI_CR0_RIE )
+#define __ssi_enable_rx_error_intr()  \
+	( REG_SSI_CR0 |= SSI_CR0_REIE )
+#define __ssi_disable_rx_error_intr()  \
+	( REG_SSI_CR0 &= ~SSI_CR0_REIE )
+
+#define __ssi_enable_loopback()  ( REG_SSI_CR0 |= SSI_CR0_LOOP )
+#define __ssi_disable_loopback() ( REG_SSI_CR0 &= ~SSI_CR0_LOOP )
+
+#define __ssi_enable_receive()   ( REG_SSI_CR0 &= ~SSI_CR0_DISREV )
+#define __ssi_disable_receive()  ( REG_SSI_CR0 |= SSI_CR0_DISREV )
+
+#define __ssi_finish_receive() 	\
+  ( REG_SSI_CR0 |= (SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_disable_recvfinish() \
+  ( REG_SSI_CR0 &= ~(SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_flush_txfifo()   ( REG_SSI_CR0 |= SSI_CR0_TFLUSH )
+#define __ssi_flush_rxfifo()   ( REG_SSI_CR0 |= SSI_CR0_RFLUSH )
+
+#define __ssi_flush_fifo() \
+  ( REG_SSI_CR0 |= SSI_CR0_TFLUSH | SSI_CR0_RFLUSH )
+
+#define __ssi_finish_transmit() ( REG_SSI_CR1 &= ~SSI_CR1_UNFIN )
+#define __ssi_wait_transmit() ( REG_SSI_CR1 |= SSI_CR1_UNFIN )
+
+#define __ssi_spi_format() 					\
+do { 								\
+	REG_SSI_CR1 &= ~SSI_CR1_FMAT_MASK; 			\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_SPI; 			\
+	REG_SSI_CR1 &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK);\
+	REG_SSI_CR1 |= (SSI_CR1_TFVCK_1 | SSI_CR1_TCKFI_1);	\
+} while (0)
+
+/* TI's SSP format, must clear SSI_CR1.UNFIN */
+#define __ssi_ssp_format() 					\
+do { 								\
+	REG_SSI_CR1 &= ~(SSI_CR1_FMAT_MASK | SSI_CR1_UNFIN); 	\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_SSP; 			\
+} while (0)
+
+/* National's Microwire format, must clear SSI_CR0.RFINE, and set max delay */
+#define __ssi_microwire_format() 				\
+do { 								\
+	REG_SSI_CR1 &= ~SSI_CR1_FMAT_MASK; 			\
+	REG_SSI_CR1 |= SSI_CR1_FMAT_MW1; 			\
+	REG_SSI_CR1 &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK);\
+	REG_SSI_CR1 |= (SSI_CR1_TFVCK_3 | SSI_CR1_TCKFI_3);	\
+	REG_SSI_CR0 &= ~SSI_CR0_RFINE; 				\
+} while (0)
+
+/* CE# level (FRMHL), CE# in interval time (ITFRM),
+   clock phase and polarity (PHA POL),
+   interval time (SSIITR), interval characters/frame (SSIICR) */
+
+ /* frmhl,endian,mcom,flen,pha,pol MASK */
+#define SSICR1_MISC_MASK 					\
+	( SSI_CR1_FRMHL_MASK | SSI_CR1_LFST | SSI_CR1_MCOM_MASK	\
+	| SSI_CR1_FLEN_MASK | SSI_CR1_PHA | SSI_CR1_POL )	\
+
+#define __ssi_spi_set_misc(frmhl,endian,flen,mcom,pha,pol)	\
+do { 								\
+	REG_SSI_CR1 &= ~SSICR1_MISC_MASK; 			\
+	REG_SSI_CR1 |= ((frmhl) << 30) | ((endian) << 25) | 	\
+		 (((mcom) - 1) << 12) | (((flen) - 2) << 4) | 	\
+	         ((pha) << 1) | (pol); 				\
+} while(0)
+
+/* Transfer with MSB or LSB first */
+#define __ssi_set_msb() ( REG_SSI_CR1 &= ~SSI_CR1_LFST )
+#define __ssi_set_lsb() ( REG_SSI_CR1 |= SSI_CR1_LFST )
+
+#define __ssi_set_frame_length(n) \
+    REG_SSI_CR1 = (REG_SSI_CR1 & ~SSI_CR1_FLEN_MASK) | (((n) - 2) << 4) 
+
+/* n = 1 - 16 */
+#define __ssi_set_microwire_command_length(n) \
+	( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_MCOM_MASK) | SSI_CR1_MCOM_##n##BIT) )
+
+/* Set the clock phase for SPI */
+#define __ssi_set_spi_clock_phase(n) \
+	( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_PHA) | ((n&0x1)<< 1)))
+
+/* Set the clock polarity for SPI */
+#define __ssi_set_spi_clock_polarity(n) \
+    ( REG_SSI_CR1 = ((REG_SSI_CR1 & ~SSI_CR1_POL) | (n&0x1)) )
+
+/* n = ix8 */
+#define __ssi_set_tx_trigger(n) 		\
+do { 						\
+	REG_SSI_CR1 &= ~SSI_CR1_TTRG_MASK; 	\
+	REG_SSI_CR1 |= (n/8)<<SSI_CR1_TTRG_BIT; \
+} while (0)
+
+/* n = ix8 */
+#define __ssi_set_rx_trigger(n) 		\
+do { 						\
+	REG_SSI_CR1 &= ~SSI_CR1_RTRG_MASK; 	\
+	REG_SSI_CR1 |= (n/8)<<SSI_CR1_RTRG_BIT; \
+} while (0)
+
+#define __ssi_get_txfifo_count() \
+    ( (REG_SSI_SR & SSI_SR_TFIFONUM_MASK) >> SSI_SR_TFIFONUM_BIT )
+
+#define __ssi_get_rxfifo_count() \
+    ( (REG_SSI_SR & SSI_SR_RFIFONUM_MASK) >> SSI_SR_RFIFONUM_BIT )
+
+#define __ssi_transfer_end()	( REG_SSI_SR & SSI_SR_END )
+#define __ssi_is_busy()		( REG_SSI_SR & SSI_SR_BUSY )
+
+#define __ssi_txfifo_full()	( REG_SSI_SR & SSI_SR_TFF )
+#define __ssi_rxfifo_empty()	( REG_SSI_SR & SSI_SR_RFE )
+#define __ssi_rxfifo_half_full()	( REG_SSI_SR & SSI_SR_RFHF )
+#define __ssi_txfifo_half_empty()	( REG_SSI_SR & SSI_SR_TFHE )
+#define __ssi_underrun()		( REG_SSI_SR & SSI_SR_UNDR )
+#define __ssi_overrun()			( REG_SSI_SR & SSI_SR_OVER )
+#define __ssi_clear_underrun()		( REG_SSI_SR = ~SSI_SR_UNDR )
+#define __ssi_clear_overrun()		( REG_SSI_SR = ~SSI_SR_OVER )
+#define __ssi_clear_errors() \
+    ( REG_SSI_SR &= ~(SSI_SR_UNDR | SSI_SR_OVER) )
+
+
+#define __ssi_set_clk(dev_clk, ssi_clk) \
+  ( REG_SSI_GR = (dev_clk) / (2*(ssi_clk)) - 1 )
+
+#define __ssi_receive_data()    REG_SSI_DR
+#define __ssi_transmit_data(v)  ( REG_SSI_DR = (v) )
+
+
+/***************************************************************************
+ * CIM
+ ***************************************************************************/
+
+#define __cim_enable()	( REG_CIM_CTRL |= CIM_CTRL_ENA )
+#define __cim_disable()	( REG_CIM_CTRL &= ~CIM_CTRL_ENA )
+
+#define __cim_input_data_inverse()	( REG_CIM_CFG |= CIM_CFG_INV_DAT )
+#define __cim_input_data_normal()	( REG_CIM_CFG &= ~CIM_CFG_INV_DAT )
+
+#define __cim_vsync_active_low()	( REG_CIM_CFG |= CIM_CFG_VSP )
+#define __cim_vsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_VSP )
+
+#define __cim_hsync_active_low()	( REG_CIM_CFG |= CIM_CFG_HSP )
+#define __cim_hsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_HSP )
+
+#define __cim_sample_data_at_pclk_falling_edge() \
+  ( REG_CIM_CFG |= CIM_CFG_PCP )
+#define __cim_sample_data_at_pclk_rising_edge() \
+  ( REG_CIM_CFG &= ~CIM_CFG_PCP )
+
+#define __cim_enable_dummy_zero()	( REG_CIM_CFG |= CIM_CFG_DUMMY_ZERO )
+#define __cim_disable_dummy_zero()	( REG_CIM_CFG &= ~CIM_CFG_DUMMY_ZERO )
+
+#define __cim_select_external_vsync()	( REG_CIM_CFG |= CIM_CFG_EXT_VSYNC )
+#define __cim_select_internal_vsync()	( REG_CIM_CFG &= ~CIM_CFG_EXT_VSYNC )
+
+/* n=0-7 */
+#define __cim_set_data_packing_mode(n) 		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_PACK_MASK; 		\
+    REG_CIM_CFG |= (CIM_CFG_PACK_##n); 		\
+} while (0)
+
+#define __cim_enable_ccir656_progressive_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CPM; 		\
+} while (0)
+
+#define __cim_enable_ccir656_interlace_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_CIM; 		\
+} while (0)
+
+#define __cim_enable_gated_clock_mode()		\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_GCM; 		\
+} while (0)
+
+#define __cim_enable_nongated_clock_mode()	\
+do {						\
+    REG_CIM_CFG &= ~CIM_CFG_DSM_MASK; 		\
+    REG_CIM_CFG |= CIM_CFG_DSM_NGCM; 		\
+} while (0)
+
+/* sclk:system bus clock
+ * mclk: CIM master clock
+ */
+#define __cim_set_master_clk(sclk, mclk)			\
+do {								\
+    REG_CIM_CTRL &= ~CIM_CTRL_MCLKDIV_MASK;			\
+    REG_CIM_CTRL |= (((sclk)/(mclk) - 1) << CIM_CTRL_MCLKDIV_BIT);	\
+} while (0)
+
+#define __cim_enable_sof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_SOFM )
+#define __cim_disable_sof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_SOFM )
+
+#define __cim_enable_eof_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_EOFM )
+#define __cim_disable_eof_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EOFM )
+
+#define __cim_enable_stop_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_DMA_STOPM )
+#define __cim_disable_stop_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_STOPM )
+
+#define __cim_enable_trig_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_TRIGM )
+#define __cim_disable_trig_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIGM )
+
+#define __cim_enable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL |= CIM_CTRL_RXF_OFM )
+#define __cim_disable_rxfifo_overflow_intr() \
+  ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_OFM )
+
+/* n=1-16 */
+#define __cim_set_frame_rate(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_FRC_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_FRC_##n; 		\
+} while (0)
+
+#define __cim_enable_dma()   ( REG_CIM_CTRL |= CIM_CTRL_DMA_EN )
+#define __cim_disable_dma()  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EN )
+
+#define __cim_reset_rxfifo() ( REG_CIM_CTRL |= CIM_CTRL_RXF_RST )
+#define __cim_unreset_rxfifo() ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_RST )
+
+/* n=4,8,12,16,20,24,28,32 */
+#define __cim_set_rxfifo_trigger(n) 		\
+do {						\
+    REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIG_MASK; 	\
+    REG_CIM_CTRL |= CIM_CTRL_RXF_TRIG_##n; 	\
+} while (0)
+
+#define __cim_clear_state()   	     ( REG_CIM_STATE = 0 )
+
+#define __cim_disable_done()   	     ( REG_CIM_STATE & CIM_STATE_VDD )
+#define __cim_rxfifo_empty()   	     ( REG_CIM_STATE & CIM_STATE_RXF_EMPTY )
+#define __cim_rxfifo_reach_trigger() ( REG_CIM_STATE & CIM_STATE_RXF_TRIG )
+#define __cim_rxfifo_overflow()      ( REG_CIM_STATE & CIM_STATE_RXF_OF )
+#define __cim_clear_rxfifo_overflow() ( REG_CIM_STATE &= ~CIM_STATE_RXF_OF )
+#define __cim_dma_stop()   	     ( REG_CIM_STATE & CIM_STATE_DMA_STOP )
+#define __cim_dma_eof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_EOF )
+#define __cim_dma_sof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_SOF )
+
+#define __cim_get_iid()   	     ( REG_CIM_IID )
+#define __cim_get_image_data()       ( REG_CIM_RXFIFO )
+#define __cim_get_dam_cmd()          ( REG_CIM_CMD )
+
+#define __cim_set_da(a)              ( REG_CIM_DA = (a) )
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+#define __lcd_as_smart_lcd() 		( REG_LCD_CFG |= (1<<LCD_CFG_LCDPIN_BIT) )
+#define __lcd_as_general_lcd() 		( REG_LCD_CFG &= ~(1<<LCD_CFG_LCDPIN_BIT) )
+
+#define __lcd_set_dis()			( REG_LCD_CTRL |= LCD_CTRL_DIS )
+#define __lcd_clr_dis()			( REG_LCD_CTRL &= ~LCD_CTRL_DIS )
+
+#define __lcd_set_ena()			( REG_LCD_CTRL |= LCD_CTRL_ENA )
+#define __lcd_clr_ena()			( REG_LCD_CTRL &= ~LCD_CTRL_ENA )
+
+/* n=1,2,4,8,16 */
+#define __lcd_set_bpp(n) \
+  ( REG_LCD_CTRL = (REG_LCD_CTRL & ~LCD_CTRL_BPP_MASK) | LCD_CTRL_BPP_##n )
+
+/* n=4,8,16 */
+#define __lcd_set_burst_length(n) 		\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_BST_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_BST_n##;	\
+} while (0)
+
+#define __lcd_select_rgb565()		( REG_LCD_CTRL &= ~LCD_CTRL_RGB555 )
+#define __lcd_select_rgb555()		( REG_LCD_CTRL |= LCD_CTRL_RGB555 )
+
+#define __lcd_set_ofup()		( REG_LCD_CTRL |= LCD_CTRL_OFUP )
+#define __lcd_clr_ofup()		( REG_LCD_CTRL &= ~LCD_CTRL_OFUP )
+
+/* n=2,4,16 */
+#define __lcd_set_stn_frc(n) 			\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_FRC_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_FRC_n##;	\
+} while (0)
+
+
+#define __lcd_pixel_endian_little()	( REG_LCD_CTRL |= LCD_CTRL_PEDN )
+#define __lcd_pixel_endian_big()	( REG_LCD_CTRL &= ~LCD_CTRL_PEDN )
+
+#define __lcd_reverse_byte_endian()	( REG_LCD_CTRL |= LCD_CTRL_BEDN )
+#define __lcd_normal_byte_endian()	( REG_LCD_CTRL &= ~LCD_CTRL_BEDN )
+
+#define __lcd_enable_eof_intr()		( REG_LCD_CTRL |= LCD_CTRL_EOFM )
+#define __lcd_disable_eof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_EOFM )
+
+#define __lcd_enable_sof_intr()		( REG_LCD_CTRL |= LCD_CTRL_SOFM )
+#define __lcd_disable_sof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_SOFM )
+
+#define __lcd_enable_ofu_intr()		( REG_LCD_CTRL |= LCD_CTRL_OFUM )
+#define __lcd_disable_ofu_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_OFUM )
+
+#define __lcd_enable_ifu0_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM0 )
+#define __lcd_disable_ifu0_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM0 )
+
+#define __lcd_enable_ifu1_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM1 )
+#define __lcd_disable_ifu1_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM1 )
+
+#define __lcd_enable_ldd_intr()		( REG_LCD_CTRL |= LCD_CTRL_LDDM )
+#define __lcd_disable_ldd_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_LDDM )
+
+#define __lcd_enable_qd_intr()		( REG_LCD_CTRL |= LCD_CTRL_QDM )
+#define __lcd_disable_qd_intr()		( REG_LCD_CTRL &= ~LCD_CTRL_QDM )
+
+
+/* LCD status register indication */
+
+#define __lcd_quick_disable_done()	( REG_LCD_STATE & LCD_STATE_QD )
+#define __lcd_disable_done()		( REG_LCD_STATE & LCD_STATE_LDD )
+#define __lcd_infifo0_underrun()	( REG_LCD_STATE & LCD_STATE_IFU0 )
+#define __lcd_infifo1_underrun()	( REG_LCD_STATE & LCD_STATE_IFU1 )
+#define __lcd_outfifo_underrun()	( REG_LCD_STATE & LCD_STATE_OFU )
+#define __lcd_start_of_frame()		( REG_LCD_STATE & LCD_STATE_SOF )
+#define __lcd_end_of_frame()		( REG_LCD_STATE & LCD_STATE_EOF )
+
+#define __lcd_clr_outfifounderrun()	( REG_LCD_STATE &= ~LCD_STATE_OFU )
+#define __lcd_clr_sof()			( REG_LCD_STATE &= ~LCD_STATE_SOF )
+#define __lcd_clr_eof()			( REG_LCD_STATE &= ~LCD_STATE_EOF )
+
+#define __lcd_panel_white()		( REG_LCD_CFG |= LCD_CFG_WHITE )
+#define __lcd_panel_black()		( REG_LCD_CFG &= ~LCD_CFG_WHITE )
+
+/* n=1,2,4,8 for single mono-STN 
+ * n=4,8 for dual mono-STN
+ */
+#define __lcd_set_panel_datawidth(n) 		\
+do { 						\
+	REG_LCD_CFG &= ~LCD_CFG_PDW_MASK; 	\
+	REG_LCD_CFG |= LCD_CFG_PDW_n##;		\
+} while (0)
+
+/* m=LCD_CFG_MODE_GENERUIC_TFT_xxx */
+#define __lcd_set_panel_mode(m) 		\
+do {						\
+	REG_LCD_CFG &= ~LCD_CFG_MODE_MASK;	\
+	REG_LCD_CFG |= (m);			\
+} while(0)
+
+/* n = 0-255 */
+#define __lcd_disable_ac_bias()		( REG_LCD_IO = 0xff )
+#define __lcd_set_ac_bias(n) 			\
+do {						\
+	REG_LCD_IO &= ~LCD_IO_ACB_MASK;		\
+	REG_LCD_IO |= ((n) << LCD_IO_ACB_BIT);	\
+} while(0)
+
+#define __lcd_io_set_dir()		( REG_LCD_IO |= LCD_IO_DIR )
+#define __lcd_io_clr_dir()		( REG_LCD_IO &= ~LCD_IO_DIR )
+
+#define __lcd_io_set_dep()		( REG_LCD_IO |= LCD_IO_DEP )
+#define __lcd_io_clr_dep()		( REG_LCD_IO &= ~LCD_IO_DEP )
+
+#define __lcd_io_set_vsp()		( REG_LCD_IO |= LCD_IO_VSP )
+#define __lcd_io_clr_vsp()		( REG_LCD_IO &= ~LCD_IO_VSP )
+
+#define __lcd_io_set_hsp()		( REG_LCD_IO |= LCD_IO_HSP )
+#define __lcd_io_clr_hsp()		( REG_LCD_IO &= ~LCD_IO_HSP )
+
+#define __lcd_io_set_pcp()		( REG_LCD_IO |= LCD_IO_PCP )
+#define __lcd_io_clr_pcp()		( REG_LCD_IO &= ~LCD_IO_PCP )
+
+#define __lcd_vsync_get_vps() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPS_MASK) >> LCD_VSYNC_VPS_BIT )
+
+#define __lcd_vsync_get_vpe() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPE_MASK) >> LCD_VSYNC_VPE_BIT )
+#define __lcd_vsync_set_vpe(n) 				\
+do {							\
+	REG_LCD_VSYNC &= ~LCD_VSYNC_VPE_MASK;		\
+	REG_LCD_VSYNC |= (n) << LCD_VSYNC_VPE_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hps() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPS_MASK) >> LCD_HSYNC_HPS_BIT )
+#define __lcd_hsync_set_hps(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPS_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPS_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hpe() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPE_MASK) >> LCD_VSYNC_HPE_BIT )
+#define __lcd_hsync_set_hpe(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPE_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPE_BIT;	\
+} while (0)
+
+#define __lcd_vat_get_ht() \
+  ( (REG_LCD_VAT & LCD_VAT_HT_MASK) >> LCD_VAT_HT_BIT )
+#define __lcd_vat_set_ht(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_HT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_HT_BIT;		\
+} while (0)
+
+#define __lcd_vat_get_vt() \
+  ( (REG_LCD_VAT & LCD_VAT_VT_MASK) >> LCD_VAT_VT_BIT )
+#define __lcd_vat_set_vt(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_VT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_VT_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hds() \
+  ( (REG_LCD_DAH & LCD_DAH_HDS_MASK) >> LCD_DAH_HDS_BIT )
+#define __lcd_dah_set_hds(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDS_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDS_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hde() \
+  ( (REG_LCD_DAH & LCD_DAH_HDE_MASK) >> LCD_DAH_HDE_BIT )
+#define __lcd_dah_set_hde(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDE_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDE_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vds() \
+  ( (REG_LCD_DAV & LCD_DAV_VDS_MASK) >> LCD_DAV_VDS_BIT )
+#define __lcd_dav_set_vds(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDS_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDS_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vde() \
+  ( (REG_LCD_DAV & LCD_DAV_VDE_MASK) >> LCD_DAV_VDE_BIT )
+#define __lcd_dav_set_vde(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDE_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDE_BIT;		\
+} while (0)
+
+#define __lcd_cmd0_set_sofint()		( REG_LCD_CMD0 |= LCD_CMD_SOFINT )
+#define __lcd_cmd0_clr_sofint()		( REG_LCD_CMD0 &= ~LCD_CMD_SOFINT )
+#define __lcd_cmd1_set_sofint()		( REG_LCD_CMD1 |= LCD_CMD_SOFINT )
+#define __lcd_cmd1_clr_sofint()		( REG_LCD_CMD1 &= ~LCD_CMD_SOFINT )
+
+#define __lcd_cmd0_set_eofint()		( REG_LCD_CMD0 |= LCD_CMD_EOFINT )
+#define __lcd_cmd0_clr_eofint()		( REG_LCD_CMD0 &= ~LCD_CMD_EOFINT )
+#define __lcd_cmd1_set_eofint()		( REG_LCD_CMD1 |= LCD_CMD_EOFINT )
+#define __lcd_cmd1_clr_eofint()		( REG_LCD_CMD1 &= ~LCD_CMD_EOFINT )
+
+#define __lcd_cmd0_set_pal()		( REG_LCD_CMD0 |= LCD_CMD_PAL )
+#define __lcd_cmd0_clr_pal()		( REG_LCD_CMD0 &= ~LCD_CMD_PAL )
+
+#define __lcd_cmd0_get_len() \
+  ( (REG_LCD_CMD0 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+#define __lcd_cmd1_get_len() \
+  ( (REG_LCD_CMD1 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+
+/*******************************************************
+ * SMART LCD
+ *******************************************************/
+
+#define __slcd_dma_enable() (REG_SLCD_CTRL |= SLCD_CTRL_DMA_EN)
+#define __slcd_dma_disable() \
+do {\
+	while (REG_SLCD_STATE & SLCD_STATE_BUSY); 	\
+	REG_SLCD_CTRL &= ~SLCD_CTRL_DMA_EN;		\
+} while(0)
+
+/*******************************************************
+ * SMART LCD
+ *******************************************************/
+
+#define __slcd_dma_enable() (REG_SLCD_CTRL |= SLCD_CTRL_DMA_EN)
+#define __slcd_dma_disable() \
+do {\
+	while (REG_SLCD_STATE & SLCD_STATE_BUSY); 	\
+	REG_SLCD_CTRL &= ~SLCD_CTRL_DMA_EN;		\
+} while(0)
+
+/***************************************************************************
+ * RTC ops
+ ***************************************************************************/
+
+#define __rtc_write_ready()  ( (REG_RTC_RCR & RTC_RCR_WRDY) >> RTC_RCR_WRDY_BIT )
+#define __rtc_enabled()        ( REG_RTC_RCR |= RTC_RCR_RTCE )
+#define __rtc_disabled()         ( REG_RTC_RCR &= ~RTC_RCR_RTCE )
+#define __rtc_enable_alarm()         ( REG_RTC_RCR |= RTC_RCR_AE )
+#define __rtc_disable_alarm()         ( REG_RTC_RCR &= ~RTC_RCR_AE )
+#define __rtc_enable_alarm_irq()         ( REG_RTC_RCR |= RTC_RCR_AIE )
+#define __rtc_disable_alarm_irq()         ( REG_RTC_RCR &= ~RTC_RCR_AIE )
+#define __rtc_enable_1Hz_irq()         ( REG_RTC_RCR |= RTC_RCR_1HZIE )
+#define __rtc_disable_1Hz_irq()         ( REG_RTC_RCR &= ~RTC_RCR_1HZIE )
+
+#define __rtc_get_1Hz_flag()           ( (REG_RTC_RCR >> RTC_RCR_1HZ_BIT) & 0x1 )
+#define __rtc_clear_1Hz_flag()           ( REG_RTC_RCR &= ~RTC_RCR_1HZ )
+#define __rtc_get_alarm_flag()           ( (REG_RTC_RCR >> RTC_RCR_AF_BIT) & 0x1 )
+#define __rtc_clear_alarm_flag()           ( REG_RTC_RCR &= ~RTC_RCR_AF )
+
+#define __rtc_get_second()   ( REG_RTC_RSR )
+#define __rtc_set_second(v)   ( REG_RTC_RSR = v )
+
+#define __rtc_get_alarm_second()   ( REG_RTC_RSAR )
+#define __rtc_set_alarm_second(v)   ( REG_RTC_RSAR = v )
+
+#define __rtc_RGR_is_locked()       ( (REG_RTC_RGR >> RTC_RGR_LOCK) )
+#define __rtc_lock_RGR()       ( REG_RTC_RGR |= RTC_RGR_LOCK )
+#define __rtc_unlock_RGR()       ( REG_RTC_RGR &= ~RTC_RGR_LOCK )
+#define __rtc_get_adjc_val()       ( (REG_RTC_RGR & RTC_RGR_ADJC_MASK) >> RTC_RGR_ADJC_BIT )
+#define __rtc_set_adjc_val(v)      \
+       ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_ADJC_MASK) | (v << RTC_RGR_ADJC_BIT) ))
+#define __rtc_get_nc1Hz_val()       ( (REG_RTC_RGR & RTC_RGR_NC1HZ_MASK) >> RTC_RGR_NC1HZ_BIT )
+#define __rtc_set_nc1Hz_val(v)      \
+       ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_NC1HZ_MASK) | (v << RTC_RGR_NC1HZ_BIT) ))
+
+#define __rtc_power_down()            ( REG_RTC_HCR |= RTC_HCR_PD )
+
+#define __rtc_get_hwfcr_val()         ( REG_RTC_HWFCR & RTC_HWFCR_MASK )
+#define __rtc_set_hwfcr_val(v)         ( REG_RTC_HWFCR = (v) & RTC_HWFCR_MASK )
+#define __rtc_get_hrcr_val()         ( REG_RTC_HRCR & RTC_HRCR_MASK )
+#define __rtc_set_hrcr_val(v)         ( REG_RTC_HRCR = (v) & RTC_HRCR_MASK )
+
+#define __rtc_enable_alarm_wakeup()        ( REG_RTC_HWCR |= RTC_HWCR_EALM )
+#define __rtc_disable_alarm_wakeup()        ( REG_RTC_HWCR &= ~RTC_HWCR_EALM )
+
+#define __rtc_status_hib_reset_occur()        ( (REG_RTC_HWRSR >> RTC_HWRSR_HR) & 0x1 )
+#define __rtc_status_ppr_reset_occur()        ( (REG_RTC_HWRSR >> RTC_HWRSR_PPR) & 0x1 )
+#define __rtc_status_wakeup_pin_waken_up()    ( (REG_RTC_HWRSR >> RTC_HWRSR_PIN) & 0x1 )
+#define __rtc_status_alarm_waken_up()        ( (REG_RTC_HWRSR >> RTC_HWRSR_ALM) & 0x1 )
+#define __rtc_clear_hib_stat_all()               ( REG_RTC_HWRSR = 0 )
+
+#define __rtc_get_scratch_pattern() 		(REG_RTC_HSPR)
+#define __rtc_set_scratch_pattern(n) 		(REG_RTC_HSPR = n )
+
+
+
+#endif /* __JZ4740_OPS_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/regs.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,2392 @@
+/*
+ *  linux/include/asm-mips/mach-jz4740/regs.h
+ *
+ *  Ingenic's JZ4740 common include.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <yliu@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __JZ4740_REGS_H__
+#define __JZ4740_REGS_H__
+
+#if defined(__ASSEMBLY__) || defined(__LANGUAGE_ASSEMBLY)
+#define REG8(addr)	(addr)
+#define REG16(addr)	(addr)
+#define REG32(addr)	(addr)
+#else
+#define REG8(addr)	*((volatile unsigned char *)(addr))
+#define REG16(addr)	*((volatile unsigned short *)(addr))
+#define REG32(addr)	*((volatile unsigned int *)(addr))
+#endif
+
+/*
+ * Define the module base addresses
+ */
+#define	CPM_BASE	0xB0000000
+#define	INTC_BASE	0xB0001000
+#define	TCU_BASE	0xB0002000
+#define	WDT_BASE	0xB0002000
+#define	RTC_BASE	0xB0003000
+#define	GPIO_BASE	0xB0010000
+#define	AIC_BASE	0xB0020000
+#define	ICDC_BASE	0xB0020000
+#define	MSC_BASE	0xB0021000
+#define	UART0_BASE	0xB0030000
+#define	UART1_BASE	0xB0031000
+#define	I2C_BASE	0xB0042000
+#define	SSI_BASE	0xB0043000
+#define	SADC_BASE	0xB0070000
+#define	EMC_BASE	0xB3010000
+#define	DMAC_BASE	0xB3020000
+#define	UHC_BASE	0xB3030000
+#define	UDC_BASE	0xB3040000
+#define	LCD_BASE	0xB3050000
+#define	SLCD_BASE	0xB3050000
+#define	CIM_BASE	0xB3060000
+#define IPU_BASE	0xB3080000
+#define	ETH_BASE	0xB3100000
+
+
+/*************************************************************************
+ * INTC (Interrupt Controller)
+ *************************************************************************/
+#define INTC_ISR	(INTC_BASE + 0x00)
+#define INTC_IMR	(INTC_BASE + 0x04)
+#define INTC_IMSR	(INTC_BASE + 0x08)
+#define INTC_IMCR	(INTC_BASE + 0x0c)
+#define INTC_IPR	(INTC_BASE + 0x10)
+
+#define REG_INTC_ISR	REG32(INTC_ISR)
+#define REG_INTC_IMR	REG32(INTC_IMR)
+#define REG_INTC_IMSR	REG32(INTC_IMSR)
+#define REG_INTC_IMCR	REG32(INTC_IMCR)
+#define REG_INTC_IPR	REG32(INTC_IPR)
+
+// 1st-level interrupts
+#define IRQ_I2C		1
+#define IRQ_UHC		3
+#define IRQ_UART1	8
+#define IRQ_UART0	9
+#define IRQ_SADC	12
+#define IRQ_MSC		14
+#define IRQ_RTC		15
+#define IRQ_SSI		16
+#define IRQ_CIM		17
+#define IRQ_AIC		18
+#define IRQ_ETH		19
+#define IRQ_DMAC	20
+#define IRQ_TCU2	21
+#define IRQ_TCU1	22
+#define IRQ_TCU0	23
+#define IRQ_UDC 	24
+#define IRQ_GPIO3	25
+#define IRQ_GPIO2	26
+#define IRQ_GPIO1	27
+#define IRQ_GPIO0	28
+#define IRQ_IPU		29
+#define IRQ_LCD		30
+
+// 2nd-level interrupts
+#define IRQ_DMA_0	32  /* 32 to 37 for DMAC channel 0 to 5 */
+#define IRQ_GPIO_0	48  /* 48 to 175 for GPIO pin 0 to 127 */
+
+#define NUM_DMA         6
+#define NUM_GPIO        128
+/*************************************************************************
+ * RTC
+ *************************************************************************/
+#define RTC_RCR		(RTC_BASE + 0x00) /* RTC Control Register */
+#define RTC_RSR		(RTC_BASE + 0x04) /* RTC Second Register */
+#define RTC_RSAR	(RTC_BASE + 0x08) /* RTC Second Alarm Register */
+#define RTC_RGR		(RTC_BASE + 0x0c) /* RTC Regulator Register */
+
+#define RTC_HCR		(RTC_BASE + 0x20) /* Hibernate Control Register */
+#define RTC_HWFCR	(RTC_BASE + 0x24) /* Hibernate Wakeup Filter Counter Reg */
+#define RTC_HRCR	(RTC_BASE + 0x28) /* Hibernate Reset Counter Register */
+#define RTC_HWCR	(RTC_BASE + 0x2c) /* Hibernate Wakeup Control Register */
+#define RTC_HWRSR	(RTC_BASE + 0x30) /* Hibernate Wakeup Status Register */
+#define RTC_HSPR	(RTC_BASE + 0x34) /* Hibernate Scratch Pattern Register */
+
+#define REG_RTC_RCR	REG32(RTC_RCR)
+#define REG_RTC_RSR	REG32(RTC_RSR)
+#define REG_RTC_RSAR	REG32(RTC_RSAR)
+#define REG_RTC_RGR	REG32(RTC_RGR)
+#define REG_RTC_HCR	REG32(RTC_HCR)
+#define REG_RTC_HWFCR	REG32(RTC_HWFCR)
+#define REG_RTC_HRCR	REG32(RTC_HRCR)
+#define REG_RTC_HWCR	REG32(RTC_HWCR)
+#define REG_RTC_HWRSR	REG32(RTC_HWRSR)
+#define REG_RTC_HSPR	REG32(RTC_HSPR)
+
+/* RTC Control Register */
+#define RTC_RCR_WRDY_BIT 7
+#define RTC_RCR_WRDY	(1 << 7)  /* Write Ready Flag */
+#define RTC_RCR_1HZ_BIT	6
+#define RTC_RCR_1HZ	(1 << RTC_RCR_1HZ_BIT)  /* 1Hz Flag */
+#define RTC_RCR_1HZIE	(1 << 5)  /* 1Hz Interrupt Enable */
+#define RTC_RCR_AF_BIT	4
+#define RTC_RCR_AF	(1 << RTC_RCR_AF_BIT)  /* Alarm Flag */
+#define RTC_RCR_AIE	(1 << 3)  /* Alarm Interrupt Enable */
+#define RTC_RCR_AE	(1 << 2)  /* Alarm Enable */
+#define RTC_RCR_RTCE	(1 << 0)  /* RTC Enable */
+
+/* RTC Regulator Register */
+#define RTC_RGR_LOCK		(1 << 31) /* Lock Bit */
+#define RTC_RGR_ADJC_BIT	16
+#define RTC_RGR_ADJC_MASK	(0x3ff << RTC_RGR_ADJC_BIT)
+#define RTC_RGR_NC1HZ_BIT	0
+#define RTC_RGR_NC1HZ_MASK	(0xffff << RTC_RGR_NC1HZ_BIT)
+
+/* Hibernate Control Register */
+#define RTC_HCR_PD		(1 << 0)  /* Power Down */
+
+/* Hibernate Wakeup Filter Counter Register */
+#define RTC_HWFCR_BIT		5
+#define RTC_HWFCR_MASK		(0x7ff << RTC_HWFCR_BIT)
+
+/* Hibernate Reset Counter Register */
+#define RTC_HRCR_BIT		5
+#define RTC_HRCR_MASK		(0x7f << RTC_HRCR_BIT)
+
+/* Hibernate Wakeup Control Register */
+#define RTC_HWCR_EALM		(1 << 0)  /* RTC alarm wakeup enable */
+
+/* Hibernate Wakeup Status Register */
+#define RTC_HWRSR_HR		(1 << 5)  /* Hibernate reset */
+#define RTC_HWRSR_PPR		(1 << 4)  /* PPR reset */
+#define RTC_HWRSR_PIN		(1 << 1)  /* Wakeup pin status bit */
+#define RTC_HWRSR_ALM		(1 << 0)  /* RTC alarm status bit */
+
+
+/*************************************************************************
+ * CPM (Clock reset and Power control Management)
+ *************************************************************************/
+#define CPM_CPCCR	(CPM_BASE+0x00)
+#define CPM_CPPCR	(CPM_BASE+0x10)
+#define CPM_I2SCDR	(CPM_BASE+0x60)
+#define CPM_LPCDR	(CPM_BASE+0x64)
+#define CPM_MSCCDR	(CPM_BASE+0x68)
+#define CPM_UHCCDR	(CPM_BASE+0x6C)
+#define CPM_SSICDR	(CPM_BASE+0x74)
+
+#define CPM_LCR		(CPM_BASE+0x04)
+#define CPM_CLKGR	(CPM_BASE+0x20)
+#define CPM_SCR		(CPM_BASE+0x24)
+
+#define CPM_HCR		(CPM_BASE+0x30)
+#define CPM_HWFCR	(CPM_BASE+0x34)
+#define CPM_HRCR	(CPM_BASE+0x38)
+#define CPM_HWCR	(CPM_BASE+0x3c)
+#define CPM_HWSR	(CPM_BASE+0x40)
+#define CPM_HSPR	(CPM_BASE+0x44)
+
+#define CPM_RSR		(CPM_BASE+0x08)
+
+
+#define REG_CPM_CPCCR	REG32(CPM_CPCCR)
+#define REG_CPM_CPPCR	REG32(CPM_CPPCR)
+#define REG_CPM_I2SCDR	REG32(CPM_I2SCDR)
+#define REG_CPM_LPCDR	REG32(CPM_LPCDR)
+#define REG_CPM_MSCCDR	REG32(CPM_MSCCDR)
+#define REG_CPM_UHCCDR	REG32(CPM_UHCCDR)
+#define REG_CPM_SSICDR	REG32(CPM_SSICDR)
+
+#define REG_CPM_LCR	REG32(CPM_LCR)
+#define REG_CPM_CLKGR	REG32(CPM_CLKGR)
+#define REG_CPM_SCR	REG32(CPM_SCR)
+#define REG_CPM_HCR	REG32(CPM_HCR)
+#define REG_CPM_HWFCR	REG32(CPM_HWFCR)
+#define REG_CPM_HRCR	REG32(CPM_HRCR)
+#define REG_CPM_HWCR	REG32(CPM_HWCR)
+#define REG_CPM_HWSR	REG32(CPM_HWSR)
+#define REG_CPM_HSPR	REG32(CPM_HSPR)
+
+#define REG_CPM_RSR	REG32(CPM_RSR)
+
+
+/* Clock Control Register */
+#define CPM_CPCCR_I2CS		(1 << 31)
+#define CPM_CPCCR_CLKOEN	(1 << 30)
+#define CPM_CPCCR_UCS		(1 << 29)
+#define CPM_CPCCR_UDIV_BIT	23
+#define CPM_CPCCR_UDIV_MASK	(0x3f << CPM_CPCCR_UDIV_BIT)
+#define CPM_CPCCR_CE		(1 << 22)
+#define CPM_CPCCR_PCS		(1 << 21)
+#define CPM_CPCCR_LDIV_BIT	16
+#define CPM_CPCCR_LDIV_MASK	(0x1f << CPM_CPCCR_LDIV_BIT)
+#define CPM_CPCCR_MDIV_BIT	12
+#define CPM_CPCCR_MDIV_MASK	(0x0f << CPM_CPCCR_MDIV_BIT)
+#define CPM_CPCCR_PDIV_BIT	8
+#define CPM_CPCCR_PDIV_MASK	(0x0f << CPM_CPCCR_PDIV_BIT)
+#define CPM_CPCCR_HDIV_BIT	4
+#define CPM_CPCCR_HDIV_MASK	(0x0f << CPM_CPCCR_HDIV_BIT)
+#define CPM_CPCCR_CDIV_BIT	0
+#define CPM_CPCCR_CDIV_MASK	(0x0f << CPM_CPCCR_CDIV_BIT)
+
+/* I2S Clock Divider Register */
+#define CPM_I2SCDR_I2SDIV_BIT	0
+#define CPM_I2SCDR_I2SDIV_MASK	(0x1ff << CPM_I2SCDR_I2SDIV_BIT)
+
+/* LCD Pixel Clock Divider Register */
+#define CPM_LPCDR_PIXDIV_BIT	0
+#define CPM_LPCDR_PIXDIV_MASK	(0x7ff << CPM_LPCDR_PIXDIV_BIT)
+
+/* MSC Clock Divider Register */
+#define CPM_MSCCDR_MSCDIV_BIT	0
+#define CPM_MSCCDR_MSCDIV_MASK	(0x1f << CPM_MSCCDR_MSCDIV_BIT)
+
+/* UHC Clock Divider Register */
+#define CPM_UHCCDR_UHCDIV_BIT	0
+#define CPM_UHCCDR_UHCDIV_MASK	(0xf << CPM_UHCCDR_UHCDIV_BIT)
+
+/* SSI Clock Divider Register */
+#define CPM_SSICDR_SCS		(1<<31) /* SSI clock source selection, 0:EXCLK, 1: PLL */
+#define CPM_SSICDR_SSIDIV_BIT	0
+#define CPM_SSICDR_SSIDIV_MASK	(0xf << CPM_SSICDR_SSIDIV_BIT)
+
+/* PLL Control Register */
+#define CPM_CPPCR_PLLM_BIT	23
+#define CPM_CPPCR_PLLM_MASK	(0x1ff << CPM_CPPCR_PLLM_BIT)
+#define CPM_CPPCR_PLLN_BIT	18
+#define CPM_CPPCR_PLLN_MASK	(0x1f << CPM_CPPCR_PLLN_BIT)
+#define CPM_CPPCR_PLLOD_BIT	16
+#define CPM_CPPCR_PLLOD_MASK	(0x03 << CPM_CPPCR_PLLOD_BIT)
+#define CPM_CPPCR_PLLS		(1 << 10)
+#define CPM_CPPCR_PLLBP		(1 << 9)
+#define CPM_CPPCR_PLLEN		(1 << 8)
+#define CPM_CPPCR_PLLST_BIT	0
+#define CPM_CPPCR_PLLST_MASK	(0xff << CPM_CPPCR_PLLST_BIT)
+
+/* Low Power Control Register */
+#define CPM_LCR_DOZE_DUTY_BIT 	3
+#define CPM_LCR_DOZE_DUTY_MASK 	(0x1f << CPM_LCR_DOZE_DUTY_BIT)
+#define CPM_LCR_DOZE_ON		(1 << 2)
+#define CPM_LCR_LPM_BIT		0
+#define CPM_LCR_LPM_MASK	(0x3 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_IDLE	(0x0 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_SLEEP	(0x1 << CPM_LCR_LPM_BIT)
+
+/* Clock Gate Register */
+#define CPM_CLKGR_UART1		(1 << 15)
+#define CPM_CLKGR_UHC		(1 << 14)
+#define CPM_CLKGR_IPU		(1 << 13)
+#define CPM_CLKGR_DMAC		(1 << 12)
+#define CPM_CLKGR_UDC		(1 << 11)
+#define CPM_CLKGR_LCD		(1 << 10)
+#define CPM_CLKGR_CIM		(1 << 9)
+#define CPM_CLKGR_SADC		(1 << 8)
+#define CPM_CLKGR_MSC		(1 << 7)
+#define CPM_CLKGR_AIC1		(1 << 6)
+#define CPM_CLKGR_AIC2		(1 << 5)
+#define CPM_CLKGR_SSI		(1 << 4)
+#define CPM_CLKGR_I2C		(1 << 3)
+#define CPM_CLKGR_RTC		(1 << 2)
+#define CPM_CLKGR_TCU		(1 << 1)
+#define CPM_CLKGR_UART0		(1 << 0)
+
+/* Sleep Control Register */
+#define CPM_SCR_O1ST_BIT	8
+#define CPM_SCR_O1ST_MASK	(0xff << CPM_SCR_O1ST_BIT)
+#define CPM_SCR_USBPHY_ENABLE	(1 << 6)
+#define CPM_SCR_OSC_ENABLE	(1 << 4)
+
+/* Hibernate Control Register */
+#define CPM_HCR_PD		(1 << 0)
+
+/* Wakeup Filter Counter Register in Hibernate Mode */
+#define CPM_HWFCR_TIME_BIT	0
+#define CPM_HWFCR_TIME_MASK	(0x3ff << CPM_HWFCR_TIME_BIT)
+
+/* Reset Counter Register in Hibernate Mode */
+#define CPM_HRCR_TIME_BIT	0
+#define CPM_HRCR_TIME_MASK	(0x7f << CPM_HRCR_TIME_BIT)
+
+/* Wakeup Control Register in Hibernate Mode */
+#define CPM_HWCR_WLE_LOW	(0 << 2)
+#define CPM_HWCR_WLE_HIGH	(1 << 2)
+#define CPM_HWCR_PIN_WAKEUP	(1 << 1)
+#define CPM_HWCR_RTC_WAKEUP	(1 << 0)
+
+/* Wakeup Status Register in Hibernate Mode */
+#define CPM_HWSR_WSR_PIN	(1 << 1)
+#define CPM_HWSR_WSR_RTC	(1 << 0)
+
+/* Reset Status Register */
+#define CPM_RSR_HR		(1 << 2)
+#define CPM_RSR_WR		(1 << 1)
+#define CPM_RSR_PR		(1 << 0)
+
+
+/*************************************************************************
+ * TCU (Timer Counter Unit)
+ *************************************************************************/
+#define TCU_TSR		(TCU_BASE + 0x1C) /* Timer Stop Register */
+#define TCU_TSSR	(TCU_BASE + 0x2C) /* Timer Stop Set Register */
+#define TCU_TSCR	(TCU_BASE + 0x3C) /* Timer Stop Clear Register */
+#define TCU_TER		(TCU_BASE + 0x10) /* Timer Counter Enable Register */
+#define TCU_TESR	(TCU_BASE + 0x14) /* Timer Counter Enable Set Register */
+#define TCU_TECR	(TCU_BASE + 0x18) /* Timer Counter Enable Clear Register */
+#define TCU_TFR		(TCU_BASE + 0x20) /* Timer Flag Register */
+#define TCU_TFSR	(TCU_BASE + 0x24) /* Timer Flag Set Register */
+#define TCU_TFCR	(TCU_BASE + 0x28) /* Timer Flag Clear Register */
+#define TCU_TMR		(TCU_BASE + 0x30) /* Timer Mask Register */
+#define TCU_TMSR	(TCU_BASE + 0x34) /* Timer Mask Set Register */
+#define TCU_TMCR	(TCU_BASE + 0x38) /* Timer Mask Clear Register */
+#define TCU_TDFR0	(TCU_BASE + 0x40) /* Timer Data Full Register */
+#define TCU_TDHR0	(TCU_BASE + 0x44) /* Timer Data Half Register */
+#define TCU_TCNT0	(TCU_BASE + 0x48) /* Timer Counter Register */
+#define TCU_TCSR0	(TCU_BASE + 0x4C) /* Timer Control Register */
+#define TCU_TDFR1	(TCU_BASE + 0x50)
+#define TCU_TDHR1	(TCU_BASE + 0x54)
+#define TCU_TCNT1	(TCU_BASE + 0x58)
+#define TCU_TCSR1	(TCU_BASE + 0x5C)
+#define TCU_TDFR2	(TCU_BASE + 0x60)
+#define TCU_TDHR2	(TCU_BASE + 0x64)
+#define TCU_TCNT2	(TCU_BASE + 0x68)
+#define TCU_TCSR2	(TCU_BASE + 0x6C)
+#define TCU_TDFR3	(TCU_BASE + 0x70)
+#define TCU_TDHR3	(TCU_BASE + 0x74)
+#define TCU_TCNT3	(TCU_BASE + 0x78)
+#define TCU_TCSR3	(TCU_BASE + 0x7C)
+#define TCU_TDFR4	(TCU_BASE + 0x80)
+#define TCU_TDHR4	(TCU_BASE + 0x84)
+#define TCU_TCNT4	(TCU_BASE + 0x88)
+#define TCU_TCSR4	(TCU_BASE + 0x8C)
+#define TCU_TDFR5	(TCU_BASE + 0x90)
+#define TCU_TDHR5	(TCU_BASE + 0x94)
+#define TCU_TCNT5	(TCU_BASE + 0x98)
+#define TCU_TCSR5	(TCU_BASE + 0x9C)
+
+#define REG_TCU_TSR	REG32(TCU_TSR)
+#define REG_TCU_TSSR	REG32(TCU_TSSR)
+#define REG_TCU_TSCR	REG32(TCU_TSCR)
+#define REG_TCU_TER	REG8(TCU_TER)
+#define REG_TCU_TESR	REG8(TCU_TESR)
+#define REG_TCU_TECR	REG8(TCU_TECR)
+#define REG_TCU_TFR	REG32(TCU_TFR)
+#define REG_TCU_TFSR	REG32(TCU_TFSR)
+#define REG_TCU_TFCR	REG32(TCU_TFCR)
+#define REG_TCU_TMR	REG32(TCU_TMR)
+#define REG_TCU_TMSR	REG32(TCU_TMSR)
+#define REG_TCU_TMCR	REG32(TCU_TMCR)
+#define REG_TCU_TDFR0	REG16(TCU_TDFR0)
+#define REG_TCU_TDHR0	REG16(TCU_TDHR0)
+#define REG_TCU_TCNT0	REG16(TCU_TCNT0)
+#define REG_TCU_TCSR0	REG16(TCU_TCSR0)
+#define REG_TCU_TDFR1	REG16(TCU_TDFR1)
+#define REG_TCU_TDHR1	REG16(TCU_TDHR1)
+#define REG_TCU_TCNT1	REG16(TCU_TCNT1)
+#define REG_TCU_TCSR1	REG16(TCU_TCSR1)
+#define REG_TCU_TDFR2	REG16(TCU_TDFR2)
+#define REG_TCU_TDHR2	REG16(TCU_TDHR2)
+#define REG_TCU_TCNT2	REG16(TCU_TCNT2)
+#define REG_TCU_TCSR2	REG16(TCU_TCSR2)
+#define REG_TCU_TDFR3	REG16(TCU_TDFR3)
+#define REG_TCU_TDHR3	REG16(TCU_TDHR3)
+#define REG_TCU_TCNT3	REG16(TCU_TCNT3)
+#define REG_TCU_TCSR3	REG16(TCU_TCSR3)
+#define REG_TCU_TDFR4	REG16(TCU_TDFR4)
+#define REG_TCU_TDHR4	REG16(TCU_TDHR4)
+#define REG_TCU_TCNT4	REG16(TCU_TCNT4)
+#define REG_TCU_TCSR4	REG16(TCU_TCSR4)
+
+// n = 0,1,2,3,4,5
+#define TCU_TDFR(n)	(TCU_BASE + (0x40 + (n)*0x10)) /* Timer Data Full Reg */
+#define TCU_TDHR(n)	(TCU_BASE + (0x44 + (n)*0x10)) /* Timer Data Half Reg */
+#define TCU_TCNT(n)	(TCU_BASE + (0x48 + (n)*0x10)) /* Timer Counter Reg */
+#define TCU_TCSR(n)	(TCU_BASE + (0x4C + (n)*0x10)) /* Timer Control Reg */
+
+#define REG_TCU_TDFR(n)	REG16(TCU_TDFR((n)))
+#define REG_TCU_TDHR(n)	REG16(TCU_TDHR((n)))
+#define REG_TCU_TCNT(n)	REG16(TCU_TCNT((n)))
+#define REG_TCU_TCSR(n)	REG16(TCU_TCSR((n)))
+
+// Register definitions
+#define TCU_TCSR_PWM_SD		(1 << 9)
+#define TCU_TCSR_PWM_INITL_HIGH	(1 << 8)
+#define TCU_TCSR_PWM_EN		(1 << 7)
+#define TCU_TCSR_PRESCALE_BIT	3
+#define TCU_TCSR_PRESCALE_MASK	(0x7 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1	(0x0 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE4	(0x1 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE16	(0x2 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE64	(0x3 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE256	(0x4 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1024	(0x5 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_EXT_EN		(1 << 2)
+#define TCU_TCSR_RTC_EN		(1 << 1)
+#define TCU_TCSR_PCK_EN		(1 << 0)
+
+#define TCU_TER_TCEN5		(1 << 5)
+#define TCU_TER_TCEN4		(1 << 4)
+#define TCU_TER_TCEN3		(1 << 3)
+#define TCU_TER_TCEN2		(1 << 2)
+#define TCU_TER_TCEN1		(1 << 1)
+#define TCU_TER_TCEN0		(1 << 0)
+
+#define TCU_TESR_TCST5		(1 << 5)
+#define TCU_TESR_TCST4		(1 << 4)
+#define TCU_TESR_TCST3		(1 << 3)
+#define TCU_TESR_TCST2		(1 << 2)
+#define TCU_TESR_TCST1		(1 << 1)
+#define TCU_TESR_TCST0		(1 << 0)
+
+#define TCU_TECR_TCCL5		(1 << 5)
+#define TCU_TECR_TCCL4		(1 << 4)
+#define TCU_TECR_TCCL3		(1 << 3)
+#define TCU_TECR_TCCL2		(1 << 2)
+#define TCU_TECR_TCCL1		(1 << 1)
+#define TCU_TECR_TCCL0		(1 << 0)
+
+#define TCU_TFR_HFLAG5		(1 << 21)
+#define TCU_TFR_HFLAG4		(1 << 20)
+#define TCU_TFR_HFLAG3		(1 << 19)
+#define TCU_TFR_HFLAG2		(1 << 18)
+#define TCU_TFR_HFLAG1		(1 << 17)
+#define TCU_TFR_HFLAG0		(1 << 16)
+#define TCU_TFR_FFLAG5		(1 << 5)
+#define TCU_TFR_FFLAG4		(1 << 4)
+#define TCU_TFR_FFLAG3		(1 << 3)
+#define TCU_TFR_FFLAG2		(1 << 2)
+#define TCU_TFR_FFLAG1		(1 << 1)
+#define TCU_TFR_FFLAG0		(1 << 0)
+
+#define TCU_TFSR_HFLAG5		(1 << 21)
+#define TCU_TFSR_HFLAG4		(1 << 20)
+#define TCU_TFSR_HFLAG3		(1 << 19)
+#define TCU_TFSR_HFLAG2		(1 << 18)
+#define TCU_TFSR_HFLAG1		(1 << 17)
+#define TCU_TFSR_HFLAG0		(1 << 16)
+#define TCU_TFSR_FFLAG5		(1 << 5)
+#define TCU_TFSR_FFLAG4		(1 << 4)
+#define TCU_TFSR_FFLAG3		(1 << 3)
+#define TCU_TFSR_FFLAG2		(1 << 2)
+#define TCU_TFSR_FFLAG1		(1 << 1)
+#define TCU_TFSR_FFLAG0		(1 << 0)
+
+#define TCU_TFCR_HFLAG5		(1 << 21)
+#define TCU_TFCR_HFLAG4		(1 << 20)
+#define TCU_TFCR_HFLAG3		(1 << 19)
+#define TCU_TFCR_HFLAG2		(1 << 18)
+#define TCU_TFCR_HFLAG1		(1 << 17)
+#define TCU_TFCR_HFLAG0		(1 << 16)
+#define TCU_TFCR_FFLAG5		(1 << 5)
+#define TCU_TFCR_FFLAG4		(1 << 4)
+#define TCU_TFCR_FFLAG3		(1 << 3)
+#define TCU_TFCR_FFLAG2		(1 << 2)
+#define TCU_TFCR_FFLAG1		(1 << 1)
+#define TCU_TFCR_FFLAG0		(1 << 0)
+
+#define TCU_TMR_HMASK5		(1 << 21)
+#define TCU_TMR_HMASK4		(1 << 20)
+#define TCU_TMR_HMASK3		(1 << 19)
+#define TCU_TMR_HMASK2		(1 << 18)
+#define TCU_TMR_HMASK1		(1 << 17)
+#define TCU_TMR_HMASK0		(1 << 16)
+#define TCU_TMR_FMASK5		(1 << 5)
+#define TCU_TMR_FMASK4		(1 << 4)
+#define TCU_TMR_FMASK3		(1 << 3)
+#define TCU_TMR_FMASK2		(1 << 2)
+#define TCU_TMR_FMASK1		(1 << 1)
+#define TCU_TMR_FMASK0		(1 << 0)
+
+#define TCU_TMSR_HMST5		(1 << 21)
+#define TCU_TMSR_HMST4		(1 << 20)
+#define TCU_TMSR_HMST3		(1 << 19)
+#define TCU_TMSR_HMST2		(1 << 18)
+#define TCU_TMSR_HMST1		(1 << 17)
+#define TCU_TMSR_HMST0		(1 << 16)
+#define TCU_TMSR_FMST5		(1 << 5)
+#define TCU_TMSR_FMST4		(1 << 4)
+#define TCU_TMSR_FMST3		(1 << 3)
+#define TCU_TMSR_FMST2		(1 << 2)
+#define TCU_TMSR_FMST1		(1 << 1)
+#define TCU_TMSR_FMST0		(1 << 0)
+
+#define TCU_TMCR_HMCL5		(1 << 21)
+#define TCU_TMCR_HMCL4		(1 << 20)
+#define TCU_TMCR_HMCL3		(1 << 19)
+#define TCU_TMCR_HMCL2		(1 << 18)
+#define TCU_TMCR_HMCL1		(1 << 17)
+#define TCU_TMCR_HMCL0		(1 << 16)
+#define TCU_TMCR_FMCL5		(1 << 5)
+#define TCU_TMCR_FMCL4		(1 << 4)
+#define TCU_TMCR_FMCL3		(1 << 3)
+#define TCU_TMCR_FMCL2		(1 << 2)
+#define TCU_TMCR_FMCL1		(1 << 1)
+#define TCU_TMCR_FMCL0		(1 << 0)
+
+#define TCU_TSR_WDTS		(1 << 16)
+#define TCU_TSR_STOP5		(1 << 5)
+#define TCU_TSR_STOP4		(1 << 4)
+#define TCU_TSR_STOP3		(1 << 3)
+#define TCU_TSR_STOP2		(1 << 2)
+#define TCU_TSR_STOP1		(1 << 1)
+#define TCU_TSR_STOP0		(1 << 0)
+
+#define TCU_TSSR_WDTSS		(1 << 16)
+#define TCU_TSSR_STPS5		(1 << 5)
+#define TCU_TSSR_STPS4		(1 << 4)
+#define TCU_TSSR_STPS3		(1 << 3)
+#define TCU_TSSR_STPS2		(1 << 2)
+#define TCU_TSSR_STPS1		(1 << 1)
+#define TCU_TSSR_STPS0		(1 << 0)
+
+#define TCU_TSSR_WDTSC		(1 << 16)
+#define TCU_TSSR_STPC5		(1 << 5)
+#define TCU_TSSR_STPC4		(1 << 4)
+#define TCU_TSSR_STPC3		(1 << 3)
+#define TCU_TSSR_STPC2		(1 << 2)
+#define TCU_TSSR_STPC1		(1 << 1)
+#define TCU_TSSR_STPC0		(1 << 0)
+
+
+/*************************************************************************
+ * WDT (WatchDog Timer)
+ *************************************************************************/
+#define WDT_TDR		(WDT_BASE + 0x00)
+#define WDT_TCER	(WDT_BASE + 0x04)
+#define WDT_TCNT	(WDT_BASE + 0x08)
+#define WDT_TCSR	(WDT_BASE + 0x0C)
+
+#define REG_WDT_TDR	REG16(WDT_TDR)
+#define REG_WDT_TCER	REG8(WDT_TCER)
+#define REG_WDT_TCNT	REG16(WDT_TCNT)
+#define REG_WDT_TCSR	REG16(WDT_TCSR)
+
+// Register definition
+#define WDT_TCSR_PRESCALE_BIT	3
+#define WDT_TCSR_PRESCALE_MASK	(0x7 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1	(0x0 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE4	(0x1 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE16	(0x2 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE64	(0x3 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE256	(0x4 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1024	(0x5 << WDT_TCSR_PRESCALE_BIT)
+#define WDT_TCSR_EXT_EN		(1 << 2)
+#define WDT_TCSR_RTC_EN		(1 << 1)
+#define WDT_TCSR_PCK_EN		(1 << 0)
+
+#define WDT_TCER_TCEN		(1 << 0)
+
+
+/*************************************************************************
+ * DMAC (DMA Controller)
+ *************************************************************************/
+
+#define MAX_DMA_NUM	6  /* max 6 channels */
+
+#define DMAC_DSAR(n)	(DMAC_BASE + (0x00 + (n) * 0x20)) /* DMA source address */
+#define DMAC_DTAR(n)	(DMAC_BASE + (0x04 + (n) * 0x20)) /* DMA target address */
+#define DMAC_DTCR(n)	(DMAC_BASE + (0x08 + (n) * 0x20)) /* DMA transfer count */
+#define DMAC_DRSR(n)	(DMAC_BASE + (0x0c + (n) * 0x20)) /* DMA request source */
+#define DMAC_DCCSR(n)	(DMAC_BASE + (0x10 + (n) * 0x20)) /* DMA control/status */
+#define DMAC_DCMD(n)	(DMAC_BASE + (0x14 + (n) * 0x20)) /* DMA command */
+#define DMAC_DDA(n)	(DMAC_BASE + (0x18 + (n) * 0x20)) /* DMA descriptor address */
+#define DMAC_DMACR	(DMAC_BASE + 0x0300)              /* DMA control register */
+#define DMAC_DMAIPR	(DMAC_BASE + 0x0304)              /* DMA interrupt pending */
+#define DMAC_DMADBR	(DMAC_BASE + 0x0308)              /* DMA doorbell */
+#define DMAC_DMADBSR	(DMAC_BASE + 0x030C)              /* DMA doorbell set */
+
+// channel 0
+#define DMAC_DSAR0      DMAC_DSAR(0)
+#define DMAC_DTAR0      DMAC_DTAR(0)
+#define DMAC_DTCR0      DMAC_DTCR(0)
+#define DMAC_DRSR0      DMAC_DRSR(0)
+#define DMAC_DCCSR0     DMAC_DCCSR(0)
+#define DMAC_DCMD0	DMAC_DCMD(0)
+#define DMAC_DDA0	DMAC_DDA(0)
+
+// channel 1
+#define DMAC_DSAR1      DMAC_DSAR(1)
+#define DMAC_DTAR1      DMAC_DTAR(1)
+#define DMAC_DTCR1      DMAC_DTCR(1)
+#define DMAC_DRSR1      DMAC_DRSR(1)
+#define DMAC_DCCSR1     DMAC_DCCSR(1)
+#define DMAC_DCMD1	DMAC_DCMD(1)
+#define DMAC_DDA1	DMAC_DDA(1)
+
+// channel 2
+#define DMAC_DSAR2      DMAC_DSAR(2)
+#define DMAC_DTAR2      DMAC_DTAR(2)
+#define DMAC_DTCR2      DMAC_DTCR(2)
+#define DMAC_DRSR2      DMAC_DRSR(2)
+#define DMAC_DCCSR2     DMAC_DCCSR(2)
+#define DMAC_DCMD2	DMAC_DCMD(2)
+#define DMAC_DDA2	DMAC_DDA(2)
+
+// channel 3
+#define DMAC_DSAR3      DMAC_DSAR(3)
+#define DMAC_DTAR3      DMAC_DTAR(3)
+#define DMAC_DTCR3      DMAC_DTCR(3)
+#define DMAC_DRSR3      DMAC_DRSR(3)
+#define DMAC_DCCSR3     DMAC_DCCSR(3)
+#define DMAC_DCMD3	DMAC_DCMD(3)
+#define DMAC_DDA3	DMAC_DDA(3)
+
+// channel 4
+#define DMAC_DSAR4      DMAC_DSAR(4)
+#define DMAC_DTAR4      DMAC_DTAR(4)
+#define DMAC_DTCR4      DMAC_DTCR(4)
+#define DMAC_DRSR4      DMAC_DRSR(4)
+#define DMAC_DCCSR4     DMAC_DCCSR(4)
+#define DMAC_DCMD4	DMAC_DCMD(4)
+#define DMAC_DDA4	DMAC_DDA(4)
+
+// channel 5
+#define DMAC_DSAR5      DMAC_DSAR(5)
+#define DMAC_DTAR5      DMAC_DTAR(5)
+#define DMAC_DTCR5      DMAC_DTCR(5)
+#define DMAC_DRSR5      DMAC_DRSR(5)
+#define DMAC_DCCSR5     DMAC_DCCSR(5)
+#define DMAC_DCMD5	DMAC_DCMD(5)
+#define DMAC_DDA5	DMAC_DDA(5)
+
+#define REG_DMAC_DSAR(n)	REG32(DMAC_DSAR((n)))
+#define REG_DMAC_DTAR(n)	REG32(DMAC_DTAR((n)))
+#define REG_DMAC_DTCR(n)	REG32(DMAC_DTCR((n)))
+#define REG_DMAC_DRSR(n)	REG32(DMAC_DRSR((n)))
+#define REG_DMAC_DCCSR(n)	REG32(DMAC_DCCSR((n)))
+#define REG_DMAC_DCMD(n)	REG32(DMAC_DCMD((n)))
+#define REG_DMAC_DDA(n)		REG32(DMAC_DDA((n)))
+#define REG_DMAC_DMACR		REG32(DMAC_DMACR)
+#define REG_DMAC_DMAIPR		REG32(DMAC_DMAIPR)
+#define REG_DMAC_DMADBR		REG32(DMAC_DMADBR)
+#define REG_DMAC_DMADBSR	REG32(DMAC_DMADBSR)
+
+// DMA request source register
+#define DMAC_DRSR_RS_BIT	0
+#define DMAC_DRSR_RS_MASK	(0x1f << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AUTO	(8 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0OUT	(20 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0IN	(21 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSIOUT	(22 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSIIN	(23 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICOUT	(24 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICIN	(25 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSCOUT	(26 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSCIN	(27 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_TCU	(28 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SADC	(29 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SLCD	(30 << DMAC_DRSR_RS_BIT)
+
+// DMA channel control/status register
+#define DMAC_DCCSR_NDES		(1 << 31) /* descriptor (0) or not (1) ? */
+#define DMAC_DCCSR_CDOA_BIT	16        /* copy of DMA offset address */
+#define DMAC_DCCSR_CDOA_MASK	(0xff << DMAC_DCCSR_CDOA_BIT)
+#define DMAC_DCCSR_INV		(1 << 6)  /* descriptor invalid */
+#define DMAC_DCCSR_AR		(1 << 4)  /* address error */
+#define DMAC_DCCSR_TT		(1 << 3)  /* transfer terminated */
+#define DMAC_DCCSR_HLT		(1 << 2)  /* DMA halted */
+#define DMAC_DCCSR_CT		(1 << 1)  /* count terminated */
+#define DMAC_DCCSR_EN		(1 << 0)  /* channel enable bit */
+
+// DMA channel command register 
+#define DMAC_DCMD_SAI		(1 << 23) /* source address increment */
+#define DMAC_DCMD_DAI		(1 << 22) /* dest address increment */
+#define DMAC_DCMD_RDIL_BIT	16        /* request detection interval length */
+#define DMAC_DCMD_RDIL_MASK	(0x0f << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_IGN	(0 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_2	(1 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_4	(2 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_8	(3 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_12	(4 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_16	(5 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_20	(6 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_24	(7 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_28	(8 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_32	(9 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_48	(10 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_60	(11 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_64	(12 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_124	(13 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_128	(14 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_200	(15 << DMAC_DCMD_RDIL_BIT)
+#define DMAC_DCMD_SWDH_BIT	14  /* source port width */
+#define DMAC_DCMD_SWDH_MASK	(0x03 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_32	(0 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_8	(1 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_16	(2 << DMAC_DCMD_SWDH_BIT)
+#define DMAC_DCMD_DWDH_BIT	12  /* dest port width */
+#define DMAC_DCMD_DWDH_MASK	(0x03 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_32	(0 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_8	(1 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_16	(2 << DMAC_DCMD_DWDH_BIT)
+#define DMAC_DCMD_DS_BIT	8  /* transfer data size of a data unit */
+#define DMAC_DCMD_DS_MASK	(0x07 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BIT	(0 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_8BIT	(1 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BIT	(2 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BYTE	(3 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BYTE	(4 << DMAC_DCMD_DS_BIT)
+#define DMAC_DCMD_TM		(1 << 7)  /* transfer mode: 0-single 1-block */
+#define DMAC_DCMD_DES_V		(1 << 4)  /* descriptor valid flag */
+#define DMAC_DCMD_DES_VM	(1 << 3)  /* descriptor valid mask: 1:support V-bit */
+#define DMAC_DCMD_DES_VIE	(1 << 2)  /* DMA valid error interrupt enable */
+#define DMAC_DCMD_TIE		(1 << 1)  /* DMA transfer interrupt enable */
+#define DMAC_DCMD_LINK		(1 << 0)  /* descriptor link enable */
+
+// DMA descriptor address register
+#define DMAC_DDA_BASE_BIT	12  /* descriptor base address */
+#define DMAC_DDA_BASE_MASK	(0x0fffff << DMAC_DDA_BASE_BIT)
+#define DMAC_DDA_OFFSET_BIT	4  /* descriptor offset address */
+#define DMAC_DDA_OFFSET_MASK	(0x0ff << DMAC_DDA_OFFSET_BIT)
+
+// DMA control register
+#define DMAC_DMACR_PR_BIT	8  /* channel priority mode */
+#define DMAC_DMACR_PR_MASK	(0x03 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_012345	(0 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_023145	(1 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_201345	(2 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_RR	(3 << DMAC_DMACR_PR_BIT) /* round robin */
+#define DMAC_DMACR_HLT		(1 << 3)  /* DMA halt flag */
+#define DMAC_DMACR_AR		(1 << 2)  /* address error flag */
+#define DMAC_DMACR_DMAE		(1 << 0)  /* DMA enable bit */
+
+// DMA doorbell register
+#define DMAC_DMADBR_DB5		(1 << 5)  /* doorbell for channel 5 */
+#define DMAC_DMADBR_DB4		(1 << 5)  /* doorbell for channel 4 */
+#define DMAC_DMADBR_DB3		(1 << 5)  /* doorbell for channel 3 */
+#define DMAC_DMADBR_DB2		(1 << 5)  /* doorbell for channel 2 */
+#define DMAC_DMADBR_DB1		(1 << 5)  /* doorbell for channel 1 */
+#define DMAC_DMADBR_DB0		(1 << 5)  /* doorbell for channel 0 */
+
+// DMA doorbell set register
+#define DMAC_DMADBSR_DBS5	(1 << 5)  /* enable doorbell for channel 5 */
+#define DMAC_DMADBSR_DBS4	(1 << 5)  /* enable doorbell for channel 4 */
+#define DMAC_DMADBSR_DBS3	(1 << 5)  /* enable doorbell for channel 3 */
+#define DMAC_DMADBSR_DBS2	(1 << 5)  /* enable doorbell for channel 2 */
+#define DMAC_DMADBSR_DBS1	(1 << 5)  /* enable doorbell for channel 1 */
+#define DMAC_DMADBSR_DBS0	(1 << 5)  /* enable doorbell for channel 0 */
+
+// DMA interrupt pending register
+#define DMAC_DMAIPR_CIRQ5	(1 << 5)  /* irq pending status for channel 5 */
+#define DMAC_DMAIPR_CIRQ4	(1 << 4)  /* irq pending status for channel 4 */
+#define DMAC_DMAIPR_CIRQ3	(1 << 3)  /* irq pending status for channel 3 */
+#define DMAC_DMAIPR_CIRQ2	(1 << 2)  /* irq pending status for channel 2 */
+#define DMAC_DMAIPR_CIRQ1	(1 << 1)  /* irq pending status for channel 1 */
+#define DMAC_DMAIPR_CIRQ0	(1 << 0)  /* irq pending status for channel 0 */
+
+
+/*************************************************************************
+ * GPIO (General-Purpose I/O Ports)
+ *************************************************************************/
+#define MAX_GPIO_NUM	128
+
+//n = 0,1,2,3
+#define GPIO_PXPIN(n)	(GPIO_BASE + (0x00 + (n)*0x100)) /* PIN Level Register */
+#define GPIO_PXDAT(n)	(GPIO_BASE + (0x10 + (n)*0x100)) /* Port Data Register */
+#define GPIO_PXDATS(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Data Set Register */
+#define GPIO_PXDATC(n)	(GPIO_BASE + (0x18 + (n)*0x100)) /* Port Data Clear Register */
+#define GPIO_PXIM(n)	(GPIO_BASE + (0x20 + (n)*0x100)) /* Interrupt Mask Register */
+#define GPIO_PXIMS(n)	(GPIO_BASE + (0x24 + (n)*0x100)) /* Interrupt Mask Set Reg */
+#define GPIO_PXIMC(n)	(GPIO_BASE + (0x28 + (n)*0x100)) /* Interrupt Mask Clear Reg */
+#define GPIO_PXPE(n)	(GPIO_BASE + (0x30 + (n)*0x100)) /* Pull Enable Register */
+#define GPIO_PXPES(n)	(GPIO_BASE + (0x34 + (n)*0x100)) /* Pull Enable Set Reg. */
+#define GPIO_PXPEC(n)	(GPIO_BASE + (0x38 + (n)*0x100)) /* Pull Enable Clear Reg. */
+#define GPIO_PXFUN(n)	(GPIO_BASE + (0x40 + (n)*0x100)) /* Function Register */
+#define GPIO_PXFUNS(n)	(GPIO_BASE + (0x44 + (n)*0x100)) /* Function Set Register */
+#define GPIO_PXFUNC(n)	(GPIO_BASE + (0x48 + (n)*0x100)) /* Function Clear Register */
+#define GPIO_PXSEL(n)	(GPIO_BASE + (0x50 + (n)*0x100)) /* Select Register */
+#define GPIO_PXSELS(n)	(GPIO_BASE + (0x54 + (n)*0x100)) /* Select Set Register */
+#define GPIO_PXSELC(n)	(GPIO_BASE + (0x58 + (n)*0x100)) /* Select Clear Register */
+#define GPIO_PXDIR(n)	(GPIO_BASE + (0x60 + (n)*0x100)) /* Direction Register */
+#define GPIO_PXDIRS(n)	(GPIO_BASE + (0x64 + (n)*0x100)) /* Direction Set Register */
+#define GPIO_PXDIRC(n)	(GPIO_BASE + (0x68 + (n)*0x100)) /* Direction Clear Register */
+#define GPIO_PXTRG(n)	(GPIO_BASE + (0x70 + (n)*0x100)) /* Trigger Register */
+#define GPIO_PXTRGS(n)	(GPIO_BASE + (0x74 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXTRGC(n)	(GPIO_BASE + (0x78 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXFLG(n)	(GPIO_BASE + (0x80 + (n)*0x100)) /* Port Flag Register */
+#define GPIO_PXFLGC(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Flag Clear Register */
+
+#define REG_GPIO_PXPIN(n)	REG32(GPIO_PXPIN((n)))  /* PIN level */
+#define REG_GPIO_PXDAT(n)	REG32(GPIO_PXDAT((n)))  /* 1: interrupt pending */
+#define REG_GPIO_PXDATS(n)	REG32(GPIO_PXDATS((n)))
+#define REG_GPIO_PXDATC(n)	REG32(GPIO_PXDATC((n)))
+#define REG_GPIO_PXIM(n)	REG32(GPIO_PXIM((n)))   /* 1: mask pin interrupt */
+#define REG_GPIO_PXIMS(n)	REG32(GPIO_PXIMS((n)))
+#define REG_GPIO_PXIMC(n)	REG32(GPIO_PXIMC((n)))
+#define REG_GPIO_PXPE(n)	REG32(GPIO_PXPE((n)))   /* 1: disable pull up/down */
+#define REG_GPIO_PXPES(n)	REG32(GPIO_PXPES((n)))
+#define REG_GPIO_PXPEC(n)	REG32(GPIO_PXPEC((n)))
+#define REG_GPIO_PXFUN(n)	REG32(GPIO_PXFUN((n)))  /* 0:GPIO or intr, 1:FUNC */
+#define REG_GPIO_PXFUNS(n)	REG32(GPIO_PXFUNS((n)))
+#define REG_GPIO_PXFUNC(n)	REG32(GPIO_PXFUNC((n)))
+#define REG_GPIO_PXSEL(n)	REG32(GPIO_PXSEL((n))) /* 0:GPIO/Fun0,1:intr/fun1*/
+#define REG_GPIO_PXSELS(n)	REG32(GPIO_PXSELS((n)))
+#define REG_GPIO_PXSELC(n)	REG32(GPIO_PXSELC((n)))
+#define REG_GPIO_PXDIR(n)	REG32(GPIO_PXDIR((n))) /* 0:input/low-level-trig/falling-edge-trig, 1:output/high-level-trig/rising-edge-trig */
+#define REG_GPIO_PXDIRS(n)	REG32(GPIO_PXDIRS((n)))
+#define REG_GPIO_PXDIRC(n)	REG32(GPIO_PXDIRC((n)))
+#define REG_GPIO_PXTRG(n)	REG32(GPIO_PXTRG((n))) /* 0:level-trigger, 1:edge-trigger */
+#define REG_GPIO_PXTRGS(n)	REG32(GPIO_PXTRGS((n)))
+#define REG_GPIO_PXTRGC(n)	REG32(GPIO_PXTRGC((n)))
+#define REG_GPIO_PXFLG(n)	REG32(GPIO_PXFLG((n))) /* interrupt flag */
+#define REG_GPIO_PXFLGC(n)	REG32(GPIO_PXFLGC((n))) /* interrupt flag */
+
+
+/*************************************************************************
+ * UART
+ *************************************************************************/
+
+#define IRDA_BASE	UART0_BASE
+#define UART_BASE	UART0_BASE
+#define UART_OFF	0x1000
+
+/* Register Offset */
+#define OFF_RDR		(0x00)	/* R  8b H'xx */
+#define OFF_TDR		(0x00)	/* W  8b H'xx */
+#define OFF_DLLR	(0x00)	/* RW 8b H'00 */
+#define OFF_DLHR	(0x04)	/* RW 8b H'00 */
+#define OFF_IER		(0x04)	/* RW 8b H'00 */
+#define OFF_ISR		(0x08)	/* R  8b H'01 */
+#define OFF_FCR		(0x08)	/* W  8b H'00 */
+#define OFF_LCR		(0x0C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_LSR		(0x14)	/* R  8b H'00 */
+#define OFF_MSR		(0x18)	/* R  8b H'00 */
+#define OFF_SPR		(0x1C)	/* RW 8b H'00 */
+#define OFF_SIRCR	(0x20)	/* RW 8b H'00, UART0 */
+#define OFF_UMR		(0x24)	/* RW 8b H'00, UART M Register */
+#define OFF_UACR	(0x28)	/* RW 8b H'00, UART Add Cycle Register */
+
+/* Register Address */
+#define UART0_RDR	(UART0_BASE + OFF_RDR)
+#define UART0_TDR	(UART0_BASE + OFF_TDR)
+#define UART0_DLLR	(UART0_BASE + OFF_DLLR)
+#define UART0_DLHR	(UART0_BASE + OFF_DLHR)
+#define UART0_IER	(UART0_BASE + OFF_IER)
+#define UART0_ISR	(UART0_BASE + OFF_ISR)
+#define UART0_FCR	(UART0_BASE + OFF_FCR)
+#define UART0_LCR	(UART0_BASE + OFF_LCR)
+#define UART0_MCR	(UART0_BASE + OFF_MCR)
+#define UART0_LSR	(UART0_BASE + OFF_LSR)
+#define UART0_MSR	(UART0_BASE + OFF_MSR)
+#define UART0_SPR	(UART0_BASE + OFF_SPR)
+#define UART0_SIRCR	(UART0_BASE + OFF_SIRCR)
+#define UART0_UMR	(UART0_BASE + OFF_UMR)
+#define UART0_UACR	(UART0_BASE + OFF_UACR)
+
+/*
+ * Define macros for UARTIER
+ * UART Interrupt Enable Register
+ */
+#define UARTIER_RIE	(1 << 0)	/* 0: receive fifo full interrupt disable */
+#define UARTIER_TIE	(1 << 1)	/* 0: transmit fifo empty interrupt disable */
+#define UARTIER_RLIE	(1 << 2)	/* 0: receive line status interrupt disable */
+#define UARTIER_MIE	(1 << 3)	/* 0: modem status interrupt disable */
+#define UARTIER_RTIE	(1 << 4)	/* 0: receive timeout interrupt disable */
+
+/*
+ * Define macros for UARTISR
+ * UART Interrupt Status Register
+ */
+#define UARTISR_IP	(1 << 0)	/* 0: interrupt is pending  1: no interrupt */
+#define UARTISR_IID	(7 << 1)	/* Source of Interrupt */
+#define UARTISR_IID_MSI		(0 << 1)  /* Modem status interrupt */
+#define UARTISR_IID_THRI	(1 << 1)  /* Transmitter holding register empty */
+#define UARTISR_IID_RDI		(2 << 1)  /* Receiver data interrupt */
+#define UARTISR_IID_RLSI	(3 << 1)  /* Receiver line status interrupt */
+#define UARTISR_IID_RTO		(6 << 1)  /* Receive timeout */
+#define UARTISR_FFMS		(3 << 6)  /* FIFO mode select, set when UARTFCR.FE is set to 1 */
+#define UARTISR_FFMS_NO_FIFO	(0 << 6)
+#define UARTISR_FFMS_FIFO_MODE	(3 << 6)
+
+/*
+ * Define macros for UARTFCR
+ * UART FIFO Control Register
+ */
+#define UARTFCR_FE	(1 << 0)	/* 0: non-FIFO mode  1: FIFO mode */
+#define UARTFCR_RFLS	(1 << 1)	/* write 1 to flush receive FIFO */
+#define UARTFCR_TFLS	(1 << 2)	/* write 1 to flush transmit FIFO */
+#define UARTFCR_DMS	(1 << 3)	/* 0: disable DMA mode */
+#define UARTFCR_UUE	(1 << 4)	/* 0: disable UART */
+#define UARTFCR_RTRG	(3 << 6)	/* Receive FIFO Data Trigger */
+#define UARTFCR_RTRG_1	(0 << 6)
+#define UARTFCR_RTRG_4	(1 << 6)
+#define UARTFCR_RTRG_8	(2 << 6)
+#define UARTFCR_RTRG_15	(3 << 6)
+
+/*
+ * Define macros for UARTLCR
+ * UART Line Control Register
+ */
+#define UARTLCR_WLEN	(3 << 0)	/* word length */
+#define UARTLCR_WLEN_5	(0 << 0)
+#define UARTLCR_WLEN_6	(1 << 0)
+#define UARTLCR_WLEN_7	(2 << 0)
+#define UARTLCR_WLEN_8	(3 << 0)
+#define UARTLCR_STOP	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UARTLCR_STOP1	(0 << 2)
+#define UARTLCR_STOP2	(1 << 2)
+#define UARTLCR_PE	(1 << 3)	/* 0: parity disable */
+#define UARTLCR_PROE	(1 << 4)	/* 0: even parity  1: odd parity */
+#define UARTLCR_SPAR	(1 << 5)	/* 0: sticky parity disable */
+#define UARTLCR_SBRK	(1 << 6)	/* write 0 normal, write 1 send break */
+#define UARTLCR_DLAB	(1 << 7)	/* 0: access UARTRDR/TDR/IER  1: access UARTDLLR/DLHR */
+
+/*
+ * Define macros for UARTLSR
+ * UART Line Status Register
+ */
+#define UARTLSR_DR	(1 << 0)	/* 0: receive FIFO is empty  1: receive data is ready */
+#define UARTLSR_ORER	(1 << 1)	/* 0: no overrun error */
+#define UARTLSR_PER	(1 << 2)	/* 0: no parity error */
+#define UARTLSR_FER	(1 << 3)	/* 0; no framing error */
+#define UARTLSR_BRK	(1 << 4)	/* 0: no break detected  1: receive a break signal */
+#define UARTLSR_TDRQ	(1 << 5)	/* 1: transmit FIFO half "empty" */
+#define UARTLSR_TEMT	(1 << 6)	/* 1: transmit FIFO and shift registers empty */
+#define UARTLSR_RFER	(1 << 7)	/* 0: no receive error  1: receive error in FIFO mode */
+
+/*
+ * Define macros for UARTMCR
+ * UART Modem Control Register
+ */
+#define UARTMCR_RTS	(1 << 1)	/* 0: RTS_ output high, 1: RTS_ output low */
+#define UARTMCR_LOOP	(1 << 4)	/* 0: normal  1: loopback mode */
+#define UARTMCR_MCE	(1 << 7)	/* 0: modem function is disable */
+
+/*
+ * Define macros for UARTMSR
+ * UART Modem Status Register
+ */
+#define UARTMSR_CCTS	(1 << 0)        /* 1: a change on CTS_ pin */
+#define UARTMSR_CTS	(1 << 4)	/* 0: CTS_ pin is high */
+
+/*
+ * Define macros for SIRCR
+ * Slow IrDA Control Register
+ */
+#define SIRCR_TSIRE	(1 << 0)  /* 0: transmitter is in UART mode  1: SIR mode */
+#define SIRCR_RSIRE	(1 << 1)  /* 0: receiver is in UART mode  1: SIR mode */
+#define SIRCR_TPWS	(1 << 2)  /* 0: transmit 0 pulse width is 3/16 of bit length
+					   1: 0 pulse width is 1.6us for 115.2Kbps */
+#define SIRCR_TDPL	(1 << 3)  /* 0: encoder generates a positive pulse for 0 */
+#define SIRCR_RDPL	(1 << 4)  /* 0: decoder interprets positive pulse as 0 */
+
+
+/*************************************************************************
+ * AIC (AC97/I2S Controller)
+ *************************************************************************/
+#define	AIC_FR			(AIC_BASE + 0x000)
+#define	AIC_CR			(AIC_BASE + 0x004)
+#define	AIC_ACCR1		(AIC_BASE + 0x008)
+#define	AIC_ACCR2		(AIC_BASE + 0x00C)
+#define	AIC_I2SCR		(AIC_BASE + 0x010)
+#define	AIC_SR			(AIC_BASE + 0x014)
+#define	AIC_ACSR		(AIC_BASE + 0x018)
+#define	AIC_I2SSR		(AIC_BASE + 0x01C)
+#define	AIC_ACCAR		(AIC_BASE + 0x020)
+#define	AIC_ACCDR		(AIC_BASE + 0x024)
+#define	AIC_ACSAR		(AIC_BASE + 0x028)
+#define	AIC_ACSDR		(AIC_BASE + 0x02C)
+#define	AIC_I2SDIV		(AIC_BASE + 0x030)
+#define	AIC_DR			(AIC_BASE + 0x034)
+
+#define	REG_AIC_FR		REG32(AIC_FR)
+#define	REG_AIC_CR		REG32(AIC_CR)
+#define	REG_AIC_ACCR1		REG32(AIC_ACCR1)
+#define	REG_AIC_ACCR2		REG32(AIC_ACCR2)
+#define	REG_AIC_I2SCR		REG32(AIC_I2SCR)
+#define	REG_AIC_SR		REG32(AIC_SR)
+#define	REG_AIC_ACSR		REG32(AIC_ACSR)
+#define	REG_AIC_I2SSR		REG32(AIC_I2SSR)
+#define	REG_AIC_ACCAR		REG32(AIC_ACCAR)
+#define	REG_AIC_ACCDR		REG32(AIC_ACCDR)
+#define	REG_AIC_ACSAR		REG32(AIC_ACSAR)
+#define	REG_AIC_ACSDR		REG32(AIC_ACSDR)
+#define	REG_AIC_I2SDIV		REG32(AIC_I2SDIV)
+#define	REG_AIC_DR		REG32(AIC_DR)
+
+/* AIC Controller Configuration Register (AIC_FR) */
+
+#define	AIC_FR_RFTH_BIT		12        /* Receive FIFO Threshold */
+#define	AIC_FR_RFTH_MASK	(0xf << AIC_FR_RFTH_BIT)
+#define	AIC_FR_TFTH_BIT		8         /* Transmit FIFO Threshold */
+#define	AIC_FR_TFTH_MASK	(0xf << AIC_FR_TFTH_BIT)
+#define	AIC_FR_LSMP		(1 << 6)  /* Play Zero sample or last sample */
+#define	AIC_FR_ICDC		(1 << 5)  /* External(0) or Internal CODEC(1) */
+#define	AIC_FR_AUSEL		(1 << 4)  /* AC97(0) or I2S/MSB-justified(1) */
+#define	AIC_FR_RST		(1 << 3)  /* AIC registers reset */
+#define	AIC_FR_BCKD		(1 << 2)  /* I2S BIT_CLK direction, 0:input,1:output */
+#define	AIC_FR_SYNCD		(1 << 1)  /* I2S SYNC direction, 0:input,1:output */
+#define	AIC_FR_ENB		(1 << 0)  /* AIC enable bit */
+
+/* AIC Controller Common Control Register (AIC_CR) */
+
+#define	AIC_CR_OSS_BIT		19  /* Output Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_OSS_MASK		(0x7 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_8BIT	(0x0 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_16BIT	(0x1 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_18BIT	(0x2 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_20BIT	(0x3 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_24BIT	(0x4 << AIC_CR_OSS_BIT)
+#define	AIC_CR_ISS_BIT		16  /* Input Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_ISS_MASK		(0x7 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_8BIT	(0x0 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_16BIT	(0x1 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_18BIT	(0x2 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_20BIT	(0x3 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_24BIT	(0x4 << AIC_CR_ISS_BIT)
+#define	AIC_CR_RDMS		(1 << 15)  /* Receive DMA enable */
+#define	AIC_CR_TDMS		(1 << 14)  /* Transmit DMA enable */
+#define	AIC_CR_M2S		(1 << 11)  /* Mono to Stereo enable */
+#define	AIC_CR_ENDSW		(1 << 10)  /* Endian switch enable */
+#define	AIC_CR_AVSTSU		(1 << 9)   /* Signed <-> Unsigned toggle enable */
+#define	AIC_CR_FLUSH		(1 << 8)   /* Flush FIFO */
+#define	AIC_CR_EROR		(1 << 6)   /* Enable ROR interrupt */
+#define	AIC_CR_ETUR		(1 << 5)   /* Enable TUR interrupt */
+#define	AIC_CR_ERFS		(1 << 4)   /* Enable RFS interrupt */
+#define	AIC_CR_ETFS		(1 << 3)   /* Enable TFS interrupt */
+#define	AIC_CR_ENLBF		(1 << 2)   /* Enable Loopback Function */
+#define	AIC_CR_ERPL		(1 << 1)   /* Enable Playback Function */
+#define	AIC_CR_EREC		(1 << 0)   /* Enable Record Function */
+
+/* AIC Controller AC-link Control Register 1 (AIC_ACCR1) */
+
+#define	AIC_ACCR1_RS_BIT	16          /* Receive Valid Slots */
+#define	AIC_ACCR1_RS_MASK	(0x3ff << AIC_ACCR1_RS_BIT)
+  #define AIC_ACCR1_RS_SLOT12	  (1 << 25) /* Slot 12 valid bit */
+  #define AIC_ACCR1_RS_SLOT11	  (1 << 24) /* Slot 11 valid bit */
+  #define AIC_ACCR1_RS_SLOT10	  (1 << 23) /* Slot 10 valid bit */
+  #define AIC_ACCR1_RS_SLOT9	  (1 << 22) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_RS_SLOT8	  (1 << 21) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_RS_SLOT7	  (1 << 20) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_RS_SLOT6	  (1 << 19) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_RS_SLOT5	  (1 << 18) /* Slot 5 valid bit */
+  #define AIC_ACCR1_RS_SLOT4	  (1 << 17) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_RS_SLOT3	  (1 << 16) /* Slot 3 valid bit, PCM Left */
+#define	AIC_ACCR1_XS_BIT	0          /* Transmit Valid Slots */
+#define	AIC_ACCR1_XS_MASK	(0x3ff << AIC_ACCR1_XS_BIT)
+  #define AIC_ACCR1_XS_SLOT12	  (1 << 9) /* Slot 12 valid bit */
+  #define AIC_ACCR1_XS_SLOT11	  (1 << 8) /* Slot 11 valid bit */
+  #define AIC_ACCR1_XS_SLOT10	  (1 << 7) /* Slot 10 valid bit */
+  #define AIC_ACCR1_XS_SLOT9	  (1 << 6) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_XS_SLOT8	  (1 << 5) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_XS_SLOT7	  (1 << 4) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_XS_SLOT6	  (1 << 3) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_XS_SLOT5	  (1 << 2) /* Slot 5 valid bit */
+  #define AIC_ACCR1_XS_SLOT4	  (1 << 1) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_XS_SLOT3	  (1 << 0) /* Slot 3 valid bit, PCM Left */
+
+/* AIC Controller AC-link Control Register 2 (AIC_ACCR2) */
+
+#define	AIC_ACCR2_ERSTO		(1 << 18) /* Enable RSTO interrupt */
+#define	AIC_ACCR2_ESADR		(1 << 17) /* Enable SADR interrupt */
+#define	AIC_ACCR2_ECADT		(1 << 16) /* Enable CADT interrupt */
+#define	AIC_ACCR2_OASS_BIT	8  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_OASS_MASK	(0x3 << AIC_ACCR2_OASS_BIT)
+  #define AIC_ACCR2_OASS_20BIT	  (0 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_OASS_18BIT	  (1 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_OASS_16BIT	  (2 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_OASS_8BIT	  (3 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_IASS_BIT	6  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_IASS_MASK	(0x3 << AIC_ACCR2_IASS_BIT)
+  #define AIC_ACCR2_IASS_20BIT	  (0 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_IASS_18BIT	  (1 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_IASS_16BIT	  (2 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_IASS_8BIT	  (3 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_SO		(1 << 3)  /* SDATA_OUT output value */
+#define	AIC_ACCR2_SR		(1 << 2)  /* RESET# pin level */
+#define	AIC_ACCR2_SS		(1 << 1)  /* SYNC pin level */
+#define	AIC_ACCR2_SA		(1 << 0)  /* SYNC and SDATA_OUT alternation */
+
+/* AIC Controller I2S/MSB-justified Control Register (AIC_I2SCR) */
+
+#define	AIC_I2SCR_STPBK		(1 << 12) /* Stop BIT_CLK for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_BIT	1  /* Input/Output Sample Size for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_MASK	(0x7 << AIC_I2SCR_WL_BIT)
+  #define AIC_I2SCR_WL_24BIT	  (0 << AIC_I2SCR_WL_BIT) /* Word Length is 24 bit */
+  #define AIC_I2SCR_WL_20BIT	  (1 << AIC_I2SCR_WL_BIT) /* Word Length is 20 bit */
+  #define AIC_I2SCR_WL_18BIT	  (2 << AIC_I2SCR_WL_BIT) /* Word Length is 18 bit */
+  #define AIC_I2SCR_WL_16BIT	  (3 << AIC_I2SCR_WL_BIT) /* Word Length is 16 bit */
+  #define AIC_I2SCR_WL_8BIT	  (4 << AIC_I2SCR_WL_BIT) /* Word Length is 8 bit */
+#define	AIC_I2SCR_AMSL		(1 << 0) /* 0:I2S, 1:MSB-justified */
+
+/* AIC Controller FIFO Status Register (AIC_SR) */
+
+#define	AIC_SR_RFL_BIT		24  /* Receive FIFO Level */
+#define	AIC_SR_RFL_MASK		(0x3f << AIC_SR_RFL_BIT)
+#define	AIC_SR_TFL_BIT		8   /* Transmit FIFO level */
+#define	AIC_SR_TFL_MASK		(0x3f << AIC_SR_TFL_BIT)
+#define	AIC_SR_ROR		(1 << 6) /* Receive FIFO Overrun */
+#define	AIC_SR_TUR		(1 << 5) /* Transmit FIFO Underrun */
+#define	AIC_SR_RFS		(1 << 4) /* Receive FIFO Service Request */
+#define	AIC_SR_TFS		(1 << 3) /* Transmit FIFO Service Request */
+
+/* AIC Controller AC-link Status Register (AIC_ACSR) */
+
+#define	AIC_ACSR_SLTERR		(1 << 21) /* Slot Error Flag */
+#define	AIC_ACSR_CRDY		(1 << 20) /* External CODEC Ready Flag */
+#define	AIC_ACSR_CLPM		(1 << 19) /* External CODEC low power mode flag */
+#define	AIC_ACSR_RSTO		(1 << 18) /* External CODEC regs read status timeout */
+#define	AIC_ACSR_SADR		(1 << 17) /* External CODEC regs status addr and data received */
+#define	AIC_ACSR_CADT		(1 << 16) /* Command Address and Data Transmitted */
+
+/* AIC Controller I2S/MSB-justified Status Register (AIC_I2SSR) */
+
+#define	AIC_I2SSR_BSY		(1 << 2)  /* AIC Busy in I2S/MSB-justified format */
+
+/* AIC Controller AC97 codec Command Address Register (AIC_ACCAR) */
+
+#define	AIC_ACCAR_CAR_BIT	0
+#define	AIC_ACCAR_CAR_MASK	(0xfffff << AIC_ACCAR_CAR_BIT)
+
+/* AIC Controller AC97 codec Command Data Register (AIC_ACCDR) */
+
+#define	AIC_ACCDR_CDR_BIT	0
+#define	AIC_ACCDR_CDR_MASK	(0xfffff << AIC_ACCDR_CDR_BIT)
+
+/* AIC Controller AC97 codec Status Address Register (AIC_ACSAR) */
+
+#define	AIC_ACSAR_SAR_BIT	0
+#define	AIC_ACSAR_SAR_MASK	(0xfffff << AIC_ACSAR_SAR_BIT)
+
+/* AIC Controller AC97 codec Status Data Register (AIC_ACSDR) */
+
+#define	AIC_ACSDR_SDR_BIT	0
+#define	AIC_ACSDR_SDR_MASK	(0xfffff << AIC_ACSDR_SDR_BIT)
+
+/* AIC Controller I2S/MSB-justified Clock Divider Register (AIC_I2SDIV) */
+
+#define	AIC_I2SDIV_DIV_BIT	0
+#define	AIC_I2SDIV_DIV_MASK	(0x7f << AIC_I2SDIV_DIV_BIT)
+  #define AIC_I2SDIV_BITCLK_3072KHZ	(0x0C << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 3.072MHz */
+  #define AIC_I2SDIV_BITCLK_2836KHZ	(0x0D << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 2.836MHz */
+  #define AIC_I2SDIV_BITCLK_1418KHZ	(0x1A << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.418MHz */
+  #define AIC_I2SDIV_BITCLK_1024KHZ	(0x24 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.024MHz */
+  #define AIC_I2SDIV_BITCLK_7089KHZ	(0x34 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 708.92KHz */
+  #define AIC_I2SDIV_BITCLK_512KHZ	(0x48 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 512.00KHz */
+
+
+/*************************************************************************
+ * ICDC (Internal CODEC)
+ *************************************************************************/
+#define	ICDC_CR			(ICDC_BASE + 0x0400)  /* ICDC Control Register */
+#define	ICDC_APWAIT		(ICDC_BASE + 0x0404)  /* Anti-Pop WAIT Stage Timing Control Register */
+#define	ICDC_APPRE		(ICDC_BASE + 0x0408)  /* Anti-Pop HPEN-PRE Stage Timing Control Register */
+#define	ICDC_APHPEN		(ICDC_BASE + 0x040C)  /* Anti-Pop HPEN Stage Timing Control Register */
+#define	ICDC_APSR		(ICDC_BASE + 0x0410)  /* Anti-Pop Status Register */
+#define ICDC_CDCCR1             (ICDC_BASE + 0x0080)
+#define ICDC_CDCCR2             (ICDC_BASE + 0x0084)
+
+#define	REG_ICDC_CR		REG32(ICDC_CR)
+#define	REG_ICDC_APWAIT		REG32(ICDC_APWAIT)
+#define	REG_ICDC_APPRE		REG32(ICDC_APPRE)
+#define	REG_ICDC_APHPEN		REG32(ICDC_APHPEN)
+#define	REG_ICDC_APSR		REG32(ICDC_APSR)
+#define REG_ICDC_CDCCR1         REG32(ICDC_CDCCR1)
+#define REG_ICDC_CDCCR2         REG32(ICDC_CDCCR2)
+
+/* ICDC Control Register */
+#define	ICDC_CR_LINVOL_BIT	24 /* LINE Input Volume Gain: GAIN=LINVOL*1.5-34.5 */
+#define	ICDC_CR_LINVOL_MASK	(0x1f << ICDC_CR_LINVOL_BIT)
+#define	ICDC_CR_ASRATE_BIT	20 /* Audio Sample Rate */
+#define	ICDC_CR_ASRATE_MASK	(0x0f << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_8000	(0x0 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_11025	(0x1 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_12000	(0x2 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_16000	(0x3 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_22050	(0x4 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_24000	(0x5 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_32000	(0x6 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_44100	(0x7 << ICDC_CR_ASRATE_BIT)
+  #define ICDC_CR_ASRATE_48000	(0x8 << ICDC_CR_ASRATE_BIT)
+#define	ICDC_CR_MICBG_BIT	18 /* MIC Boost Gain */
+#define	ICDC_CR_MICBG_MASK	(0x3 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_0DB	(0x0 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_6DB	(0x1 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_12DB	(0x2 << ICDC_CR_MICBG_BIT)
+  #define ICDC_CR_MICBG_20DB	(0x3 << ICDC_CR_MICBG_BIT)
+#define	ICDC_CR_HPVOL_BIT	16 /* Headphone Volume Gain */
+#define	ICDC_CR_HPVOL_MASK	(0x3 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_0DB	(0x0 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_2DB	(0x1 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_4DB	(0x2 << ICDC_CR_HPVOL_BIT)
+  #define ICDC_CR_HPVOL_6DB	(0x3 << ICDC_CR_HPVOL_BIT)
+#define ICDC_CR_ELINEIN		(1 << 13) /* Enable LINE Input */
+#define ICDC_CR_EMIC		(1 << 12) /* Enable MIC Input */
+#define ICDC_CR_SW1ON		(1 << 11) /* Switch 1 in CODEC is on */
+#define ICDC_CR_EADC		(1 << 10) /* Enable ADC */
+#define ICDC_CR_SW2ON		(1 << 9)  /* Switch 2 in CODEC is on */
+#define ICDC_CR_EDAC		(1 << 8)  /* Enable DAC */
+#define ICDC_CR_HPMUTE		(1 << 5)  /* Headphone Mute */
+#define ICDC_CR_HPTON		(1 << 4)  /* Headphone Amplifier Trun On */
+#define ICDC_CR_HPTOFF		(1 << 3)  /* Headphone Amplifier Trun Off */
+#define ICDC_CR_TAAP		(1 << 2)  /* Turn Around of the Anti-Pop Procedure */
+#define ICDC_CR_EAP		(1 << 1)  /* Enable Anti-Pop Procedure */
+#define ICDC_CR_SUSPD		(1 << 0)  /* CODEC Suspend */
+
+/* Anti-Pop WAIT Stage Timing Control Register */
+#define	ICDC_APWAIT_WAITSN_BIT	0
+#define	ICDC_APWAIT_WAITSN_MASK	(0x7ff << ICDC_APWAIT_WAITSN_BIT)
+
+/* Anti-Pop HPEN-PRE Stage Timing Control Register */
+#define	ICDC_APPRE_PRESN_BIT	0
+#define	ICDC_APPRE_PRESN_MASK	(0x1ff << ICDC_APPRE_PRESN_BIT)
+
+/* Anti-Pop HPEN Stage Timing Control Register */
+#define	ICDC_APHPEN_HPENSN_BIT	0
+#define	ICDC_APHPEN_HPENSN_MASK	(0x3fff << ICDC_APHPEN_HPENSN_BIT)
+
+/* Anti-Pop Status Register */
+#define	ICDC_SR_HPST_BIT	14  /* Headphone Amplifier State */
+#define	ICDC_SR_HPST_MASK	(0x7 << ICDC_SR_HPST_BIT)
+#define ICDC_SR_HPST_HP_OFF	 (0x0 << ICDC_SR_HPST_BIT) /* HP amplifier is off */
+#define ICDC_SR_HPST_TON_WAIT	 (0x1 << ICDC_SR_HPST_BIT) /* wait state in turn-on */
+  #define ICDC_SR_HPST_TON_PRE	 (0x2 << ICDC_SR_HPST_BIT) /* pre-enable state in turn-on */
+#define ICDC_SR_HPST_TON_HPEN	 (0x3 << ICDC_SR_HPST_BIT) /* HP enable state in turn-on */
+  #define ICDC_SR_HPST_TOFF_HPEN (0x4 << ICDC_SR_HPST_BIT) /* HP enable state in turn-off */
+  #define ICDC_SR_HPST_TOFF_PRE  (0x5 << ICDC_SR_HPST_BIT) /* pre-enable state in turn-off */
+  #define ICDC_SR_HPST_TOFF_WAIT (0x6 << ICDC_SR_HPST_BIT) /* wait state in turn-off */
+  #define ICDC_SR_HPST_HP_ON	 (0x7 << ICDC_SR_HPST_BIT) /* HP amplifier is on */
+#define	ICDC_SR_SNCNT_BIT	0  /* Sample Number Counter */
+#define	ICDC_SR_SNCNT_MASK	(0x3fff << ICDC_SR_SNCNT_BIT)
+
+
+/*************************************************************************
+ * I2C
+ *************************************************************************/
+#define	I2C_DR			(I2C_BASE + 0x000)
+#define	I2C_CR			(I2C_BASE + 0x004)
+#define	I2C_SR			(I2C_BASE + 0x008)
+#define	I2C_GR			(I2C_BASE + 0x00C)
+
+#define	REG_I2C_DR		REG8(I2C_DR)
+#define	REG_I2C_CR		REG8(I2C_CR)
+#define REG_I2C_SR		REG8(I2C_SR)
+#define REG_I2C_GR		REG16(I2C_GR)
+
+/* I2C Control Register (I2C_CR) */
+
+#define I2C_CR_IEN		(1 << 4)
+#define I2C_CR_STA		(1 << 3)
+#define I2C_CR_STO		(1 << 2)
+#define I2C_CR_AC		(1 << 1)
+#define I2C_CR_I2CE		(1 << 0)
+
+/* I2C Status Register (I2C_SR) */
+
+#define I2C_SR_STX		(1 << 4)
+#define I2C_SR_BUSY		(1 << 3)
+#define I2C_SR_TEND		(1 << 2)
+#define I2C_SR_DRF		(1 << 1)
+#define I2C_SR_ACKF		(1 << 0)
+
+
+/*************************************************************************
+ * SSI
+ *************************************************************************/
+#define	SSI_DR			(SSI_BASE + 0x000)
+#define	SSI_CR0			(SSI_BASE + 0x004)
+#define	SSI_CR1			(SSI_BASE + 0x008)
+#define	SSI_SR			(SSI_BASE + 0x00C)
+#define	SSI_ITR			(SSI_BASE + 0x010)
+#define	SSI_ICR			(SSI_BASE + 0x014)
+#define	SSI_GR			(SSI_BASE + 0x018)
+
+#define	REG_SSI_DR		REG32(SSI_DR)
+#define	REG_SSI_CR0		REG16(SSI_CR0)
+#define	REG_SSI_CR1		REG32(SSI_CR1)
+#define	REG_SSI_SR		REG32(SSI_SR)
+#define	REG_SSI_ITR		REG16(SSI_ITR)
+#define	REG_SSI_ICR		REG8(SSI_ICR)
+#define	REG_SSI_GR		REG16(SSI_GR)
+
+/* SSI Data Register (SSI_DR) */
+
+#define	SSI_DR_GPC_BIT		0
+#define	SSI_DR_GPC_MASK		(0x1ff << SSI_DR_GPC_BIT)
+
+/* SSI Control Register 0 (SSI_CR0) */
+
+#define SSI_CR0_SSIE		(1 << 15)
+#define SSI_CR0_TIE		(1 << 14)
+#define SSI_CR0_RIE		(1 << 13)
+#define SSI_CR0_TEIE		(1 << 12)
+#define SSI_CR0_REIE		(1 << 11)
+#define SSI_CR0_LOOP		(1 << 10)
+#define SSI_CR0_RFINE		(1 << 9)
+#define SSI_CR0_RFINC		(1 << 8)
+#define SSI_CR0_FSEL		(1 << 6)
+#define SSI_CR0_TFLUSH		(1 << 2)
+#define SSI_CR0_RFLUSH		(1 << 1)
+#define SSI_CR0_DISREV		(1 << 0)
+
+/* SSI Control Register 1 (SSI_CR1) */
+
+#define SSI_CR1_FRMHL_BIT	30
+#define SSI_CR1_FRMHL_MASK	(0x3 << SSI_CR1_FRMHL_BIT)
+  #define SSI_CR1_FRMHL_CELOW_CE2LOW	(0 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2LOW	(1 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CELOW_CE2HIGH	(2 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid  and SSI_CE2_ is high valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2HIGH	(3 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is high valid */
+#define SSI_CR1_TFVCK_BIT	28
+#define SSI_CR1_TFVCK_MASK	(0x3 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_0	  (0 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_1	  (1 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_2	  (2 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_3	  (3 << SSI_CR1_TFVCK_BIT)
+#define SSI_CR1_TCKFI_BIT	26
+#define SSI_CR1_TCKFI_MASK	(0x3 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_0	  (0 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_1	  (1 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_2	  (2 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_3	  (3 << SSI_CR1_TCKFI_BIT)
+#define SSI_CR1_LFST		(1 << 25)
+#define SSI_CR1_ITFRM		(1 << 24)
+#define SSI_CR1_UNFIN		(1 << 23)
+#define SSI_CR1_MULTS		(1 << 22)
+#define SSI_CR1_FMAT_BIT	20
+#define SSI_CR1_FMAT_MASK	(0x3 << SSI_CR1_FMAT_BIT)
+  #define SSI_CR1_FMAT_SPI	  (0 << SSI_CR1_FMAT_BIT) /* Motorolas SPI format */
+  #define SSI_CR1_FMAT_SSP	  (1 << SSI_CR1_FMAT_BIT) /* TI's SSP format */
+  #define SSI_CR1_FMAT_MW1	  (2 << SSI_CR1_FMAT_BIT) /* National Microwire 1 format */
+  #define SSI_CR1_FMAT_MW2	  (3 << SSI_CR1_FMAT_BIT) /* National Microwire 2 format */
+#define SSI_CR1_TTRG_BIT	16
+#define SSI_CR1_TTRG_MASK	(0xf << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_1	  (0 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_8	  (1 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_16	  (2 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_24	  (3 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_32	  (4 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_40	  (5 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_48	  (6 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_56	  (7 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_64	  (8 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_72	  (9 << SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_80	  (10<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_88	  (11<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_96	  (12<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_104	  (13<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_112	  (14<< SSI_CR1_TTRG_BIT)
+  #define SSI_CR1_TTRG_120	  (15<< SSI_CR1_TTRG_BIT)
+#define SSI_CR1_MCOM_BIT	12
+#define SSI_CR1_MCOM_MASK	(0xf << SSI_CR1_MCOM_BIT)
+  #define SSI_CR1_MCOM_1BIT	  (0x0 << SSI_CR1_MCOM_BIT) /* 1-bit command selected */
+  #define SSI_CR1_MCOM_2BIT	  (0x1 << SSI_CR1_MCOM_BIT) /* 2-bit command selected */
+  #define SSI_CR1_MCOM_3BIT	  (0x2 << SSI_CR1_MCOM_BIT) /* 3-bit command selected */
+  #define SSI_CR1_MCOM_4BIT	  (0x3 << SSI_CR1_MCOM_BIT) /* 4-bit command selected */
+  #define SSI_CR1_MCOM_5BIT	  (0x4 << SSI_CR1_MCOM_BIT) /* 5-bit command selected */
+  #define SSI_CR1_MCOM_6BIT	  (0x5 << SSI_CR1_MCOM_BIT) /* 6-bit command selected */
+  #define SSI_CR1_MCOM_7BIT	  (0x6 << SSI_CR1_MCOM_BIT) /* 7-bit command selected */
+  #define SSI_CR1_MCOM_8BIT	  (0x7 << SSI_CR1_MCOM_BIT) /* 8-bit command selected */
+  #define SSI_CR1_MCOM_9BIT	  (0x8 << SSI_CR1_MCOM_BIT) /* 9-bit command selected */
+  #define SSI_CR1_MCOM_10BIT	  (0x9 << SSI_CR1_MCOM_BIT) /* 10-bit command selected */
+  #define SSI_CR1_MCOM_11BIT	  (0xA << SSI_CR1_MCOM_BIT) /* 11-bit command selected */
+  #define SSI_CR1_MCOM_12BIT	  (0xB << SSI_CR1_MCOM_BIT) /* 12-bit command selected */
+  #define SSI_CR1_MCOM_13BIT	  (0xC << SSI_CR1_MCOM_BIT) /* 13-bit command selected */
+  #define SSI_CR1_MCOM_14BIT	  (0xD << SSI_CR1_MCOM_BIT) /* 14-bit command selected */
+  #define SSI_CR1_MCOM_15BIT	  (0xE << SSI_CR1_MCOM_BIT) /* 15-bit command selected */
+  #define SSI_CR1_MCOM_16BIT	  (0xF << SSI_CR1_MCOM_BIT) /* 16-bit command selected */
+#define SSI_CR1_RTRG_BIT	8
+#define SSI_CR1_RTRG_MASK	(0xf << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_1	  (0 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_8	  (1 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_16	  (2 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_24	  (3 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_32	  (4 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_40	  (5 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_48	  (6 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_56	  (7 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_64	  (8 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_72	  (9 << SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_80	  (10<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_88	  (11<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_96	  (12<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_104	  (13<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_112	  (14<< SSI_CR1_RTRG_BIT)
+  #define SSI_CR1_RTRG_120	  (15<< SSI_CR1_RTRG_BIT)
+#define SSI_CR1_FLEN_BIT	4
+#define SSI_CR1_FLEN_MASK	(0xf << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_2BIT	  (0x0 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_3BIT	  (0x1 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_4BIT	  (0x2 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_5BIT	  (0x3 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_6BIT	  (0x4 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_7BIT	  (0x5 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_8BIT	  (0x6 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_9BIT	  (0x7 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_10BIT	  (0x8 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_11BIT	  (0x9 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_12BIT	  (0xA << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_13BIT	  (0xB << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_14BIT	  (0xC << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_15BIT	  (0xD << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_16BIT	  (0xE << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_17BIT	  (0xF << SSI_CR1_FLEN_BIT)
+#define SSI_CR1_PHA		(1 << 1)
+#define SSI_CR1_POL		(1 << 0)
+
+/* SSI Status Register (SSI_SR) */
+
+#define SSI_SR_TFIFONUM_BIT	16
+#define SSI_SR_TFIFONUM_MASK	(0xff << SSI_SR_TFIFONUM_BIT)
+#define SSI_SR_RFIFONUM_BIT	8
+#define SSI_SR_RFIFONUM_MASK	(0xff << SSI_SR_RFIFONUM_BIT)
+#define SSI_SR_END		(1 << 7)
+#define SSI_SR_BUSY		(1 << 6)
+#define SSI_SR_TFF		(1 << 5)
+#define SSI_SR_RFE		(1 << 4)
+#define SSI_SR_TFHE		(1 << 3)
+#define SSI_SR_RFHF		(1 << 2)
+#define SSI_SR_UNDR		(1 << 1)
+#define SSI_SR_OVER		(1 << 0)
+
+/* SSI Interval Time Control Register (SSI_ITR) */
+
+#define	SSI_ITR_CNTCLK		(1 << 15)
+#define SSI_ITR_IVLTM_BIT	0
+#define SSI_ITR_IVLTM_MASK	(0x7fff << SSI_ITR_IVLTM_BIT)
+
+
+/*************************************************************************
+ * MSC
+ *************************************************************************/
+#define	MSC_STRPCL		(MSC_BASE + 0x000)
+#define	MSC_STAT		(MSC_BASE + 0x004)
+#define	MSC_CLKRT		(MSC_BASE + 0x008)
+#define	MSC_CMDAT		(MSC_BASE + 0x00C)
+#define	MSC_RESTO		(MSC_BASE + 0x010)
+#define	MSC_RDTO		(MSC_BASE + 0x014)
+#define	MSC_BLKLEN		(MSC_BASE + 0x018)
+#define	MSC_NOB			(MSC_BASE + 0x01C)
+#define	MSC_SNOB		(MSC_BASE + 0x020)
+#define	MSC_IMASK		(MSC_BASE + 0x024)
+#define	MSC_IREG		(MSC_BASE + 0x028)
+#define	MSC_CMD			(MSC_BASE + 0x02C)
+#define	MSC_ARG			(MSC_BASE + 0x030)
+#define	MSC_RES			(MSC_BASE + 0x034)
+#define	MSC_RXFIFO		(MSC_BASE + 0x038)
+#define	MSC_TXFIFO		(MSC_BASE + 0x03C)
+
+#define	REG_MSC_STRPCL		REG16(MSC_STRPCL)
+#define	REG_MSC_STAT		REG32(MSC_STAT)
+#define	REG_MSC_CLKRT		REG16(MSC_CLKRT)
+#define	REG_MSC_CMDAT		REG32(MSC_CMDAT)
+#define	REG_MSC_RESTO		REG16(MSC_RESTO)
+#define	REG_MSC_RDTO		REG16(MSC_RDTO)
+#define	REG_MSC_BLKLEN		REG16(MSC_BLKLEN)
+#define	REG_MSC_NOB		REG16(MSC_NOB)
+#define	REG_MSC_SNOB		REG16(MSC_SNOB)
+#define	REG_MSC_IMASK		REG16(MSC_IMASK)
+#define	REG_MSC_IREG		REG16(MSC_IREG)
+#define	REG_MSC_CMD		REG8(MSC_CMD)
+#define	REG_MSC_ARG		REG32(MSC_ARG)
+#define	REG_MSC_RES		REG16(MSC_RES)
+#define	REG_MSC_RXFIFO		REG32(MSC_RXFIFO)
+#define	REG_MSC_TXFIFO		REG32(MSC_TXFIFO)
+
+/* MSC Clock and Control Register (MSC_STRPCL) */
+
+#define MSC_STRPCL_EXIT_MULTIPLE	(1 << 7)
+#define MSC_STRPCL_EXIT_TRANSFER	(1 << 6)
+#define MSC_STRPCL_START_READWAIT	(1 << 5)
+#define MSC_STRPCL_STOP_READWAIT	(1 << 4)
+#define MSC_STRPCL_RESET		(1 << 3)
+#define MSC_STRPCL_START_OP		(1 << 2)
+#define MSC_STRPCL_CLOCK_CONTROL_BIT	0
+#define MSC_STRPCL_CLOCK_CONTROL_MASK	(0x3 << MSC_STRPCL_CLOCK_CONTROL_BIT)
+  #define MSC_STRPCL_CLOCK_CONTROL_STOP	  (0x1 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Stop MMC/SD clock */
+  #define MSC_STRPCL_CLOCK_CONTROL_START  (0x2 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Start MMC/SD clock */
+
+/* MSC Status Register (MSC_STAT) */
+
+#define MSC_STAT_IS_RESETTING		(1 << 15)
+#define MSC_STAT_SDIO_INT_ACTIVE	(1 << 14)
+#define MSC_STAT_PRG_DONE		(1 << 13)
+#define MSC_STAT_DATA_TRAN_DONE		(1 << 12)
+#define MSC_STAT_END_CMD_RES		(1 << 11)
+#define MSC_STAT_DATA_FIFO_AFULL	(1 << 10)
+#define MSC_STAT_IS_READWAIT		(1 << 9)
+#define MSC_STAT_CLK_EN			(1 << 8)
+#define MSC_STAT_DATA_FIFO_FULL		(1 << 7)
+#define MSC_STAT_DATA_FIFO_EMPTY	(1 << 6)
+#define MSC_STAT_CRC_RES_ERR		(1 << 5)
+#define MSC_STAT_CRC_READ_ERROR		(1 << 4)
+#define MSC_STAT_CRC_WRITE_ERROR_BIT	2
+#define MSC_STAT_CRC_WRITE_ERROR_MASK	(0x3 << MSC_STAT_CRC_WRITE_ERROR_BIT)
+  #define MSC_STAT_CRC_WRITE_ERROR_NO		(0 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No error on transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR		(1 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* Card observed erroneous transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR_NOSTS	(2 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No CRC status is sent back */
+#define MSC_STAT_TIME_OUT_RES		(1 << 1)
+#define MSC_STAT_TIME_OUT_READ		(1 << 0)
+
+/* MSC Bus Clock Control Register (MSC_CLKRT) */
+
+#define	MSC_CLKRT_CLK_RATE_BIT		0
+#define	MSC_CLKRT_CLK_RATE_MASK		(0x7 << MSC_CLKRT_CLK_RATE_BIT)
+  #define MSC_CLKRT_CLK_RATE_DIV_1	  (0x0 << MSC_CLKRT_CLK_RATE_BIT) /* CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_2	  (0x1 << MSC_CLKRT_CLK_RATE_BIT) /* 1/2 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_4	  (0x2 << MSC_CLKRT_CLK_RATE_BIT) /* 1/4 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_8	  (0x3 << MSC_CLKRT_CLK_RATE_BIT) /* 1/8 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_16	  (0x4 << MSC_CLKRT_CLK_RATE_BIT) /* 1/16 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_32	  (0x5 << MSC_CLKRT_CLK_RATE_BIT) /* 1/32 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_64	  (0x6 << MSC_CLKRT_CLK_RATE_BIT) /* 1/64 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_128	  (0x7 << MSC_CLKRT_CLK_RATE_BIT) /* 1/128 of CLK_SRC */
+
+/* MSC Command Sequence Control Register (MSC_CMDAT) */
+
+#define	MSC_CMDAT_IO_ABORT		(1 << 11)
+#define	MSC_CMDAT_BUS_WIDTH_BIT		9
+#define	MSC_CMDAT_BUS_WIDTH_MASK	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define MSC_CMDAT_BUS_WIDTH_1BIT	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT) /* 1-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_4BIT	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT) /* 4-bit data bus */
+  #define CMDAT_BUS_WIDTH1	  (0x0 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define CMDAT_BUS_WIDTH4	  (0x2 << MSC_CMDAT_BUS_WIDTH_BIT)
+#define	MSC_CMDAT_DMA_EN		(1 << 8)
+#define	MSC_CMDAT_INIT			(1 << 7)
+#define	MSC_CMDAT_BUSY			(1 << 6)
+#define	MSC_CMDAT_STREAM_BLOCK		(1 << 5)
+#define	MSC_CMDAT_WRITE			(1 << 4)
+#define	MSC_CMDAT_READ			(0 << 4)
+#define	MSC_CMDAT_DATA_EN		(1 << 3)
+#define	MSC_CMDAT_RESPONSE_BIT	0
+#define	MSC_CMDAT_RESPONSE_MASK	(0x7 << MSC_CMDAT_RESPONSE_BIT)
+  #define MSC_CMDAT_RESPONSE_NONE  (0x0 << MSC_CMDAT_RESPONSE_BIT) /* No response */
+  #define MSC_CMDAT_RESPONSE_R1	  (0x1 << MSC_CMDAT_RESPONSE_BIT) /* Format R1 and R1b */
+  #define MSC_CMDAT_RESPONSE_R2	  (0x2 << MSC_CMDAT_RESPONSE_BIT) /* Format R2 */
+  #define MSC_CMDAT_RESPONSE_R3	  (0x3 << MSC_CMDAT_RESPONSE_BIT) /* Format R3 */
+  #define MSC_CMDAT_RESPONSE_R4	  (0x4 << MSC_CMDAT_RESPONSE_BIT) /* Format R4 */
+  #define MSC_CMDAT_RESPONSE_R5	  (0x5 << MSC_CMDAT_RESPONSE_BIT) /* Format R5 */
+  #define MSC_CMDAT_RESPONSE_R6	  (0x6 << MSC_CMDAT_RESPONSE_BIT) /* Format R6 */
+
+#define	CMDAT_DMA_EN	(1 << 8)
+#define	CMDAT_INIT	(1 << 7)
+#define	CMDAT_BUSY	(1 << 6)
+#define	CMDAT_STREAM	(1 << 5)
+#define	CMDAT_WRITE	(1 << 4)
+#define	CMDAT_DATA_EN	(1 << 3)
+
+/* MSC Interrupts Mask Register (MSC_IMASK) */
+
+#define	MSC_IMASK_SDIO			(1 << 7)
+#define	MSC_IMASK_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IMASK_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IMASK_END_CMD_RES		(1 << 2)
+#define	MSC_IMASK_PRG_DONE		(1 << 1)
+#define	MSC_IMASK_DATA_TRAN_DONE	(1 << 0)
+
+
+/* MSC Interrupts Status Register (MSC_IREG) */
+
+#define	MSC_IREG_SDIO			(1 << 7)
+#define	MSC_IREG_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IREG_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IREG_END_CMD_RES		(1 << 2)
+#define	MSC_IREG_PRG_DONE		(1 << 1)
+#define	MSC_IREG_DATA_TRAN_DONE		(1 << 0)
+
+
+/*************************************************************************
+ * EMC (External Memory Controller)
+ *************************************************************************/
+#define EMC_SMCR0	(EMC_BASE + 0x10)  /* Static Memory Control Register 0 */
+#define EMC_SMCR1	(EMC_BASE + 0x14)  /* Static Memory Control Register 1 */
+#define EMC_SMCR2	(EMC_BASE + 0x18)  /* Static Memory Control Register 2 */
+#define EMC_SMCR3	(EMC_BASE + 0x1c)  /* Static Memory Control Register 3 */
+#define EMC_SMCR4	(EMC_BASE + 0x20)  /* Static Memory Control Register 4 */
+#define EMC_SACR0	(EMC_BASE + 0x30)  /* Static Memory Bank 0 Addr Config Reg */
+#define EMC_SACR1	(EMC_BASE + 0x34)  /* Static Memory Bank 1 Addr Config Reg */
+#define EMC_SACR2	(EMC_BASE + 0x38)  /* Static Memory Bank 2 Addr Config Reg */
+#define EMC_SACR3	(EMC_BASE + 0x3c)  /* Static Memory Bank 3 Addr Config Reg */
+#define EMC_SACR4	(EMC_BASE + 0x40)  /* Static Memory Bank 4 Addr Config Reg */
+
+#define EMC_NFCSR	(EMC_BASE + 0x050) /* NAND Flash Control/Status Register */
+#define EMC_NFECR	(EMC_BASE + 0x100) /* NAND Flash ECC Control Register */
+#define EMC_NFECC	(EMC_BASE + 0x104) /* NAND Flash ECC Data Register */
+#define EMC_NFPAR0	(EMC_BASE + 0x108) /* NAND Flash RS Parity 0 Register */
+#define EMC_NFPAR1	(EMC_BASE + 0x10c) /* NAND Flash RS Parity 1 Register */
+#define EMC_NFPAR2	(EMC_BASE + 0x110) /* NAND Flash RS Parity 2 Register */
+#define EMC_NFINTS	(EMC_BASE + 0x114) /* NAND Flash Interrupt Status Register */
+#define EMC_NFINTE	(EMC_BASE + 0x118) /* NAND Flash Interrupt Enable Register */
+#define EMC_NFERR0	(EMC_BASE + 0x11c) /* NAND Flash RS Error Report 0 Register */
+#define EMC_NFERR1	(EMC_BASE + 0x120) /* NAND Flash RS Error Report 1 Register */
+#define EMC_NFERR2	(EMC_BASE + 0x124) /* NAND Flash RS Error Report 2 Register */
+#define EMC_NFERR3	(EMC_BASE + 0x128) /* NAND Flash RS Error Report 3 Register */
+
+#define EMC_DMCR	(EMC_BASE + 0x80)  /* DRAM Control Register */
+#define EMC_RTCSR	(EMC_BASE + 0x84)  /* Refresh Time Control/Status Register */
+#define EMC_RTCNT	(EMC_BASE + 0x88)  /* Refresh Timer Counter */
+#define EMC_RTCOR	(EMC_BASE + 0x8c)  /* Refresh Time Constant Register */
+#define EMC_DMAR0	(EMC_BASE + 0x90)  /* SDRAM Bank 0 Addr Config Register */
+#define EMC_SDMR0	(EMC_BASE + 0xa000) /* Mode Register of SDRAM bank 0 */
+
+
+#define REG_EMC_SMCR0	REG32(EMC_SMCR0)
+#define REG_EMC_SMCR1	REG32(EMC_SMCR1)
+#define REG_EMC_SMCR2	REG32(EMC_SMCR2)
+#define REG_EMC_SMCR3	REG32(EMC_SMCR3)
+#define REG_EMC_SMCR4	REG32(EMC_SMCR4)
+#define REG_EMC_SACR0	REG32(EMC_SACR0)
+#define REG_EMC_SACR1	REG32(EMC_SACR1)
+#define REG_EMC_SACR2	REG32(EMC_SACR2)
+#define REG_EMC_SACR3	REG32(EMC_SACR3)
+#define REG_EMC_SACR4	REG32(EMC_SACR4)
+
+#define REG_EMC_NFCSR	REG32(EMC_NFCSR)
+#define REG_EMC_NFECR	REG32(EMC_NFECR)
+#define REG_EMC_NFECC	REG32(EMC_NFECC)
+#define REG_EMC_NFPAR0	REG32(EMC_NFPAR0)
+#define REG_EMC_NFPAR1	REG32(EMC_NFPAR1)
+#define REG_EMC_NFPAR2	REG32(EMC_NFPAR2)
+#define REG_EMC_NFINTS	REG32(EMC_NFINTS)
+#define REG_EMC_NFINTE	REG32(EMC_NFINTE)
+#define REG_EMC_NFERR0	REG32(EMC_NFERR0)
+#define REG_EMC_NFERR1	REG32(EMC_NFERR1)
+#define REG_EMC_NFERR2	REG32(EMC_NFERR2)
+#define REG_EMC_NFERR3	REG32(EMC_NFERR3)
+
+#define REG_EMC_DMCR	REG32(EMC_DMCR)
+#define REG_EMC_RTCSR	REG16(EMC_RTCSR)
+#define REG_EMC_RTCNT	REG16(EMC_RTCNT)
+#define REG_EMC_RTCOR	REG16(EMC_RTCOR)
+#define REG_EMC_DMAR0	REG32(EMC_DMAR0)
+
+/* Static Memory Control Register */
+#define EMC_SMCR_STRV_BIT	24
+#define EMC_SMCR_STRV_MASK	(0x0f << EMC_SMCR_STRV_BIT)
+#define EMC_SMCR_TAW_BIT	20
+#define EMC_SMCR_TAW_MASK	(0x0f << EMC_SMCR_TAW_BIT)
+#define EMC_SMCR_TBP_BIT	16
+#define EMC_SMCR_TBP_MASK	(0x0f << EMC_SMCR_TBP_BIT)
+#define EMC_SMCR_TAH_BIT	12
+#define EMC_SMCR_TAH_MASK	(0x07 << EMC_SMCR_TAH_BIT)
+#define EMC_SMCR_TAS_BIT	8
+#define EMC_SMCR_TAS_MASK	(0x07 << EMC_SMCR_TAS_BIT)
+#define EMC_SMCR_BW_BIT		6
+#define EMC_SMCR_BW_MASK	(0x03 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_8BIT	(0 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_16BIT	(1 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_32BIT	(2 << EMC_SMCR_BW_BIT)
+#define EMC_SMCR_BCM		(1 << 3)
+#define EMC_SMCR_BL_BIT		1
+#define EMC_SMCR_BL_MASK	(0x03 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_4		(0 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_8		(1 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_16	(2 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_32	(3 << EMC_SMCR_BL_BIT)
+#define EMC_SMCR_SMT		(1 << 0)
+
+/* Static Memory Bank Addr Config Reg */
+#define EMC_SACR_BASE_BIT	8
+#define EMC_SACR_BASE_MASK	(0xff << EMC_SACR_BASE_BIT)
+#define EMC_SACR_MASK_BIT	0
+#define EMC_SACR_MASK_MASK	(0xff << EMC_SACR_MASK_BIT)
+
+/* NAND Flash Control/Status Register */
+#define EMC_NFCSR_NFCE4		(1 << 7) /* NAND Flash Enable */
+#define EMC_NFCSR_NFE4		(1 << 6) /* NAND Flash FCE# Assertion Enable */
+#define EMC_NFCSR_NFCE3		(1 << 5)
+#define EMC_NFCSR_NFE3		(1 << 4)
+#define EMC_NFCSR_NFCE2		(1 << 3)
+#define EMC_NFCSR_NFE2		(1 << 2)
+#define EMC_NFCSR_NFCE1		(1 << 1)
+#define EMC_NFCSR_NFE1		(1 << 0)
+
+/* NAND Flash ECC Control Register */
+#define EMC_NFECR_PRDY		(1 << 4) /* Parity Ready */
+#define EMC_NFECR_RS_DECODING	(0 << 3) /* RS is in decoding phase */
+#define EMC_NFECR_RS_ENCODING	(1 << 3) /* RS is in encoding phase */
+#define EMC_NFECR_HAMMING	(0 << 2) /* Select HAMMING Correction Algorithm */
+#define EMC_NFECR_RS		(1 << 2) /* Select RS Correction Algorithm */
+#define EMC_NFECR_ERST		(1 << 1) /* ECC Reset */
+#define EMC_NFECR_ECCE		(1 << 0) /* ECC Enable */
+
+/* NAND Flash ECC Data Register */
+#define EMC_NFECC_ECC2_BIT	16
+#define EMC_NFECC_ECC2_MASK	(0xff << EMC_NFECC_ECC2_BIT)
+#define EMC_NFECC_ECC1_BIT	8
+#define EMC_NFECC_ECC1_MASK	(0xff << EMC_NFECC_ECC1_BIT)
+#define EMC_NFECC_ECC0_BIT	0
+#define EMC_NFECC_ECC0_MASK	(0xff << EMC_NFECC_ECC0_BIT)
+
+/* NAND Flash Interrupt Status Register */
+#define EMC_NFINTS_ERRCNT_BIT	29       /* Error Count */
+#define EMC_NFINTS_ERRCNT_MASK	(0x7 << EMC_NFINTS_ERRCNT_BIT)
+#define EMC_NFINTS_PADF		(1 << 4) /* Padding Finished */
+#define EMC_NFINTS_DECF		(1 << 3) /* Decoding Finished */
+#define EMC_NFINTS_ENCF		(1 << 2) /* Encoding Finished */
+#define EMC_NFINTS_UNCOR	(1 << 1) /* Uncorrectable Error Occurred */
+#define EMC_NFINTS_ERR		(1 << 0) /* Error Occurred */
+
+/* NAND Flash Interrupt Enable Register */
+#define EMC_NFINTE_PADFE	(1 << 4) /* Padding Finished Interrupt Enable */
+#define EMC_NFINTE_DECFE	(1 << 3) /* Decoding Finished Interrupt Enable */
+#define EMC_NFINTE_ENCFE	(1 << 2) /* Encoding Finished Interrupt Enable */
+#define EMC_NFINTE_UNCORE	(1 << 1) /* Uncorrectable Error Occurred Intr Enable */
+#define EMC_NFINTE_ERRE		(1 << 0) /* Error Occurred Interrupt */
+
+/* NAND Flash RS Error Report Register */
+#define EMC_NFERR_INDEX_BIT	16       /* Error Symbol Index */
+#define EMC_NFERR_INDEX_MASK	(0x1ff << EMC_NFERR_INDEX_BIT)
+#define EMC_NFERR_MASK_BIT	0        /* Error Symbol Value */
+#define EMC_NFERR_MASK_MASK	(0x1ff << EMC_NFERR_MASK_BIT)
+
+
+/* DRAM Control Register */
+#define EMC_DMCR_BW_BIT		31
+#define EMC_DMCR_BW		(1 << EMC_DMCR_BW_BIT)
+#define EMC_DMCR_CA_BIT		26
+#define EMC_DMCR_CA_MASK	(0x07 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_8		(0 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_9		(1 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_10	(2 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_11	(3 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_12	(4 << EMC_DMCR_CA_BIT)
+#define EMC_DMCR_RMODE		(1 << 25)
+#define EMC_DMCR_RFSH		(1 << 24)
+#define EMC_DMCR_MRSET		(1 << 23)
+#define EMC_DMCR_RA_BIT		20
+#define EMC_DMCR_RA_MASK	(0x03 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_11	(0 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_12	(1 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_13	(2 << EMC_DMCR_RA_BIT)
+#define EMC_DMCR_BA_BIT		19
+#define EMC_DMCR_BA		(1 << EMC_DMCR_BA_BIT)
+#define EMC_DMCR_PDM		(1 << 18)
+#define EMC_DMCR_EPIN		(1 << 17)
+#define EMC_DMCR_TRAS_BIT	13
+#define EMC_DMCR_TRAS_MASK	(0x07 << EMC_DMCR_TRAS_BIT)
+#define EMC_DMCR_RCD_BIT	11
+#define EMC_DMCR_RCD_MASK	(0x03 << EMC_DMCR_RCD_BIT)
+#define EMC_DMCR_TPC_BIT	8
+#define EMC_DMCR_TPC_MASK	(0x07 << EMC_DMCR_TPC_BIT)
+#define EMC_DMCR_TRWL_BIT	5
+#define EMC_DMCR_TRWL_MASK	(0x03 << EMC_DMCR_TRWL_BIT)
+#define EMC_DMCR_TRC_BIT	2
+#define EMC_DMCR_TRC_MASK	(0x07 << EMC_DMCR_TRC_BIT)
+#define EMC_DMCR_TCL_BIT	0
+#define EMC_DMCR_TCL_MASK	(0x03 << EMC_DMCR_TCL_BIT)
+
+/* Refresh Time Control/Status Register */
+#define EMC_RTCSR_CMF		(1 << 7)
+#define EMC_RTCSR_CKS_BIT	0
+#define EMC_RTCSR_CKS_MASK	(0x07 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_DISABLE	(0 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4	(1 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_16	(2 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_64	(3 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_256	(4 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_1024	(5 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_2048	(6 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4096	(7 << EMC_RTCSR_CKS_BIT)
+
+/* SDRAM Bank Address Configuration Register */
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_BIT	0
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+/* Mode Register of SDRAM bank 0 */
+#define EMC_SDMR_BM		(1 << 9) /* Write Burst Mode */
+#define EMC_SDMR_OM_BIT		7        /* Operating Mode */
+#define EMC_SDMR_OM_MASK	(3 << EMC_SDMR_OM_BIT)
+  #define EMC_SDMR_OM_NORMAL	(0 << EMC_SDMR_OM_BIT)
+#define EMC_SDMR_CAS_BIT	4        /* CAS Latency */
+#define EMC_SDMR_CAS_MASK	(7 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_1	(1 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_2	(2 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_3	(3 << EMC_SDMR_CAS_BIT)
+#define EMC_SDMR_BT_BIT		3        /* Burst Type */
+#define EMC_SDMR_BT_MASK	(1 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_SEQ	(0 << EMC_SDMR_BT_BIT) /* Sequential */
+  #define EMC_SDMR_BT_INT	(1 << EMC_SDMR_BT_BIT) /* Interleave */
+#define EMC_SDMR_BL_BIT		0        /* Burst Length */
+#define EMC_SDMR_BL_MASK	(7 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_1		(0 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_2		(1 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_4		(2 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_8		(3 << EMC_SDMR_BL_BIT)
+
+#define EMC_SDMR_CAS2_16BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS2_32BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+#define EMC_SDMR_CAS3_16BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS3_32BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+
+
+/*************************************************************************
+ * CIM
+ *************************************************************************/
+#define	CIM_CFG			(CIM_BASE + 0x0000)
+#define	CIM_CTRL		(CIM_BASE + 0x0004)
+#define	CIM_STATE		(CIM_BASE + 0x0008)
+#define	CIM_IID			(CIM_BASE + 0x000C)
+#define	CIM_RXFIFO		(CIM_BASE + 0x0010)
+#define	CIM_DA			(CIM_BASE + 0x0020)
+#define	CIM_FA			(CIM_BASE + 0x0024)
+#define	CIM_FID			(CIM_BASE + 0x0028)
+#define	CIM_CMD			(CIM_BASE + 0x002C)
+
+#define	REG_CIM_CFG		REG32(CIM_CFG)
+#define	REG_CIM_CTRL		REG32(CIM_CTRL)
+#define	REG_CIM_STATE		REG32(CIM_STATE)
+#define	REG_CIM_IID		REG32(CIM_IID)
+#define	REG_CIM_RXFIFO		REG32(CIM_RXFIFO)
+#define	REG_CIM_DA		REG32(CIM_DA)
+#define	REG_CIM_FA		REG32(CIM_FA)
+#define	REG_CIM_FID		REG32(CIM_FID)
+#define	REG_CIM_CMD		REG32(CIM_CMD)
+
+/* CIM Configuration Register  (CIM_CFG) */
+
+#define	CIM_CFG_INV_DAT		(1 << 15)
+#define	CIM_CFG_VSP		(1 << 14)
+#define	CIM_CFG_HSP		(1 << 13)
+#define	CIM_CFG_PCP		(1 << 12)
+#define	CIM_CFG_DUMMY_ZERO	(1 << 9)
+#define	CIM_CFG_EXT_VSYNC	(1 << 8)
+#define	CIM_CFG_PACK_BIT	4
+#define	CIM_CFG_PACK_MASK	(0x7 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_0	  (0 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_1	  (1 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_2	  (2 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_3	  (3 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_4	  (4 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_5	  (5 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_6	  (6 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_7	  (7 << CIM_CFG_PACK_BIT)
+#define	CIM_CFG_DSM_BIT		0
+#define	CIM_CFG_DSM_MASK	(0x3 << CIM_CFG_DSM_BIT)
+  #define CIM_CFG_DSM_CPM	  (0 << CIM_CFG_DSM_BIT) /* CCIR656 Progressive Mode */
+  #define CIM_CFG_DSM_CIM	  (1 << CIM_CFG_DSM_BIT) /* CCIR656 Interlace Mode */
+  #define CIM_CFG_DSM_GCM	  (2 << CIM_CFG_DSM_BIT) /* Gated Clock Mode */
+  #define CIM_CFG_DSM_NGCM	  (3 << CIM_CFG_DSM_BIT) /* Non-Gated Clock Mode */
+
+/* CIM Control Register  (CIM_CTRL) */
+
+#define	CIM_CTRL_MCLKDIV_BIT	24
+#define	CIM_CTRL_MCLKDIV_MASK	(0xff << CIM_CTRL_MCLKDIV_BIT)
+#define	CIM_CTRL_FRC_BIT	16
+#define	CIM_CTRL_FRC_MASK	(0xf << CIM_CTRL_FRC_BIT)
+  #define CIM_CTRL_FRC_1	  (0x0 << CIM_CTRL_FRC_BIT) /* Sample every frame */
+  #define CIM_CTRL_FRC_2	  (0x1 << CIM_CTRL_FRC_BIT) /* Sample 1/2 frame */
+  #define CIM_CTRL_FRC_3	  (0x2 << CIM_CTRL_FRC_BIT) /* Sample 1/3 frame */
+  #define CIM_CTRL_FRC_4	  (0x3 << CIM_CTRL_FRC_BIT) /* Sample 1/4 frame */
+  #define CIM_CTRL_FRC_5	  (0x4 << CIM_CTRL_FRC_BIT) /* Sample 1/5 frame */
+  #define CIM_CTRL_FRC_6	  (0x5 << CIM_CTRL_FRC_BIT) /* Sample 1/6 frame */
+  #define CIM_CTRL_FRC_7	  (0x6 << CIM_CTRL_FRC_BIT) /* Sample 1/7 frame */
+  #define CIM_CTRL_FRC_8	  (0x7 << CIM_CTRL_FRC_BIT) /* Sample 1/8 frame */
+  #define CIM_CTRL_FRC_9	  (0x8 << CIM_CTRL_FRC_BIT) /* Sample 1/9 frame */
+  #define CIM_CTRL_FRC_10	  (0x9 << CIM_CTRL_FRC_BIT) /* Sample 1/10 frame */
+  #define CIM_CTRL_FRC_11	  (0xA << CIM_CTRL_FRC_BIT) /* Sample 1/11 frame */
+  #define CIM_CTRL_FRC_12	  (0xB << CIM_CTRL_FRC_BIT) /* Sample 1/12 frame */
+  #define CIM_CTRL_FRC_13	  (0xC << CIM_CTRL_FRC_BIT) /* Sample 1/13 frame */
+  #define CIM_CTRL_FRC_14	  (0xD << CIM_CTRL_FRC_BIT) /* Sample 1/14 frame */
+  #define CIM_CTRL_FRC_15	  (0xE << CIM_CTRL_FRC_BIT) /* Sample 1/15 frame */
+  #define CIM_CTRL_FRC_16	  (0xF << CIM_CTRL_FRC_BIT) /* Sample 1/16 frame */
+#define	CIM_CTRL_VDDM		(1 << 13)
+#define	CIM_CTRL_DMA_SOFM	(1 << 12)
+#define	CIM_CTRL_DMA_EOFM	(1 << 11)
+#define	CIM_CTRL_DMA_STOPM	(1 << 10)
+#define	CIM_CTRL_RXF_TRIGM	(1 << 9)
+#define	CIM_CTRL_RXF_OFM	(1 << 8)
+#define	CIM_CTRL_RXF_TRIG_BIT	4
+#define	CIM_CTRL_RXF_TRIG_MASK	(0x7 << CIM_CTRL_RXF_TRIG_BIT)
+  #define CIM_CTRL_RXF_TRIG_4	  (0 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 4 */
+  #define CIM_CTRL_RXF_TRIG_8	  (1 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 8 */
+  #define CIM_CTRL_RXF_TRIG_12	  (2 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 12 */
+  #define CIM_CTRL_RXF_TRIG_16	  (3 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 16 */
+  #define CIM_CTRL_RXF_TRIG_20	  (4 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 20 */
+  #define CIM_CTRL_RXF_TRIG_24	  (5 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 24 */
+  #define CIM_CTRL_RXF_TRIG_28	  (6 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 28 */
+  #define CIM_CTRL_RXF_TRIG_32	  (7 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 32 */
+#define	CIM_CTRL_DMA_EN		(1 << 2)
+#define	CIM_CTRL_RXF_RST	(1 << 1)
+#define	CIM_CTRL_ENA		(1 << 0)
+
+/* CIM State Register  (CIM_STATE) */
+
+#define	CIM_STATE_DMA_SOF	(1 << 6)
+#define	CIM_STATE_DMA_EOF	(1 << 5)
+#define	CIM_STATE_DMA_STOP	(1 << 4)
+#define	CIM_STATE_RXF_OF	(1 << 3)
+#define	CIM_STATE_RXF_TRIG	(1 << 2)
+#define	CIM_STATE_RXF_EMPTY	(1 << 1)
+#define	CIM_STATE_VDD		(1 << 0)
+
+/* CIM DMA Command Register (CIM_CMD) */
+
+#define	CIM_CMD_SOFINT		(1 << 31)
+#define	CIM_CMD_EOFINT		(1 << 30)
+#define	CIM_CMD_STOP		(1 << 28)
+#define	CIM_CMD_LEN_BIT		0
+#define	CIM_CMD_LEN_MASK	(0xffffff << CIM_CMD_LEN_BIT)
+
+
+/*************************************************************************
+ * SADC (Smart A/D Controller)
+ *************************************************************************/
+
+#define SADC_ENA	(SADC_BASE + 0x00)  /* ADC Enable Register */
+#define SADC_CFG	(SADC_BASE + 0x04)  /* ADC Configure Register */
+#define SADC_CTRL	(SADC_BASE + 0x08)  /* ADC Control Register */
+#define SADC_STATE	(SADC_BASE + 0x0C)  /* ADC Status Register*/
+#define SADC_SAMETIME	(SADC_BASE + 0x10)  /* ADC Same Point Time Register */
+#define SADC_WAITTIME	(SADC_BASE + 0x14)  /* ADC Wait Time Register */
+#define SADC_TSDAT	(SADC_BASE + 0x18)  /* ADC Touch Screen Data Register */
+#define SADC_BATDAT	(SADC_BASE + 0x1C)  /* ADC PBAT Data Register */
+#define SADC_SADDAT	(SADC_BASE + 0x20)  /* ADC SADCIN Data Register */
+
+#define REG_SADC_ENA		REG8(SADC_ENA)
+#define REG_SADC_CFG		REG32(SADC_CFG)
+#define REG_SADC_CTRL		REG8(SADC_CTRL)
+#define REG_SADC_STATE		REG8(SADC_STATE)
+#define REG_SADC_SAMETIME	REG16(SADC_SAMETIME)
+#define REG_SADC_WAITTIME	REG16(SADC_WAITTIME)
+#define REG_SADC_TSDAT		REG32(SADC_TSDAT)
+#define REG_SADC_BATDAT		REG16(SADC_BATDAT)
+#define REG_SADC_SADDAT		REG16(SADC_SADDAT)
+
+/* ADC Enable Register */
+#define SADC_ENA_ADEN		(1 << 7)  /* Touch Screen Enable */
+#define SADC_ENA_TSEN		(1 << 2)  /* Touch Screen Enable */
+#define SADC_ENA_PBATEN		(1 << 1)  /* PBAT Enable */
+#define SADC_ENA_SADCINEN	(1 << 0)  /* SADCIN Enable */
+
+/* ADC Configure Register */
+#define SADC_CFG_EXIN           (1 << 30)
+#define SADC_CFG_CLKOUT_NUM_BIT	16
+#define SADC_CFG_CLKOUT_NUM_MASK (0x7 << SADC_CFG_CLKOUT_NUM_BIT)
+#define SADC_CFG_TS_DMA		(1 << 15)  /* Touch Screen DMA Enable */
+#define SADC_CFG_XYZ_BIT	13  /* XYZ selection */
+#define SADC_CFG_XYZ_MASK	(0x3 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XY		(0 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ		(1 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ1Z2	(2 << SADC_CFG_XYZ_BIT)
+#define SADC_CFG_SNUM_BIT	10  /* Sample Number */
+#define SADC_CFG_SNUM_MASK	(0x7 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_1	(0x0 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_2	(0x1 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_3	(0x2 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_4	(0x3 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_5	(0x4 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_6	(0x5 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_8	(0x6 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_9	(0x7 << SADC_CFG_SNUM_BIT)
+#define SADC_CFG_CLKDIV_BIT	5  /* AD Converter frequency clock divider */
+#define SADC_CFG_CLKDIV_MASK	(0x1f << SADC_CFG_CLKDIV_BIT)
+#define SADC_CFG_PBAT_HIGH	(0 << 4)  /* PBAT >= 2.5V */
+#define SADC_CFG_PBAT_LOW	(1 << 4)  /* PBAT < 2.5V */
+#define SADC_CFG_CMD_BIT	0  /* ADC Command */
+#define SADC_CFG_CMD_MASK	(0xf << SADC_CFG_CMD_BIT)
+  #define SADC_CFG_CMD_X_SE	(0x0 << SADC_CFG_CMD_BIT) /* X Single-End */
+  #define SADC_CFG_CMD_Y_SE	(0x1 << SADC_CFG_CMD_BIT) /* Y Single-End */
+  #define SADC_CFG_CMD_X_DIFF	(0x2 << SADC_CFG_CMD_BIT) /* X Differential */
+  #define SADC_CFG_CMD_Y_DIFF	(0x3 << SADC_CFG_CMD_BIT) /* Y Differential */
+  #define SADC_CFG_CMD_Z1_DIFF	(0x4 << SADC_CFG_CMD_BIT) /* Z1 Differential */
+  #define SADC_CFG_CMD_Z2_DIFF	(0x5 << SADC_CFG_CMD_BIT) /* Z2 Differential */
+  #define SADC_CFG_CMD_Z3_DIFF	(0x6 << SADC_CFG_CMD_BIT) /* Z3 Differential */
+  #define SADC_CFG_CMD_Z4_DIFF	(0x7 << SADC_CFG_CMD_BIT) /* Z4 Differential */
+  #define SADC_CFG_CMD_TP_SE	(0x8 << SADC_CFG_CMD_BIT) /* Touch Pressure */
+  #define SADC_CFG_CMD_PBATH_SE	(0x9 << SADC_CFG_CMD_BIT) /* PBAT >= 2.5V */
+  #define SADC_CFG_CMD_PBATL_SE	(0xa << SADC_CFG_CMD_BIT) /* PBAT < 2.5V */
+  #define SADC_CFG_CMD_SADCIN_SE (0xb << SADC_CFG_CMD_BIT) /* Measure SADCIN */
+  #define SADC_CFG_CMD_INT_PEN	(0xc << SADC_CFG_CMD_BIT) /* INT_PEN Enable */
+
+/* ADC Control Register */
+#define SADC_CTRL_PENDM		(1 << 4)  /* Pen Down Interrupt Mask */
+#define SADC_CTRL_PENUM		(1 << 3)  /* Pen Up Interrupt Mask */
+#define SADC_CTRL_TSRDYM	(1 << 2)  /* Touch Screen Data Ready Interrupt Mask */
+#define SADC_CTRL_PBATRDYM	(1 << 1)  /* PBAT Data Ready Interrupt Mask */
+#define SADC_CTRL_SRDYM		(1 << 0)  /* SADCIN Data Ready Interrupt Mask */
+
+/* ADC Status Register */
+#define SADC_STATE_TSBUSY	(1 << 7)  /* TS A/D is working */
+#define SADC_STATE_PBATBUSY	(1 << 6)  /* PBAT A/D is working */
+#define SADC_STATE_SBUSY	(1 << 5)  /* SADCIN A/D is working */
+#define SADC_STATE_PEND		(1 << 4)  /* Pen Down Interrupt Flag */
+#define SADC_STATE_PENU		(1 << 3)  /* Pen Up Interrupt Flag */
+#define SADC_STATE_TSRDY	(1 << 2)  /* Touch Screen Data Ready Interrupt Flag */
+#define SADC_STATE_PBATRDY	(1 << 1)  /* PBAT Data Ready Interrupt Flag */
+#define SADC_STATE_SRDY		(1 << 0)  /* SADCIN Data Ready Interrupt Flag */
+
+/* ADC Touch Screen Data Register */
+#define SADC_TSDAT_DATA0_BIT	0
+#define SADC_TSDAT_DATA0_MASK	(0xfff << SADC_TSDAT_DATA0_BIT)
+#define SADC_TSDAT_TYPE0	(1 << 15)
+#define SADC_TSDAT_DATA1_BIT	16
+#define SADC_TSDAT_DATA1_MASK	(0xfff << SADC_TSDAT_DATA1_BIT)
+#define SADC_TSDAT_TYPE1	(1 << 31)
+
+
+/*************************************************************************
+ * SLCD (Smart LCD Controller)
+ *************************************************************************/
+
+#define SLCD_CFG	(SLCD_BASE + 0xA0)  /* SLCD Configure Register */
+#define SLCD_CTRL	(SLCD_BASE + 0xA4)  /* SLCD Control Register */
+#define SLCD_STATE	(SLCD_BASE + 0xA8)  /* SLCD Status Register */
+#define SLCD_DATA	(SLCD_BASE + 0xAC)  /* SLCD Data Register */
+#define SLCD_FIFO	(SLCD_BASE + 0xB0)  /* SLCD FIFO Register */
+
+#define REG_SLCD_CFG	REG32(SLCD_CFG)
+#define REG_SLCD_CTRL	REG8(SLCD_CTRL)
+#define REG_SLCD_STATE	REG8(SLCD_STATE)
+#define REG_SLCD_DATA	REG32(SLCD_DATA)
+#define REG_SLCD_FIFO	REG32(SLCD_FIFO)
+
+/* SLCD Configure Register */
+#define SLCD_CFG_BURST_BIT	14
+#define SLCD_CFG_BURST_MASK	(0x3 << SLCD_CFG_BURST_BIT)
+  #define SLCD_CFG_BURST_4_WORD	(0 << SLCD_CFG_BURST_BIT)
+  #define SLCD_CFG_BURST_8_WORD	(1 << SLCD_CFG_BURST_BIT)
+#define SLCD_CFG_DWIDTH_BIT	10
+#define SLCD_CFG_DWIDTH_MASK	(0x7 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_18	(0 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_16	(1 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x3	(2 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x2	(3 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8_x1	(4 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_9_x2	(7 << SLCD_CFG_DWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_16BIT	(0 << 8)
+#define SLCD_CFG_CWIDTH_8BIT	(1 << 8)
+#define SLCD_CFG_CWIDTH_18BIT	(2 << 8)
+#define SLCD_CFG_CS_ACTIVE_LOW	(0 << 4)
+#define SLCD_CFG_CS_ACTIVE_HIGH	(1 << 4)
+#define SLCD_CFG_RS_CMD_LOW	(0 << 3)
+#define SLCD_CFG_RS_CMD_HIGH	(1 << 3)
+#define SLCD_CFG_CLK_ACTIVE_FALLING	(0 << 1)
+#define SLCD_CFG_CLK_ACTIVE_RISING	(1 << 1)
+#define SLCD_CFG_TYPE_PARALLEL	(0 << 0)
+#define SLCD_CFG_TYPE_SERIAL	(1 << 0)
+
+/* SLCD Control Register */
+#define SLCD_CTRL_DMA_EN	(1 << 0)
+
+/* SLCD Status Register */
+#define SLCD_STATE_BUSY		(1 << 0)
+
+/* SLCD Data Register */
+#define SLCD_DATA_RS_DATA	(0 << 31)
+#define SLCD_DATA_RS_COMMAND	(1 << 31)
+
+/* SLCD FIFO Register */
+#define SLCD_FIFO_RS_DATA	(0 << 31)
+#define SLCD_FIFO_RS_COMMAND	(1 << 31)
+
+
+/*************************************************************************
+ * LCD (LCD Controller)
+ *************************************************************************/
+#define LCD_CFG		(LCD_BASE + 0x00) /* LCD Configure Register */
+#define LCD_VSYNC	(LCD_BASE + 0x04) /* Vertical Synchronize Register */
+#define LCD_HSYNC	(LCD_BASE + 0x08) /* Horizontal Synchronize Register */
+#define LCD_VAT		(LCD_BASE + 0x0c) /* Virtual Area Setting Register */
+#define LCD_DAH		(LCD_BASE + 0x10) /* Display Area Horizontal Start/End Point */
+#define LCD_DAV		(LCD_BASE + 0x14) /* Display Area Vertical Start/End Point */
+#define LCD_PS		(LCD_BASE + 0x18) /* PS Signal Setting */
+#define LCD_CLS		(LCD_BASE + 0x1c) /* CLS Signal Setting */
+#define LCD_SPL		(LCD_BASE + 0x20) /* SPL Signal Setting */
+#define LCD_REV		(LCD_BASE + 0x24) /* REV Signal Setting */
+#define LCD_CTRL	(LCD_BASE + 0x30) /* LCD Control Register */
+#define LCD_STATE	(LCD_BASE + 0x34) /* LCD Status Register */
+#define LCD_IID		(LCD_BASE + 0x38) /* Interrupt ID Register */
+#define LCD_DA0		(LCD_BASE + 0x40) /* Descriptor Address Register 0 */
+#define LCD_SA0		(LCD_BASE + 0x44) /* Source Address Register 0 */
+#define LCD_FID0	(LCD_BASE + 0x48) /* Frame ID Register 0 */
+#define LCD_CMD0	(LCD_BASE + 0x4c) /* DMA Command Register 0 */
+#define LCD_DA1		(LCD_BASE + 0x50) /* Descriptor Address Register 1 */
+#define LCD_SA1		(LCD_BASE + 0x54) /* Source Address Register 1 */
+#define LCD_FID1	(LCD_BASE + 0x58) /* Frame ID Register 1 */
+#define LCD_CMD1	(LCD_BASE + 0x5c) /* DMA Command Register 1 */
+
+#define REG_LCD_CFG	REG32(LCD_CFG)
+#define REG_LCD_VSYNC	REG32(LCD_VSYNC)
+#define REG_LCD_HSYNC	REG32(LCD_HSYNC)
+#define REG_LCD_VAT	REG32(LCD_VAT)
+#define REG_LCD_DAH	REG32(LCD_DAH)
+#define REG_LCD_DAV	REG32(LCD_DAV)
+#define REG_LCD_PS	REG32(LCD_PS)
+#define REG_LCD_CLS	REG32(LCD_CLS)
+#define REG_LCD_SPL	REG32(LCD_SPL)
+#define REG_LCD_REV	REG32(LCD_REV)
+#define REG_LCD_CTRL	REG32(LCD_CTRL)
+#define REG_LCD_STATE	REG32(LCD_STATE)
+#define REG_LCD_IID	REG32(LCD_IID)
+#define REG_LCD_DA0	REG32(LCD_DA0)
+#define REG_LCD_SA0	REG32(LCD_SA0)
+#define REG_LCD_FID0	REG32(LCD_FID0)
+#define REG_LCD_CMD0	REG32(LCD_CMD0)
+#define REG_LCD_DA1	REG32(LCD_DA1)
+#define REG_LCD_SA1	REG32(LCD_SA1)
+#define REG_LCD_FID1	REG32(LCD_FID1)
+#define REG_LCD_CMD1	REG32(LCD_CMD1)
+
+/* LCD Configure Register */
+#define LCD_CFG_LCDPIN_BIT	31  /* LCD pins selection */
+#define LCD_CFG_LCDPIN_MASK	(0x1 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_LCD	(0x0 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_SLCD	(0x1 << LCD_CFG_LCDPIN_BIT)
+#define LCD_CFG_PSM		(1 << 23) /* PS signal mode */
+#define LCD_CFG_CLSM		(1 << 22) /* CLS signal mode */
+#define LCD_CFG_SPLM		(1 << 21) /* SPL signal mode */
+#define LCD_CFG_REVM		(1 << 20) /* REV signal mode */
+#define LCD_CFG_HSYNM		(1 << 19) /* HSYNC signal mode */
+#define LCD_CFG_PCLKM		(1 << 18) /* PCLK signal mode */
+#define LCD_CFG_INVDAT		(1 << 17) /* Inverse output data */
+#define LCD_CFG_SYNDIR_IN	(1 << 16) /* VSYNC&HSYNC direction */
+#define LCD_CFG_PSP		(1 << 15) /* PS pin reset state */
+#define LCD_CFG_CLSP		(1 << 14) /* CLS pin reset state */
+#define LCD_CFG_SPLP		(1 << 13) /* SPL pin reset state */
+#define LCD_CFG_REVP		(1 << 12) /* REV pin reset state */
+#define LCD_CFG_HSP		(1 << 11) /* HSYNC pority:0-active high,1-active low */
+#define LCD_CFG_PCP		(1 << 10) /* PCLK pority:0-rising,1-falling */
+#define LCD_CFG_DEP		(1 << 9)  /* DE pority:0-active high,1-active low */
+#define LCD_CFG_VSP		(1 << 8)  /* VSYNC pority:0-rising,1-falling */
+#define LCD_CFG_PDW_BIT		4  /* STN pins utilization */
+#define LCD_CFG_PDW_MASK	(0x3 << LCD_DEV_PDW_BIT)
+#define LCD_CFG_PDW_1		(0 << LCD_CFG_PDW_BIT) /* LCD_D[0] */
+  #define LCD_CFG_PDW_2		(1 << LCD_CFG_PDW_BIT) /* LCD_D[0:1] */
+  #define LCD_CFG_PDW_4		(2 << LCD_CFG_PDW_BIT) /* LCD_D[0:3]/LCD_D[8:11] */
+  #define LCD_CFG_PDW_8		(3 << LCD_CFG_PDW_BIT) /* LCD_D[0:7]/LCD_D[8:15] */
+#define LCD_CFG_MODE_BIT	0  /* Display Device Mode Select */
+#define LCD_CFG_MODE_MASK	(0x0f << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_GENERIC_TFT	(0 << LCD_CFG_MODE_BIT) /* 16,18 bit TFT */
+  #define LCD_CFG_MODE_SPECIAL_TFT_1	(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_2	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_3	(3 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_NONINTER_CCIR656	(4 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_INTER_CCIR656	(6 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_CSTN	(8 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_MSTN	(9 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_CSTN	(10 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_MSTN	(11 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SERIAL_TFT	(12 << LCD_CFG_MODE_BIT)
+  /* JZ47XX defines */
+  #define LCD_CFG_MODE_SHARP_HR		(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_CASIO_TFT	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SAMSUNG_ALPHA	(3 << LCD_CFG_MODE_BIT)
+
+
+
+/* Vertical Synchronize Register */
+#define LCD_VSYNC_VPS_BIT	16  /* VSYNC pulse start in line clock, fixed to 0 */
+#define LCD_VSYNC_VPS_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+#define LCD_VSYNC_VPE_BIT	0   /* VSYNC pulse end in line clock */
+#define LCD_VSYNC_VPE_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+
+/* Horizontal Synchronize Register */
+#define LCD_HSYNC_HPS_BIT	16  /* HSYNC pulse start position in dot clock */
+#define LCD_HSYNC_HPS_MASK	(0xffff << LCD_HSYNC_HPS_BIT)
+#define LCD_HSYNC_HPE_BIT	0   /* HSYNC pulse end position in dot clock */
+#define LCD_HSYNC_HPE_MASK	(0xffff << LCD_HSYNC_HPE_BIT)
+
+/* Virtual Area Setting Register */
+#define LCD_VAT_HT_BIT		16  /* Horizontal Total size in dot clock */
+#define LCD_VAT_HT_MASK		(0xffff << LCD_VAT_HT_BIT)
+#define LCD_VAT_VT_BIT		0   /* Vertical Total size in dot clock */
+#define LCD_VAT_VT_MASK		(0xffff << LCD_VAT_VT_BIT)
+
+/* Display Area Horizontal Start/End Point Register */
+#define LCD_DAH_HDS_BIT		16  /* Horizontal display area start in dot clock */
+#define LCD_DAH_HDS_MASK	(0xffff << LCD_DAH_HDS_BIT)
+#define LCD_DAH_HDE_BIT		0   /* Horizontal display area end in dot clock */
+#define LCD_DAH_HDE_MASK	(0xffff << LCD_DAH_HDE_BIT)
+
+/* Display Area Vertical Start/End Point Register */
+#define LCD_DAV_VDS_BIT		16  /* Vertical display area start in line clock */
+#define LCD_DAV_VDS_MASK	(0xffff << LCD_DAV_VDS_BIT)
+#define LCD_DAV_VDE_BIT		0   /* Vertical display area end in line clock */
+#define LCD_DAV_VDE_MASK	(0xffff << LCD_DAV_VDE_BIT)
+
+/* PS Signal Setting */
+#define LCD_PS_PSS_BIT		16  /* PS signal start position in dot clock */
+#define LCD_PS_PSS_MASK		(0xffff << LCD_PS_PSS_BIT)
+#define LCD_PS_PSE_BIT		0   /* PS signal end position in dot clock */
+#define LCD_PS_PSE_MASK		(0xffff << LCD_PS_PSE_BIT)
+
+/* CLS Signal Setting */
+#define LCD_CLS_CLSS_BIT	16  /* CLS signal start position in dot clock */
+#define LCD_CLS_CLSS_MASK	(0xffff << LCD_CLS_CLSS_BIT)
+#define LCD_CLS_CLSE_BIT	0   /* CLS signal end position in dot clock */
+#define LCD_CLS_CLSE_MASK	(0xffff << LCD_CLS_CLSE_BIT)
+
+/* SPL Signal Setting */
+#define LCD_SPL_SPLS_BIT	16  /* SPL signal start position in dot clock */
+#define LCD_SPL_SPLS_MASK	(0xffff << LCD_SPL_SPLS_BIT)
+#define LCD_SPL_SPLE_BIT	0   /* SPL signal end position in dot clock */
+#define LCD_SPL_SPLE_MASK	(0xffff << LCD_SPL_SPLE_BIT)
+
+/* REV Signal Setting */
+#define LCD_REV_REVS_BIT	16  /* REV signal start position in dot clock */
+#define LCD_REV_REVS_MASK	(0xffff << LCD_REV_REVS_BIT)
+
+/* LCD Control Register */
+#define LCD_CTRL_BST_BIT	28  /* Burst Length Selection */
+#define LCD_CTRL_BST_MASK	(0x03 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_4	(0 << LCD_CTRL_BST_BIT) /* 4-word */
+  #define LCD_CTRL_BST_8	(1 << LCD_CTRL_BST_BIT) /* 8-word */
+  #define LCD_CTRL_BST_16	(2 << LCD_CTRL_BST_BIT) /* 16-word */
+#define LCD_CTRL_RGB565		(0 << 27) /* RGB565 mode */
+#define LCD_CTRL_RGB555		(1 << 27) /* RGB555 mode */
+#define LCD_CTRL_OFUP		(1 << 26) /* Output FIFO underrun protection enable */
+#define LCD_CTRL_FRC_BIT	24  /* STN FRC Algorithm Selection */
+#define LCD_CTRL_FRC_MASK	(0x03 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_16	(0 << LCD_CTRL_FRC_BIT) /* 16 grayscale */
+  #define LCD_CTRL_FRC_4	(1 << LCD_CTRL_FRC_BIT) /* 4 grayscale */
+  #define LCD_CTRL_FRC_2	(2 << LCD_CTRL_FRC_BIT) /* 2 grayscale */
+#define LCD_CTRL_PDD_BIT	16  /* Load Palette Delay Counter */
+#define LCD_CTRL_PDD_MASK	(0xff << LCD_CTRL_PDD_BIT)
+#define LCD_CTRL_EOFM		(1 << 13) /* EOF interrupt mask */
+#define LCD_CTRL_SOFM		(1 << 12) /* SOF interrupt mask */
+#define LCD_CTRL_OFUM		(1 << 11) /* Output FIFO underrun interrupt mask */
+#define LCD_CTRL_IFUM0		(1 << 10) /* Input FIFO 0 underrun interrupt mask */
+#define LCD_CTRL_IFUM1		(1 << 9)  /* Input FIFO 1 underrun interrupt mask */
+#define LCD_CTRL_LDDM		(1 << 8)  /* LCD disable done interrupt mask */
+#define LCD_CTRL_QDM		(1 << 7)  /* LCD quick disable done interrupt mask */
+#define LCD_CTRL_BEDN		(1 << 6)  /* Endian selection */
+#define LCD_CTRL_PEDN		(1 << 5)  /* Endian in byte:0-msb first, 1-lsb first */
+#define LCD_CTRL_DIS		(1 << 4)  /* Disable indicate bit */
+#define LCD_CTRL_ENA		(1 << 3)  /* LCD enable bit */
+#define LCD_CTRL_BPP_BIT	0  /* Bits Per Pixel */
+#define LCD_CTRL_BPP_MASK	(0x07 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_1	(0 << LCD_CTRL_BPP_BIT) /* 1 bpp */
+  #define LCD_CTRL_BPP_2	(1 << LCD_CTRL_BPP_BIT) /* 2 bpp */
+  #define LCD_CTRL_BPP_4	(2 << LCD_CTRL_BPP_BIT) /* 4 bpp */
+  #define LCD_CTRL_BPP_8	(3 << LCD_CTRL_BPP_BIT) /* 8 bpp */
+  #define LCD_CTRL_BPP_16	(4 << LCD_CTRL_BPP_BIT) /* 15/16 bpp */
+  #define LCD_CTRL_BPP_18_24	(5 << LCD_CTRL_BPP_BIT) /* 18/24/32 bpp */
+
+/* LCD Status Register */
+#define LCD_STATE_QD		(1 << 7) /* Quick Disable Done */
+#define LCD_STATE_EOF		(1 << 5) /* EOF Flag */
+#define LCD_STATE_SOF		(1 << 4) /* SOF Flag */
+#define LCD_STATE_OFU		(1 << 3) /* Output FIFO Underrun */
+#define LCD_STATE_IFU0		(1 << 2) /* Input FIFO 0 Underrun */
+#define LCD_STATE_IFU1		(1 << 1) /* Input FIFO 1 Underrun */
+#define LCD_STATE_LDD		(1 << 0) /* LCD Disabled */
+
+/* DMA Command Register */
+#define LCD_CMD_SOFINT		(1 << 31)
+#define LCD_CMD_EOFINT		(1 << 30)
+#define LCD_CMD_PAL		(1 << 28)
+#define LCD_CMD_LEN_BIT		0
+#define LCD_CMD_LEN_MASK	(0xffffff << LCD_CMD_LEN_BIT)
+
+
+/*************************************************************************
+ * USB Device
+ *************************************************************************/
+#define USB_BASE  UDC_BASE
+
+#define USB_REG_FADDR		(USB_BASE + 0x00) /* Function Address 8-bit */
+#define USB_REG_POWER		(USB_BASE + 0x01) /* Power Managemetn 8-bit */
+#define USB_REG_INTRIN		(USB_BASE + 0x02) /* Interrupt IN 16-bit */
+#define USB_REG_INTROUT		(USB_BASE + 0x04) /* Interrupt OUT 16-bit */
+#define USB_REG_INTRINE		(USB_BASE + 0x06) /* Intr IN enable 16-bit */
+#define USB_REG_INTROUTE	(USB_BASE + 0x08) /* Intr OUT enable 16-bit */
+#define USB_REG_INTRUSB		(USB_BASE + 0x0a) /* Interrupt USB 8-bit */
+#define USB_REG_INTRUSBE	(USB_BASE + 0x0b) /* Interrupt USB Enable 8-bit */
+#define USB_REG_FRAME		(USB_BASE + 0x0c) /* Frame number 16-bit */
+#define USB_REG_INDEX		(USB_BASE + 0x0e) /* Index register 8-bit */
+#define USB_REG_TESTMODE	(USB_BASE + 0x0f) /* USB test mode 8-bit */
+
+#define USB_REG_CSR0		(USB_BASE + 0x12) /* EP0 CSR 8-bit */
+#define USB_REG_INMAXP		(USB_BASE + 0x10) /* EP1-2 IN Max Pkt Size 16-bit */
+#define USB_REG_INCSR		(USB_BASE + 0x12) /* EP1-2 IN CSR LSB 8/16bit */
+#define USB_REG_INCSRH		(USB_BASE + 0x13) /* EP1-2 IN CSR MSB 8-bit */
+#define USB_REG_OUTMAXP		(USB_BASE + 0x14) /* EP1 OUT Max Pkt Size 16-bit */
+#define USB_REG_OUTCSR		(USB_BASE + 0x16) /* EP1 OUT CSR LSB 8/16bit */
+#define USB_REG_OUTCSRH		(USB_BASE + 0x17) /* EP1 OUT CSR MSB 8-bit */
+#define USB_REG_OUTCOUNT	(USB_BASE + 0x18) /* bytes in EP0/1 OUT FIFO 16-bit */
+
+#define USB_FIFO_EP0		(USB_BASE + 0x20)
+#define USB_FIFO_EP1		(USB_BASE + 0x24)
+#define USB_FIFO_EP2		(USB_BASE + 0x28)
+
+#define USB_REG_EPINFO		(USB_BASE + 0x78) /* Endpoint information */
+#define USB_REG_RAMINFO		(USB_BASE + 0x79) /* RAM information */
+
+#define USB_REG_INTR		(USB_BASE + 0x200) /* DMA pending interrupts */
+#define USB_REG_CNTL1		(USB_BASE + 0x204) /* DMA channel 1 control */
+#define USB_REG_ADDR1		(USB_BASE + 0x208) /* DMA channel 1 AHB memory addr */
+#define USB_REG_COUNT1		(USB_BASE + 0x20c) /* DMA channel 1 byte count */
+#define USB_REG_CNTL2		(USB_BASE + 0x214) /* DMA channel 2 control */
+#define USB_REG_ADDR2		(USB_BASE + 0x218) /* DMA channel 2 AHB memory addr */
+#define USB_REG_COUNT2		(USB_BASE + 0x21c) /* DMA channel 2 byte count */
+
+
+/* Power register bit masks */
+#define USB_POWER_SUSPENDM	0x01
+#define USB_POWER_RESUME	0x04
+#define USB_POWER_HSMODE	0x10
+#define USB_POWER_HSENAB	0x20
+#define USB_POWER_SOFTCONN	0x40
+
+/* Interrupt register bit masks */
+#define USB_INTR_SUSPEND	0x01
+#define USB_INTR_RESUME		0x02
+#define USB_INTR_RESET		0x04
+
+#define USB_INTR_EP0		0x0001
+#define USB_INTR_INEP1		0x0002
+#define USB_INTR_INEP2		0x0004
+#define USB_INTR_OUTEP1		0x0002
+
+/* CSR0 bit masks */
+#define USB_CSR0_OUTPKTRDY	0x01
+#define USB_CSR0_INPKTRDY	0x02
+#define USB_CSR0_SENTSTALL	0x04
+#define USB_CSR0_DATAEND	0x08
+#define USB_CSR0_SETUPEND	0x10
+#define USB_CSR0_SENDSTALL	0x20
+#define USB_CSR0_SVDOUTPKTRDY	0x40
+#define USB_CSR0_SVDSETUPEND	0x80
+
+/* Endpoint CSR register bits */
+#define USB_INCSRH_AUTOSET	0x80
+#define USB_INCSRH_ISO		0x40
+#define USB_INCSRH_MODE		0x20
+#define USB_INCSRH_DMAREQENAB	0x10
+#define USB_INCSRH_DMAREQMODE	0x04
+#define USB_INCSR_CDT		0x40
+#define USB_INCSR_SENTSTALL	0x20
+#define USB_INCSR_SENDSTALL	0x10
+#define USB_INCSR_FF		0x08
+#define USB_INCSR_UNDERRUN	0x04
+#define USB_INCSR_FFNOTEMPT	0x02
+#define USB_INCSR_INPKTRDY	0x01
+#define USB_OUTCSRH_AUTOCLR	0x80
+#define USB_OUTCSRH_ISO		0x40
+#define USB_OUTCSRH_DMAREQENAB	0x20
+#define USB_OUTCSRH_DNYT	0x10
+#define USB_OUTCSRH_DMAREQMODE	0x08
+#define USB_OUTCSR_CDT		0x80
+#define USB_OUTCSR_SENTSTALL	0x40
+#define USB_OUTCSR_SENDSTALL	0x20
+#define USB_OUTCSR_FF		0x10
+#define USB_OUTCSR_DATAERR	0x08
+#define USB_OUTCSR_OVERRUN	0x04
+#define USB_OUTCSR_FFFULL	0x02
+#define USB_OUTCSR_OUTPKTRDY	0x01
+
+/* Testmode register bits */
+#define USB_TEST_SE0NAK		0x01
+#define USB_TEST_J		0x02
+#define USB_TEST_K		0x04
+#define USB_TEST_PACKET		0x08
+
+/* DMA control bits */
+#define USB_CNTL_ENA		0x01
+#define USB_CNTL_DIR_IN		0x02
+#define USB_CNTL_MODE_1		0x04
+#define USB_CNTL_INTR_EN	0x08
+#define USB_CNTL_EP(n)		((n) << 4)
+#define USB_CNTL_BURST_0	(0 << 9)
+#define USB_CNTL_BURST_4	(1 << 9)
+#define USB_CNTL_BURST_8	(2 << 9)
+#define USB_CNTL_BURST_16	(3 << 9)
+
+#endif /* __JZ4740_REGS_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/serial.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/serial.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,30 @@
+/*
+ *  linux/include/asm-mips/mach-jz4740/serial.h
+ *
+ *  Ingenic's JZ4740 common include.
+ *
+ *  Copyright (C) 2006 - 2007 Ingenic Semiconductor Inc.
+ *
+ *  Author: <yliu@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_BOARD_SERIAL_H__
+#define __ASM_BOARD_SERIAL_H__
+
+#ifndef CONFIG_SERIAL_MANY_PORTS
+#undef RS_TABLE_SIZE
+#define RS_TABLE_SIZE  1
+#endif
+
+#define JZ_BASE_BAUD	(12000000/16)
+
+#define JZ_SERIAL_PORT_DEFNS \
+	{ .baud_base = JZ_BASE_BAUD, .irq = IRQ_UART0, \
+	  .flags = STD_COM_FLAGS, .iomem_base = (u8 *)UART0_BASE, \
+	  .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM },
+
+#endif /* __ASM_BORAD_SERIAL_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4740/war.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4740/war.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_JZ4740_WAR_H
+#define __ASM_MIPS_MACH_JZ4740_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_JZ4740_WAR_H */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750/board-apus.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750/board-apus.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,119 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750/board-apus.h
+ *
+ *  JZ4750-based APUS board ver 1.x definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750_APUS_H__
+#define __ASM_JZ4750_APUS_H__
+
+/*====================================================================== 
+ * Frequencies of on-board oscillators
+ */
+#define JZ_EXTAL		24000000  /* Main extal freq: 24 MHz */
+#define JZ_EXTAL2		32768     /* RTC extal freq: 32.768 KHz */
+
+/*====================================================================== 
+ * GPIO
+ */
+#define GPIO_DISP_OFF_N         (32*4+25) /* GPE25 */
+#define GPIO_SD0_VCC_EN_N	(32*2+10) /* GPC10 */
+#define GPIO_SD0_CD_N		(32*2+11) /* GPC11 */
+#define GPIO_SD0_WP		(32*2+12) /* GPC12 */
+#define GPIO_SD1_VCC_EN_N	(32*2+13) /* GPC13 */
+#define GPIO_SD1_CD_N		(32*2+14) /* GPC14 */
+#define GPIO_USB_DETE		(32*2+11) /* GPC15 */
+#define GPIO_DC_DETE_N		(32*2+8)  /* GPC8 */
+#define GPIO_CHARG_STAT_N	(32*2+9)  /* GPC9 */
+#define GPIO_LCD_VCC_EN_N	(32*3+30) /* GPC10 */
+#define GPIO_LCD_PWM   		(32*4+24) /* GPE24 */
+#define GPIO_UDC_HOTPLUG	GPIO_USB_DETE
+
+
+/*====================================================================== 
+ * LCD backlight
+ */
+#define LCD_PWM_CHN 4    /* pwm channel */
+#define LCD_PWM_FULL 101
+/* 100 level: 0,1,...,100 */
+#define __lcd_set_backlight_level(n)	\
+do {					\
+	__gpio_as_output(GPIO_LCD_PWM);	\
+	__gpio_set_pin(GPIO_LCD_PWM);	\
+} while (0)
+
+#define __lcd_close_backlight()		\
+do {					\
+	__gpio_as_output(GPIO_LCD_PWM);	\
+	__gpio_clear_pin(GPIO_LCD_PWM);	\
+} while (0)
+
+/*====================================================================== 
+ * MMC/SD
+ */
+
+#define MSC0_WP_PIN		GPIO_SD0_WP
+#define MSC0_HOTPLUG_PIN	GPIO_SD0_CD_N
+#define MSC0_HOTPLUG_IRQ	(IRQ_GPIO_0 + GPIO_SD0_CD_N)
+
+#define MSC1_WP_PIN		GPIO_SD1_WP
+#define MSC1_HOTPLUG_PIN	GPIO_SD1_CD_N
+#define MSC1_HOTPLUG_IRQ	(IRQ_GPIO_0 + GPIO_SD1_CD_N)
+
+#define __msc0_init_io()			\
+do {						\
+	__gpio_as_output(GPIO_SD0_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD0_CD_N);		\
+} while (0)
+
+#define __msc0_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD0_VCC_EN_N);	\
+} while (0)
+
+#define __msc0_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD0_VCC_EN_N);	\
+} while (0)
+
+#define __msc0_card_detected(s)			\
+({						\
+	int detected = 1;			\
+	if (__gpio_get_pin(GPIO_SD0_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+
+#define __msc1_init_io()			\
+do {						\
+	__gpio_as_output(GPIO_SD1_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD1_CD_N);		\
+} while (0)
+
+#define __msc1_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD1_VCC_EN_N);	\
+} while (0)
+
+#define __msc1_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD1_VCC_EN_N);	\
+} while (0)
+
+#define __msc1_card_detected(s)			\
+({						\
+	int detected = 0;			\
+	if (__gpio_get_pin(GPIO_SD1_CD_N))	\
+		detected = 1;			\
+	detected;				\
+})
+
+#endif /* __ASM_JZ4750_APUS_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750/board-fuwa.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750/board-fuwa.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,93 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750/board-fuwa.h
+ *
+ *  JZ4750-based FUWA board ver 1.x definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750_FUWA_H__
+#define __ASM_JZ4750_FUWA_H__
+
+#define CONFIG_FPGA	 /* fuwa is an FPGA board */
+
+/*====================================================================== 
+ * Frequencies of on-board oscillators
+ */
+#define JZ_EXTAL		48000000  /* Main extal freq: 12 MHz */
+#define JZ_EXTAL2		32768     /* RTC extal freq: 32.768 KHz */
+
+
+/*====================================================================== 
+ * GPIO
+ */
+#define GPIO_SD_VCC_EN_N	113 /* GPD17 */
+#define GPIO_SD_CD_N		110 /* GPD14 */
+#define GPIO_SD_WP		112 /* GPD16 */
+#define GPIO_USB_DETE		102 /* GPD6 */
+#define GPIO_DC_DETE_N		103 /* GPD7 */
+#define GPIO_CHARG_STAT_N	111 /* GPD15 */
+#define GPIO_DISP_OFF_N		121 /* GPD25, LCD_REV */
+#define GPIO_LED_EN       	124 /* GPD28 */
+
+#define GPIO_UDC_HOTPLUG	GPIO_USB_DETE
+
+/*====================================================================== 
+ * LCD backlight
+ */
+#define GPIO_LCD_PWM   		(32*4+20) /* GPE20 */
+
+#define LCD_PWM_CHN 0    /* pwm channel */
+#define LCD_PWM_FULL 101
+/* 100 level: 0,1,...,100 */
+#define __lcd_set_backlight_level(n)	\
+do {					\
+	__gpio_as_output(GPIO_LCD_PWM);	\
+	__gpio_set_pin(GPIO_LCD_PWM);	\
+} while (0)
+
+#define __lcd_close_backlight()		\
+do {					\
+	__gpio_as_output(GPIO_LCD_PWM);	\
+	__gpio_clear_pin(GPIO_LCD_PWM);	\
+} while (0)
+
+/*====================================================================== 
+ * MMC/SD
+ */
+
+#define MSC_WP_PIN		GPIO_SD_WP
+#define MSC_HOTPLUG_PIN		GPIO_SD_CD_N
+#define MSC_HOTPLUG_IRQ		(IRQ_GPIO_0 + GPIO_SD_CD_N)
+
+#define __msc_init_io()				\
+do {						\
+	__gpio_as_output(GPIO_SD_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD_CD_N);		\
+} while (0)
+
+#define __msc_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD_VCC_EN_N);	\
+} while (0)
+
+#define __msc_card_detected(s)			\
+({						\
+	int detected = 1;			\
+	if (__gpio_get_pin(GPIO_SD_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+
+#endif /* __ASM_JZ4750_FUWA_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750/clock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750/clock.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,204 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750/clock.h
+ *
+ *  JZ4750 clocks definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750_CLOCK_H__
+#define __ASM_JZ4750_CLOCK_H__
+
+#ifndef JZ_EXTAL
+#define JZ_EXTAL		12000000   /* 3.6864 MHz */
+#endif
+#ifndef JZ_EXTAL2
+#define JZ_EXTAL2		32768     /* 32.768 KHz */
+#endif
+
+/*
+ * JZ4750 clocks structure
+ */
+typedef struct {
+	unsigned int cclk;      /* CPU clock */
+	unsigned int hclk;      /* System bus clock */
+	unsigned int pclk;      /* Peripheral bus clock */
+	unsigned int mclk;      /* Flash/SRAM/SDRAM clock */
+	unsigned int lcdclk;    /* LCDC module clock */
+	unsigned int pixclk;    /* LCD pixel clock */
+	unsigned int i2sclk;    /* AIC module clock */
+	unsigned int usbclk;    /* USB module clock */
+	unsigned int mscclk;    /* MSC module clock */
+	unsigned int extalclk;  /* EXTAL clock for UART,I2C,SSI,TCU,USB-PHY */
+	unsigned int rtcclk;    /* RTC clock for CPM,INTC,RTC,TCU,WDT */
+} jz_clocks_t;
+
+extern jz_clocks_t jz_clocks;
+
+
+/* PLL output frequency */
+static __inline__ unsigned int __cpm_get_pllout(void)
+{
+	unsigned long m, n, no, pllout;
+	unsigned long cppcr = REG_CPM_CPPCR;
+	unsigned long od[4] = {1, 2, 2, 4};
+	if ((cppcr & CPM_CPPCR_PLLEN) && !(cppcr & CPM_CPPCR_PLLBP)) {
+		m = __cpm_get_pllm() + 2;
+		n = __cpm_get_plln() + 2;
+		no = od[__cpm_get_pllod()];
+		pllout = ((JZ_EXTAL) / (n * no)) * m;
+	} else
+		pllout = JZ_EXTAL;
+	return pllout;
+}
+
+/* PLL output frequency for MSC/I2S/LCD/USB */
+static __inline__ unsigned int __cpm_get_pllout2(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_PCS)
+		return __cpm_get_pllout();
+	else
+		return __cpm_get_pllout()/2;
+}
+
+/* CPU core clock */
+static __inline__ unsigned int __cpm_get_cclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_cdiv()];
+}
+
+/* AHB system bus clock */
+static __inline__ unsigned int __cpm_get_hclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_hdiv()];
+}
+
+/* Memory bus clock */
+static __inline__ unsigned int __cpm_get_mclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_mdiv()];
+}
+
+/* APB peripheral bus clock */
+static __inline__ unsigned int __cpm_get_pclk(void)
+{
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_pdiv()];
+}
+
+/* LCDC module clock */
+static __inline__ unsigned int __cpm_get_lcdclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_ldiv() + 1);
+}
+
+/* LCD pixel clock */
+static __inline__ unsigned int __cpm_get_pixclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_pixdiv() + 1);
+}
+
+/* I2S clock */
+static __inline__ unsigned int __cpm_get_i2sclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_I2CS) {
+		return __cpm_get_pllout2() / (__cpm_get_i2sdiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* USB clock */
+static __inline__ unsigned int __cpm_get_usbclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_UCS) {
+		return __cpm_get_pllout2() / (__cpm_get_udiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* 
+ * MSC clock
+ * @n: the index of MMC/SD controller 
+ */
+static __inline__ unsigned int __cpm_get_mscclk(int n)
+{
+	return __cpm_get_pllout2() / (__cpm_get_mscdiv(n) + 1);
+}
+
+/* EXTAL clock */
+static __inline__ unsigned int __cpm_get_extalclk0(void)
+{
+	return JZ_EXTAL;
+}
+
+/* EXTAL clock for UART,I2C,SSI,TCU,USB-PHY */
+static __inline__ unsigned int __cpm_get_extalclk(void)
+{
+#if defined(CONFIG_FPGA)
+	return JZ_EXTAL;
+#else
+	if (REG_CPM_CPCCR & CPM_CPCCR_ECS)
+		return __cpm_get_extalclk0()/2;
+	else
+		return __cpm_get_extalclk0();
+#endif
+}
+
+/* RTC clock for CPM,INTC,RTC,TCU,WDT */
+static __inline__ unsigned int __cpm_get_rtcclk(void)
+{
+	return JZ_EXTAL2;
+}
+
+/*
+ * Output 24MHz for SD and 16MHz for MMC.
+ * @n: the index of MMC/SD controller
+ */
+static inline void __cpm_select_msc_clk(int n, int sd)
+{
+	unsigned int pllout2 = __cpm_get_pllout2();
+	unsigned int div = 0;
+
+	if (sd) {
+		div = pllout2 / 24000000;
+	}
+	else {
+		div = pllout2 / 16000000;
+	}
+
+	REG_CPM_MSCCDR(n) = div - 1;
+	REG_CPM_CPCCR |= CPM_CPCCR_CE;
+}
+
+/*
+ * Output 48MHz for high speed card.
+ */
+static inline void __cpm_select_msc_clk_high(int n, int sd)
+{
+	unsigned int pllout2 = __cpm_get_pllout2();
+	unsigned int div = 0;
+
+	div = pllout2 / 48000000;
+
+	REG_CPM_MSCCDR(n) = div - 1;
+	REG_CPM_CPCCR |= CPM_CPCCR_CE;
+}
+
+#endif /* __ASM_JZ4750_CLOCK_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750/dma.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,307 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750/dma.h
+ *
+ *  JZ4750 DMA definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750_DMA_H__
+#define __ASM_JZ4750_DMA_H__
+
+#include <linux/interrupt.h>
+#include <asm/io.h>			/* need byte IO */
+#include <linux/spinlock.h>		/* And spinlocks */
+#include <linux/delay.h>
+#include <asm/system.h>
+
+/*
+ * Descriptor structure for JZ4750 DMA engine
+ * Note: this structure must always be aligned to a 16-bytes boundary.
+ */
+
+/* old descriptor 4-word */
+typedef struct {
+	volatile u32 dcmd;	/* DCMD value for the current transfer */
+	volatile u32 dsadr;	/* DSAR value for the current transfer */
+	volatile u32 dtadr;	/* DTAR value for the current transfer */
+	volatile u32 ddadr;	/* Points to the next descriptor + transfer count */
+} jz_dma_desc;
+
+/* new descriptor 8-word */
+typedef struct {
+	volatile u32 dcmd;	/* DCMD value for the current transfer */
+	volatile u32 dsadr;	/* DSAR value for the current transfer */
+	volatile u32 dtadr;	/* DTAR value for the current transfer */
+	volatile u32 ddadr;	/* Points to the next descriptor + transfer count */
+	volatile u32 dstrd;     /* DMA source and target stride address */
+	volatile u32 dreqt;     /* DMA request type for current transfer */
+	volatile u32 reserved0;	/* Reserved */
+	volatile u32 reserved1;	/* Reserved */
+} jz_dma_desc_8word;
+
+/* DMA Device ID's follow */
+enum {
+	DMA_ID_EXT = 0,		/* External request with DREQn */
+	DMA_ID_NAND,		/* NAND DMA request */
+	DMA_ID_BCH_ENC,		/* BCH Encoding DMA request */
+	DMA_ID_BCH_DEC,		/* BCH Decoding DMA request */
+	DMA_ID_AUTO,		/* Auto-request */
+//	DMA_ID_TSSI_RX,		/* TSSI receive fifo full request */
+	DMA_ID_UART3_TX,	/* UART3 transmit-fifo-empty request */
+	DMA_ID_UART3_RX,	/* UART3 receve-fifo-full request */
+	DMA_ID_UART2_TX,	/* UART2 transmit-fifo-empty request */
+	DMA_ID_UART2_RX,	/* UART2 receve-fifo-full request */
+	DMA_ID_UART1_TX,	/* UART1 transmit-fifo-empty request */
+	DMA_ID_UART1_RX,	/* UART1 receve-fifo-full request */
+	DMA_ID_UART0_TX,	/* UART0 transmit-fifo-empty request */
+	DMA_ID_UART0_RX,	/* UART0 receve-fifo-full request */
+	DMA_ID_SSI0_TX,		/* SSI0 transmit-fifo-full request */
+	DMA_ID_SSI0_RX,		/* SSI0 receive-fifo-empty request */
+	DMA_ID_AIC_TX,		/* AIC transmit-fifo-full request */
+	DMA_ID_AIC_RX,		/* AIC receive-fifo-empty request */
+	DMA_ID_MSC0_TX,		/* MSC0 transmit-fifo-full request */
+	DMA_ID_MSC0_RX,		/* MSC0 receive-fifo-empty request */
+	DMA_ID_TCU_OVERFLOW,	/* TCU channel n overflow interrupt */
+	DMA_ID_SADC,		/* SADC transfer request */
+	DMA_ID_MSC1_TX,		/* MSC1 transmit-fifo-full request */
+	DMA_ID_MSC1_RX,		/* MSC1 receive-fifo-empty request */
+	DMA_ID_SSI1_TX,		/* SSI1 transmit-fifo-full request */
+	DMA_ID_SSI1_RX,		/* SSI1 receive-fifo-empty request */
+	DMA_ID_PCM_TX,		/* PM transmit-fifo-full request */
+	DMA_ID_PCM_RX,		/* PM receive-fifo-empty request */
+	DMA_ID_RAW_SET,
+	DMA_ID_MAX
+};
+
+/* DMA modes, simulated by sw */
+#define DMA_MODE_READ	0x0  /* I/O to memory, no autoinit, increment, single mode */
+#define DMA_MODE_WRITE	0x1  /* memory to I/O, no autoinit, increment, single mode */
+#define DMA_AUTOINIT	0x2
+#define DMA_MODE_MASK	0x3
+
+struct jz_dma_chan {
+	int dev_id;	/* DMA ID: this channel is allocated if >=0, free otherwise */ 
+	unsigned int io;        /* DMA channel number */
+	const char *dev_str;    /* string describes the DMA channel */
+	int irq;                /* DMA irq number */
+	void *irq_dev;          /* DMA private device structure */
+	unsigned int fifo_addr; /* physical fifo address of the requested device */
+	unsigned int cntl;	/* DMA controll */
+	unsigned int mode;      /* DMA configuration */
+	unsigned int source;    /* DMA request source */
+};
+
+extern struct jz_dma_chan jz_dma_table[];
+
+
+#define DMA_8BIT_RX_CMD					\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_8 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_8BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_8BIT_TX_CMD					\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_8 |		\
+	DMAC_DCMD_DS_8BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BIT_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BIT_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BIT_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BIT_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_8 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_8 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_8 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_8 |		\
+	DMAC_DCMD_DS_32BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_32_32BYTE_TX_CMD		       	\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BYTE | DMAC_DCMD_RDIL_IGN
+#define DMA_AIC_32_16BYTE_TX_CMD		       	\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_32_16BYTE_RX_CMD			\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BIT_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BIT_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BYTE_TX_CMD_UC			\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+extern int jz_request_dma(int dev_id,
+			  const char *dev_str,
+			  irqreturn_t (*irqhandler)(int, void *),
+			  unsigned long irqflags,
+			  void *irq_dev_id);
+extern void jz_free_dma(unsigned int dmanr);
+
+extern int jz_dma_read_proc(char *buf, char **start, off_t fpos,
+			      int length, int *eof, void *data);
+extern void dump_jz_dma_channel(unsigned int dmanr);
+
+extern void enable_dma(unsigned int dmanr);
+extern void disable_dma(unsigned int dmanr);
+extern void set_dma_addr(unsigned int dmanr, unsigned int phyaddr);
+extern void set_dma_count(unsigned int dmanr, unsigned int bytecnt);
+extern void set_dma_mode(unsigned int dmanr, unsigned int mode);
+extern void jz_set_oss_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt);
+extern void jz_set_alsa_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt);
+extern void jz_set_dma_src_width(int dmanr, int nbit);
+extern void jz_set_dma_dest_width(int dmanr, int nbit);
+extern void jz_set_dma_block_size(int dmanr, int nbyte);
+extern unsigned int get_dma_residue(unsigned int dmanr);
+
+extern spinlock_t  dma_spin_lock;
+
+static __inline__ unsigned long claim_dma_lock(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dma_spin_lock, flags);
+	return flags;
+}
+
+static __inline__ void release_dma_lock(unsigned long flags)
+{
+	spin_unlock_irqrestore(&dma_spin_lock, flags);
+}
+
+/* Clear the 'DMA Pointer Flip Flop'.
+ * Write 0 for LSB/MSB, 1 for MSB/LSB access.
+ */
+#define clear_dma_ff(channel)
+
+static __inline__ struct jz_dma_chan *get_dma_chan(unsigned int dmanr)
+{
+	if (dmanr > MAX_DMA_NUM
+	    || jz_dma_table[dmanr].dev_id < 0)
+		return NULL;
+	return &jz_dma_table[dmanr];
+}
+
+static __inline__ int dma_halted(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 1;
+	return  __dmac_channel_transmit_halt_detected(dmanr) ? 1 : 0;
+}
+
+static __inline__ unsigned int get_dma_mode(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+	return chan->mode;
+}
+
+static __inline__ void clear_dma_done(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+}
+
+static __inline__ void clear_dma_halt(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT);
+	REG_DMAC_DMACR((chan->io)/HALF_DMA_NUM) &= ~(DMAC_DMACR_HLT);
+}
+
+static __inline__ void clear_dma_flag(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+	REG_DMAC_DMACR((chan->io)/HALF_DMA_NUM) &= ~(DMAC_DMACR_HLT | DMAC_DMACR_AR);
+}
+
+static __inline__ void set_dma_page(unsigned int dmanr, char pagenr)
+{
+}
+
+static __inline__ unsigned int get_dma_done_status(unsigned int dmanr)
+{
+	unsigned long dccsr;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+	dccsr = REG_DMAC_DCCSR(chan->io);
+	return dccsr & (DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+}
+
+static __inline__ int get_dma_done_irq(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return -1;
+	return chan->irq;
+}
+
+#endif  /* __ASM_JZ4750_DMA_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750/jz4750.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750/jz4750.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,44 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750/jz4750.h
+ *
+ *  JZ4750 common definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750_H__
+#define __ASM_JZ4750_H__
+
+#include <asm/mach-jz4750/regs.h>
+#include <asm/mach-jz4750/ops.h>
+#include <asm/mach-jz4750/dma.h>
+#include <asm/mach-jz4750/misc.h>
+
+/*------------------------------------------------------------------
+ * Platform definitions
+ */
+#ifdef CONFIG_JZ4750_FUWA
+#include <asm/mach-jz4750/board-fuwa.h>
+#endif
+
+#ifdef CONFIG_JZ4750_APUS
+#include <asm/mach-jz4750/board-apus.h>
+#endif
+
+/* Add other platform definition here ... */
+
+
+/*------------------------------------------------------------------
+ * Follows are related to platform definitions
+ */
+
+#include <asm/mach-jz4750/clock.h>
+#include <asm/mach-jz4750/serial.h>
+
+#endif /* __ASM_JZ4750_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750/misc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750/misc.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,44 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750/misc.h
+ *
+ *  Ingenic's JZ4750 common include.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750_MISC_H__
+#define __ASM_JZ4750_MISC_H__
+
+/*==========================================================
+ * I2C
+ *===========================================================*/
+
+#define I2C_EEPROM_DEV	0xA	/* b'1010 */
+#define I2C_RTC_DEV	0xD	/* b'1101 */
+#define DIMM0_SPD_ADDR	0
+#define DIMM1_SPD_ADDR	1
+#define DIMM2_SPD_ADDR	2
+#define DIMM3_SPD_ADDR	3
+#define JZ_HCI_ADDR	7
+
+#define DIMM_SPD_LEN	128
+#define JZ_HCI_LEN	512    /* 4K bits E2PROM */
+#define I2C_RTC_LEN	16
+#define HCI_MAC_OFFSET	64
+
+extern void i2c_open(void);
+extern void i2c_close(void);
+extern void i2c_setclk(unsigned int i2cclk);
+
+extern int i2c_read(unsigned char device, unsigned char *buf,
+		    unsigned char address, int count);
+extern int i2c_write(unsigned char device, unsigned char *buf,
+		     unsigned char address, int count);
+
+#endif /* __ASM_JZ4750_MISC_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750/ops.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750/ops.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,3569 @@
+/*
+ * linux/include/asm-mips/mach-jz4750/ops.h
+ *
+ * JZ4750 register definition.
+ *
+ * Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef __JZ4750_OPS_H__
+#define __JZ4750_OPS_H__
+
+/*
+ * Definition of Module Operations
+ */
+
+/***************************************************************************
+ * EMC
+ ***************************************************************************/
+#define is_share_mode() ((REG_EMC_BCR & EMC_BCR_BSR_MASK) == EMC_BCR_BSR_SHARE)
+#define is_normal_order() (!(REG_EMC_BCR & EMC_BCR_PK_SEL))
+
+/***************************************************************************
+ * GPIO
+ ***************************************************************************/
+
+//------------------------------------------------------
+// GPIO Pins Description
+//
+// PORT 0:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		D0		-
+//	1		D1		-
+//	2		D2		-
+//	3		D3		-
+//	4		D4		-
+//	5		D5		-
+//	6		D6		-
+//	7		D7		-
+//	8		D8		-
+//	9		D9		-
+//	10		D10		-
+//	11		D11		-
+//	12		D12		-
+//	13		D13		-
+//	14		D14		-
+//	15		D15		-
+//	16		D16		-
+//	17		D17		-
+//	18		D18		-
+//	19		D19		-
+//	20		D20		-
+//	21		D21		-
+//	22		D22		-
+//	23		D23		-
+//	24		D24		-
+//	25		D25		-
+//	26		D26		-
+//	27		D27		-
+//	28		D28		-
+//	29		D29		-
+//	30		D30		-
+//	31		D31		-
+//
+//------------------------------------------------------
+// PORT 1:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		A0		-
+//	1		A1		-
+//	2		A2		-
+//	3		A3		-
+//	4		A4		-
+//	5		A5		-
+//	6		A6		-
+//	7		A7		-
+//	8		A8		-
+//	9		A9		-
+//	10		A10		-
+//	11		A11		-
+//	12		A12		-
+//	13		A13		-
+//	14		A14		-
+//	15		A15/CLE		SA3
+//	16		DCS0#		-
+//	17		RAS#		-
+//	18		CAS#		-
+//	19		RDWE#/BUFD#	-
+//	20		WE0#		-
+//	21		WE1#		-
+//	22		WE2#		-
+//	23		WE3#		-
+//	24		CKO		-		Note1
+//	25		CKE		-
+//	26		SSI0_CLK	-
+//	27		SSI0_DT		-
+//	28		SSI0_DR		-
+//	29		SSI0_CE0#	-
+//	30		SSI0_CE1#_GPC	-
+//	31		SSI0_CE2#	-
+//
+// Note1: BIT24: it is CKO when chip is reset
+//
+//------------------------------------------------------
+// PORT 2:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		SD0		A20
+//	1		SD1		A21
+//	2		SD2		A22
+//	3		SD3		A23
+//	4		SD4		A24
+//	5		SD5		A25
+//	6		SD6		-
+//	7		SD7		-
+//	8		SD8		TSDI0
+//	9		SD9		TSDI1
+//	10		SD10		TSDI2
+//	11		SD11		TSDI3
+//	12		SD12		TSDI4
+//	13		SD13		TSDI5
+//	14		SD14		TSDI6
+//	15		SD15		TSDI7
+//	16		A16/ALE		SA4
+//	17		SA0		A17
+//	18		SA1		A18
+//	19		SA2		A19
+//	20		WAIT#		-		Note2
+//	21		CS1#		-
+//	22		CS2#		-
+//	23		CS3#		-
+//	24		CS4#		-
+//	25		RD#		-
+//	26		WR#		-
+//	27		FRB#		-		Note3
+//	28		FRE#		-
+//	29		FWE#		-
+//	30		BOOT_SEL0	-		Note4
+//	31		BOOT_SEL1	-		Note5
+//
+// Note2: BIT20: it is WAIT# pin when chip is reset
+//
+// Note3: BIT27: when NAND is used, it should connect to NANF FRB#.
+//
+// Note4: BIT30: it is BOOT_SEL0 when chip is reset, it can used as output GPIO.
+//
+// Note5: BIT31: it is BOOT_SEL1 when chip is reset, it can used as general GPIO.
+//
+//------------------------------------------------------
+// PORT 3:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		LCD_D0		-
+//	1		LCD_D1		-
+//	2		LCD_D2		-
+//	3		LCD_D3		-
+//	4		LCD_D4		-
+//	5		LCD_D5		-
+//	6		LCD_D6		-
+//	7		LCD_D7		-
+//	8		LCD_D8		-
+//	9		LCD_D9		-
+//	10		LCD_D10		-
+//	11		LCD_D11		-
+//	12		LCD_D12		-
+//	13		LCD_D13		-
+//	14		LCD_D14		-
+//	15		LCD_D15		-
+//	16		LCD_D16		-
+//	17		LCD_D17		-
+//	18		LCD_PCLK	-
+//	19		LCD_HSYNC	-
+//	20		LCD_VSYNC	-
+//	21		LCD_DE		-
+//	22		LCD_CLS		-
+//	23		LCD_SPL		-
+//	24		LCD_PS		-
+//	25		LCD_REV		-
+//	26		SSI1_CLK	-
+//	27		SSI1_DT		-
+//	28		SSI1_DR		-
+//	29		SSI1_CE0#	-
+//	30		SSI1_CE1#	-
+//	31		-		-
+//
+//------------------------------------------------------
+// PORT 4:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		CIM_D0		-
+//	1		CIM_D1		-
+//	2		CIM_D2		-
+//	3		CIM_D3		-
+//	4		CIM_D4		-
+//	5		CIM_D5		-
+//	6		CIM_D6		-
+//	7		CIM_D7		-
+//	8		CIM_MCLK	-
+//	9		CIM_PCLK	-
+//	10		CIM_VSYNC	-
+//	11		CIM_HSYNC	-
+//	12		I2C_SDA		-
+//	13		I2C_SCK		-
+//	14		-		-
+//	15		-		-
+//	16		UART1_RxD	-
+//	17		UART1_TxD	-
+//	18		UART1_CTS	PCM_DIN
+//	19		UART1_RTS	PCM_DOUT
+//	20		PWM0		PCM_CLK
+//	21		PWM1		PCM_SYN
+//	22		PWM2		SCLK_RSTN
+//	23		PWM3		BCLK
+//	24		PWM4		SYNC
+//	25		PWM5		OWI
+//	26		SDATO		UART2_TxD
+//	27		SDATI		UART2_RxD
+//	28		DCS1#		-
+//	29		-		-
+//	30		WKUP		-		Note6
+//	31		-		-		Note7
+//
+// Note6: BIT30: it is only used as input and interrupt, and with no pull-up and pull-down
+//
+// Note7: BIT31: it is used to select the function of UART or JTAG set by PESEL[31]
+//        PESEL[31] = 0, select JTAG function
+//        PESEL[31] = 1, select UART function
+//
+//------------------------------------------------------
+// PORT 5:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		MSC0_D0		-
+//	1		MSC0_D1		-
+//	2		MSC0_D2		DREQ
+//	3		MSC0_D3		DACK
+//	4		MSC0_D4		UART0_RxD
+//	5		MSC0_D5		UART0_TxD
+//	6		MSC0_D6		UART0_CTS
+//	7		MSC0_D7		UART0_RTS
+//	8		MSC0_CLK	-
+//	9		MSC0_CMD	-
+//	10		MSC1_D0		-
+//	11		MSC1_D1		-
+//	12		MSC1_D2		-
+//	13		MSC1_D3		-
+//	14		MSC1_CLK	-
+//	15		MSC1_CMD	-
+//	16		UART3_RxD	-
+//	17		UART3_TxD	-
+//	18		UART3_CTS	-
+//	19		UART3_RTS	-
+//	20		TSCLK		-
+//	21		TSSTR		-
+//	22		TSFRM		-
+//	23		TSFAIL		-
+//	24		-		-
+//	25		-		-
+//	26		-		-
+//	27		-		-
+//	28		-		-
+//	29		-		-
+//	30		-		-
+//	31		-		-
+//
+//////////////////////////////////////////////////////////
+
+/* 
+ * p is the port number (0,1,2,3,4,5)
+ * o is the pin offset (0-31) inside the port
+ * n is the absolute number of a pin (0-191), regardless of the port
+ */
+
+//-------------------------------------------
+// Function Pins Mode
+
+#define __gpio_as_func0(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXSELC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_func1(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+} while (0)
+
+/*
+ * D0 ~ D31, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ */
+#define __gpio_as_sdram_32bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0xffffffff;	\
+	REG_GPIO_PXSELC(0) = 0xffffffff;	\
+	REG_GPIO_PXPES(0) = 0xffffffff;		\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;	\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;	\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;		\
+} while (0)
+
+/*
+ * D0 ~ D15, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ */
+#define __gpio_as_sdram_16bit()						\
+do {								        \
+	if (is_normal_order()) {					\
+		/* 32/16-bit data normal order */			\
+		REG_GPIO_PXFUNS(0) = 0x0000ffff;			\
+		REG_GPIO_PXSELC(0) = 0x0000ffff;			\
+		REG_GPIO_PXPES(0) = 0x0000ffff;				\
+	} else {							\
+		/* 16-bit data special order */				\
+		REG_GPIO_PXFUNS(0) = 0x00ffff00;			\
+		REG_GPIO_PXSELC(0) = 0x00ffff00;			\
+		REG_GPIO_PXPES(0) = 0x00ffff00;				\
+	}								\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;				\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;				\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;					\
+} while (0)
+
+/*
+ * D0 ~ D7, CS1#, CLE, ALE, FRE#, FWE#, FRB#, RDWE#/BUFD#
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nand_8bit(n)						\
+do {		              						\
+	if (!is_share_mode()) {						\
+		/* unshare mode */					\
+		REG_GPIO_PXFUNS(2) = 0x000000ff; /* SD0~SD7 */		\
+		REG_GPIO_PXSELS(2) = 0x000000ff;			\
+		REG_GPIO_PXPES(2) = 0x000000ff;				\
+		REG_GPIO_PXFUNS(1) = 0x00008000; /* CLE(SA3) */		\
+		REG_GPIO_PXSELS(1) = 0x00008000;			\
+		REG_GPIO_PXPES(1) = 0x00008000;				\
+		REG_GPIO_PXFUNS(2) = 0x00010000; /* ALE(SA4) */		\
+		REG_GPIO_PXSELS(2) = 0x00010000;			\
+		REG_GPIO_PXPES(2) = 0x00010000;				\
+	} else {							\
+		/* share mode */					\
+		if (is_normal_order()) {	              		\
+			/* 32/16-bit data normal order */		\
+			REG_GPIO_PXFUNS(0) = 0x000000ff; /* D0~D7 */	\
+			REG_GPIO_PXSELC(0) = 0x000000ff;		\
+			REG_GPIO_PXPES(0) = 0x000000ff;			\
+		} else {						\
+			/* 16-bit data special order */			\
+			REG_GPIO_PXFUNS(0) = 0x0000ff00; /* D0~D7 */	\
+			REG_GPIO_PXSELC(0) = 0x0000ff00;		\
+			REG_GPIO_PXPES(0) = 0x0000ff00;			\
+		}							\
+		REG_GPIO_PXFUNS(1) = 0x00008000; /* CLE(A15) */		\
+		REG_GPIO_PXSELC(1) = 0x00008000;			\
+		REG_GPIO_PXPES(1) = 0x00008000;				\
+		REG_GPIO_PXFUNS(2) = 0x00010000; /* ALE(A16) */		\
+		REG_GPIO_PXSELC(2) = 0x00010000;			\
+		REG_GPIO_PXPES(2) = 0x00010000;				\
+	}								\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+        REG_GPIO_PXFUNS(1) = 0x00080000; /* RDWE#/BUFD# */		\
+        REG_GPIO_PXSELC(1) = 0x00080000;				\
+	REG_GPIO_PXPES(1) = 0x00080000;					\
+	REG_GPIO_PXFUNS(2) = 0x30000000; /* FRE#, FWE# */		\
+	REG_GPIO_PXSELC(2) = 0x30000000;				\
+	REG_GPIO_PXPES(2) = 0x30000000;					\
+	REG_GPIO_PXFUNC(2) = 0x08000000; /* FRB#(input) */		\
+	REG_GPIO_PXSELC(2) = 0x08000000;				\
+	REG_GPIO_PXDIRC(2) = 0x08000000;				\
+	REG_GPIO_PXPES(2) = 0x08000000;					\
+} while (0)
+
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D7
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nor_8bit(n)						\
+do {								        \
+	if (is_normal_order()) {					\
+		/* 32/16-bit data normal order */			\
+		REG_GPIO_PXFUNS(0) = 0x000000ff;			\
+		REG_GPIO_PXSELC(0) = 0x000000ff;			\
+		REG_GPIO_PXPES(0) = 0x000000ff;				\
+	} else {							\
+		/* 16-bit data special order */				\
+		REG_GPIO_PXFUNS(0) = 0x0000ff00;			\
+		REG_GPIO_PXSELC(0) = 0x0000ff00;			\
+		REG_GPIO_PXPES(0) = 0x0000ff00;				\
+	}								\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+	REG_GPIO_PXFUNS(1) = 0x0000ffff; /* A0~A15 */			\
+	REG_GPIO_PXSELC(1) = 0x0000ffff;				\
+	REG_GPIO_PXPES(1) = 0x0000ffff;					\
+	REG_GPIO_PXFUNS(2) = 0x06110007; /* RD#, WR#, WAIT#, A20~A22 */	\
+	REG_GPIO_PXSELC(2) = 0x06110007;				\
+	REG_GPIO_PXPES(2) = 0x06110007;					\
+	REG_GPIO_PXFUNS(2) = 0x000e0000; /* A17~A19 */	        	\
+	REG_GPIO_PXSELS(2) = 0x000e0000;				\
+	REG_GPIO_PXPES(2) = 0x000e0000;					\
+} while (0)
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D15
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nor_16bit(n)						\
+do {	               							\
+	if (is_normal_order()) {					\
+		/* 32/16-bit data normal order */			\
+		REG_GPIO_PXFUNS(0) = 0x0000ffff;			\
+		REG_GPIO_PXSELC(0) = 0x0000ffff;			\
+		REG_GPIO_PXPES(0) = 0x0000ffff;				\
+	} else {							\
+		/* 16-bit data special order */				\
+		REG_GPIO_PXFUNS(0) = 0x00ffff00;			\
+		REG_GPIO_PXSELC(0) = 0x00ffff00;			\
+		REG_GPIO_PXPES(0) = 0x00ffff00;				\
+	}								\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+	REG_GPIO_PXFUNS(1) = 0x0000ffff; /* A0~A15 */			\
+	REG_GPIO_PXSELC(1) = 0x0000ffff;				\
+	REG_GPIO_PXPES(1) = 0x0000ffff;					\
+	REG_GPIO_PXFUNS(2) = 0x06110007; /* RD#, WR#, WAIT#, A20~A22 */	\
+	REG_GPIO_PXSELC(2) = 0x06110007;				\
+	REG_GPIO_PXPES(2) = 0x06110007;					\
+	REG_GPIO_PXFUNS(2) = 0x000e0000; /* A17~A19 */	        	\
+	REG_GPIO_PXSELS(2) = 0x000e0000;				\
+	REG_GPIO_PXPES(2) = 0x000e0000;					\
+} while (0)
+
+/*
+ * UART0_TxD, UART0_RxD
+ */
+#define __gpio_as_uart0()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x00000030;	\
+	REG_GPIO_PXSELS(5) = 0x00000030;	\
+	REG_GPIO_PXPES(5) = 0x00000030;		\
+} while (0)
+
+/*
+ * UART0_TxD, UART0_RxD, UART0_CTS, UART0_RTS
+ */
+#define __gpio_as_uart0_ctsrts()		\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x000000f0;	\
+	REG_GPIO_PXSELS(5) = 0x000000f0;	\
+	REG_GPIO_PXPES(5) = 0x000000f0;		\
+} while (0)
+
+/*
+ * UART1_TxD, UART1_RxD
+ */
+#define __gpio_as_uart1()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00030000;	\
+	REG_GPIO_PXSELC(4) = 0x00030000;	\
+	REG_GPIO_PXPES(4) = 0x00030000;		\
+} while (0)
+
+/*
+ * UART1_TxD, UART1_RxD, UART1_CTS, UART1_RTS
+ */
+#define __gpio_as_uart1_ctsrts()		\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x000f0000;	\
+	REG_GPIO_PXSELC(4) = 0x000f0000;	\
+	REG_GPIO_PXPES(4) = 0x000f0000;		\
+} while (0)
+
+/*
+ * UART2_TxD, UART2_RxD
+ */
+#define __gpio_as_uart2()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x0c000000;	\
+	REG_GPIO_PXSELS(4) = 0x0c000000;	\
+	REG_GPIO_PXPES(4) = 0x0c000000;		\
+} while (0)
+
+/*
+ * UART3_TxD, UART3_RxD
+ */
+#define __gpio_as_uart3()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x00030000;	\
+	REG_GPIO_PXSELC(5) = 0x00030000;	\
+	REG_GPIO_PXPES(5) = 0x00030000;		\
+} while (0)
+
+/*
+ * UART3_TxD, UART3_RxD, UART3_CTS, UART3_RTS
+ */
+#define __gpio_as_uart3_ctsrts()		\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x000f0000;	\
+	REG_GPIO_PXSELC(5) = 0x000f0000;	\
+	REG_GPIO_PXPES(5) = 0x000f0000;		\
+} while (0)
+
+/*
+ * TSCLK, TSSTR, TSFRM, TSFAIL, TSDI0~7
+ */
+#define __gpio_as_tssi()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x0000ff00;	\
+	REG_GPIO_PXSELS(2) = 0x0000ff00;	\
+	REG_GPIO_PXPES(2) = 0x0000ff00;		\
+	REG_GPIO_PXFUNS(5) = 0x00f00000;	\
+	REG_GPIO_PXSELC(5) = 0x00f00000;	\
+	REG_GPIO_PXPES(5) = 0x00f00000;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D7, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003c00ff;	\
+	REG_GPIO_PXSELC(3) = 0x003c00ff;	\
+	REG_GPIO_PXPES(3) = 0x003c00ff;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D15, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003cffff;	\
+	REG_GPIO_PXSELC(3) = 0x003cffff;	\
+	REG_GPIO_PXPES(3) = 0x003cffff;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D17, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_18bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003fffff;	\
+	REG_GPIO_PXSELC(3) = 0x003fffff;	\
+	REG_GPIO_PXPES(3) = 0x003fffff;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D17, LCD_D_R1, LCD_D_G0, LCD_D_G1, LCD_D_B1,
+ * LCD_D_R0, LCD_D_B0, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_24bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003fffff;	\
+	REG_GPIO_PXSELC(3) = 0x003fffff;	\
+	REG_GPIO_PXPES(3)  = 0x003fffff;	\
+	REG_GPIO_PXFUNS(3) = 0x03c00000;	\
+	REG_GPIO_PXSELS(3) = 0x03c00000;	\
+	REG_GPIO_PXPES(3)  = 0x03c00000;	\
+	REG_GPIO_PXFUNS(5) = 0x000c0000;	\
+	REG_GPIO_PXSELS(5) = 0x000c0000;	\
+	REG_GPIO_PXPES(5)  = 0x000c0000;	\
+} while (0)
+
+/*
+ * SLCD_DAT0~7, SLCD_CLK, SLCD_RS, SLCD_CS
+ */
+#define __gpio_as_lcd_smart_pal_8bit()		\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x001c00ff;	\
+	REG_GPIO_PXSELC(3) = 0x001c00ff;	\
+	REG_GPIO_PXPES(3) = 0x001c00ff;		\
+} while (0)
+
+/*
+ * SLCD_DAT0~15, SLCD_CLK, SLCD_RS, SLCD_CS
+ */
+#define __gpio_as_lcd_smart_pal_15bit()		\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x001cffff;	\
+	REG_GPIO_PXSELC(3) = 0x001cffff;	\
+	REG_GPIO_PXPES(3) = 0x001cffff;		\
+} while (0)
+
+/*
+ * SLCD_DAT0~17, SLCD_CLK, SLCD_RS, SLCD_CS
+ */
+#define __gpio_as_lcd_smart_pal_17bit()		\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x001fffff;	\
+	REG_GPIO_PXSELC(3) = 0x001fffff;	\
+	REG_GPIO_PXPES(3) = 0x001fffff;		\
+} while (0)
+
+/*
+ * SLCD_DAT15, SLCD_CLK, SLCD_RS, SLCD_CS
+ */
+#define __gpio_as_lcd_smart_serial()		\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x001c8000;	\
+	REG_GPIO_PXSELC(3) = 0x001c8000;	\
+	REG_GPIO_PXPES(3) = 0x001c8000;		\
+} while (0)
+
+/*
+ *  LCD_CLS, LCD_SPL, LCD_PS, LCD_REV
+ */
+#define __gpio_as_lcd_special()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x03C00000;	\
+	REG_GPIO_PXSELC(3) = 0x03C00000;	\
+	REG_GPIO_PXPES(3)  = 0x03C00000;	\
+} while (0)
+
+/*
+ * CIM_D0~CIM_D7, CIM_MCLK, CIM_PCLK, CIM_VSYNC, CIM_HSYNC
+ */
+#define __gpio_as_cim()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00000fff;	\
+	REG_GPIO_PXSELC(4) = 0x00000fff;	\
+	REG_GPIO_PXPES(4)  = 0x00000fff;	\
+} while (0)
+
+/* 
+ * SDATO, SDATI, BCLK, SYNC, SCLK_RSTN(gpio sepc) or
+ * SDATA_OUT, SDATA_IN, BIT_CLK, SYNC, SCLK_RESET(aic spec)
+ */
+#define __gpio_as_aic()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x0c000000;	\
+	REG_GPIO_PXSELS(4) = 0x0c000000;	\
+	REG_GPIO_PXPES(4)  = 0x0c000000;	\
+	REG_GPIO_PXFUNS(4) = 0x00e00000;	\
+	REG_GPIO_PXSELC(4) = 0x00e00000;	\
+	REG_GPIO_PXPES(4)  = 0x00e00000;	\
+} while (0)
+
+/*
+ * PCM_DIN, PCM_DOUT, PCM_CLK, PCM_SYN
+*/
+#define __gpio_as_pcm() 			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x003c0000;	\
+	REG_GPIO_PXSELS(4) = 0x003c0000;	\
+	REG_GPIO_PXPES(4)  = 0x003c0000; 	\
+} while (0)
+
+/*
+ * OWI
+*/
+#define __gpio_as_owi() 			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x02000000;	\
+	REG_GPIO_PXSELS(4) = 0x02000000;	\
+	REG_GPIO_PXPES(4) = 0x02000000;		\
+} while (0)
+
+/*
+ * MSC0_CMD, MSC0_CLK, MSC0_D0 ~ MSC0_D3
+ */
+#define __gpio_as_msc0_4bit()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x0000030f;	\
+	REG_GPIO_PXSELC(5) = 0x0000030f;	\
+	REG_GPIO_PXPES(5)  = 0x0000030f;	\
+} while (0)
+
+/*
+ * MSC0_CMD, MSC0_CLK, MSC0_D0 ~ MSC0_D7
+ */
+#define __gpio_as_msc0_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x000003ff;	\
+	REG_GPIO_PXSELC(5) = 0x000003ff;	\
+	REG_GPIO_PXPES(5)  = 0x000003ff;	\
+} while (0)
+
+/*
+ * MSC1_CMD, MSC1_CLK, MSC1_D0 ~ MSC1_D3
+ */
+#define __gpio_as_msc1_4bit()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x0000fc00;	\
+	REG_GPIO_PXSELC(5) = 0x0000fc00;	\
+	REG_GPIO_PXPES(5)  = 0x0000fc00;	\
+} while (0)
+
+#define __gpio_as_msc 	__gpio_as_msc0_8bit /* default as msc0 8bit */
+#define __gpio_as_msc0 	__gpio_as_msc0_8bit /* msc0 default as 8bit */
+#define __gpio_as_msc1 	__gpio_as_msc1_4bit /* msc1 only support 4bit */
+
+/*
+ * SSI0_CE0, SSI0_CE1#_GPC, SSI0_CE2, SSI0_CLK, SSI0_DT, SSI0_DR
+ */
+#define __gpio_as_ssi0()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0xfc000000;	\
+	REG_GPIO_PXSELC(1) = 0xfc000000;	\
+	REG_GPIO_PXPES(1)  = 0xfc000000;	\
+} while (0)
+
+/*
+ * SSI1_CE0, SSI1_CE1, SSI1_CLK, SSI1_DT, SSI1_DR
+ */
+#define __gpio_as_ssi1()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x7c000000;	\
+	REG_GPIO_PXSELC(3) = 0x7c000000;	\
+	REG_GPIO_PXPES(3)  = 0x7c000000;	\
+} while (0)
+
+/* n = 0(SSI0), 1(SSI1) */
+#define __gpio_as_ssi(n)	 __gpio_as_ssi##n()
+
+/*
+ * I2C_SCK, I2C_SDA
+ */
+#define __gpio_as_i2c()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00003000;	\
+	REG_GPIO_PXSELC(4) = 0x00003000;	\
+	REG_GPIO_PXPES(4)  = 0x00003000;	\
+} while (0)
+
+/*
+ * PWM0
+ */
+#define __gpio_as_pwm0()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00100000;	\
+	REG_GPIO_PXSELC(4) = 0x00100000;	\
+	REG_GPIO_PXPES(4) = 0x00100000;		\
+} while (0)
+
+/*
+ * PWM1
+ */
+#define __gpio_as_pwm1()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00200000;	\
+	REG_GPIO_PXSELC(4) = 0x00200000;	\
+	REG_GPIO_PXPES(4) = 0x00200000;		\
+} while (0)
+
+/*
+ * PWM2
+ */
+#define __gpio_as_pwm2()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00400000;	\
+	REG_GPIO_PXSELC(4) = 0x00400000;	\
+	REG_GPIO_PXPES(4) = 0x00400000;		\
+} while (0)
+
+/*
+ * PWM3
+ */
+#define __gpio_as_pwm3()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00800000;	\
+	REG_GPIO_PXSELC(4) = 0x00800000;	\
+	REG_GPIO_PXPES(4) = 0x00800000;		\
+} while (0)
+
+/*
+ * PWM4
+ */
+#define __gpio_as_pwm4()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x01000000;	\
+	REG_GPIO_PXSELC(4) = 0x01000000;	\
+	REG_GPIO_PXPES(4) = 0x01000000;		\
+} while (0)
+
+/*
+ * PWM5
+ */
+#define __gpio_as_pwm5()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x02000000;	\
+	REG_GPIO_PXSELC(4) = 0x02000000;	\
+	REG_GPIO_PXPES(4) = 0x02000000;		\
+} while (0)
+
+/*
+ * n = 0 ~ 5
+ */
+#define __gpio_as_pwm(n)	__gpio_as_pwm##n()
+
+/*
+ * DREQ
+ */
+#define __gpio_as_dreq()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x00000004;	\
+	REG_GPIO_PXSELS(5) = 0x00000004;	\
+	REG_GPIO_PXPES(5) = 0x00000004;		\
+} while (0)
+
+/*
+ * DACK
+ */
+#define __gpio_as_dack()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x00000008;	\
+	REG_GPIO_PXSELS(5) = 0x00000008;	\
+	REG_GPIO_PXPES(5) = 0x00000008;		\
+} while (0)
+
+/*
+ * GPIO or Interrupt Mode
+ */
+#define __gpio_get_port(p)	(REG_GPIO_PXPIN(p))
+
+#define __gpio_port_as_output(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRS(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_port_as_input(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRC(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_as_output(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_output(p, o);		\
+} while (0)
+
+#define __gpio_as_input(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_input(p, o);		\
+} while (0)
+
+#define __gpio_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_pin(n)			\
+({						\
+	unsigned int p, o, v;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	if (__gpio_get_port(p) & (1 << o))	\
+		v = 1;				\
+	else					\
+		v = 0;				\
+	v;					\
+})
+
+#define __gpio_as_irq_high_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_low_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_rise_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_fall_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_mask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_unmask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_ack_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_irq()			\
+({						\
+	unsigned int p, i, tmp, v = 0;		\
+	for (p = 3; p >= 0; p--) {		\
+		tmp = REG_GPIO_PXFLG(p);	\
+		for (i = 0; i < 32; i++)	\
+			if (tmp & (1 << i))	\
+				v = (32*p + i);	\
+	}					\
+	v;					\
+})
+
+#define __gpio_group_irq(n)			\
+({						\
+	register int tmp, i;			\
+	tmp = REG_GPIO_PXFLG((n));		\
+	for (i=31;i>=0;i--)			\
+		if (tmp & (1 << i))		\
+			break;			\
+	i;					\
+})
+
+#define __gpio_enable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPEC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_disable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPES(p) = (1 << o);		\
+} while (0)
+
+
+/***************************************************************************
+ * CPM
+ ***************************************************************************/
+#define __cpm_get_pllm() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLM_MASK) >> CPM_CPPCR_PLLM_BIT)
+#define __cpm_get_plln() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLN_MASK) >> CPM_CPPCR_PLLN_BIT)
+#define __cpm_get_pllod() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLOD_MASK) >> CPM_CPPCR_PLLOD_BIT)
+
+#define __cpm_get_cdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_CDIV_MASK) >> CPM_CPCCR_CDIV_BIT)
+#define __cpm_get_hdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_HDIV_MASK) >> CPM_CPCCR_HDIV_BIT)
+#define __cpm_get_pdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_PDIV_MASK) >> CPM_CPCCR_PDIV_BIT)
+#define __cpm_get_mdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_MDIV_MASK) >> CPM_CPCCR_MDIV_BIT)
+#define __cpm_get_ldiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_LDIV_MASK) >> CPM_CPCCR_LDIV_BIT)
+#define __cpm_get_udiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_UDIV_MASK) >> CPM_CPCCR_UDIV_BIT)
+#define __cpm_get_i2sdiv() \
+	((REG_CPM_I2SCDR & CPM_I2SCDR_I2SDIV_MASK) >> CPM_I2SCDR_I2SDIV_BIT)
+#define __cpm_get_pixdiv() \
+	((REG_CPM_LPCDR & CPM_LPCDR_PIXDIV_MASK) >> CPM_LPCDR_PIXDIV_BIT)
+#define __cpm_get_mscdiv(n) \
+	((REG_CPM_MSCCDR(n) & CPM_MSCCDR_MSCDIV_MASK) >> CPM_MSCCDR_MSCDIV_BIT)
+#define __cpm_get_uhcdiv() \
+	((REG_CPM_UHCCDR & CPM_UHCCDR_UHCDIV_MASK) >> CPM_UHCCDR_UHCDIV_BIT)
+#define __cpm_get_ssidiv() \
+	((REG_CPM_SSICCDR & CPM_SSICDR_SSICDIV_MASK) >> CPM_SSICDR_SSIDIV_BIT)
+#define __cpm_get_pcmdiv(v) \
+	((REG_CPM_PCMCDR & CPM_PCMCDR_PCMCD_MASK) >> CPM_PCMCDR_PCMCD_BIT)
+
+#define __cpm_set_cdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_CDIV_MASK) | ((v) << (CPM_CPCCR_CDIV_BIT)))
+#define __cpm_set_hdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_HDIV_MASK) | ((v) << (CPM_CPCCR_HDIV_BIT)))
+#define __cpm_set_pdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_PDIV_MASK) | ((v) << (CPM_CPCCR_PDIV_BIT)))
+#define __cpm_set_mdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_MDIV_MASK) | ((v) << (CPM_CPCCR_MDIV_BIT)))
+#define __cpm_set_ldiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_LDIV_MASK) | ((v) << (CPM_CPCCR_LDIV_BIT)))
+#define __cpm_set_udiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_UDIV_MASK) | ((v) << (CPM_CPCCR_UDIV_BIT)))
+#define __cpm_set_i2sdiv(v) \
+	(REG_CPM_I2SCDR = (REG_CPM_I2SCDR & ~CPM_I2SCDR_I2SDIV_MASK) | ((v) << (CPM_I2SCDR_I2SDIV_BIT)))
+#define __cpm_set_pixdiv(v) \
+	(REG_CPM_LPCDR = (REG_CPM_LPCDR & ~CPM_LPCDR_PIXDIV_MASK) | ((v) << (CPM_LPCDR_PIXDIV_BIT)))
+#define __cpm_set_mscdiv(n, v) \
+	(REG_CPM_MSCCDR(n) = (REG_CPM_MSCCDR(n) & ~CPM_MSCCDR_MSCDIV_MASK) | ((v) << (CPM_MSCCDR_MSCDIV_BIT)))
+#define __cpm_set_uhcdiv(v) \
+	(REG_CPM_UHCCDR = (REG_CPM_UHCCDR & ~CPM_UHCCDR_UHCDIV_MASK) | ((v) << (CPM_UHCCDR_UHCDIV_BIT)))
+#define __cpm_set_ssidiv(v) \
+	(REG_CPM_SSICDR = (REG_CPM_SSICDR & ~CPM_SSICDR_SSIDIV_MASK) | ((v) << (CPM_SSICDR_SSIDIV_BIT)))
+#define __cpm_set_pcmdiv(v) \
+	(REG_CPM_PCMCDR = (REG_CPM_PCMCDR & ~CPM_PCMCDR_PCMCD_MASK) | ((v) << (CPM_PCMCDR_PCMCD_BIT)))
+
+#define __cpm_select_pcmclk_pll() 	(REG_CPM_PCMCDR |= CPM_PCMCDR_PCMS)
+#define __cpm_select_pcmclk_exclk() 	(REG_CPM_PCMCDR &= ~CPM_PCMCDR_PCMS)
+#define __cpm_select_pixclk_ext()	(REG_CPM_LPCDR |= CPM_LPCDR_LPCS)
+#define __cpm_select_pixclk_pll()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LPCS)
+#define __cpm_select_tveclk_exclk()	(REG_CPM_LPCDR |= CPM_CPCCR_LSCS)
+#define __cpm_select_tveclk_pll()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LSCS)
+#define __cpm_select_pixclk_lcd()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LTCS)
+#define __cpm_select_pixclk_tve()	(REG_CPM_LPCDR |= CPM_LPCDR_LTCS)
+#define __cpm_select_i2sclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_I2CS)
+#define __cpm_select_i2sclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_I2CS)
+#define __cpm_select_usbclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_UCS)
+#define __cpm_select_usbclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_UCS)
+
+#define __cpm_enable_cko()
+#define __cpm_exclk_direct()		(REG_CPM_CPCCR &= ~CPM_CPCCR_ECS)
+#define __cpm_exclk_div2()             	(REG_CPM_CPCCR |= CPM_CPCCR_ECS)
+#define __cpm_enable_pll_change()	(REG_CPM_CPCCR |= CPM_CPCCR_CE)
+#define __cpm_pllout_direct()		(REG_CPM_CPCCR |= CPM_CPCCR_PCS)
+#define __cpm_pllout_div2()		(REG_CPM_CPCCR &= ~CPM_CPCCR_PCS)
+#define __cpm_pll_enable()		(REG_CPM_CPPCR |= CPM_CPPCR_PLLEN)
+
+#define __cpm_pll_is_off()		(REG_CPM_CPPSR & CPM_CPPSR_PLLOFF)
+#define __cpm_pll_is_on()		(REG_CPM_CPPSR & CPM_CPPSR_PLLON)
+#define __cpm_pll_bypass()		(REG_CPM_CPPSR |= CPM_CPPSR_PLLBP)
+
+#define __cpm_get_cclk_doze_duty() \
+	((REG_CPM_LCR & CPM_LCR_DOZE_DUTY_MASK) >> CPM_LCR_DOZE_DUTY_BIT)
+#define __cpm_set_cclk_doze_duty(v) \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_DOZE_DUTY_MASK) | ((v) << (CPM_LCR_DOZE_DUTY_BIT)))
+
+#define __cpm_doze_mode()		(REG_CPM_LCR |= CPM_LCR_DOZE_ON)
+#define __cpm_idle_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_IDLE)
+#define __cpm_sleep_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_SLEEP)
+
+#define __cpm_stop_all() 	(REG_CPM_CLKGR = 0x1fffffff)
+#define __cpm_stop_cimram()	(REG_CPM_CLKGR |= CPM_CLKGR_CIMRAM)
+#define __cpm_stop_idct()	(REG_CPM_CLKGR |= CPM_CLKGR_IDCT)
+#define __cpm_stop_db()	        (REG_CPM_CLKGR |= CPM_CLKGR_DB)
+#define __cpm_stop_me()	        (REG_CPM_CLKGR |= CPM_CLKGR_ME)
+#define __cpm_stop_mc()	        (REG_CPM_CLKGR |= CPM_CLKGR_MC)
+#define __cpm_stop_tve()        (REG_CPM_CLKGR |= CPM_CLKGR_TVE)
+#define __cpm_stop_tssi()       (REG_CPM_CLKGR |= CPM_CLKGR_TSSI)
+#define __cpm_stop_owi()        (REG_CPM_CLKGR |= CPM_CLKGR_OWI)
+#define __cpm_stop_pcm()        (REG_CPM_CLKGR |= CPM_CLKGR_PCM)
+#define __cpm_stop_uart3()	(REG_CPM_CLKGR |= CPM_CLKGR_UART3)
+#define __cpm_stop_uart2()	(REG_CPM_CLKGR |= CPM_CLKGR_UART2)
+#define __cpm_stop_uart1()	(REG_CPM_CLKGR |= CPM_CLKGR_UART1)
+#define __cpm_stop_uhc()	(REG_CPM_CLKGR |= CPM_CLKGR_UHC)
+#define __cpm_stop_ipu()	(REG_CPM_CLKGR |= CPM_CLKGR_IPU)
+#define __cpm_stop_dmac()	(REG_CPM_CLKGR |= CPM_CLKGR_DMAC)
+#define __cpm_stop_udc()	(REG_CPM_CLKGR |= CPM_CLKGR_UDC)
+#define __cpm_stop_lcd()	(REG_CPM_CLKGR |= CPM_CLKGR_LCD)
+#define __cpm_stop_cim()	(REG_CPM_CLKGR |= CPM_CLKGR_CIM)
+#define __cpm_stop_sadc()	(REG_CPM_CLKGR |= CPM_CLKGR_SADC)
+#define __cpm_stop_msc(n)	(REG_CPM_CLKGR |= CPM_CLKGR_MSC##n)
+#define __cpm_stop_aic1()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC1)
+#define __cpm_stop_aic2()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC2)
+#define __cpm_stop_ssi(n)	(REG_CPM_CLKGR |= CPM_CLKGR_SSI##n)
+#define __cpm_stop_i2c()	(REG_CPM_CLKGR |= CPM_CLKGR_I2C)
+#define __cpm_stop_rtc()	(REG_CPM_CLKGR |= CPM_CLKGR_RTC)
+#define __cpm_stop_tcu()	(REG_CPM_CLKGR |= CPM_CLKGR_TCU)
+#define __cpm_stop_uart0()	(REG_CPM_CLKGR |= CPM_CLKGR_UART0)
+
+#define __cpm_start_all() 	(REG_CPM_CLKGR = 0x0)
+#define __cpm_start_cimram()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIMRAM)
+#define __cpm_start_idct()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IDCT)
+#define __cpm_start_db()        (REG_CPM_CLKGR &= ~CPM_CLKGR_DB)
+#define __cpm_start_me()        (REG_CPM_CLKGR &= ~CPM_CLKGR_ME)
+#define __cpm_start_mc()        (REG_CPM_CLKGR &= ~CPM_CLKGR_MC)
+#define __cpm_start_tve()        (REG_CPM_CLKGR &= ~CPM_CLKGR_TVE)
+#define __cpm_start_tssi()       (REG_CPM_CLKGR &= ~CPM_CLKGR_TSSI)
+#define __cpm_start_owi()        (REG_CPM_CLKGR &= ~CPM_CLKGR_OWI)
+#define __cpm_start_pcm()        (REG_CPM_CLKGR &= ~CPM_CLKGR_PCM)
+#define __cpm_start_uart3()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART3)
+#define __cpm_start_uart2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART2)
+#define __cpm_start_uart1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART1)
+#define __cpm_start_uhc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UHC)
+#define __cpm_start_ipu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IPU)
+#define __cpm_start_dmac()	(REG_CPM_CLKGR &= ~CPM_CLKGR_DMAC)
+#define __cpm_start_udc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UDC)
+#define __cpm_start_lcd()	(REG_CPM_CLKGR &= ~CPM_CLKGR_LCD)
+#define __cpm_start_cim()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIM)
+#define __cpm_start_sadc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_SADC)
+#define __cpm_start_msc(n)	(REG_CPM_CLKGR &= ~CPM_CLKGR_MSC##n)
+#define __cpm_start_aic1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC1)
+#define __cpm_start_aic2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC2)
+#define __cpm_start_ssi(n)	(REG_CPM_CLKGR &= ~CPM_CLKGR_SSI##n)
+#define __cpm_start_i2c()	(REG_CPM_CLKGR &= ~CPM_CLKGR_I2C)
+#define __cpm_start_rtc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_RTC)
+#define __cpm_start_tcu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_TCU)
+#define __cpm_start_uart0()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART0)
+
+#define __cpm_get_o1st() \
+	((REG_CPM_OPCR & CPM_OPCR_O1ST_MASK) >> CPM_OPCR_O1ST_BIT)
+#define __cpm_set_o1st(v) \
+	(REG_CPM_OPCR = (REG_CPM_OPCR & ~CPM_OPCR_O1ST_MASK) | ((v) << (CPM_OPCR_O1ST_BIT)))
+#define __cpm_enable_uhcphy()		(REG_CPM_OPCR &= ~CPM_OPCR_UHCPHY_DISABLE)
+#define __cpm_suspend_uhcphy()		(REG_CPM_OPCR |= CPM_OPCR_UHCPHY_DISABLE)
+#define __cpm_enable_udcphy()		(REG_CPM_OPCR |= CPM_OPCR_UDCPHY_ENABLE)
+#define __cpm_suspend_udcphy()		(REG_CPM_OPCR &= ~CPM_OPCR_UDCPHY_ENABLE)
+#define __cpm_enable_osc_in_sleep()	(REG_CPM_OPCR |= CPM_OPCR_OSC_ENABLE)
+#define __cpm_disable_osc_in_sleep()	(REG_CPM_OPCR &= ~CPM_OPCR_OSC_ENABLE)
+#define __cpm_select_rtcclk_rtc()	(REG_CPM_OPCR |= CPM_OPCR_ERCS)
+#define __cpm_select_rtcclk_exclk()	(REG_CPM_OPCR &= ~CPM_OPCR_ERCS)
+
+
+/***************************************************************************
+ * TCU
+ ***************************************************************************/
+// where 'n' is the TCU channel
+#define __tcu_select_extalclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_EXT_EN)
+#define __tcu_select_rtcclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_RTC_EN)
+#define __tcu_select_pclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_PCK_EN)
+#define __tcu_disable_pclk(n) \
+	REG_TCU_TCSR(n) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PCK_EN);
+#define __tcu_select_clk_div1(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1)
+#define __tcu_select_clk_div4(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE4)
+#define __tcu_select_clk_div16(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE16)
+#define __tcu_select_clk_div64(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE64)
+#define __tcu_select_clk_div256(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE256)
+#define __tcu_select_clk_div1024(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1024)
+
+#define __tcu_enable_pwm_output(n)	(REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_EN)
+#define __tcu_disable_pwm_output(n)	(REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_EN)
+
+#define __tcu_init_pwm_output_high(n)	(REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_INITL_HIGH)
+#define __tcu_init_pwm_output_low(n)	(REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_INITL_HIGH)
+
+#define __tcu_set_pwm_output_shutdown_graceful(n)	(REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_SD)
+#define __tcu_set_pwm_output_shutdown_abrupt(n)		(REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_SD)
+
+#define __tcu_clear_counter_to_zero(n)	(REG_TCU_TCSR((n)) |= TCU_TCSR_CNT_CLRZ)
+
+#define __tcu_ost_enabled()		(REG_TCU_TER & TCU_TER_OSTEN)
+#define __tcu_enable_ost()		(REG_TCU_TESR = TCU_TESR_OSTST)
+#define __tcu_disable_ost()		(REG_TCU_TECR = TCU_TECR_OSTCL)
+
+#define __tcu_counter_enabled(n)	(REG_TCU_TER & (1 << (n)))
+#define __tcu_start_counter(n)		(REG_TCU_TESR |= (1 << (n)))
+#define __tcu_stop_counter(n)		(REG_TCU_TECR |= (1 << (n)))
+
+#define __tcu_half_match_flag(n)	(REG_TCU_TFR & (1 << ((n) + 16)))
+#define __tcu_full_match_flag(n)	(REG_TCU_TFR & (1 << (n)))
+#define __tcu_set_half_match_flag(n)	(REG_TCU_TFSR = (1 << ((n) + 16)))
+#define __tcu_set_full_match_flag(n)	(REG_TCU_TFSR = (1 << (n)))
+#define __tcu_clear_half_match_flag(n)	(REG_TCU_TFCR = (1 << ((n) + 16)))
+#define __tcu_clear_full_match_flag(n)	(REG_TCU_TFCR = (1 << (n)))
+#define __tcu_mask_half_match_irq(n)	(REG_TCU_TMSR = (1 << ((n) + 16)))
+#define __tcu_mask_full_match_irq(n)	(REG_TCU_TMSR = (1 << (n)))
+#define __tcu_unmask_half_match_irq(n)	(REG_TCU_TMCR = (1 << ((n) + 16)))
+#define __tcu_unmask_full_match_irq(n)	(REG_TCU_TMCR = (1 << (n)))
+
+#define __tcu_ost_match_flag()		(REG_TCU_TFR & TCU_TFR_OSTFLAG)
+#define __tcu_set_ost_match_flag()	(REG_TCU_TFSR = TCU_TFSR_OSTFST)
+#define __tcu_clear_ost_match_flag()	(REG_TCU_TFCR = TCU_TFCR_OSTFCL)
+#define __tcu_ost_match_irq_masked()	(REG_TCU_TMR & TCU_TMR_OSTMASK)
+#define __tcu_mask_ost_match_irq()	(REG_TCU_TMSR = TCU_TMSR_OSTMST)
+#define __tcu_unmask_ost_match_irq()	(REG_TCU_TMCR = TCU_TMCR_OSTMCL)
+
+#define __tcu_wdt_clock_stopped()	(REG_TCU_TSR & TCU_TSSR_WDTSC)
+#define __tcu_ost_clock_stopped()	(REG_TCU_TSR & TCU_TSR_OST)
+#define __tcu_timer_clock_stopped(n)	(REG_TCU_TSR & (1 << (n)))
+
+#define __tcu_start_wdt_clock()		(REG_TCU_TSCR = TCU_TSSR_WDTSC)
+#define __tcu_start_ost_clock()		(REG_TCU_TSCR = TCU_TSCR_OSTSC)
+#define __tcu_start_timer_clock(n)	(REG_TCU_TSCR = (1 << (n)))
+
+#define __tcu_stop_wdt_clock()		(REG_TCU_TSSR = TCU_TSSR_WDTSC)
+#define __tcu_stop_ost_clock()		(REG_TCU_TSSR = TCU_TSSR_OSTSS)
+#define __tcu_stop_timer_clock(n)	(REG_TCU_TSSR = (1 << (n)))
+
+#define __tcu_get_count(n)		(REG_TCU_TCNT((n)))
+#define __tcu_set_count(n,v)		(REG_TCU_TCNT((n)) = (v))
+#define __tcu_set_full_data(n,v)	(REG_TCU_TDFR((n)) = (v))
+#define __tcu_set_half_data(n,v)	(REG_TCU_TDHR((n)) = (v))
+
+/* TCU2, counter 1, 2*/
+#define __tcu_read_real_value(n)	(REG_TCU_TSTR & (1 << ((n) + 16)))
+#define __tcu_read_false_value(n)	(REG_TCU_TSTR & (1 << ((n) + 16)))
+#define __tcu_counter_busy(n)		(REG_TCU_TSTR & (1 << (n)))
+#define __tcu_counter_ready(n)		(REG_TCU_TSTR & (1 << (n)))
+
+#define __tcu_set_read_real_value(n)	(REG_TCU_TSTSR = (1 << ((n) + 16)))
+#define __tcu_set_read_false_value(n)	(REG_TCU_TSTCR = (1 << ((n) + 16)))
+#define __tcu_set_counter_busy(n)	(REG_TCU_TSTSR = (1 << (n)))
+#define __tcu_set_counter_ready(n)	(REG_TCU_TSTCR = (1 << (n)))
+
+/* ost counter */
+#define __ostcu_set_pwm_output_shutdown_graceful()	(REG_TCU_OSTCSR &= ~TCU_TCSR_PWM_SD)
+#define __ostcu_set_ost_output_shutdown_abrupt()	(REG_TCU_OSTCSR |= TCU_TCSR_PWM_SD)
+#define __ostcu_select_clk_div1() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE1)
+#define __ostcu_select_clk_div4() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE4)
+#define __ostcu_select_clk_div16() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE16)
+#define __ostcu_select_clk_div64() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE64)
+#define __ostcu_select_clk_div256() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE256)
+#define __ostcu_select_clk_div1024() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE1024)
+#define __ostcu_select_rtcclk() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~(TCU_OSTCSR_EXT_EN | TCU_OSTCSR_RTC_EN | TCU_OSTCSR_PCK_EN)) | TCU_OSTCSR_RTC_EN)
+#define __ostcu_select_extalclk() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~(TCU_OSTCSR_EXT_EN | TCU_OSTCSR_RTC_EN | TCU_OSTCSR_PCK_EN)) | TCU_OSTCSR_EXT_EN)
+#define __ostcu_select_pclk() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~(TCU_OSTCSR_EXT_EN | TCU_OSTCSR_RTC_EN | TCU_OSTCSR_PCK_EN)) | TCU_OSTCSR_PCK_EN)
+
+
+/***************************************************************************
+ * WDT
+ ***************************************************************************/
+#define __wdt_start()			( REG_WDT_TCER |= WDT_TCER_TCEN )
+#define __wdt_stop()			( REG_WDT_TCER &= ~WDT_TCER_TCEN )
+#define __wdt_set_count(v)		( REG_WDT_TCNT = (v) )
+#define __wdt_set_data(v)		( REG_WDT_TDR = (v) )
+
+#define __wdt_select_extalclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_EXT_EN)
+#define __wdt_select_rtcclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_RTC_EN)
+#define __wdt_select_pclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_PCK_EN)
+
+#define __wdt_select_clk_div1() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1)
+#define __wdt_select_clk_div4() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE4)
+#define __wdt_select_clk_div16() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE16)
+#define __wdt_select_clk_div64() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE64)
+#define __wdt_select_clk_div256() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE256)
+#define __wdt_select_clk_div1024() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1024)
+
+
+/***************************************************************************
+ * UART
+ ***************************************************************************/
+
+#define __uart_enable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) |= UARTFCR_UUE | UARTFCR_FE )
+#define __uart_disable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) = ~UARTFCR_UUE )
+
+#define __uart_enable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_TIE )
+#define __uart_disable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~UARTIER_TIE )
+
+#define __uart_enable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE )
+#define __uart_disable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~(UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE) )
+
+#define __uart_enable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) |= UARTMCR_LOOP )
+#define __uart_disable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) &= ~UARTMCR_LOOP )
+
+#define __uart_set_8n1(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) = UARTLCR_WLEN_8 )
+
+#define __uart_set_baud(n, devclk, baud)						\
+  do {											\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) |= UARTLCR_DLAB;			\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLLR) = (devclk / 16 / baud) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLHR) = ((devclk / 16 / baud) >> 8) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) &= ~UARTLCR_DLAB;			\
+  } while (0)
+
+#define __uart_parity_error(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_PER) != 0 )
+
+#define __uart_clear_errors(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) &= ~(UARTLSR_ORER | UARTLSR_BRK | UARTLSR_FER | UARTLSR_PER | UARTLSR_RFER) )
+
+#define __uart_transmit_fifo_empty(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TDRQ) != 0 )
+
+#define __uart_transmit_end(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TEMT) != 0 )
+
+#define __uart_transmit_char(n, ch) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_TDR) = (ch)
+
+#define __uart_receive_fifo_full(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_ready(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_char(n) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_RDR)
+
+#define __uart_disable_irda() \
+  ( REG8(IRDA_BASE + OFF_SIRCR) &= ~(SIRCR_TSIRE | SIRCR_RSIRE) )
+#define __uart_enable_irda() \
+  /* Tx high pulse as 0, Rx low pulse as 0 */ \
+  ( REG8(IRDA_BASE + OFF_SIRCR) = SIRCR_TSIRE | SIRCR_RSIRE | SIRCR_RXPL | SIRCR_TPWS )
+
+
+/***************************************************************************
+ * DMAC
+ ***************************************************************************/
+
+/* m is the DMA controller index (0, 1), n is the DMA channel index (0 - 11) */
+
+#define __dmac_enable_module(m) \
+	( REG_DMAC_DMACR(m) |= DMAC_DMACR_DMAE | DMAC_DMACR_PR_012345 )
+#define __dmac_disable_module(m) \
+	( REG_DMAC_DMACR(m) &= ~DMAC_DMACR_DMAE )
+
+/* p=0,1,2,3 */
+#define __dmac_set_priority(m,p)			\
+do {							\
+	REG_DMAC_DMACR(m) &= ~DMAC_DMACR_PR_MASK;	\
+	REG_DMAC_DMACR(m) |= ((p) << DMAC_DMACR_PR_BIT);	\
+} while (0)
+
+#define __dmac_test_halt_error(m) ( REG_DMAC_DMACR(m) & DMAC_DMACR_HLT )
+#define __dmac_test_addr_error(m) ( REG_DMAC_DMACR(m) & DMAC_DMACR_AR )
+
+#define __dmac_channel_enable_clk(n) \
+	REG_DMAC_DMACKE((n)/HALF_DMA_NUM) |= 1 << ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM);
+
+#define __dmac_enable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_NDES )
+#define __dmac_disable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_NDES )
+
+#define __dmac_enable_channel(n)                 \
+do {                                             \
+	REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_EN;    \
+} while (0)
+#define __dmac_disable_channel(n)                \
+do {                                             \
+	REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_EN;   \
+} while (0)
+#define __dmac_channel_enabled(n) \
+  ( REG_DMAC_DCCSR((n)) & DMAC_DCCSR_EN )
+
+#define __dmac_channel_enable_irq(n) \
+  ( REG_DMAC_DCMD((n)) |= DMAC_DCMD_TIE )
+#define __dmac_channel_disable_irq(n) \
+  ( REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_TIE )
+
+#define __dmac_channel_transmit_halt_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_HLT )
+#define __dmac_channel_transmit_end_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_TT )
+#define __dmac_channel_address_error_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_AR )
+#define __dmac_channel_count_terminated_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_CT )
+#define __dmac_channel_descriptor_invalid_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_INV )
+
+#define __dmac_channel_clear_transmit_halt(n)				\
+	do {								\
+		/* clear both channel halt error and globle halt error */ \
+		REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_HLT;			\
+		REG_DMAC_DMACR(n/HALF_DMA_NUM) &= ~DMAC_DMACR_HLT;	\
+	} while (0)
+#define __dmac_channel_clear_transmit_end(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TT )
+#define __dmac_channel_clear_address_error(n)				\
+	do {								\
+		REG_DMAC_DDA(n) = 0; /* clear descriptor address register */ \
+		REG_DMAC_DSAR(n) = 0; /* clear source address register */ \
+		REG_DMAC_DTAR(n) = 0; /* clear target address register */ \
+		/* clear both channel addr error and globle address error */ \
+		REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_AR;			\
+		REG_DMAC_DMACR(n/HALF_DMA_NUM) &= ~DMAC_DMACR_AR;	\
+	} while (0)
+#define __dmac_channel_clear_count_terminated(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_CT )
+#define __dmac_channel_clear_descriptor_invalid(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_INV )
+
+#define __dmac_channel_set_transfer_unit_32bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_8bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_8BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BYTE;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_32byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BYTE;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_dest_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DWDH_##w;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_src_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_SWDH_##w;	\
+} while (0)
+
+/* v=0-15 */
+#define __dmac_channel_set_rdil(n,v)				\
+do {								\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_RDIL_MASK;		\
+	REG_DMAC_DCMD((n) |= ((v) << DMAC_DCMD_RDIL_BIT);	\
+} while (0)
+
+#define __dmac_channel_dest_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DAI )
+#define __dmac_channel_dest_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_DAI )
+
+#define __dmac_channel_src_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SAI )
+#define __dmac_channel_src_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_SAI )
+
+#define __dmac_channel_set_doorbell(n)	\
+	(  REG_DMAC_DMADBSR((n)/HALF_DMA_NUM) = (1 << ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM)) )
+
+#define __dmac_channel_irq_detected(n)  ( REG_DMAC_DMAIPR((n)/HALF_DMA_NUM) & (1 << ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM)) )
+#define __dmac_channel_ack_irq(n)       ( REG_DMAC_DMAIPR((n)/HALF_DMA_NUM) &= ~(1 <<((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM)) )
+
+static __inline__ int __dmac_get_irq(void)
+{
+	int i;
+	for (i = 0; i < MAX_DMA_NUM; i++)
+		if (__dmac_channel_irq_detected(i))
+			return i;
+	return -1;
+}
+
+
+/***************************************************************************
+ * AIC (AC'97 & I2S Controller)
+ ***************************************************************************/
+
+#define __aic_enable()		( REG_AIC_FR |= AIC_FR_ENB )
+#define __aic_disable()		( REG_AIC_FR &= ~AIC_FR_ENB )
+
+#define __aic_select_ac97()	( REG_AIC_FR &= ~AIC_FR_AUSEL )
+#define __aic_select_i2s()	( REG_AIC_FR |= AIC_FR_AUSEL )
+
+#define __aic_play_zero()	( REG_AIC_FR &= ~AIC_FR_LSMP )
+#define __aic_play_lastsample()	( REG_AIC_FR |= AIC_FR_LSMP )
+
+#define __i2s_as_master()	( REG_AIC_FR |= AIC_FR_BCKD | AIC_FR_SYNCD )
+#define __i2s_as_slave()	( REG_AIC_FR &= ~(AIC_FR_BCKD | AIC_FR_SYNCD) )
+#define __aic_reset_status()          ( REG_AIC_FR & AIC_FR_RST )
+
+#define __aic_reset()                                   \
+do {                                                    \
+        REG_AIC_FR |= AIC_FR_RST;                       \
+} while(0)
+
+
+#define __aic_set_transmit_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_TFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_TFTH_BIT);		\
+} while(0)
+
+#define __aic_set_receive_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_RFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_RFTH_BIT);		\
+} while(0)
+
+#define __aic_enable_record()	( REG_AIC_CR |= AIC_CR_EREC )
+#define __aic_disable_record()	( REG_AIC_CR &= ~AIC_CR_EREC )
+#define __aic_enable_replay()	( REG_AIC_CR |= AIC_CR_ERPL )
+#define __aic_disable_replay()	( REG_AIC_CR &= ~AIC_CR_ERPL )
+#define __aic_enable_loopback()	( REG_AIC_CR |= AIC_CR_ENLBF )
+#define __aic_disable_loopback() ( REG_AIC_CR &= ~AIC_CR_ENLBF )
+
+#define __aic_flush_fifo()	( REG_AIC_CR |= AIC_CR_FLUSH )
+#define __aic_unflush_fifo()	( REG_AIC_CR &= ~AIC_CR_FLUSH )
+
+#define __aic_enable_transmit_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_disable_transmit_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_enable_receive_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ERFS | AIC_CR_EROR) )
+#define __aic_disable_receive_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ERFS | AIC_CR_EROR) )
+
+#define __aic_enable_transmit_dma()  ( REG_AIC_CR |= AIC_CR_TDMS )
+#define __aic_disable_transmit_dma() ( REG_AIC_CR &= ~AIC_CR_TDMS )
+#define __aic_enable_receive_dma()   ( REG_AIC_CR |= AIC_CR_RDMS )
+#define __aic_disable_receive_dma()  ( REG_AIC_CR &= ~AIC_CR_RDMS )
+
+#define __aic_enable_mono2stereo()   ( REG_AIC_CR |= AIC_CR_M2S )
+#define __aic_disable_mono2stereo()  ( REG_AIC_CR &= ~AIC_CR_M2S )
+#define __aic_enable_byteswap()      ( REG_AIC_CR |= AIC_CR_ENDSW )
+#define __aic_disable_byteswap()     ( REG_AIC_CR &= ~AIC_CR_ENDSW )
+#define __aic_enable_unsignadj()     ( REG_AIC_CR |= AIC_CR_AVSTSU )
+#define __aic_disable_unsignadj()    ( REG_AIC_CR &= ~AIC_CR_AVSTSU )
+
+#define AC97_PCM_XS_L_FRONT   	AIC_ACCR1_XS_SLOT3
+#define AC97_PCM_XS_R_FRONT   	AIC_ACCR1_XS_SLOT4
+#define AC97_PCM_XS_CENTER    	AIC_ACCR1_XS_SLOT6
+#define AC97_PCM_XS_L_SURR    	AIC_ACCR1_XS_SLOT7
+#define AC97_PCM_XS_R_SURR    	AIC_ACCR1_XS_SLOT8
+#define AC97_PCM_XS_LFE       	AIC_ACCR1_XS_SLOT9
+
+#define AC97_PCM_RS_L_FRONT   	AIC_ACCR1_RS_SLOT3
+#define AC97_PCM_RS_R_FRONT   	AIC_ACCR1_RS_SLOT4
+#define AC97_PCM_RS_CENTER    	AIC_ACCR1_RS_SLOT6
+#define AC97_PCM_RS_L_SURR    	AIC_ACCR1_RS_SLOT7
+#define AC97_PCM_RS_R_SURR    	AIC_ACCR1_RS_SLOT8
+#define AC97_PCM_RS_LFE       	AIC_ACCR1_RS_SLOT9
+
+#define __ac97_set_xs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK )
+#define __ac97_set_xs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_R_FRONT;				\
+} while(0)
+#define __ac97_set_xs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_L_FRONT | AC97_PCM_XS_R_FRONT;	\
+} while(0)
+
+/* In fact, only stereo is support now. */ 
+#define __ac97_set_rs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK )
+#define __ac97_set_rs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_R_FRONT;				\
+} while(0)
+#define __ac97_set_rs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_L_FRONT | AC97_PCM_RS_R_FRONT;	\
+} while(0)
+
+#define __ac97_warm_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SS;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+
+#define __ac97_cold_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |=  AIC_ACCR2_SR;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SR;		\
+ } while (0)
+
+/* n=8,16,18,20 */
+#define __ac97_set_iass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_IASS_MASK) | AIC_ACCR2_IASS_##n##BIT )
+#define __ac97_set_oass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_OASS_MASK) | AIC_ACCR2_OASS_##n##BIT )
+
+#define __i2s_select_i2s()            ( REG_AIC_I2SCR &= ~AIC_I2SCR_AMSL )
+#define __i2s_select_msbjustified()   ( REG_AIC_I2SCR |= AIC_I2SCR_AMSL )
+
+/* n=8,16,18,20,24 */
+/*#define __i2s_set_sample_size(n) \
+ ( REG_AIC_I2SCR |= (REG_AIC_I2SCR & ~AIC_I2SCR_WL_MASK) | AIC_I2SCR_WL_##n##BIT )*/
+
+#define __i2s_set_oss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_OSS_MASK) | AIC_CR_OSS_##n##BIT )
+#define __i2s_set_iss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_ISS_MASK) | AIC_CR_ISS_##n##BIT )
+
+#define __i2s_stop_bitclk()   ( REG_AIC_I2SCR |= AIC_I2SCR_STPBK )
+#define __i2s_start_bitclk()  ( REG_AIC_I2SCR &= ~AIC_I2SCR_STPBK )
+
+#define __aic_transmit_request()  ( REG_AIC_SR & AIC_SR_TFS )
+#define __aic_receive_request()   ( REG_AIC_SR & AIC_SR_RFS )
+#define __aic_transmit_underrun() ( REG_AIC_SR & AIC_SR_TUR )
+#define __aic_receive_overrun()   ( REG_AIC_SR & AIC_SR_ROR )
+
+#define __aic_clear_errors()      ( REG_AIC_SR &= ~(AIC_SR_TUR | AIC_SR_ROR) )
+
+#define __aic_get_transmit_resident() \
+  ( (REG_AIC_SR & AIC_SR_TFL_MASK) >> AIC_SR_TFL_BIT )
+#define __aic_get_receive_count() \
+  ( (REG_AIC_SR & AIC_SR_RFL_MASK) >> AIC_SR_RFL_BIT )
+
+#define __ac97_command_transmitted()     ( REG_AIC_ACSR & AIC_ACSR_CADT )
+#define __ac97_status_received()         ( REG_AIC_ACSR & AIC_ACSR_SADR )
+#define __ac97_status_receive_timeout()  ( REG_AIC_ACSR & AIC_ACSR_RSTO )
+#define __ac97_codec_is_low_power_mode() ( REG_AIC_ACSR & AIC_ACSR_CLPM )
+#define __ac97_codec_is_ready()          ( REG_AIC_ACSR & AIC_ACSR_CRDY )
+#define __ac97_slot_error_detected()     ( REG_AIC_ACSR & AIC_ACSR_SLTERR )
+#define __ac97_clear_slot_error()        ( REG_AIC_ACSR &= ~AIC_ACSR_SLTERR )
+
+#define __i2s_is_busy()         ( REG_AIC_I2SSR & AIC_I2SSR_BSY )
+
+#define CODEC_READ_CMD	        (1 << 19)
+#define CODEC_WRITE_CMD	        (0 << 19)
+#define CODEC_REG_INDEX_BIT     12
+#define CODEC_REG_INDEX_MASK	(0x7f << CODEC_REG_INDEX_BIT)	/* 18:12 */
+#define CODEC_REG_DATA_BIT      4
+#define CODEC_REG_DATA_MASK	(0x0ffff << 4)	/* 19:4 */
+
+#define __ac97_out_rcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_READ_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_wcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_WRITE_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_data(value) 						\
+do { 									\
+    REG_AIC_ACCDR = ((value) << CODEC_REG_DATA_BIT); 			\
+} while (0)
+
+#define __ac97_in_data() \
+ ( (REG_AIC_ACSDR & CODEC_REG_DATA_MASK) >> CODEC_REG_DATA_BIT )
+
+#define __ac97_in_status_addr() \
+ ( (REG_AIC_ACSAR & CODEC_REG_INDEX_MASK) >> CODEC_REG_INDEX_BIT )
+
+#define __i2s_set_sample_rate(i2sclk, sync) \
+  ( REG_AIC_I2SDIV = ((i2sclk) / (4*64)) / (sync) )
+
+#define __aic_write_tfifo(v)  ( REG_AIC_DR = (v) )
+#define __aic_read_rfifo()    ( REG_AIC_DR )
+
+#define __aic_internal_codec()  ( REG_AIC_FR |= AIC_FR_ICDC ) 
+#define __aic_external_codec()  ( REG_AIC_FR &= ~AIC_FR_ICDC )
+
+//
+// Define next ops for AC97 compatible
+//
+
+#define AC97_ACSR	AIC_ACSR
+
+#define __ac97_enable()		__aic_enable(); __aic_select_ac97()
+#define __ac97_disable()	__aic_disable()
+#define __ac97_reset()		__aic_reset()
+
+#define __ac97_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __ac97_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __ac97_enable_record()		__aic_enable_record()
+#define __ac97_disable_record()		__aic_disable_record()
+#define __ac97_enable_replay()		__aic_enable_replay()
+#define __ac97_disable_replay()		__aic_disable_replay()
+#define __ac97_enable_loopback()	__aic_enable_loopback()
+#define __ac97_disable_loopback()	__aic_disable_loopback()
+
+#define __ac97_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __ac97_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __ac97_enable_receive_dma()	__aic_enable_receive_dma()
+#define __ac97_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __ac97_transmit_request()	__aic_transmit_request()
+#define __ac97_receive_request()	__aic_receive_request()
+#define __ac97_transmit_underrun()	__aic_transmit_underrun()
+#define __ac97_receive_overrun()	__aic_receive_overrun()
+
+#define __ac97_clear_errors()		__aic_clear_errors()
+
+#define __ac97_get_transmit_resident()	__aic_get_transmit_resident()
+#define __ac97_get_receive_count()	__aic_get_receive_count()
+
+#define __ac97_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __ac97_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __ac97_enable_receive_intr()	__aic_enable_receive_intr()
+#define __ac97_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __ac97_write_tfifo(v)		__aic_write_tfifo(v)
+#define __ac97_read_rfifo()		__aic_read_rfifo()
+
+//
+// Define next ops for I2S compatible
+//
+
+#define I2S_ACSR	AIC_I2SSR
+
+#define __i2s_enable()		 __aic_enable(); __aic_select_i2s()
+#define __i2s_disable()		__aic_disable()
+#define __i2s_reset()		__aic_reset()
+
+#define __i2s_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __i2s_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __i2s_enable_record()		__aic_enable_record()
+#define __i2s_disable_record()		__aic_disable_record()
+#define __i2s_enable_replay()		__aic_enable_replay()
+#define __i2s_disable_replay()		__aic_disable_replay()
+#define __i2s_enable_loopback()		__aic_enable_loopback()
+#define __i2s_disable_loopback()	__aic_disable_loopback()
+
+#define __i2s_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __i2s_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __i2s_enable_receive_dma()	__aic_enable_receive_dma()
+#define __i2s_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __i2s_transmit_request()	__aic_transmit_request()
+#define __i2s_receive_request()		__aic_receive_request()
+#define __i2s_transmit_underrun()	__aic_transmit_underrun()
+#define __i2s_receive_overrun()		__aic_receive_overrun()
+
+#define __i2s_clear_errors()		__aic_clear_errors()
+
+#define __i2s_get_transmit_resident()	__aic_get_transmit_resident()
+#define __i2s_get_receive_count()	__aic_get_receive_count()
+
+#define __i2s_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __i2s_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __i2s_enable_receive_intr()	__aic_enable_receive_intr()
+#define __i2s_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __i2s_write_tfifo(v)		__aic_write_tfifo(v)
+#define __i2s_read_rfifo()		__aic_read_rfifo()
+
+#define __i2s_reset_codec()			\
+ do {						\
+ } while (0)
+
+/*************************************************************************
+ * PCM Controller operation
+ *************************************************************************/
+
+#define __pcm_enable()          ( REG_PCM_CTL |= PCM_CTL_PCMEN )
+#define __pcm_disable()         ( REG_PCM_CTL &= ~PCM_CTL_PCMEN )
+
+#define __pcm_clk_enable()      ( REG_PCM_CTL |= PCM_CTL_CLKEN )
+#define __pcm_clk_disable()     ( REG_PCM_CTL &= ~PCM_CTL_CLKEN )
+
+#define __pcm_reset()           ( REG_PCM_CTL |= PCM_CTL_RST )
+#define __pcm_flush_fifo()	( REG_PCM_CTL |= PCM_CTL_FLUSH )
+
+#define __pcm_enable_record()		( REG_PCM_CTL |= PCM_CTL_EREC )
+#define __pcm_disable_record()		( REG_PCM_CTL &= ~PCM_CTL_EREC )
+#define __pcm_enable_playback()		( REG_PCM_CTL |= PCM_CTL_ERPL )
+#define __pcm_disable_playback()	( REG_PCM_CTL &= ~PCM_CTL_ERPL )
+
+#define __pcm_enable_rxfifo()           __pcm_enable_record()
+#define __pcm_disable_rxfifo()          __pcm_disable_record()
+#define __pcm_enable_txfifo()           __pcm_enable_playback()
+#define __pcm_disable_txfifo()          __pcm_disable_playback()
+
+#define __pcm_last_sample()     ( REG_PCM_CTL |= PCM_CTL_LSMP )
+#define __pcm_zero_sample()     ( REG_PCM_CTL &= ~PCM_CTL_LSMP )
+
+#define __pcm_enable_transmit_dma()    ( REG_PCM_CTL |= PCM_CTL_ETDMA )
+#define __pcm_disable_transmit_dma()   ( REG_PCM_CTL &= ~PCM_CTL_ETDMA )
+#define __pcm_enable_receive_dma()     ( REG_PCM_CTL |= PCM_CTL_ERDMA )
+#define __pcm_disable_receive_dma()    ( REG_PCM_CTL &= ~PCM_CTL_ERDMA )
+
+#define __pcm_as_master()     ( REG_PCM_CFG &= PCM_CFG_MODE )
+#define __pcm_as_slave()      ( REG_PCM_CFG |= ~PCM_CFG_MODE )
+
+#define __pcm_set_transmit_trigger(n) 			\
+do {							\
+	REG_PCM_CFG &= ~PCM_CFG_TFTH_MASK;		\
+	REG_PCM_CFG |= ((n) << PCM_CFG_TFTH_BIT);	\
+} while(0)
+
+#define __pcm_set_receive_trigger(n) 			\
+do {							\
+	REG_PCM_CFG &= ~PCM_CFG_RFTH_MASK;		\
+	REG_PCM_CFG |= ((n) << PCM_CFG_RFTH_BIT);	\
+} while(0)
+
+#define __pcm_omsb_same_sync()   ( REG_PCM_CFG &= ~PCM_CFG_OMSBPOS )
+#define __pcm_omsb_next_sync()   ( REG_PCM_CFG |= PCM_CFG_OMSBPOS )
+
+#define __pcm_imsb_same_sync()   ( REG_PCM_CFG &= ~PCM_CFG_IMSBPOS )
+#define __pcm_imsb_next_sync()   ( REG_PCM_CFG |= PCM_CFG_IMSBPOS )
+
+/* set input sample size 8 or 16*/
+#define __pcm_set_iss(n) \
+( REG_PCM_CFG = (REG_PCM_CFG & ~PCM_CFG_ISS_MASK) | PCM_CFG_ISS_##n )
+/* set output sample size 8 or 16*/
+#define __pcm_set_oss(n) \
+( REG_PCM_CFG = (REG_PCM_CFG & ~PCM_CFG_OSS_MASK) | PCM_CFG_OSS_##n )
+
+#define __pcm_set_valid_slot(n) \
+( REG_PCM_CFG = (REG_PCM_CFG & ~PCM_CFG_SLOT_MASK) | PCM_CFG_SLOT_##n )
+
+#define __pcm_write_data(v)           ( REG_PCM_DP = (v) )
+#define __pcm_read_data()             ( REG_PCM_DP )
+
+#define __pcm_enable_tfs_intr()       ( REG_PCM_INTC |= PCM_INTC_ETFS )
+#define __pcm_disable_tfs_intr()      ( REG_PCM_INTC &= ~PCM_INTC_ETFS )
+
+#define __pcm_enable_tur_intr()       ( REG_PCM_INTC |= PCM_INTC_ETUR )
+#define __pcm_disable_tur_intr()      ( REG_PCM_INTC &= ~PCM_INTC_ETUR )
+
+#define __pcm_enable_rfs_intr()       ( REG_PCM_INTC |= PCM_INTC_ERFS )
+#define __pcm_disable_rfs_intr()      ( REG_PCM_INTC &= ~PCM_INTC_ERFS )
+
+#define __pcm_enable_ror_intr()       ( REG_PCM_INTC |= PCM_INTC_EROR )
+#define __pcm_disable_ror_intr()      ( REG_PCM_INTC &= ~PCM_INTC_EROR )
+
+#define __pcm_ints_valid_tx() \
+( ((REG_PCM_INTS & PCM_INTS_TFL_MASK) >> PCM_INTS_TFL_BIT) )
+#define __pcm_ints_valid_rx() \
+( ((REG_PCM_INTS & PCM_INTS_RFL_MASK) >> PCM_INTS_RFL_BIT) )
+
+#define __pcm_set_clk_div(n) \
+( REG_PCM_DIV = (REG_PCM_DIV & ~PCM_DIV_CLKDIV_MASK) | ((n) << PCM_DIV_CLKDIV_BIT) )
+
+/* sysclk(cpm_pcm_sysclk) Hz is created by cpm logic, and pcmclk Hz is the pcm in/out clock wanted */
+#define __pcm_set_clk_rate(sysclk, pcmclk) \
+__pcm_set_clk_div(((sysclk) / (pcmclk) - 1)) 
+
+#define __pcm_set_sync_div(n) \
+( REG_PCM_DIV = (REG_PCM_DIV & ~PCM_DIV_SYNDIV_MASK) | ((n) << PCM_DIV_SYNDIV_BIT) )
+
+/* pcmclk is source clock Hz, and sync is the frame sync clock Hz wanted */
+#define __pcm_set_sync_rate(pcmclk, sync) \
+__pcm_set_sync_div(((pcmclk) / (8 * (sync)) - 1))
+
+ /* set sync length in pcmclk n = 0 ... 63 */
+#define __pcm_set_sync_len(n) \
+( REG_PCM_DIV = (REG_PCM_DIV & ~PCM_DIV_SYNL_MASK) | (n << PCM_DIV_SYNL_BIT) )
+
+
+/***************************************************************************
+ * ICDC
+ ***************************************************************************/
+#define __i2s_internal_codec()         __aic_internal_codec()
+#define __i2s_external_codec()         __aic_external_codec()
+
+#define __icdc_clk_ready()             ( REG_ICDC_CKCFG & ICDC_CKCFG_CKRDY )
+#define __icdc_sel_adc()               ( REG_ICDC_CKCFG |= ICDC_CKCFG_SELAD )
+#define __icdc_sel_dac()               ( REG_ICDC_CKCFG &= ~ICDC_CKCFG_SELAD )
+
+#define __icdc_set_rgwr()              ( REG_ICDC_RGADW |= ICDC_RGADW_RGWR )
+#define __icdc_clear_rgwr()            ( REG_ICDC_RGADW &= ~ICDC_RGADW_RGWR )
+#define __icdc_rgwr_ready()            ( REG_ICDC_RGADW & ICDC_RGADW_RGWR )
+
+#define __icdc_set_addr(n)				\
+do {          						\
+	REG_ICDC_RGADW &= ~ICDC_RGADW_RGADDR_MASK;	\
+	REG_ICDC_RGADW |= (n) << ICDC_RGADW_RGADDR_BIT;	\
+} while(0)
+
+#define __icdc_set_cmd(n)				\
+do {          						\
+	REG_ICDC_RGADW &= ~ICDC_RGADW_RGDIN_MASK;	\
+	REG_ICDC_RGADW |= (n) << ICDC_RGADW_RGDIN_BIT;	\
+} while(0)
+
+#define __icdc_irq_pending()            ( REG_ICDC_RGDATA & ICDC_RGDATA_IRQ )
+#define __icdc_get_value()              ( REG_ICDC_RGDATA & ICDC_RGDATA_RGDOUT_MASK )
+
+/***************************************************************************
+ * INTC
+ ***************************************************************************/
+#define __intc_unmask_irq(n)	( REG_INTC_IMCR = (1 << (n)) )
+#define __intc_mask_irq(n)	( REG_INTC_IMSR = (1 << (n)) )
+#define __intc_ack_irq(n)	( REG_INTC_IPR = (1 << (n)) ) /* A dummy ack, as the Pending Register is Read Only. Should we remove __intc_ack_irq() */
+
+
+/***************************************************************************
+ * I2C
+ ***************************************************************************/
+
+#define __i2c_enable()		( REG_I2C_CR |= I2C_CR_I2CE )
+#define __i2c_disable()		( REG_I2C_CR &= ~I2C_CR_I2CE )
+
+#define __i2c_send_start()	( REG_I2C_CR |= I2C_CR_STA )
+#define __i2c_send_stop()	( REG_I2C_CR |= I2C_CR_STO )
+#define __i2c_send_ack()	( REG_I2C_CR &= ~I2C_CR_AC )
+#define __i2c_send_nack()	( REG_I2C_CR |= I2C_CR_AC )
+
+#define __i2c_set_drf()		( REG_I2C_SR |= I2C_SR_DRF )
+#define __i2c_clear_drf()	( REG_I2C_SR &= ~I2C_SR_DRF )
+#define __i2c_check_drf()	( REG_I2C_SR & I2C_SR_DRF )
+
+#define __i2c_received_ack()	( !(REG_I2C_SR & I2C_SR_ACKF) )
+#define __i2c_is_busy()		( REG_I2C_SR & I2C_SR_BUSY )
+#define __i2c_transmit_ended()	( REG_I2C_SR & I2C_SR_TEND )
+
+#define __i2c_set_clk(dev_clk, i2c_clk) \
+  ( REG_I2C_GR = (dev_clk) / (16*(i2c_clk)) - 1 )
+
+#define __i2c_read()		( REG_I2C_DR )
+#define __i2c_write(val)	( REG_I2C_DR = (val) )
+
+
+/***************************************************************************
+ * MSC
+ ***************************************************************************/
+/* n = 0, 1 (MSC0, MSC1) */
+
+#define __msc_start_op(n) \
+	( REG_MSC_STRPCL(n) = MSC_STRPCL_START_OP | MSC_STRPCL_CLOCK_CONTROL_START )
+
+#define __msc_set_resto(n, to)  	( REG_MSC_RESTO(n) = to )
+#define __msc_set_rdto(n, to)   	( REG_MSC_RDTO(n) = to )
+#define __msc_set_cmd(n, cmd)   	( REG_MSC_CMD(n) = cmd )
+#define __msc_set_arg(n, arg)   	( REG_MSC_ARG(n) = arg )
+#define __msc_set_nob(n, nob)      	( REG_MSC_NOB(n) = nob )
+#define __msc_get_nob(n)        	( REG_MSC_NOB(n) )
+#define __msc_set_blklen(n, len)        ( REG_MSC_BLKLEN(n) = len )
+#define __msc_set_cmdat(n, cmdat)   	( REG_MSC_CMDAT(n) = cmdat )
+#define __msc_set_cmdat_ioabort(n) 	( REG_MSC_CMDAT(n) |= MSC_CMDAT_IO_ABORT )
+#define __msc_clear_cmdat_ioabort(n) 	( REG_MSC_CMDAT(n) &= ~MSC_CMDAT_IO_ABORT )
+
+#define __msc_set_cmdat_bus_width1(n) 			\
+do { 							\
+	REG_MSC_CMDAT(n) &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT(n) |= MSC_CMDAT_BUS_WIDTH_1BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_bus_width4(n) 			\
+do { 							\
+	REG_MSC_CMDAT(n) &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT(n) |= MSC_CMDAT_BUS_WIDTH_4BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_dma_en(n)       ( REG_MSC_CMDAT(n) |= MSC_CMDAT_DMA_EN )
+#define __msc_set_cmdat_init(n) 	( REG_MSC_CMDAT(n) |= MSC_CMDAT_INIT )
+#define __msc_set_cmdat_busy(n) 	( REG_MSC_CMDAT(n) |= MSC_CMDAT_BUSY )
+#define __msc_set_cmdat_stream(n)       ( REG_MSC_CMDAT(n) |= MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_block(n)        ( REG_MSC_CMDAT(n) &= ~MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_read(n) 	( REG_MSC_CMDAT(n) &= ~MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_write(n)        ( REG_MSC_CMDAT(n) |= MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_data_en(n)      ( REG_MSC_CMDAT(n) |= MSC_CMDAT_DATA_EN )
+
+/* r is MSC_CMDAT_RESPONSE_FORMAT_Rx or MSC_CMDAT_RESPONSE_FORMAT_NONE */
+#define __msc_set_cmdat_res_format(n, r)				\
+do { 								\
+	REG_MSC_CMDAT(n) &= ~MSC_CMDAT_RESPONSE_FORMAT_MASK; 	\
+	REG_MSC_CMDAT(n) |= (r); 					\
+} while(0)
+
+#define __msc_clear_cmdat(n) \
+  REG_MSC_CMDAT(n) &= ~( MSC_CMDAT_IO_ABORT | MSC_CMDAT_DMA_EN | MSC_CMDAT_INIT| \
+  MSC_CMDAT_BUSY | MSC_CMDAT_STREAM_BLOCK | MSC_CMDAT_WRITE_READ | \
+  MSC_CMDAT_DATA_EN | MSC_CMDAT_RESPONSE_FORMAT_MASK )
+
+#define __msc_get_imask(n) 		( REG_MSC_IMASK(n) )
+#define __msc_mask_all_intrs(n) 	( REG_MSC_IMASK(n) = 0xff )
+#define __msc_unmask_all_intrs(n) 	( REG_MSC_IMASK(n) = 0x00 )
+#define __msc_mask_rd(n) 		( REG_MSC_IMASK(n) |= MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_unmask_rd(n) 		( REG_MSC_IMASK(n) &= ~MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_mask_wr(n) 		( REG_MSC_IMASK(n) |= MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_unmask_wr(n) 		( REG_MSC_IMASK(n) &= ~MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_mask_endcmdres(n) 	( REG_MSC_IMASK(n) |= MSC_IMASK_END_CMD_RES )
+#define __msc_unmask_endcmdres(n) 	( REG_MSC_IMASK(n) &= ~MSC_IMASK_END_CMD_RES )
+#define __msc_mask_datatrandone(n) 	( REG_MSC_IMASK(n) |= MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_unmask_datatrandone(n) 	( REG_MSC_IMASK(n) &= ~MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_mask_prgdone(n) 		( REG_MSC_IMASK(n) |= MSC_IMASK_PRG_DONE )
+#define __msc_unmask_prgdone(n) 	( REG_MSC_IMASK(n) &= ~MSC_IMASK_PRG_DONE )
+
+/* m=0,1,2,3,4,5,6,7 */
+#define __msc_set_clkrt(n, m) 	\
+do { 				\
+	REG_MSC_CLKRT(n) = m;	\
+} while(0)
+
+#define __msc_get_ireg(n) 	        	( REG_MSC_IREG(n) )
+#define __msc_ireg_rd(n) 	        	( REG_MSC_IREG(n) & MSC_IREG_RXFIFO_RD_REQ )
+#define __msc_ireg_wr(n) 	        	( REG_MSC_IREG(n) & MSC_IREG_TXFIFO_WR_REQ )
+#define __msc_ireg_end_cmd_res(n)       	( REG_MSC_IREG(n) & MSC_IREG_END_CMD_RES )
+#define __msc_ireg_data_tran_done(n)     	( REG_MSC_IREG(n) & MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_prg_done(n) 	        	( REG_MSC_IREG(n) & MSC_IREG_PRG_DONE )
+#define __msc_ireg_clear_end_cmd_res(n)         ( REG_MSC_IREG(n) = MSC_IREG_END_CMD_RES )
+#define __msc_ireg_clear_data_tran_done(n)      ( REG_MSC_IREG(n) = MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_clear_prg_done(n)     	( REG_MSC_IREG(n) = MSC_IREG_PRG_DONE )
+
+#define __msc_get_stat(n) 		( REG_MSC_STAT(n) )
+#define __msc_stat_not_end_cmd_res(n) 	( (REG_MSC_STAT(n) & MSC_STAT_END_CMD_RES) == 0)
+#define __msc_stat_crc_err(n) \
+  ( REG_MSC_STAT(n) & (MSC_STAT_CRC_RES_ERR | MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR_YES) )
+#define __msc_stat_res_crc_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_CRC_RES_ERR )
+#define __msc_stat_rd_crc_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_CRC_READ_ERROR )
+#define __msc_stat_wr_crc_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_CRC_WRITE_ERROR_YES )
+#define __msc_stat_resto_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_TIME_OUT_RES )
+#define __msc_stat_rdto_err(n) 		( REG_MSC_STAT(n) & MSC_STAT_TIME_OUT_READ )
+
+#define __msc_rd_resfifo(n) 		( REG_MSC_RES(n) )
+#define __msc_rd_rxfifo(n)  		( REG_MSC_RXFIFO(n) )
+#define __msc_wr_txfifo(n, v)  		( REG_MSC_TXFIFO(n) = v )
+
+#define __msc_reset(n) 						\
+do { 								\
+	REG_MSC_STRPCL(n) = MSC_STRPCL_RESET;			\
+ 	while (REG_MSC_STAT(n) & MSC_STAT_IS_RESETTING);		\
+} while (0)
+
+#define __msc_start_clk(n) 					\
+do { 								\
+	REG_MSC_STRPCL(n) = MSC_STRPCL_CLOCK_CONTROL_START;	\
+} while (0)
+
+#define __msc_stop_clk(n) 					\
+do { 								\
+	REG_MSC_STRPCL(n) = MSC_STRPCL_CLOCK_CONTROL_STOP;	\
+} while (0)
+
+#define MMC_CLK 19169200
+#define SD_CLK  24576000
+
+/* msc_clk should little than pclk and little than clk retrieve from card */
+#define __msc_calc_clk_divisor(type,dev_clk,msc_clk,lv)		\
+do {								\
+	unsigned int rate, pclk, i;				\
+	pclk = dev_clk;						\
+	rate = type?SD_CLK:MMC_CLK;				\
+  	if (msc_clk && msc_clk < pclk)				\
+    		pclk = msc_clk;					\
+	i = 0;							\
+  	while (pclk < rate)					\
+    	{							\
+      		i ++;						\
+      		rate >>= 1;					\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+/* divide rate to little than or equal to 400kHz */
+#define __msc_calc_slow_clk_divisor(type, lv)			\
+do {								\
+	unsigned int rate, i;					\
+	rate = (type?SD_CLK:MMC_CLK)/1000/400;			\
+	i = 0;							\
+	while (rate > 0)					\
+    	{							\
+      		rate >>= 1;					\
+      		i ++;						\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+
+/***************************************************************************
+ * SSI (Synchronous Serial Interface)
+ ***************************************************************************/
+/* n = 0, 1 (SSI0, SSI1) */
+#define __ssi_enable(n) 	( REG_SSI_CR0(n) |= SSI_CR0_SSIE )
+#define __ssi_disable(n) 	( REG_SSI_CR0(n) &= ~SSI_CR0_SSIE )
+#define __ssi_select_ce(n) 	( REG_SSI_CR0(n) &= ~SSI_CR0_FSEL )
+
+#define __ssi_normal_mode(n) ( REG_SSI_ITR(n) &= ~SSI_ITR_IVLTM_MASK )
+
+#define __ssi_select_ce2(n) 		\
+do { 					\
+	REG_SSI_CR0(n) |= SSI_CR0_FSEL; 	\
+	REG_SSI_CR1(n) &= ~SSI_CR1_MULTS;	\
+} while (0)
+
+#define __ssi_select_gpc(n) 			\
+do { 						\
+	REG_SSI_CR0(n) &= ~SSI_CR0_FSEL;	\
+	REG_SSI_CR1(n) |= SSI_CR1_MULTS;	\
+} while (0)
+
+#define __ssi_underrun_auto_clear(n) 		\
+do { 						\
+	REG_SSI_CR0(n) |= SSI_CR0_EACLRUN; 	\
+} while (0)
+
+#define __ssi_underrun_clear_manually(n) 	\
+do { 						\
+	REG_SSI_CR0(n) &= ~SSI_CR0_EACLRUN; 	\
+} while (0)
+
+#define __ssi_enable_tx_intr(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_TIE | SSI_CR0_TEIE )
+
+#define __ssi_disable_tx_intr(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_TIE | SSI_CR0_TEIE) )
+
+#define __ssi_enable_rx_intr(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_RIE | SSI_CR0_REIE )
+
+#define __ssi_disable_rx_intr(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_RIE | SSI_CR0_REIE) )
+
+#define __ssi_enable_txfifo_half_empty_intr(n)  \
+	( REG_SSI_CR0(n) |= SSI_CR0_TIE )
+#define __ssi_disable_txfifo_half_empty_intr(n)	\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_TIE )
+#define __ssi_enable_tx_error_intr(n)		\
+	( REG_SSI_CR0(n) |= SSI_CR0_TEIE )
+#define __ssi_disable_tx_error_intr(n)		\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_TEIE )
+#define __ssi_enable_rxfifo_half_full_intr(n)	\
+	( REG_SSI_CR0(n) |= SSI_CR0_RIE )
+#define __ssi_disable_rxfifo_half_full_intr(n)  \
+	( REG_SSI_CR0(n) &= ~SSI_CR0_RIE )
+#define __ssi_enable_rx_error_intr(n)		\
+	( REG_SSI_CR0(n) |= SSI_CR0_REIE )
+#define __ssi_disable_rx_error_intr(n)		\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_REIE )
+
+#define __ssi_enable_loopback(n)  ( REG_SSI_CR0(n) |= SSI_CR0_LOOP )
+#define __ssi_disable_loopback(n) ( REG_SSI_CR0(n) &= ~SSI_CR0_LOOP )
+
+#define __ssi_enable_receive(n)   ( REG_SSI_CR0(n) &= ~SSI_CR0_DISREV )
+#define __ssi_disable_receive(n)  ( REG_SSI_CR0(n) |= SSI_CR0_DISREV )
+
+#define __ssi_finish_receive(n)					\
+	( REG_SSI_CR0(n) |= (SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_disable_recvfinish(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_flush_txfifo(n)   	( REG_SSI_CR0(n) |= SSI_CR0_TFLUSH )
+#define __ssi_flush_rxfifo(n)   	( REG_SSI_CR0(n) |= SSI_CR0_RFLUSH )
+
+#define __ssi_flush_fifo(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_TFLUSH | SSI_CR0_RFLUSH )
+
+#define __ssi_finish_transmit(n) 	( REG_SSI_CR1(n) &= ~SSI_CR1_UNFIN )
+#define __ssi_wait_transmit(n) 		( REG_SSI_CR1(n) |= SSI_CR1_UNFIN )
+#define __ssi_use_busy_wait_mode(n) 	__ssi_wait_transmit(n)
+#define __ssi_unset_busy_wait_mode(n) 	__ssi_finish_transmit(n)
+
+#define __ssi_spi_format(n)						\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSI_CR1_FMAT_MASK; 			\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_SPI;			\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK); \
+		REG_SSI_CR1(n) |= (SSI_CR1_TFVCK_1 | SSI_CR1_TCKFI_1);	\
+	} while (0)
+
+/* TI's SSP format, must clear SSI_CR1.UNFIN */
+#define __ssi_ssp_format(n)						\
+	do { 								\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_FMAT_MASK | SSI_CR1_UNFIN);	\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_SSP;			\
+	} while (0)
+
+/* National's Microwire format, must clear SSI_CR0.RFINE, and set max delay */
+#define __ssi_microwire_format(n)					\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSI_CR1_FMAT_MASK; 			\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_MW1;			\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK); \
+		REG_SSI_CR1(n) |= (SSI_CR1_TFVCK_3 | SSI_CR1_TCKFI_3);	\
+		REG_SSI_CR0(n) &= ~SSI_CR0_RFINE;			\
+	} while (0)
+
+/* CE# level (FRMHL), CE# in interval time (ITFRM),
+   clock phase and polarity (PHA POL),
+   interval time (SSIITR), interval characters/frame (SSIICR) */
+
+/* frmhl,endian,mcom,flen,pha,pol MASK */
+#define SSICR1_MISC_MASK 					\
+	( SSI_CR1_FRMHL_MASK | SSI_CR1_LFST | SSI_CR1_MCOM_MASK	\
+	  | SSI_CR1_FLEN_MASK | SSI_CR1_PHA | SSI_CR1_POL )	
+
+#define __ssi_spi_set_misc(n,frmhl,endian,flen,mcom,pha,pol)		\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSICR1_MISC_MASK;			\
+		REG_SSI_CR1(n) |= ((frmhl) << 30) | ((endian) << 25) | 	\
+			(((mcom) - 1) << 12) | (((flen) - 2) << 4) | 	\
+			((pha) << 1) | (pol); 				\
+	} while(0)
+
+/* Transfer with MSB or LSB first */
+#define __ssi_set_msb(n) ( REG_SSI_CR1(n) &= ~SSI_CR1_LFST )
+#define __ssi_set_lsb(n) ( REG_SSI_CR1(n) |= SSI_CR1_LFST )
+
+#define __ssi_set_frame_length(n, m)					\
+	REG_SSI_CR1(n) = (REG_SSI_CR1(n) & ~SSI_CR1_FLEN_MASK) | (((m) - 2) << 4) 
+
+/* m = 1 - 16 */
+#define __ssi_set_microwire_command_length(n,m)				\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_MCOM_MASK) | SSI_CR1_MCOM_##m##BIT) )
+
+/* Set the clock phase for SPI */
+#define __ssi_set_spi_clock_phase(n, m)					\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_PHA) | (((m)&0x1)<< 1)))
+
+/* Set the clock polarity for SPI */
+#define __ssi_set_spi_clock_polarity(n, p)				\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_POL) | ((p)&0x1)) )
+
+/* SSI tx trigger, m = i x 8 */
+#define __ssi_set_tx_trigger(n, m)				\
+	do {							\
+		REG_SSI_CR1(n) &= ~SSI_CR1_TTRG_MASK;		\
+		REG_SSI_CR1(n) |= ((m)/8)<<SSI_CR1_TTRG_BIT;	\
+	} while (0)
+
+/* SSI rx trigger, m = i x 8 */
+#define __ssi_set_rx_trigger(n, m)				\
+	do {							\
+		REG_SSI_CR1(n) &= ~SSI_CR1_RTRG_MASK;		\
+		REG_SSI_CR1(n) |= ((m)/8)<<SSI_CR1_RTRG_BIT;	\
+	} while (0)
+
+#define __ssi_get_txfifo_count(n)					\
+	( (REG_SSI_SR(n) & SSI_SR_TFIFONUM_MASK) >> SSI_SR_TFIFONUM_BIT )
+
+#define __ssi_get_rxfifo_count(n)					\
+	( (REG_SSI_SR(n) & SSI_SR_RFIFONUM_MASK) >> SSI_SR_RFIFONUM_BIT )
+
+#define __ssi_transfer_end(n)		( REG_SSI_SR(n) & SSI_SR_END )
+#define __ssi_is_busy(n)		( REG_SSI_SR(n) & SSI_SR_BUSY )
+
+#define __ssi_txfifo_full(n)		( REG_SSI_SR(n) & SSI_SR_TFF )
+#define __ssi_rxfifo_empty(n)		( REG_SSI_SR(n) & SSI_SR_RFE )
+#define __ssi_rxfifo_half_full(n)	( REG_SSI_SR(n) & SSI_SR_RFHF )
+#define __ssi_txfifo_half_empty(n)	( REG_SSI_SR(n) & SSI_SR_TFHE )
+#define __ssi_underrun(n)		( REG_SSI_SR(n) & SSI_SR_UNDR )
+#define __ssi_overrun(n)		( REG_SSI_SR(n) & SSI_SR_OVER )
+#define __ssi_clear_underrun(n)		( REG_SSI_SR(n) = ~SSI_SR_UNDR )
+#define __ssi_clear_overrun(n)		( REG_SSI_SR(n) = ~SSI_SR_OVER )
+#define __ssi_clear_errors(n)		( REG_SSI_SR(n) &= ~(SSI_SR_UNDR | SSI_SR_OVER) )
+
+#define __ssi_set_clk(n, dev_clk, ssi_clk)			\
+	( REG_SSI_GR(n) = (dev_clk) / (2*(ssi_clk)) - 1 )
+
+#define __ssi_receive_data(n) 		REG_SSI_DR(n)
+#define __ssi_transmit_data(n, v) 	(REG_SSI_DR(n) = (v))
+
+
+/***************************************************************************
+ * CIM
+ ***************************************************************************/
+
+#define __cim_enable()	( REG_CIM_CTRL |= CIM_CTRL_ENA )
+#define __cim_disable()	( REG_CIM_CTRL &= ~CIM_CTRL_ENA )
+
+/* n = 0, 1, 2, 3 */
+#define __cim_set_input_data_stream_order(n)				\
+	do {								\
+		REG_CIM_CFG &= CIM_CFG_ORDER_MASK;			\
+		REG_CIM_CFG |= ((n)<<CIM_CFG_ORDER_BIT)&CIM_CFG_ORDER_MASK; \
+	} while (0)
+
+#define __cim_input_data_format_select_RGB()	\
+	do {					\
+		REG_CIM_CFG &= CIM_CFG_DF_MASK;	\
+		REG_CIM_CFG |= CIM_CFG_DF_RGB;	\
+	} while (0)
+
+#define __cim_input_data_format_select_YUV444()		\
+	do {						\
+		REG_CIM_CFG &= CIM_CFG_DF_MASK;		\
+		REG_CIM_CFG |= CIM_CFG_DF_YUV444;	\
+	} while (0)
+
+#define __cim_input_data_format_select_YUV422()		\
+	do {						\
+		REG_CIM_CFG &= CIM_CFG_DF_MASK;		\
+		REG_CIM_CFG |= CIM_CFG_DF_YUV422;	\
+	} while (0)
+
+#define __cim_input_data_format_select_ITU656()		\
+	do {						\
+		REG_CIM_CFG &= CIM_CFG_DF_MASK;		\
+		REG_CIM_CFG |= CIM_CFG_DF_ITU656;	\
+	} while (0)
+
+#define __cim_input_data_inverse()	( REG_CIM_CFG |= CIM_CFG_INV_DAT )
+#define __cim_input_data_normal()	( REG_CIM_CFG &= ~CIM_CFG_INV_DAT )
+
+#define __cim_vsync_active_low()	( REG_CIM_CFG |= CIM_CFG_VSP )
+#define __cim_vsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_VSP )
+
+#define __cim_hsync_active_low()	( REG_CIM_CFG |= CIM_CFG_HSP )
+#define __cim_hsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_HSP )
+
+#define __cim_sample_data_at_pclk_falling_edge() \
+	( REG_CIM_CFG |= CIM_CFG_PCP )
+#define __cim_sample_data_at_pclk_rising_edge() \
+	( REG_CIM_CFG &= ~CIM_CFG_PCP )
+
+#define __cim_enable_dummy_zero()	( REG_CIM_CFG |= CIM_CFG_DUMMY_ZERO )
+#define __cim_disable_dummy_zero()	( REG_CIM_CFG &= ~CIM_CFG_DUMMY_ZERO )
+
+#define __cim_select_external_vsync()	( REG_CIM_CFG |= CIM_CFG_EXT_VSYNC )
+#define __cim_select_internal_vsync()	( REG_CIM_CFG &= ~CIM_CFG_EXT_VSYNC )
+
+/* n=0-7 */
+#define __cim_set_data_packing_mode(n) 		\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_PACK_MASK;	\
+	REG_CIM_CFG |= (CIM_CFG_PACK_##n);	\
+} while (0)
+
+#define __cim_enable_bypass_func() 	(REG_CIM_CFG |= CIM_CFG_BYPASS)
+#define __cim_disable_bypass_func() 	(REG_CIM_CFG &= ~CIM_CFG_BYPASS_MASK)
+
+#define __cim_enable_ccir656_progressive_mode()	\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_DSM_MASK;	\
+	REG_CIM_CFG |= CIM_CFG_DSM_CPM;		\
+} while (0)
+
+#define __cim_enable_ccir656_interlace_mode()	\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_DSM_MASK;	\
+	REG_CIM_CFG |= CIM_CFG_DSM_CIM;		\
+} while (0)
+
+#define __cim_enable_gated_clock_mode()		\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_DSM_MASK;	\
+	REG_CIM_CFG |= CIM_CFG_DSM_GCM;		\
+} while (0)
+
+#define __cim_enable_nongated_clock_mode()	\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_DSM_MASK;	\
+	REG_CIM_CFG |= CIM_CFG_DSM_NGCM;	\
+} while (0)
+
+/* sclk:system bus clock
+ * mclk: CIM master clock
+ */
+#define __cim_set_master_clk(sclk, mclk)			\
+do {								\
+	REG_CIM_CTRL &= ~CIM_CTRL_MCLKDIV_MASK;				\
+	REG_CIM_CTRL |= (((sclk)/(mclk) - 1) << CIM_CTRL_MCLKDIV_BIT);	\
+} while (0)
+/* n=1-16 */
+#define __cim_set_frame_rate(n) 		\
+do {						\
+	REG_CIM_CTRL &= ~CIM_CTRL_FRC_MASK; 	\
+	REG_CIM_CTRL |= CIM_CTRL_FRC_##n;	\
+} while (0)
+
+#define __cim_enable_size_func() \
+	( REG_CIM_CTRL |= CIM_CTRL_SIZEEN )
+#define __cim_disable_size_func() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_SIZEEN_MASK )
+
+#define __cim_enable_vdd_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_VDDM )
+#define __cim_disable_vdd_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_VDDM )
+
+#define __cim_enable_sof_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_DMA_SOFM )
+#define __cim_disable_sof_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_DMA_SOFM )
+
+#define __cim_enable_eof_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_DMA_EOFM )
+#define __cim_disable_eof_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EOFM )
+
+#define __cim_enable_stop_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_DMA_STOPM )
+#define __cim_disable_stop_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_DMA_STOPM )
+
+#define __cim_enable_trig_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_RXF_TRIGM )
+#define __cim_disable_trig_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIGM )
+
+#define __cim_enable_rxfifo_overflow_intr()	\
+	( REG_CIM_CTRL |= CIM_CTRL_RXF_OFM )
+#define __cim_disable_rxfifo_overflow_intr()	\
+	( REG_CIM_CTRL &= ~CIM_CTRL_RXF_OFM )
+
+/* n=4,8,12,16,20,24,28,32 */
+#define __cim_set_rxfifo_trigger(n) 		\
+do {						\
+	REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIG_MASK; 	\
+	REG_CIM_CTRL |= CIM_CTRL_RXF_TRIG_##n;		\
+} while (0)
+#define __cim_enable_fast_mode() 	( REG_CIM_CTRL |= CIM_CTRL_FAST_MODE )
+#define __cim_disable_fast_mode() 	( REG_CIM_CTRL &= ~CIM_CTRL_FAST_MODE )
+#define __cim_use_normal_mode() 	__cim_disable_fast_mode()
+#define __cim_enable_dma()   ( REG_CIM_CTRL |= CIM_CTRL_DMA_EN )
+#define __cim_disable_dma()  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EN )
+#define __cim_reset_rxfifo() ( REG_CIM_CTRL |= CIM_CTRL_RXF_RST )
+#define __cim_unreset_rxfifo() ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_RST )
+
+#define __cim_clear_state()   	     ( REG_CIM_STATE = 0 )
+
+#define __cim_disable_done()   	     ( REG_CIM_STATE & CIM_STATE_VDD )
+#define __cim_rxfifo_empty()   	     ( REG_CIM_STATE & CIM_STATE_RXF_EMPTY )
+#define __cim_rxfifo_reach_trigger() ( REG_CIM_STATE & CIM_STATE_RXF_TRIG )
+#define __cim_rxfifo_overflow()      ( REG_CIM_STATE & CIM_STATE_RXF_OF )
+#define __cim_clear_rxfifo_overflow() ( REG_CIM_STATE &= ~CIM_STATE_RXF_OF )
+#define __cim_dma_stop()   	     ( REG_CIM_STATE & CIM_STATE_DMA_STOP )
+#define __cim_dma_eof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_EOF )
+#define __cim_dma_sof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_SOF )
+
+#define __cim_get_iid()   	     ( REG_CIM_IID )
+#define __cim_get_fid()   	     ( REG_CIM_FID )
+#define __cim_get_image_data()       ( REG_CIM_RXFIFO )
+#define __cim_get_dma_cmd()          ( REG_CIM_CMD )
+
+#define __cim_set_da(a)              ( REG_CIM_DA = (a) )
+
+#define __cim_set_line(a) 	( REG_CIM_SIZE = (REG_CIM_SIZE&(~CIM_SIZE_LPF_MASK))|((a)<<CIM_SIZE_LPF_BIT) )
+#define __cim_set_pixel(a) 	( REG_CIM_SIZE = (REG_CIM_SIZE&(~CIM_SIZE_PPL_MASK))|((a)<<CIM_SIZE_PPL_BIT) )
+#define __cim_get_line() 	((REG_CIM_SIZE&CIM_SIZE_LPF_MASK)>>CIM_SIZE_LPF_BIT)
+#define __cim_get_pixel() 	((REG_CIM_SIZE&CIM_SIZE_PPL_MASK)>>CIM_SIZE_PPL_BIT)
+
+#define __cim_set_v_offset(a) 	( REG_CIM_OFFSET = (REG_CIM_OFFSET&(~CIM_OFFSET_V_MASK)) | ((a)<<CIM_OFFSET_V_BIT) )
+#define __cim_set_h_offset(a) 	( REG_CIM_OFFSET = (REG_CIM_OFFSET&(~CIM_OFFSET_H_MASK)) | ((a)<<CIM_OFFSET_H_BIT) )
+#define __cim_get_v_offset() 	((REG_CIM_OFFSET&CIM_OFFSET_V_MASK)>>CIM_OFFSET_V_BIT)
+#define __cim_get_h_offset() 	((REG_CIM_OFFSET&CIM_OFFSET_H_MASK)>>CIM_OFFSET_H_BIT)
+
+/*************************************************************************
+ * SLCD (Smart LCD Controller)
+ *************************************************************************/
+#define __slcd_set_data_18bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_18BIT )
+#define __slcd_set_data_16bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_16BIT )
+#define __slcd_set_data_8bit_x3() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_8BIT_x3 )
+#define __slcd_set_data_8bit_x2() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_8BIT_x2 )
+#define __slcd_set_data_8bit_x1() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_8BIT_x1 )
+#define __slcd_set_data_24bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_24BIT )
+#define __slcd_set_data_9bit_x2() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_9BIT_x2 )
+
+#define __slcd_set_cmd_16bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_CWIDTH_MASK) | SLCD_CFG_CWIDTH_16BIT )
+#define __slcd_set_cmd_8bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_CWIDTH_MASK) | SLCD_CFG_CWIDTH_8BIT )
+#define __slcd_set_cmd_18bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_CWIDTH_MASK) | SLCD_CFG_CWIDTH_18BIT )
+#define __slcd_set_cmd_24bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_CWIDTH_MASK) | SLCD_CFG_CWIDTH_24BIT )
+
+#define __slcd_set_cs_high()        ( REG_SLCD_CFG |= SLCD_CFG_CS_ACTIVE_HIGH )
+#define __slcd_set_cs_low()         ( REG_SLCD_CFG &= ~SLCD_CFG_CS_ACTIVE_HIGH )
+
+#define __slcd_set_rs_high()        ( REG_SLCD_CFG |= SLCD_CFG_RS_CMD_HIGH )
+#define __slcd_set_rs_low()         ( REG_SLCD_CFG &= ~SLCD_CFG_RS_CMD_HIGH )
+
+#define __slcd_set_clk_falling()    ( REG_SLCD_CFG &= ~SLCD_CFG_CLK_ACTIVE_RISING )
+#define __slcd_set_clk_rising()     ( REG_SLCD_CFG |= SLCD_CFG_CLK_ACTIVE_RISING )
+
+#define __slcd_set_parallel_type()  ( REG_SLCD_CFG &= ~SLCD_CFG_TYPE_SERIAL )
+#define __slcd_set_serial_type()    ( REG_SLCD_CFG |= SLCD_CFG_TYPE_SERIAL )
+
+/* SLCD Control Register */
+#define __slcd_enable_dma()         ( REG_SLCD_CTRL |= SLCD_CTRL_DMA_EN )
+#define __slcd_disable_dma()        ( REG_SLCD_CTRL &= ~SLCD_CTRL_DMA_EN )
+
+/* SLCD Status Register */
+#define __slcd_is_busy()            ( REG_SLCD_STATE & SLCD_STATE_BUSY )
+
+/* SLCD Data Register */
+#define __slcd_set_cmd_rs()         ( REG_SLCD_DATA |= SLCD_DATA_RS_COMMAND)
+#define __slcd_set_data_rs()        ( REG_SLCD_DATA &= ~SLCD_DATA_RS_COMMAND)
+
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+#define __lcd_as_smart_lcd() 		( REG_LCD_CFG |= ( LCD_CFG_LCDPIN_SLCD | LCD_CFG_MODE_SLCD))
+#define __lcd_as_general_lcd() 		( REG_LCD_CFG &= ~( LCD_CFG_LCDPIN_SLCD | LCD_CFG_MODE_SLCD))
+
+#define __lcd_enable_tvepeh() 		( REG_LCD_CFG |= LCD_CFG_TVEPEH )
+#define __lcd_disable_tvepeh() 		( REG_LCD_CFG &= ~LCD_CFG_TVEPEH )
+
+#define __lcd_enable_fuhold() 		( REG_LCD_CFG |= LCD_CFG_FUHOLD )
+#define __lcd_disable_fuhold() 		( REG_LCD_CFG &= ~LCD_CFG_FUHOLD )
+
+#define __lcd_des_8word() 		( REG_LCD_CFG |= LCD_CFG_NEWDES )
+#define __lcd_des_4word() 		( REG_LCD_CFG &= ~LCD_CFG_NEWDES )
+
+#define __lcd_enable_bypass_pal() 	( REG_LCD_CFG |= LCD_CFG_PALBP )
+#define __lcd_disable_bypass_pal() 	( REG_LCD_CFG &= ~LCD_CFG_PALBP )
+
+#define __lcd_set_lcdpnl_term()		( REG_LCD_CTRL |= LCD_CFG_TVEN )
+#define __lcd_set_tv_term()		( REG_LCD_CTRL &= ~LCD_CFG_TVEN )
+
+#define __lcd_enable_auto_recover() 	( REG_LCD_CFG |= LCD_CFG_RECOVER )
+#define __lcd_disable_auto_recover() 	( REG_LCD_CFG &= ~LCD_CFG_RECOVER )
+
+#define __lcd_enable_dither() 	        ( REG_LCD_CFG |= LCD_CFG_DITHER )
+#define __lcd_disable_dither() 	        ( REG_LCD_CFG &= ~LCD_CFG_DITHER )
+
+#define __lcd_disable_ps_mode()	        ( REG_LCD_CFG |= LCD_CFG_PSM )
+#define __lcd_enable_ps_mode()	        ( REG_LCD_CFG &= ~LCD_CFG_PSM )
+
+#define __lcd_disable_cls_mode() 	( REG_LCD_CFG |= LCD_CFG_CLSM )
+#define __lcd_enable_cls_mode()	        ( REG_LCD_CFG &= ~LCD_CFG_CLSM )
+
+#define __lcd_disable_spl_mode() 	( REG_LCD_CFG |= LCD_CFG_SPLM )
+#define __lcd_enable_spl_mode()	        ( REG_LCD_CFG &= ~LCD_CFG_SPLM )
+
+#define __lcd_disable_rev_mode() 	( REG_LCD_CFG |= LCD_CFG_REVM )
+#define __lcd_enable_rev_mode()	        ( REG_LCD_CFG &= ~LCD_CFG_REVM )
+
+#define __lcd_disable_hsync_mode() 	( REG_LCD_CFG |= LCD_CFG_HSYNM )
+#define __lcd_enable_hsync_mode()	( REG_LCD_CFG &= ~LCD_CFG_HSYNM )
+
+#define __lcd_disable_pclk_mode() 	( REG_LCD_CFG |= LCD_CFG_PCLKM )
+#define __lcd_enable_pclk_mode()	( REG_LCD_CFG &= ~LCD_CFG_PCLKM )
+
+#define __lcd_normal_outdata()          ( REG_LCD_CFG &= ~LCD_CFG_INVDAT )
+#define __lcd_inverse_outdata()         ( REG_LCD_CFG |= LCD_CFG_INVDAT )
+
+#define __lcd_sync_input()              ( REG_LCD_CFG |= LCD_CFG_SYNDIR_IN )
+#define __lcd_sync_output()             ( REG_LCD_CFG &= ~LCD_CFG_SYNDIR_IN )
+
+#define __lcd_hsync_active_high()       ( REG_LCD_CFG &= ~LCD_CFG_HSP )
+#define __lcd_hsync_active_low()        ( REG_LCD_CFG |= LCD_CFG_HSP )
+
+#define __lcd_pclk_rising()             ( REG_LCD_CFG &= ~LCD_CFG_PCP )
+#define __lcd_pclk_falling()            ( REG_LCD_CFG |= LCD_CFG_PCP )
+
+#define __lcd_de_active_high()          ( REG_LCD_CFG &= ~LCD_CFG_DEP )
+#define __lcd_de_active_low()           ( REG_LCD_CFG |= LCD_CFG_DEP )
+
+#define __lcd_vsync_rising()            ( REG_LCD_CFG &= ~LCD_CFG_VSP )
+#define __lcd_vsync_falling()           ( REG_LCD_CFG |= LCD_CFG_VSP )
+
+#define __lcd_set_16_tftpnl() \
+  ( REG_LCD_CFG = (REG_LCD_CFG & ~LCD_CFG_MODE_TFT_MASK) | LCD_CFG_MODE_TFT_16BIT )
+
+#define __lcd_set_18_tftpnl() \
+  ( REG_LCD_CFG = (REG_LCD_CFG & ~LCD_CFG_MODE_TFT_MASK) | LCD_CFG_MODE_TFT_18BIT )
+
+#define __lcd_set_24_tftpnl()		( REG_LCD_CFG |= LCD_CFG_MODE_TFT_24BIT )
+
+/* 
+ * n=1,2,4,8 for single mono-STN 
+ * n=4,8 for dual mono-STN
+ */
+#define __lcd_set_panel_datawidth(n) 		\
+do { 						\
+	REG_LCD_CFG &= ~LCD_CFG_PDW_MASK; 	\
+	REG_LCD_CFG |= LCD_CFG_PDW_n##;		\
+} while (0)
+
+/* m = LCD_CFG_MODE_GENERUIC_TFT_xxx */
+#define __lcd_set_panel_mode(m) 		\
+do {						\
+	REG_LCD_CFG &= ~LCD_CFG_MODE_MASK;	\
+	REG_LCD_CFG |= (m);			\
+} while(0)
+
+/* n=4,8,16 */
+#define __lcd_set_burst_length(n) 		\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_BST_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_BST_n##;	\
+} while (0)
+
+#define __lcd_select_rgb565()		( REG_LCD_CTRL &= ~LCD_CTRL_RGB555 )
+#define __lcd_select_rgb555()		( REG_LCD_CTRL |= LCD_CTRL_RGB555 )
+
+#define __lcd_set_ofup()		( REG_LCD_CTRL |= LCD_CTRL_OFUP )
+#define __lcd_clr_ofup()		( REG_LCD_CTRL &= ~LCD_CTRL_OFUP )
+
+/* n=2,4,16 */
+#define __lcd_set_stn_frc(n) 			\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_FRC_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_FRC_n##;	\
+} while (0)
+
+#define __lcd_enable_eof_intr()		( REG_LCD_CTRL |= LCD_CTRL_EOFM )
+#define __lcd_disable_eof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_EOFM )
+
+#define __lcd_enable_sof_intr()		( REG_LCD_CTRL |= LCD_CTRL_SOFM )
+#define __lcd_disable_sof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_SOFM )
+
+#define __lcd_enable_ofu_intr()		( REG_LCD_CTRL |= LCD_CTRL_OFUM )
+#define __lcd_disable_ofu_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_OFUM )
+
+#define __lcd_enable_ifu0_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM0 )
+#define __lcd_disable_ifu0_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM0 )
+
+#define __lcd_enable_ifu1_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM1 )
+#define __lcd_disable_ifu1_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM1 )
+
+#define __lcd_enable_ldd_intr()		( REG_LCD_CTRL |= LCD_CTRL_LDDM )
+#define __lcd_disable_ldd_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_LDDM )
+
+#define __lcd_enable_qd_intr()		( REG_LCD_CTRL |= LCD_CTRL_QDM )
+#define __lcd_disable_qd_intr()		( REG_LCD_CTRL &= ~LCD_CTRL_QDM )
+
+#define __lcd_reverse_byte_endian()	( REG_LCD_CTRL |= LCD_CTRL_BEDN )
+#define __lcd_normal_byte_endian()	( REG_LCD_CTRL &= ~LCD_CTRL_BEDN )
+
+#define __lcd_pixel_endian_little()	( REG_LCD_CTRL |= LCD_CTRL_PEDN )
+#define __lcd_pixel_endian_big()	( REG_LCD_CTRL &= ~LCD_CTRL_PEDN )
+
+#define __lcd_set_dis()			( REG_LCD_CTRL |= LCD_CTRL_DIS )
+#define __lcd_clr_dis()			( REG_LCD_CTRL &= ~LCD_CTRL_DIS )
+
+#define __lcd_set_ena()			( REG_LCD_CTRL |= LCD_CTRL_ENA )
+#define __lcd_clr_ena()			( REG_LCD_CTRL &= ~LCD_CTRL_ENA )
+
+/* n=1,2,4,8,16 */
+#define __lcd_set_bpp(n) \
+  ( REG_LCD_CTRL = (REG_LCD_CTRL & ~LCD_CTRL_BPP_MASK) | LCD_CTRL_BPP_##n )
+
+/* LCD status register indication */
+
+#define __lcd_quick_disable_done()	( REG_LCD_STATE & LCD_STATE_QD )
+#define __lcd_disable_done()		( REG_LCD_STATE & LCD_STATE_LDD )
+#define __lcd_infifo0_underrun()	( REG_LCD_STATE & LCD_STATE_IFU0 )
+#define __lcd_infifo1_underrun()	( REG_LCD_STATE & LCD_STATE_IFU1 )
+#define __lcd_outfifo_underrun()	( REG_LCD_STATE & LCD_STATE_OFU )
+#define __lcd_start_of_frame()		( REG_LCD_STATE & LCD_STATE_SOF )
+#define __lcd_end_of_frame()		( REG_LCD_STATE & LCD_STATE_EOF )
+
+#define __lcd_clr_outfifounderrun()	( REG_LCD_STATE &= ~LCD_STATE_OFU )
+#define __lcd_clr_sof()			( REG_LCD_STATE &= ~LCD_STATE_SOF )
+#define __lcd_clr_eof()			( REG_LCD_STATE &= ~LCD_STATE_EOF )
+
+/* OSD functions */
+#define __lcd_enable_osd() 	(REG_LCD_OSDC |= LCD_OSDC_OSDEN)
+#define __lcd_enable_f0() 	(REG_LCD_OSDC |= LCD_OSDC_F0EN)
+#define __lcd_enable_f1()	(REG_LCD_OSDC |= LCD_OSDC_F1EN)
+#define __lcd_enable_alpha() 	(REG_LCD_OSDC |= LCD_OSDC_ALPHAEN)
+#define __lcd_enable_alphamd()	(REG_LCD_OSDC |= LCD_OSDC_ALPHAMD)
+
+#define __lcd_disable_osd()	(REG_LCD_OSDC &= ~LCD_OSDC_OSDEN)
+#define __lcd_disable_f0() 	(REG_LCD_OSDC &= ~LCD_OSDC_F0EN)
+#define __lcd_disable_f1() 	(REG_LCD_OSDC &= ~LCD_OSDC_F1EN)
+#define __lcd_disable_alpha()	(REG_LCD_OSDC &= ~LCD_OSDC_ALPHAEN)
+#define __lcd_disable_alphamd()	(REG_LCD_OSDC &= ~LCD_OSDC_ALPHAMD)
+
+/* OSD Controll Register */
+#define __lcd_fg1_use_ipu() 		(REG_LCD_OSDCTRL |= LCD_OSDCTRL_IPU)
+#define __lcd_fg1_use_dma_chan1() 	(REG_LCD_OSDCTRL &= ~LCD_OSDCTRL_IPU)
+#define __lcd_fg1_unuse_ipu() 		__lcd_fg1_use_dma_chan1()
+#define __lcd_osd_rgb555_mode()         ( REG_LCD_OSDCTRL |= LCD_OSDCTRL_RGB555 )
+#define __lcd_osd_rgb565_mode()         ( REG_LCD_OSDCTRL &= ~LCD_OSDCTRL_RGB555 )
+#define __lcd_osd_change_size()         ( REG_LCD_OSDCTRL |= LCD_OSDCTRL_CHANGES )
+#define __lcd_osd_bpp_15_16() \
+  ( REG_LCD_OSDCTRL = (REG_LCD_OSDCTRL & ~LCD_OSDCTRL_OSDBPP_MASK) | LCD_OSDCTRL_OSDBPP_15_16 )
+#define __lcd_osd_bpp_18_24() \
+  ( REG_LCD_OSDCTRL = (REG_LCD_OSDCTRL & ~LCD_OSDCTRL_OSDBPP_MASK) | LCD_OSDCTRL_OSDBPP_18_24 )
+
+/* OSD State Register */
+#define __lcd_start_of_fg1()		( REG_LCD_STATE & LCD_OSDS_SOF1 )
+#define __lcd_end_of_fg1()		( REG_LCD_STATE & LCD_OSDS_EOF1 )
+#define __lcd_start_of_fg0()		( REG_LCD_STATE & LCD_OSDS_SOF0 )
+#define __lcd_end_of_fg0()		( REG_LCD_STATE & LCD_OSDS_EOF0 )
+#define __lcd_change_is_rdy()		( REG_LCD_STATE & LCD_OSDS_READY )
+
+/* Foreground Color Key Register 0,1(foreground 0, foreground 1) */
+#define __lcd_enable_colorkey0()	(REG_LCD_KEY0 |= LCD_KEY_KEYEN)
+#define __lcd_enable_colorkey1()	(REG_LCD_KEY1 |= LCD_KEY_KEYEN)
+#define __lcd_enable_colorkey0_md() 	(REG_LCD_KEY0 |= LCD_KEY_KEYMD)
+#define __lcd_enable_colorkey1_md() 	(REG_LCD_KEY1 |= LCD_KEY_KEYMD)
+#define __lcd_set_colorkey0(key) 	(REG_LCD_KEY0 = (REG_LCD_KEY0&~0xFFFFFF)|(key))
+#define __lcd_set_colorkey1(key) 	(REG_LCD_KEY1 = (REG_LCD_KEY1&~0xFFFFFF)|(key))
+
+#define __lcd_disable_colorkey0() 	(REG_LCD_KEY0 &= ~LCD_KEY_KEYEN)
+#define __lcd_disable_colorkey1() 	(REG_LCD_KEY1 &= ~LCD_KEY_KEYEN)
+#define __lcd_disable_colorkey0_md() 	(REG_LCD_KEY0 &= ~LCD_KEY_KEYMD)
+#define __lcd_disable_colorkey1_md() 	(REG_LCD_KEY1 &= ~LCD_KEY_KEYMD)
+
+/* IPU Restart Register */
+#define __lcd_enable_ipu_restart() 	(REG_LCD_IPUR |= LCD_IPUR_IPUREN)
+#define __lcd_disable_ipu_restart() 	(REG_LCD_IPUR &= ~LCD_IPUR_IPUREN)
+#define __lcd_set_ipu_restart_triger(n)	(REG_LCD_IPUR = (REG_LCD_IPUR&(~0xFFFFFF))|(n))
+
+/* RGB Control Register */
+#define __lcd_enable_rgb_dummy() 	(REG_LCD_RGBC |= LCD_RGBC_RGBDM)
+#define __lcd_disable_rgb_dummy() 	(REG_LCD_RGBC &= ~LCD_RGBC_RGBDM)
+
+#define __lcd_dummy_rgb() 	(REG_LCD_RGBC |= LCD_RGBC_DMM)
+#define __lcd_rgb_dummy() 	(REG_LCD_RGBC &= ~LCD_RGBC_DMM)
+
+#define __lcd_rgb2ycc() 	(REG_LCD_RGBC |= LCD_RGBC_YCC)
+#define __lcd_notrgb2ycc() 	(REG_LCD_RGBC &= ~LCD_RGBC_YCC)
+
+#define __lcd_odd_mode_rgb() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_RGB )
+#define __lcd_odd_mode_rbg() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_RBG )
+#define __lcd_odd_mode_grb() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_GRB)
+
+#define __lcd_odd_mode_gbr() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_GBR)
+#define __lcd_odd_mode_brg() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_BRG)
+#define __lcd_odd_mode_bgr() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_BGR)
+
+#define __lcd_even_mode_rgb() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_RGB )
+#define __lcd_even_mode_rbg() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_RBG )
+#define __lcd_even_mode_grb() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_GRB)
+
+#define __lcd_even_mode_gbr() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_GBR)
+#define __lcd_even_mode_brg() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_BRG)
+#define __lcd_even_mode_bgr() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_BGR)
+
+/* Vertical Synchronize Register */
+#define __lcd_vsync_get_vps() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPS_MASK) >> LCD_VSYNC_VPS_BIT )
+
+#define __lcd_vsync_get_vpe() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPE_MASK) >> LCD_VSYNC_VPE_BIT )
+#define __lcd_vsync_set_vpe(n) 				\
+do {							\
+	REG_LCD_VSYNC &= ~LCD_VSYNC_VPE_MASK;		\
+	REG_LCD_VSYNC |= (n) << LCD_VSYNC_VPE_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hps() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPS_MASK) >> LCD_HSYNC_HPS_BIT )
+#define __lcd_hsync_set_hps(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPS_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPS_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hpe() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPE_MASK) >> LCD_VSYNC_HPE_BIT )
+#define __lcd_hsync_set_hpe(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPE_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPE_BIT;	\
+} while (0)
+
+#define __lcd_vat_get_ht() \
+  ( (REG_LCD_VAT & LCD_VAT_HT_MASK) >> LCD_VAT_HT_BIT )
+#define __lcd_vat_set_ht(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_HT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_HT_BIT;		\
+} while (0)
+
+#define __lcd_vat_get_vt() \
+  ( (REG_LCD_VAT & LCD_VAT_VT_MASK) >> LCD_VAT_VT_BIT )
+#define __lcd_vat_set_vt(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_VT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_VT_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hds() \
+  ( (REG_LCD_DAH & LCD_DAH_HDS_MASK) >> LCD_DAH_HDS_BIT )
+#define __lcd_dah_set_hds(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDS_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDS_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hde() \
+  ( (REG_LCD_DAH & LCD_DAH_HDE_MASK) >> LCD_DAH_HDE_BIT )
+#define __lcd_dah_set_hde(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDE_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDE_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vds() \
+  ( (REG_LCD_DAV & LCD_DAV_VDS_MASK) >> LCD_DAV_VDS_BIT )
+#define __lcd_dav_set_vds(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDS_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDS_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vde() \
+  ( (REG_LCD_DAV & LCD_DAV_VDE_MASK) >> LCD_DAV_VDE_BIT )
+#define __lcd_dav_set_vde(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDE_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDE_BIT;		\
+} while (0)
+
+/* DMA Command Register */
+#define __lcd_cmd0_set_sofint()		( REG_LCD_CMD0 |= LCD_CMD_SOFINT )
+#define __lcd_cmd0_clr_sofint()		( REG_LCD_CMD0 &= ~LCD_CMD_SOFINT )
+#define __lcd_cmd1_set_sofint()		( REG_LCD_CMD1 |= LCD_CMD_SOFINT )
+#define __lcd_cmd1_clr_sofint()		( REG_LCD_CMD1 &= ~LCD_CMD_SOFINT )
+
+#define __lcd_cmd0_set_eofint()		( REG_LCD_CMD0 |= LCD_CMD_EOFINT )
+#define __lcd_cmd0_clr_eofint()		( REG_LCD_CMD0 &= ~LCD_CMD_EOFINT )
+#define __lcd_cmd1_set_eofint()		( REG_LCD_CMD1 |= LCD_CMD_EOFINT )
+#define __lcd_cmd1_clr_eofint()		( REG_LCD_CMD1 &= ~LCD_CMD_EOFINT )
+
+#define __lcd_cmd0_set_pal()		( REG_LCD_CMD0 |= LCD_CMD_PAL )
+#define __lcd_cmd0_clr_pal()		( REG_LCD_CMD0 &= ~LCD_CMD_PAL )
+
+#define __lcd_cmd0_get_len() \
+  ( (REG_LCD_CMD0 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+#define __lcd_cmd1_get_len() \
+  ( (REG_LCD_CMD1 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+
+/*************************************************************************
+ * TVE (TV Encoder Controller) ops
+ *************************************************************************/
+/* TV Encoder Control register ops */
+#define __tve_soft_reset()		(REG_TVE_CTRL |= TVE_CTRL_SWRST)
+
+#define __tve_output_colorbar()		(REG_TVE_CTRL |= TVE_CTRL_CLBAR)
+#define __tve_output_video()		(REG_TVE_CTRL &= ~TVE_CTRL_CLBAR)
+
+#define __tve_input_cr_first()		(REG_TVE_CTRL |= TVE_CTRL_CR1ST)
+#define __tve_input_cb_first()		(REG_TVE_CTRL &= ~TVE_CTRL_CR1ST)
+
+#define __tve_set_0_as_black()		(REG_TVE_CTRL |= TVE_CTRL_ZBLACK)
+#define __tve_set_16_as_black()		(REG_TVE_CTRL &= ~TVE_CTRL_ZBLACK)
+
+#define __tve_ena_invert_top_bottom()	(REG_TVE_CTRL |= TVE_CTRL_FINV)
+#define __tve_dis_invert_top_bottom()	(REG_TVE_CTRL &= ~TVE_CTRL_FINV)
+
+#define __tve_set_pal_mode()		(REG_TVE_CTRL |= TVE_CTRL_PAL)
+#define __tve_set_ntsc_mode()		(REG_TVE_CTRL &= ~TVE_CTRL_PAL)
+
+#define __tve_set_pal_dura()		(REG_TVE_CTRL |= TVE_CTRL_SYNCT)
+#define __tve_set_ntsc_dura()		(REG_TVE_CTRL &= ~TVE_CTRL_SYNCT)
+
+/* n = 0 ~ 3 */
+#define __tve_set_c_bandwidth(n) \
+do {\
+	REG_TVE_CTRL &= ~TVE_CTRL_CBW_MASK;\
+	REG_TVE_CTRL |= (n) << TVE_CTRL_CBW_BIT;	\
+}while(0)
+
+/* n = 0 ~ 3 */
+#define __tve_set_c_gain(n) \
+do {\
+	REG_TVE_CTRL &= ~TVE_CTRL_CGAIN_MASK;\
+	(REG_TVE_CTRL |= (n) << TVE_CTRL_CGAIN_BIT;	\
+}while(0)
+
+/* n = 0 ~ 7 */
+#define __tve_set_yc_delay(n)				\
+do {							\
+	REG_TVE_CTRL &= ~TVE_CTRL_YCDLY_MASK		\
+	REG_TVE_CTRL |= ((n) << TVE_CTRL_YCDLY_BIT);	\
+} while(0)
+
+#define __tve_disable_all_dacs()	(REG_TVE_CTRL |= TVE_CTRL_DAPD)
+#define __tve_disable_dac1()		(REG_TVE_CTRL |= TVE_CTRL_DAPD1)
+#define __tve_enable_dac1()		(REG_TVE_CTRL &= ~TVE_CTRL_DAPD1)
+#define __tve_disable_dac2()		(REG_TVE_CTRL |= TVE_CTRL_DAPD2)
+#define __tve_enable_dac2()		(REG_TVE_CTRL &= ~TVE_CTRL_DAPD2)
+#define __tve_disable_dac3()		(REG_TVE_CTRL |= TVE_CTRL_DAPD3)
+#define __tve_enable_dac3()		(REG_TVE_CTRL &= ~TVE_CTRL_DAPD3)
+
+#define __tve_enable_svideo_fmt()	(REG_TVE_CTRL |= TVE_CTRL_ECVBS)
+#define __tve_enable_cvbs_fmt()		(REG_TVE_CTRL &= ~TVE_CTRL_ECVBS)
+
+/* TV Encoder Frame Configure register ops */
+/* n = 0 ~ 255 */
+#define __tve_set_first_video_line(n)		\
+do {\
+		REG_TVE_FRCFG &= ~TVE_FRCFG_L1ST_MASK;\
+		REG_TVE_FRCFG |= (n) << TVE_FRCFG_L1ST_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_line_num_per_frm(n)		\
+do {\
+		REG_TVE_FRCFG &= ~TVE_FRCFG_NLINE_MASK;\
+		REG_TVE_CFG |= (n) << TVE_FRCFG_NLINE_BIT;\
+} while(0)
+#define __tve_get_video_line_num()\
+	(((REG_TVE_FRCFG & TVE_FRCFG_NLINE_MASK) >> TVE_FRCFG_NLINE_BIT) - 1 - 2 * ((REG_TVE_FRCFG & TVE_FRCFG_L1ST_MASK) >> TVE_FRCFG_L1ST_BIT))
+
+/* TV Encoder Signal Level Configure register ops */
+/* n = 0 ~ 1023 */
+#define __tve_set_white_level(n)		\
+do {\
+		REG_TVE_SLCFG1 &= ~TVE_SLCFG1_WHITEL_MASK;\
+		REG_TVE_SLCFG1 |= (n) << TVE_SLCFG1_WHITEL_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_black_level(n)		\
+do {\
+		REG_TVE_SLCFG1 &= ~TVE_SLCFG1_BLACKL_MASK;\
+		REG_TVE_SLCFG1 |= (n) << TVE_SLCFG1_BLACKL_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_blank_level(n)		\
+do {\
+		REG_TVE_SLCFG2 &= ~TVE_SLCFG2_BLANKL_MASK;\
+		REG_TVE_SLCFG2 |= (n) << TVE_SLCFG2_BLANKL_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_vbi_blank_level(n)		\
+do {\
+		REG_TVE_SLCFG2 &= ~TVE_SLCFG2_VBLANKL_MASK;\
+		REG_TVE_SLCFG2 |= (n) << TVE_SLCFG2_VBLANKL_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_sync_level(n)		\
+do {\
+		REG_TVE_SLCFG3 &= ~TVE_SLCFG3_SYNCL_MASK;\
+		REG_TVE_SLCFG3 |= (n) << TVE_SLCFG3_SYNCL_BIT;\
+} while(0)
+
+/* TV Encoder Signal Level Configure register ops */
+/* n = 0 ~ 31 */
+#define __tve_set_front_porch(n)		\
+do {\
+		REG_TVE_LTCFG1 &= ~TVE_LTCFG1_FRONTP_MASK;\
+		REG_TVE_LTCFG1 |= (n) << TVE_LTCFG1_FRONTP_BIT;	\
+} while(0)
+/* n = 0 ~ 127 */
+#define __tve_set_hsync_width(n)		\
+do {\
+		REG_TVE_LTCFG1 &= ~TVE_LTCFG1_HSYNCW_MASK;\
+		REG_TVE_LTCFG1 |= (n) << TVE_LTCFG1_HSYNCW_BIT;	\
+} while(0)
+/* n = 0 ~ 127 */
+#define __tve_set_back_porch(n)		\
+do {\
+		REG_TVE_LTCFG1 &= ~TVE_LTCFG1_BACKP_MASK;\
+		REG_TVE_LTCFG1 |= (n) << TVE_LTCFG1_BACKP_BIT;	\
+} while(0)
+/* n = 0 ~ 2047 */
+#define __tve_set_active_linec(n)		\
+do {\
+		REG_TVE_LTCFG2 &= ~TVE_LTCFG2_ACTLIN_MASK;\
+		REG_TVE_LTCFG2 |= (n) << TVE_LTCFG2_ACTLIN_BIT;	\
+} while(0)
+/* n = 0 ~ 31 */
+#define __tve_set_breezy_way(n)		\
+do {\
+		REG_TVE_LTCFG2 &= ~TVE_LTCFG2_PREBW_MASK;\
+		REG_TVE_LTCFG2 |= (n) << TVE_LTCFG2_PREBW_BIT;	\
+} while(0)
+
+/* n = 0 ~ 127 */
+#define __tve_set_burst_width(n)		\
+do {\
+		REG_TVE_LTCFG2 &= ~TVE_LTCFG2_BURSTW_MASK;\
+		REG_TVE_LTCFG2 |= (n) << TVE_LTCFG2_BURSTW_BIT;	\
+} while(0)
+
+/* TV Encoder Chrominance filter and Modulation register ops */
+/* n = 0 ~ (2^32-1) */
+#define __tve_set_c_sub_carrier_freq(n)  REG_TVE_CFREQ = (n)
+/* n = 0 ~ 255 */
+#define __tve_set_c_sub_carrier_init_phase(n) \
+do {   \
+	REG_TVE_CPHASE &= ~TVE_CPHASE_INITPH_MASK;	\
+	REG_TVE_CPHASE |= (n) << TVE_CPHASE_INITPH_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_c_sub_carrier_act_phase(n) \
+do {   \
+	REG_TVE_CPHASE &= ~TVE_CPHASE_ACTPH_MASK;	\
+	REG_TVE_CPHASE |= (n) << TVE_CPHASE_ACTPH_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_c_phase_rst_period(n) \
+do {   \
+	REG_TVE_CPHASE &= ~TVE_CPHASE_CCRSTP_MASK;	\
+	REG_TVE_CPHASE |= (n) << TVE_CPHASE_CCRSTP_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_cb_burst_amp(n) \
+do {   \
+	REG_TVE_CBCRCFG &= ~TVE_CBCRCFG_CBBA_MASK;	\
+	REG_TVE_CBCRCFG |= (n) << TVE_CBCRCFG_CBBA_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_cr_burst_amp(n) \
+do {   \
+	REG_TVE_CBCRCFG &= ~TVE_CBCRCFG_CRBA_MASK;	\
+	REG_TVE_CBCRCFG |= (n) << TVE_CBCRCFG_CRBA_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_cb_gain_amp(n) \
+do {   \
+	REG_TVE_CBCRCFG &= ~TVE_CBCRCFG_CBGAIN_MASK;	\
+	REG_TVE_CBCRCFG |= (n) << TVE_CBCRCFG_CBGAIN_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_cr_gain_amp(n) \
+do {   \
+	REG_TVE_CBCRCFG &= ~TVE_CBCRCFG_CRGAIN_MASK;	\
+	REG_TVE_CBCRCFG |= (n) << TVE_CBCRCFG_CRGAIN_BIT;	\
+} while(0)
+
+/* TV Encoder Wide Screen Signal Control register ops */
+/* n = 0 ~ 7 */
+#define __tve_set_notch_freq(n) \
+do {   \
+	REG_TVE_WSSCR &= ~TVE_WSSCR_NCHFREQ_MASK;	\
+	REG_TVE_WSSCR |= (n) << TVE_WSSCR_NCHFREQ_BIT;	\
+} while(0)
+/* n = 0 ~ 7 */
+#define __tve_set_notch_width()	(REG_TVE_WSSCR |= TVE_WSSCR_NCHW_BIT)
+#define __tve_clear_notch_width()	(REG_TVE_WSSCR &= ~TVE_WSSCR_NCHW_BIT)
+#define __tve_enable_notch()		(REG_TVE_WSSCR |= TVE_WSSCR_ENCH_BIT)
+#define __tve_disable_notch()		(REG_TVE_WSSCR &= ~TVE_WSSCR_ENCH_BIT)
+/* n = 0 ~ 7 */
+#define __tve_set_wss_edge(n) \
+do {   \
+	REG_TVE_WSSCR &= ~TVE_WSSCR_WSSEDGE_MASK;	\
+	REG_TVE_WSSCR |= (n) << TVE_WSSCR_WSSEDGE_BIT;	\
+} while(0)
+#define __tve_set_wss_clkbyp()		(REG_TVE_WSSCR |= TVE_WSSCR_WSSCKBP_BIT)
+#define __tve_set_wss_type()		(REG_TVE_WSSCR |= TVE_WSSCR_WSSTP_BIT)
+#define __tve_enable_wssf1()		(REG_TVE_WSSCR |= TVE_WSSCR_EWSS1_BIT)
+#define __tve_enable_wssf0()		(REG_TVE_WSSCR |= TVE_WSSCR_EWSS0_BIT)
+
+/* TV Encoder Wide Screen Signal Configure register 1, 2 and 3 ops */
+/* n = 0 ~ 1023 */
+#define __tve_set_wss_level(n) \
+do {   \
+	REG_TVE_WSSCFG1 &= ~TVE_WSSCFG1_WSSL_MASK;	\
+	REG_TVE_WSSCFG1 |= (n) << TVE_WSSCFG1_WSSL_BIT;	\
+} while(0)
+/* n = 0 ~ 4095 */
+#define __tve_set_wss_freq(n) \
+do {   \
+	REG_TVE_WSSCFG1 &= ~TVE_WSSCFG1_WSSFREQ_MASK;	\
+	REG_TVE_WSSCFG1 |= (n) << TVE_WSSCFG1_WSSFREQ_BIT;	\
+} while(0)
+/* n = 0, 1; l = 0 ~ 255 */
+#define __tve_set_wss_line(n,v)			\
+do {   \
+	REG_TVE_WSSCFG##n &= ~TVE_WSSCFG_WSSLINE_MASK;	\
+	REG_TVE_WSSCFG##n |= (v) << TVE_WSSCFG_WSSLINE_BIT;	\
+} while(0)
+/* n = 0, 1; d = 0 ~ (2^20-1) */
+#define __tve_set_wss_data(n, v)			\
+do {   \
+	REG_TVE_WSSCFG##n &= ~TVE_WSSCFG_WSSLINE_MASK;	\
+	REG_TVE_WSSCFG##n |= (v) << TVE_WSSCFG_WSSLINE_BIT;	\
+} while(0)
+
+/***************************************************************************
+ * RTC ops
+ ***************************************************************************/
+
+#define __rtc_write_ready()  ( (REG_RTC_RCR & RTC_RCR_WRDY) >> RTC_RCR_WRDY_BIT )
+#define __rtc_enabled()        ( REG_RTC_RCR |= RTC_RCR_RTCE )
+#define __rtc_disabled()         ( REG_RTC_RCR &= ~RTC_RCR_RTCE )
+#define __rtc_enable_alarm()         ( REG_RTC_RCR |= RTC_RCR_AE )
+#define __rtc_disable_alarm()         ( REG_RTC_RCR &= ~RTC_RCR_AE )
+#define __rtc_enable_alarm_irq()         ( REG_RTC_RCR |= RTC_RCR_AIE )
+#define __rtc_disable_alarm_irq()         ( REG_RTC_RCR &= ~RTC_RCR_AIE )
+#define __rtc_enable_1Hz_irq()         ( REG_RTC_RCR |= RTC_RCR_1HZIE )
+#define __rtc_disable_1Hz_irq()         ( REG_RTC_RCR &= ~RTC_RCR_1HZIE )
+
+#define __rtc_get_1Hz_flag()           ( (REG_RTC_RCR >> RTC_RCR_1HZ_BIT) & 0x1 )
+#define __rtc_clear_1Hz_flag()           ( REG_RTC_RCR &= ~RTC_RCR_1HZ )
+#define __rtc_get_alarm_flag()           ( (REG_RTC_RCR >> RTC_RCR_AF_BIT) & 0x1 )
+#define __rtc_clear_alarm_flag()           ( REG_RTC_RCR &= ~RTC_RCR_AF )
+
+#define __rtc_get_second()   ( REG_RTC_RSR )
+#define __rtc_set_second(v)   ( REG_RTC_RSR = v )
+
+#define __rtc_get_alarm_second()   ( REG_RTC_RSAR )
+#define __rtc_set_alarm_second(v)   ( REG_RTC_RSAR = v )
+
+#define __rtc_RGR_is_locked()       ( (REG_RTC_RGR >> RTC_RGR_LOCK) )
+#define __rtc_lock_RGR()       ( REG_RTC_RGR |= RTC_RGR_LOCK )
+#define __rtc_unlock_RGR()       ( REG_RTC_RGR &= ~RTC_RGR_LOCK )
+#define __rtc_get_adjc_val()       ( (REG_RTC_RGR & RTC_RGR_ADJC_MASK) >> RTC_RGR_ADJC_BIT )
+#define __rtc_set_adjc_val(v)      \
+       ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_ADJC_MASK) | (v << RTC_RGR_ADJC_BIT) ))
+#define __rtc_get_nc1Hz_val()       ( (REG_RTC_RGR & RTC_RGR_NC1HZ_MASK) >> RTC_RGR_NC1HZ_BIT )
+#define __rtc_set_nc1Hz_val(v)      \
+       ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_NC1HZ_MASK) | (v << RTC_RGR_NC1HZ_BIT) ))
+
+#define __rtc_power_down()            ( REG_RTC_HCR |= RTC_HCR_PD )
+
+#define __rtc_get_hwfcr_val()         ( REG_RTC_HWFCR & RTC_HWFCR_MASK )
+#define __rtc_set_hwfcr_val(v)         ( REG_RTC_HWFCR = (v) & RTC_HWFCR_MASK )
+#define __rtc_get_hrcr_val()         ( REG_RTC_HRCR & RTC_HRCR_MASK )
+#define __rtc_set_hrcr_val(v)         ( REG_RTC_HRCR = (v) & RTC_HRCR_MASK )
+
+#define __rtc_enable_alarm_wakeup()        ( REG_RTC_HWCR |= RTC_HWCR_EALM )
+#define __rtc_disable_alarm_wakeup()        ( REG_RTC_HWCR &= ~RTC_HWCR_EALM )
+
+#define __rtc_status_hib_reset_occur()        ( (REG_RTC_HWRSR >> RTC_HWRSR_HR) & 0x1 )
+#define __rtc_status_ppr_reset_occur()        ( (REG_RTC_HWRSR >> RTC_HWRSR_PPR) & 0x1 )
+#define __rtc_status_wakeup_pin_waken_up()    ( (REG_RTC_HWRSR >> RTC_HWRSR_PIN) & 0x1 )
+#define __rtc_status_alarm_waken_up()        ( (REG_RTC_HWRSR >> RTC_HWRSR_ALM) & 0x1 )
+#define __rtc_clear_hib_stat_all()               ( REG_RTC_HWRSR = 0 )
+
+#define __rtc_get_scratch_pattern() 		(REG_RTC_HSPR)
+#define __rtc_set_scratch_pattern(n) 		(REG_RTC_HSPR = n )
+
+/*************************************************************************
+ * BCH
+ *************************************************************************/
+#define __ecc_encoding_4bit()                                   \
+do {				   		        	\
+	REG_BCH_CRS = BCH_CR_ENCE | BCH_CR_BRST | BCH_CR_BCHE;  \
+	REG_BCH_CRC = BCH_CR_BSEL8;				\
+} while(0)
+#define __ecc_decoding_4bit()                           \
+do {                                                    \
+	REG_BCH_CRS = BCH_CR_BRST | BCH_CR_BCHE;	\
+	REG_BCH_CRC = BCH_CR_ENCE | BCH_CR_BSEL8;	\
+} while(0)
+#define __ecc_encoding_8bit()                                                   \
+do {				   		                        	\
+	REG_BCH_CRS = BCH_CR_ENCE | BCH_CR_BRST | BCH_CR_BSEL8 | BCH_CR_BCHE;   \
+} while(0)
+#define __ecc_decoding_8bit()                                        \
+do {                                                                 \
+	REG_BCH_CRS = BCH_CR_BRST | BCH_CR_BSEL8 | BCH_CR_BCHE;	     \
+	REG_BCH_CRC = BCH_CR_ENCE;	                             \
+} while(0)
+#define __ecc_dma_enable()        ( REG_BCH_CRS = BCH_CR_DMAE )
+#define __ecc_disable()           ( REG_BCH_CRC = BCH_CR_BCHE )
+#define __ecc_encode_sync()       while (!(REG_BCH_INTS & BCH_INTS_ENCF))
+#define __ecc_decode_sync()       while (!(REG_BCH_INTS & BCH_INTS_DECF))
+#define __ecc_cnt_dec(n)                                             \
+do {                                                                 \
+        REG_BCH_CNT &= ~(BCH_CNT_DEC_MASK << BCH_CNT_DEC_BIT);       \
+        REG_BCH_CNT = (n) << BCH_CNT_DEC_BIT;                        \
+} while(0)
+#define __ecc_cnt_enc(n)                                             \
+do {                                                                 \
+        REG_BCH_CNT &= ~(BCH_CNT_ENC_MASK << BCH_CNT_ENC_BIT);       \
+        REG_BCH_CNT = (n) << BCH_CNT_ENC_BIT;                        \
+} while(0)
+
+/***************************************************************************
+ * OWI (one-wire bus)  ops
+ ***************************************************************************/
+
+/* OW control register ops */
+#define __owi_enable_all_interrupts()      ( REG_OWI_CTL = (OWI_CTL_EBYTE | OWI_CTL_EBIT | OWI_CTL_ERST) )
+#define __owi_disable_all_interrupts()     ( REG_OWI_CTL = 0 )
+
+#define __owi_enable_byte_interrupt()      ( REG_OWI_CTL |= OWI_CTL_EBYTE )
+#define __owi_disable_byte_interrupt()     ( REG_OWI_CTL &= ~OWI_CTL_EBYTE )
+#define __owi_enable_bit_interrupt()       ( REG_OWI_CTL |= OWI_CTL_EBIT )
+#define __owi_disable_bit_interrupt()      ( REG_OWI_CTL &= ~OWI_CTL_EBIT )
+#define __owi_enable_rst_interrupt()       ( REG_OWI_CTL |= OWI_CTL_ERST ) 
+#define __owi_disable_rst_interrupt()      ( REG_OWI_CTL &=~OWI_CTL_ERST )
+
+/* OW configure register ops */
+#define __owi_select_regular_mode()        ( REG_OWI_CFG &= ~OWI_CFG_MODE )
+#define __owi_select_overdrive_mode()      ( REG_OWI_CFG |= OWI_CFG_MODE )
+
+#define __owi_set_rddata()  ( REG_OWI_CFG |= OWI_CFG_RDDATA )
+#define __owi_clr_rddata()  ( REG_OWI_CFG &= ~OWI_CFG_RDDATA )
+#define __owi_get_rddata()  ( REG_OWI_CFG & OWI_CFG_RDDATA )
+
+#define __owi_set_wrdata()  ( REG_OWI_CFG |= OWI_CFG_WRDATA )
+#define __owi_clr_wrdata()  ( REG_OWI_CFG &= ~OWI_CFG_WRDATA )
+#define __owi_get_wrdata()  ( REG_OWI_CFG & OWI_CFG_WRDATA )
+
+#define __owi_get_rdst()    ( REG_OWI_CFG & OWI_CFG_RDST )
+
+#define __owi_set_wr1rd()   ( REG_OWI_CFG |= OWI_CFG_WR1RD )
+#define __owi_clr_wr1rd()   ( REG_OWI_CFG &= ~OWI_CFG_WR1RD )
+#define __owi_get_wr1rd()   ( REG_OWI_CFG & OWI_CFG_WR1RD )
+
+#define __owi_set_wr0()     ( REG_OWI_CFG |= OWI_CFG_WR0 )
+#define __owi_clr_wr0()     ( REG_OWI_CFG &= ~OWI_CFG_WR0 )
+#define __owi_get_wr0()     ( REG_OWI_CFG & OWI_CFG_WR0 )
+
+#define __owi_set_rst()     ( REG_OWI_CFG |= OWI_CFG_RST )
+#define __owi_clr_rst()     ( REG_OWI_CFG &= ~OWI_CFG_RST )
+#define __owi_get_rst()     ( REG_OWI_CFG & OWI_CFG_RST )
+
+#define __owi_enable_ow_ops()  ( REG_OWI_CFG |= OWI_CFG_ENA )
+#define __owi_disable_ow_ops() ( REG_OWI_CFG &= ~OWI_CFG_ENA )
+#define __owi_get_enable()     ( REG_OWI_CFG & OWI_CFG_ENA )
+
+#define __owi_wait_ops_rdy()                \
+	do {				    \
+		while(__owi_get_enable());  \
+		udelay(1);		    \
+	} while(0);
+
+/* OW status register ops */
+#define __owi_clr_sts()           ( REG_OWI_STS = 0 )
+#define __owi_get_sts_pst()       ( REG_OWI_STS & OWI_STS_PST )
+#define __owi_get_sts_byte_rdy()  ( REG_OWI_STS & OWI_STS_BYTE_RDY )
+#define __owi_get_sts_bit_rdy()   ( REG_OWI_STS & OWI_STS_BIT_RDY )
+#define __owi_get_sts_pst_rdy()   ( REG_OWI_STS & OWI_STS_PST_RDY )
+
+/*************************************************************************
+ * TSSI MPEG 2-TS slave interface operation
+ *************************************************************************/
+#define __tssi_enable()                       ( REG_TSSI_ENA |= TSSI_ENA_ENA )
+#define __tssi_disable()                      ( REG_TSSI_ENA &= ~TSSI_ENA_ENA )
+#define __tssi_soft_reset()                   ( REG_TSSI_ENA |= TSSI_ENA_SFT_RST )
+#define __tssi_dma_enable()                   ( REG_TSSI_ENA |= TSSI_ENA_DMA_EN )
+#define __tssi_dma_disable()                  ( REG_TSSI_ENA &= ~TSSI_ENA_DMA_EN )
+#define __tssi_filter_enable()                ( REG_TSSI_ENA |= TSSI_ENA_PID_EN )
+#define __tssi_filter_disable()               ( REG_TSSI_ENA &= ~TSSI_ENA_PID_EN )
+
+/* n = 4, 8, 16 */
+#define __tssi_set_tigger_num(n)			\
+	do {						\
+		REG_TSSI_CFG &= ~TSSI_CFG_TRIG_MASK;	\
+		REG_TSSI_CFG |= TSSI_CFG_TRIG_##n;	\
+	} while (0)
+
+#define __tssi_set_wd_1()                     ( REG_TSSI_CFG |= TSSI_CFG_END_WD )
+#define __tssi_set_wd_0()                     ( REG_TSSI_CFG &= ~TSSI_CFG_END_WD )
+
+#define __tssi_set_bt_1()                     ( REG_TSSI_CFG |= TSSI_CFG_END_BD )
+#define __tssi_set_bt_0()                     ( REG_TSSI_CFG &= ~TSSI_CFG_END_BD )
+
+#define __tssi_set_data_pola_high()           ( REG_TSSI_CFG |= TSSI_CFG_TSDI_H )
+#define __tssi_set_data_pola_low()            ( REG_TSSI_CFG &= ~TSSI_CFG_TSDI_H )
+
+#define __tssi_set_data_use_data0()           ( REG_TSSI_CFG |= TSSI_CFG_USE_0 )
+#define __tssi_set_data_use_data7()           ( REG_TSSI_CFG &= ~TSSI_CFG_USE_0 )
+
+#define __tssi_select_clk_fast()              ( REG_TSSI_CFG &= ~TSSI_CFG_TSCLK_CH )
+#define __tssi_select_clk_slow()              ( REG_TSSI_CFG |= TSSI_CFG_TSCLK_CH )
+
+#define __tssi_select_serail_mode()           ( REG_TSSI_CFG &= ~TSSI_CFG_PARAL )
+#define __tssi_select_paral_mode()            ( REG_TSSI_CFG |= TSSI_CFG_PARAL )
+
+#define __tssi_select_clk_nega_edge()         ( REG_TSSI_CFG &= ~TSSI_CFG_TSCLK_P )
+#define __tssi_select_clk_posi_edge()         ( REG_TSSI_CFG |= TSSI_CFG_TSCLK_P )
+
+#define __tssi_select_frm_act_high()          ( REG_TSSI_CFG |= TSSI_CFG_TSFRM_H )
+#define __tssi_select_frm_act_low()           ( REG_TSSI_CFG &= ~TSSI_CFG_TSFRM_H )
+
+#define __tssi_select_str_act_high()          ( REG_TSSI_CFG |= TSSI_CFG_TSSTR_H )
+#define __tssi_select_str_act_low()           ( REG_TSSI_CFG &= ~TSSI_CFG_TSSTR_H )
+
+#define __tssi_select_fail_act_high()         ( REG_TSSI_CFG |= TSSI_CFG_TSFAIL_H )
+#define __tssi_select_fail_act_low()          ( REG_TSSI_CFG &= ~TSSI_CFG_TSFAIL_H )
+
+#define __tssi_enable_ovrn_irq()              ( REG_TSSI_CTRL &= ~TSSI_CTRL_OVRNM )
+#define __tssi_disable_ovrn_irq()             ( REG_TSSI_CTRL |= TSSI_CTRL_OVRNM )
+
+#define __tssi_enable_trig_irq()              ( REG_TSSI_CTRL &= ~TSSI_CTRL_TRIGM )
+#define __tssi_disable_trig_irq()             ( REG_TSSI_CTRL |= TSSI_CTRL_TRIGM ) 
+
+#define __tssi_state_is_overrun()             ( REG_TSSI_STAT & TSSI_STAT_OVRN )
+#define __tssi_state_trigger_meet()           ( REG_TSSI_STAT & TSSI_STAT_TRIG )
+#define __tssi_clear_state()                  ( REG_TSSI_STAT = 0 ) /* write 0??? */
+#define __tssi_state_clear_overrun()          ( REG_TSSI_STAT = TSSI_STAT_OVRN )
+
+#define __tssi_enable_filte_pid0()            ( REG_TSSI_PEN |= TSSI_PEN_PID0 )
+#define __tssi_disable_filte_pid0()           ( REG_TSSI_PEN &= ~TSSI_PEN_PID0 )
+
+/* m = 0, ..., 15 */
+#define __tssi_enable_pid_filter(m)				\
+	do {							\
+		int n = (m);					\
+		if ( n>=0 && n <(TSSI_PID_MAX*2) ) {		\
+			if ( n >= TSSI_PID_MAX ) n += 8;	\
+			REG_TSSI_PEN |= ( 1 << n );		\
+		}						\
+	} while (0)
+
+/* m = 0, ..., 15 */
+#define __tssi_disable_pid_filter(m)				       \
+	do {							       \
+		int n = (m);					       \
+		if ( n>=0 && n <(TSSI_PID_MAX*2) ) {		       \
+			if ( n >= TSSI_PID_MAX ) n += 8;	       \
+			REG_TSSI_PEN &= ~( 1 << n );		       \
+		}						       \
+	} while (0)
+
+/* n = 0, ..., 7 */
+#define __tssi_set_pid0(n, pid0)					\
+	do {								\
+		REG_TSSI_PID(n) &= ~TSSI_PID_PID0_MASK;			\
+		REG_TSSI_PID(n) |= ((pid0)<<TSSI_PID_PID0_BIT)&TSSI_PID_PID0_MASK; \
+	}while (0)
+/* n = 0, ..., 7 */
+#define __tssi_set_pid1(n, pid1)					\
+	do {								\
+		REG_TSSI_PID(n) &= ~TSSI_PID_PID1_MASK;			\
+		REG_TSSI_PID(n) |= ((pid1)<<TSSI_PID_PID1_BIT)&TSSI_PID_PID1_MASK; \
+	}while (0)
+
+/* n = 0, ..., 15 */
+#define __tssi_set_pid(n, pid)						\
+	do {								\
+		if ( n>=0 && n < TSSI_PID_MAX*2) {			\
+			if ( n < TSSI_PID_MAX )				\
+				__tssi_set_pid0(n, pid);		\
+			else						\
+				__tssi_set_pid1(n-TSSI_PID_MAX, pid);	\
+		}							\
+	}while (0)
+
+
+#if 0
+/*************************************************************************
+ * IPU (Image Processing Unit)
+ *************************************************************************/
+#define u32 volatile unsigned long
+
+#define write_reg(reg, val)	\
+do {				\
+	*(u32 *)(reg) = (val);	\
+} while(0)
+
+#define read_reg(reg, off)	(*(u32 *)((reg)+(off)))
+
+
+#define set_ipu_fmt(rgb_888_out_fmt, rgb_out_oft, out_fmt, yuv_pkg_out, in_oft, in_fmt ) \
+({ write_reg( (IPU_V_BASE + REG_D_FMT), ((in_fmt) & IN_FMT_MSK)<<IN_FMT_SFT \
+| ((in_oft) & IN_OFT_MSK)<< IN_OFT_SFT \
+| ((out_fmt) & OUT_FMT_MSK)<<OUT_FMT_SFT \
+| ((yuv_pkg_out) & YUV_PKG_OUT_MSK ) << YUV_PKG_OUT_SFT \
+| ((rgb_888_out_fmt) & RGB888_FMT_MSK ) << RGB888_FMT_SFT \
+| ((rgb_out_oft) & RGB_OUT_OFT_MSK ) << RGB_OUT_OFT_SFT); \
+})
+#define set_y_addr(y_addr) \
+({ write_reg( (IPU_V_BASE + REG_Y_ADDR), y_addr); \
+})
+#define set_u_addr(u_addr) \
+({ write_reg( (IPU_V_BASE + REG_U_ADDR), u_addr); \
+})
+
+#define set_v_addr(v_addr) \
+({ write_reg( (IPU_V_BASE + REG_V_ADDR), v_addr); \
+})
+
+#define set_y_phy_t_addr(y_phy_t_addr) \
+({ write_reg( (IPU_V_BASE + REG_Y_PHY_T_ADDR), y_phy_t_addr); \
+})
+
+#define set_u_phy_t_addr(u_phy_t_addr) \
+({ write_reg( (IPU_V_BASE + REG_U_PHY_T_ADDR), u_phy_t_addr); \
+})
+
+#define set_v_phy_t_addr(v_phy_t_addr) \
+({ write_reg( (IPU_V_BASE + REG_V_PHY_T_ADDR), v_phy_t_addr); \
+})
+
+#define set_out_phy_t_addr(out_phy_t_addr) \
+({ write_reg( (IPU_V_BASE + REG_OUT_PHY_T_ADDR), out_phy_t_addr); \
+})
+
+#define set_inframe_gsize(width, height, y_stride, u_stride, v_stride) \
+({ write_reg( (IPU_V_BASE + REG_IN_FM_GS), ((width) & IN_FM_W_MSK)<<IN_FM_W_SFT \
+| ((height) & IN_FM_H_MSK)<<IN_FM_H_SFT); \
+ write_reg( (IPU_V_BASE + REG_Y_STRIDE), ((y_stride) & Y_S_MSK)<<Y_S_SFT); \
+ write_reg( (IPU_V_BASE + REG_UV_STRIDE), ((u_stride) & U_S_MSK)<<U_S_SFT \
+| ((v_stride) & V_S_MSK)<<V_S_SFT); \
+})
+#define set_out_addr(out_addr) \
+({ write_reg( (IPU_V_BASE + REG_OUT_ADDR), out_addr); \
+})
+#define set_outframe_gsize(width, height, o_stride) \
+({ write_reg( (IPU_V_BASE + REG_OUT_GS), ((width) & OUT_FM_W_MSK)<<OUT_FM_W_SFT \
+| ((height) & OUT_FM_H_MSK)<<OUT_FM_H_SFT); \
+ write_reg( (IPU_V_BASE + REG_OUT_STRIDE), ((o_stride) & OUT_S_MSK)<<OUT_S_SFT); \
+})
+#define set_rsz_lut_end(h_end, v_end) \
+({ write_reg( (IPU_V_BASE + REG_RSZ_COEF_INDEX), ((h_end) & HE_IDX_MSK)<<HE_IDX_SFT \
+| ((v_end) & VE_IDX_MSK)<<VE_IDX_SFT); \
+})
+#define set_csc_c0(c0_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_CO_COEF), ((c0_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_csc_c1(c1_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_C1_COEF), ((c1_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_csc_c2(c2_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_C2_COEF), ((c2_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_csc_c3(c3_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_C3_COEF), ((c3_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_csc_c4(c4_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_C4_COEF), ((c4_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_hrsz_lut_coef(coef, in_n, out_n) \
+({ write_reg( (IPU_V_BASE + HRSZ_LUT_BASE ), ((coef) & W_COEF_MSK)<<W_COEF_SFT \
+| ((in_n) & IN_N_MSK)<<IN_N_SFT | ((out_n) & OUT_N_MSK)<<OUT_N_SFT); \
+})
+#define set_vrsz_lut_coef(coef, in_n, out_n) \
+({ write_reg( (IPU_V_BASE + VRSZ_LUT_BASE), ((coef) & W_COEF_MSK)<<W_COEF_SFT \
+| ((in_n) & IN_N_MSK)<<IN_N_SFT | ((out_n) & OUT_N_MSK)<<OUT_N_SFT); \
+})
+
+#define set_primary_ctrl(vrsz_en, hrsz_en,csc_en, irq_en) \
+({ write_reg( (IPU_V_BASE + REG_CTRL), ((irq_en) & FM_IRQ_EN_MSK)<<FM_IRQ_EN_SFT \
+| ((vrsz_en) & VRSZ_EN_MSK)<<VRSZ_EN_SFT \
+| ((hrsz_en) & HRSZ_EN_MSK)<<HRSZ_EN_SFT \
+| ((csc_en) & CSC_EN_MSK)<<CSC_EN_SFT \
+| (read_reg(IPU_V_BASE, REG_CTRL)) \
+& ~(CSC_EN_MSK<<CSC_EN_SFT | FM_IRQ_EN_MSK<<FM_IRQ_EN_SFT | VRSZ_EN_MSK<<VRSZ_EN_SFT | HRSZ_EN_MSK<<HRSZ_EN_SFT ) ); \
+})
+
+#define set_source_ctrl(pkg_sel, spage_sel) \
+({ write_reg( (IPU_V_BASE + REG_CTRL), ((pkg_sel) & PKG_SEL_MSK  )<< PKG_SEL_SFT \
+| ((spage_sel) & SPAGE_MAP_MSK )<< SPAGE_MAP_SFT \
+| (read_reg(IPU_V_BASE, REG_CTRL)) \
+& ~(SPAGE_MAP_MSK << SPAGE_MAP_SFT | PKG_SEL_MSK << PKG_SEL_SFT ) ) ; \
+})
+
+#define set_out_ctrl(lcdc_sel, dpage_sel, disp_sel) \
+({ write_reg( (IPU_V_BASE + REG_CTRL), ((lcdc_sel) & LCDC_SEL_MSK  )<< LCDC_SEL_SFT \
+| ((dpage_sel) & DPAGE_SEL_MSK )<< DPAGE_SEL_SFT \
+| ((disp_sel) & DISP_SEL_MSK )<< DISP_SEL_SFT \
+| (read_reg(IPU_V_BASE, REG_CTRL)) \
+& ~(LCDC_SEL_MSK<< LCDC_SEL_SFT | DPAGE_SEL_MSK << DPAGE_SEL_SFT | DISP_SEL_MSK << DISP_SEL_SFT ) ); \
+})
+
+#define set_scale_ctrl(v_scal, h_scal) \
+({ write_reg( (IPU_V_BASE + REG_CTRL), ((v_scal) & V_SCALE_MSK)<<V_SCALE_SFT \
+| ((h_scal) & H_SCALE_MSK)<<H_SCALE_SFT \
+| (read_reg(IPU_V_BASE, REG_CTRL)) & ~(V_SCALE_MSK<<V_SCALE_SFT | H_SCALE_MSK<<H_SCALE_SFT ) ); \
+})
+
+
+#define set_csc_ofset_para(chrom_oft, luma_oft) \
+({ write_reg( (IPU_V_BASE + REG_CSC_OFSET_PARA ), ((chrom_oft) & CHROM_OF_MSK ) << CHROM_OF_SFT \
+| ((luma_oft) & LUMA_OF_MSK ) << LUMA_OF_SFT ) ; \
+})
+
+#define sw_reset_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) \
+| IPU_RST_MSK<<IPU_RST_SFT); \
+})
+#define enable_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) | 0x1); \
+})
+#define disable_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) & ~0x1); \
+})
+#define run_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) | 0x2); \
+})
+#define stop_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) & ~0x2); \
+})
+
+#define polling_end_flag() \
+({ (read_reg(IPU_V_BASE, REG_STATUS)) & 0x01; \
+})
+
+#define start_vlut_coef_write() \
+({ write_reg( (IPU_V_BASE + VRSZ_LUT_BASE), ( 0x1<<12 ) ); \
+})
+
+#define start_hlut_coef_write() \
+({ write_reg( (IPU_V_BASE + HRSZ_LUT_BASE), ( 0x01<<12 ) ); \
+})
+
+#define clear_end_flag() \
+({ write_reg( (IPU_V_BASE + REG_STATUS), 0); \
+})
+#endif /* #if 0 */
+
+
+#endif /* __JZ4750_OPS_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750/regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750/regs.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,3411 @@
+/*
+ * linux/include/asm-mips/mach-jz4750/regs.h
+ *
+ * JZ4750 register definition.
+ *
+ * Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __JZ4750_REGS_H__
+#define __JZ4750_REGS_H__
+
+#if defined(__ASSEMBLY__) || defined(__LANGUAGE_ASSEMBLY)
+#define REG8(addr)	(addr)
+#define REG16(addr)	(addr)
+#define REG32(addr)	(addr)
+#else
+#define REG8(addr)	*((volatile unsigned char *)(addr))
+#define REG16(addr)	*((volatile unsigned short *)(addr))
+#define REG32(addr)	*((volatile unsigned int *)(addr))
+#endif
+
+/*
+ * Define the module base addresses
+ */
+#define	CPM_BASE	0xB0000000
+#define	INTC_BASE	0xB0001000
+#define	TCU_BASE	0xB0002000
+#define	WDT_BASE	0xB0002000
+#define	RTC_BASE	0xB0003000
+#define	GPIO_BASE	0xB0010000
+#define	AIC_BASE	0xB0020000
+#define	ICDC_BASE	0xB0020000
+#define	MSC_BASE	0xB0021000
+#define	UART0_BASE	0xB0030000
+#define	UART1_BASE	0xB0031000
+#define	UART2_BASE	0xB0032000
+#define	UART3_BASE	0xB0033000
+#define	I2C_BASE	0xB0042000
+#define	SSI_BASE	0xB0043000
+#define	SADC_BASE	0xB0070000
+#define PCM_BASE        0xB0071000
+#define	EMC_BASE	0xB3010000
+#define	DMAC_BASE	0xB3020000
+#define	UHC_BASE	0xB3030000
+#define	UDC_BASE	0xB3040000
+#define	LCD_BASE	0xB3050000
+#define	SLCD_BASE	0xB3050000
+#define	TVE_BASE	0xB3050100
+#define	CIM_BASE	0xB3060000
+#define IPU_BASE	0xB3080000
+#define ME_BASE		0xB3090000
+#define MC_BASE		0xB30A0000
+#define BCH_BASE	0xB30D0000
+#define	ETH_BASE	0xB3100000
+#define	TCSM_BASE	0xF4000000
+#define OWI_BASE	0XB0072000
+#define OTP_BASE	0xB3012000
+#define TSSI_BASE	0xB0073000
+
+/*************************************************************************
+ * INTC (Interrupt Controller)
+ *************************************************************************/
+#define INTC_ISR	(INTC_BASE + 0x00)
+#define INTC_IMR	(INTC_BASE + 0x04)
+#define INTC_IMSR	(INTC_BASE + 0x08)
+#define INTC_IMCR	(INTC_BASE + 0x0c)
+#define INTC_IPR	(INTC_BASE + 0x10)
+
+#define REG_INTC_ISR	REG32(INTC_ISR)
+#define REG_INTC_IMR	REG32(INTC_IMR)
+#define REG_INTC_IMSR	REG32(INTC_IMSR)
+#define REG_INTC_IMCR	REG32(INTC_IMCR)
+#define REG_INTC_IPR	REG32(INTC_IPR)
+
+// 1st-level interrupts
+#define IRQ_OWI		0
+#define IRQ_I2C		1
+#define IRQ_TSSI	2
+#define IRQ_UART3	3
+#define IRQ_UART2	4
+#define IRQ_UART1	5
+#define IRQ_UART0	6
+#define IRQ_PCM		7
+#define IRQ_AIC		8
+#define IRQ_RTC		9
+#define IRQ_ETH		9
+#define IRQ_SADC	10
+#define IRQ_SSI1	11
+#define IRQ_SSI0	12
+#define IRQ_MSC1	13
+#define IRQ_MSC0	14
+#define IRQ_DMAC1	15
+#define IRQ_BCH		16
+#define IRQ_UHC		17
+#define IRQ_CIM		18
+#define IRQ_UDC		19
+#define IRQ_DMAC0	20
+#define IRQ_TCU2	21
+#define IRQ_TCU1	22
+#define IRQ_TCU0	23
+#define IRQ_GPIO5	24
+#define IRQ_GPIO4	25
+#define IRQ_GPIO3	26
+#define IRQ_GPIO2	27
+#define IRQ_GPIO1	28
+#define IRQ_GPIO0	29
+#define IRQ_IPU		30
+#define IRQ_LCD		31
+
+// 2nd-level interrupts
+#define IRQ_DMA_0	32  /* 32 to 43 for DMAC0's 0-5  and DMAC1's 0-5 */
+#define IRQ_GPIO_0	48  /* 48 to 240 for GPIO pin 0 to 192 */
+
+#define NUM_DMA         MAX_DMA_NUM	/* 12 */
+#define NUM_GPIO        MAX_GPIO_NUM	/* GPIO NUM: 192, Jz4750 real num GPIO 178 */
+
+
+/*************************************************************************
+ * RTC
+ *************************************************************************/
+#define RTC_RCR		(RTC_BASE + 0x00) /* RTC Control Register */
+#define RTC_RSR		(RTC_BASE + 0x04) /* RTC Second Register */
+#define RTC_RSAR	(RTC_BASE + 0x08) /* RTC Second Alarm Register */
+#define RTC_RGR		(RTC_BASE + 0x0c) /* RTC Regulator Register */
+
+#define RTC_HCR		(RTC_BASE + 0x20) /* Hibernate Control Register */
+#define RTC_HWFCR	(RTC_BASE + 0x24) /* Hibernate Wakeup Filter Counter Reg */
+#define RTC_HRCR	(RTC_BASE + 0x28) /* Hibernate Reset Counter Register */
+#define RTC_HWCR	(RTC_BASE + 0x2c) /* Hibernate Wakeup Control Register */
+#define RTC_HWRSR	(RTC_BASE + 0x30) /* Hibernate Wakeup Status Register */
+#define RTC_HSPR	(RTC_BASE + 0x34) /* Hibernate Scratch Pattern Register */
+
+#define REG_RTC_RCR	REG32(RTC_RCR)
+#define REG_RTC_RSR	REG32(RTC_RSR)
+#define REG_RTC_RSAR	REG32(RTC_RSAR)
+#define REG_RTC_RGR	REG32(RTC_RGR)
+#define REG_RTC_HCR	REG32(RTC_HCR)
+#define REG_RTC_HWFCR	REG32(RTC_HWFCR)
+#define REG_RTC_HRCR	REG32(RTC_HRCR)
+#define REG_RTC_HWCR	REG32(RTC_HWCR)
+#define REG_RTC_HWRSR	REG32(RTC_HWRSR)
+#define REG_RTC_HSPR	REG32(RTC_HSPR)
+
+/* RTC Control Register */
+#define RTC_RCR_WRDY_BIT 7
+#define RTC_RCR_WRDY	(1 << 7)  /* Write Ready Flag */
+#define RTC_RCR_1HZ_BIT	6
+#define RTC_RCR_1HZ	(1 << RTC_RCR_1HZ_BIT)  /* 1Hz Flag */
+#define RTC_RCR_1HZIE	(1 << 5)  /* 1Hz Interrupt Enable */
+#define RTC_RCR_AF_BIT	4
+#define RTC_RCR_AF	(1 << RTC_RCR_AF_BIT)  /* Alarm Flag */
+#define RTC_RCR_AIE	(1 << 3)  /* Alarm Interrupt Enable */
+#define RTC_RCR_AE	(1 << 2)  /* Alarm Enable */
+#define RTC_RCR_RTCE	(1 << 0)  /* RTC Enable */
+
+/* RTC Regulator Register */
+#define RTC_RGR_LOCK		(1 << 31) /* Lock Bit */
+#define RTC_RGR_ADJC_BIT	16
+#define RTC_RGR_ADJC_MASK	(0x3ff << RTC_RGR_ADJC_BIT)
+#define RTC_RGR_NC1HZ_BIT	0
+#define RTC_RGR_NC1HZ_MASK	(0xffff << RTC_RGR_NC1HZ_BIT)
+
+/* Hibernate Control Register */
+#define RTC_HCR_PD		(1 << 0)  /* Power Down */
+
+/* Hibernate Wakeup Filter Counter Register */
+#define RTC_HWFCR_BIT		5
+#define RTC_HWFCR_MASK		(0x7ff << RTC_HWFCR_BIT)
+
+/* Hibernate Reset Counter Register */
+#define RTC_HRCR_BIT		5
+#define RTC_HRCR_MASK		(0x7f << RTC_HRCR_BIT)
+
+/* Hibernate Wakeup Control Register */
+#define RTC_HWCR_EALM		(1 << 0)  /* RTC alarm wakeup enable */
+
+/* Hibernate Wakeup Status Register */
+#define RTC_HWRSR_HR		(1 << 5)  /* Hibernate reset */
+#define RTC_HWRSR_PPR		(1 << 4)  /* PPR reset */
+#define RTC_HWRSR_PIN		(1 << 1)  /* Wakeup pin status bit */
+#define RTC_HWRSR_ALM		(1 << 0)  /* RTC alarm status bit */
+
+
+/*************************************************************************
+ * CPM (Clock reset and Power control Management)
+ *************************************************************************/
+#define CPM_CPCCR	(CPM_BASE+0x00)
+#define CPM_CPPCR	(CPM_BASE+0x10)
+#define CPM_CPPSR	(CPM_BASE+0x14) /* PLL Switch and Status Register */
+#define CPM_I2SCDR	(CPM_BASE+0x60)
+#define CPM_LPCDR	(CPM_BASE+0x64)
+#define CPM_MSCCDR(n)	(CPM_BASE+0x10*(n)+0x68) /* MSC0(n=0) or MSC1(n=1) device clock divider Register */
+#define CPM_UHCCDR	(CPM_BASE+0x6C)
+#define CPM_SSICDR	(CPM_BASE+0x74)
+#define CPM_PCMCDR	(CPM_BASE+0x7C) /* PCM device clock divider Register */
+
+#define CPM_LCR		(CPM_BASE+0x04)
+#define CPM_CLKGR	(CPM_BASE+0x20)
+#define CPM_OPCR	(CPM_BASE+0x24) /* Oscillator and Power Control Register */
+
+#define CPM_RSR		(CPM_BASE+0x08)
+
+#define REG_CPM_CPCCR   	REG32(CPM_CPCCR)
+#define REG_CPM_CPPCR    	REG32(CPM_CPPCR)
+#define REG_CPM_CPPSR	        REG32(CPM_CPPSR)
+#define REG_CPM_I2SCDR  	REG32(CPM_I2SCDR)
+#define REG_CPM_LPCDR   	REG32(CPM_LPCDR)
+#define REG_CPM_MSCCDR(n)	REG32(CPM_MSCCDR(n))
+#define REG_CPM_UHCCDR   	REG32(CPM_UHCCDR)
+#define REG_CPM_SSICDR  	REG32(CPM_SSICDR)
+#define REG_CPM_PCMCDR          REG32(CPM_PCMCDR)
+
+#define REG_CPM_LCR	REG32(CPM_LCR)
+#define REG_CPM_CLKGR	REG32(CPM_CLKGR)
+#define REG_CPM_OPCR	REG32(CPM_OPCR)
+
+#define REG_CPM_RSR	REG32(CPM_RSR)
+
+/* Clock Control Register */
+#define CPM_CPCCR_I2CS		(1 << 31)
+#define CPM_CPCCR_ECS   	(1 << 30) /* Select the between EXCLK and EXCLK/2 output */
+#define CPM_CPCCR_UCS		(1 << 29)
+#define CPM_CPCCR_UDIV_BIT	23
+#define CPM_CPCCR_UDIV_MASK	(0x3f << CPM_CPCCR_UDIV_BIT)
+#define CPM_CPCCR_CE		(1 << 22)
+#define CPM_CPCCR_PCS		(1 << 21)
+#define CPM_CPCCR_LDIV_BIT	16
+#define CPM_CPCCR_LDIV_MASK	(0x1f << CPM_CPCCR_LDIV_BIT)
+#define CPM_CPCCR_MDIV_BIT	12
+#define CPM_CPCCR_MDIV_MASK	(0x0f << CPM_CPCCR_MDIV_BIT)
+#define CPM_CPCCR_PDIV_BIT	8
+#define CPM_CPCCR_PDIV_MASK	(0x0f << CPM_CPCCR_PDIV_BIT)
+#define CPM_CPCCR_HDIV_BIT	4
+#define CPM_CPCCR_HDIV_MASK	(0x0f << CPM_CPCCR_HDIV_BIT)
+#define CPM_CPCCR_CDIV_BIT	0
+#define CPM_CPCCR_CDIV_MASK	(0x0f << CPM_CPCCR_CDIV_BIT)
+
+/* PLL Switch and Status Register */
+#define CPM_CPPSR_PLLOFF        (1<<31)
+#define CPM_CPPSR_PLLBP         (1<<30)
+#define CPM_CPPSR_PLLON         (1<<29)
+#define CPM_CPPSR_PS            (1<<28) /* Indicate whether the PLL parameters' change has finished */
+#define CPM_CPPSR_FS            (1<<27) /* Indicate whether the main clock's change has finished */
+#define CPM_CPPSR_CS            (1<<26) /* Indicate whether the clock switch has finished */
+#define CPM_CPPSR_PM            (1<<1)  /* Clock switch mode */
+#define CPM_CPPSR_FM            (1<<0)  /* Clock frequency change mode */
+
+/* I2S Clock Divider Register */
+#define CPM_I2SCDR_I2SDIV_BIT	0
+#define CPM_I2SCDR_I2SDIV_MASK	(0x1ff << CPM_I2SCDR_I2SDIV_BIT)
+
+/* LCD Pixel Clock Divider Register */
+#define CPM_LPCDR_LSCS	        (1<<31) /* TV encoder Source Pixel Clock Selection */
+#define CPM_LPCDR_LPCS	        (1<<30) /* LCD Panel pix clock Selection */
+#define CPM_LPCDR_LTCS	        (1<<29) /* LCD TV Encoder or Panel pix clock Selection */
+#define CPM_LPCDR_PIXDIV_BIT	0
+#define CPM_LPCDR_PIXDIV_MASK	(0x7ff << CPM_LPCDR_PIXDIV_BIT)
+
+/* MSC Clock Divider Register */
+#define CPM_MSCCDR_MSCDIV_BIT	0
+#define CPM_MSCCDR_MSCDIV_MASK	(0x1f << CPM_MSCCDR_MSCDIV_BIT)
+
+/* UHC Clock Divider Register */
+#define CPM_UHCCDR_UHCDIV_BIT	0
+#define CPM_UHCCDR_UHCDIV_MASK	(0xf << CPM_UHCCDR_UHCDIV_BIT)
+
+/* SSI Clock Divider Register */
+#define CPM_SSICDR_SSIDIV_BIT	0
+#define CPM_SSICDR_SSIDIV_MASK	(0xf << CPM_SSICDR_SSIDIV_BIT)
+
+/* PCM device clock divider Register */
+#define CPM_PCMCDR_PCMS         31 /* PCM source clock Selection */
+#define CPM_PCMCDR_PCMCD_BIT    0
+#define CPM_PCMCDR_PCMCD_MASK   (0x1ff << CPM_PCMCDR_PCMCD_BIT)
+
+/* PLL Control Register */
+#define CPM_CPPCR_PLLM_BIT	23
+#define CPM_CPPCR_PLLM_MASK	(0x1ff << CPM_CPPCR_PLLM_BIT)
+#define CPM_CPPCR_PLLN_BIT	18
+#define CPM_CPPCR_PLLN_MASK	(0x1f << CPM_CPPCR_PLLN_BIT)
+#define CPM_CPPCR_PLLOD_BIT	16
+#define CPM_CPPCR_PLLOD_MASK	(0x03 << CPM_CPPCR_PLLOD_BIT)
+#define CPM_CPPCR_PLLS		(1 << 10) /* obsolete, replaced by CPM_CPPSR_PLLON */
+#define CPM_CPPCR_PLLBP		(1 << 9)
+#define CPM_CPPCR_PLLEN		(1 << 8)
+#define CPM_CPPCR_PLLST_BIT	0
+#define CPM_CPPCR_PLLST_MASK	(0xff << CPM_CPPCR_PLLST_BIT)
+
+/* Low Power Control Register */
+#define CPM_LCR_DOZE_DUTY_BIT 	3
+#define CPM_LCR_DOZE_DUTY_MASK 	(0x1f << CPM_LCR_DOZE_DUTY_BIT)
+#define CPM_LCR_DOZE_ON		(1 << 2)
+#define CPM_LCR_LPM_BIT		0
+#define CPM_LCR_LPM_MASK	(0x3 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_IDLE	(0x0 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_SLEEP	(0x1 << CPM_LCR_LPM_BIT)
+
+/* Clock Gate Register */
+#define CPM_CLKGR_CIMRAM	(1 << 28)
+#define CPM_CLKGR_IDCT  	(1 << 27)
+#define CPM_CLKGR_DB    	(1 << 26)
+#define CPM_CLKGR_ME    	(1 << 25)
+#define CPM_CLKGR_MC    	(1 << 24)
+#define CPM_CLKGR_TVE    	(1 << 23)
+#define CPM_CLKGR_TSSI    	(1 << 22)
+#define CPM_CLKGR_OWI    	(1 << 21)
+#define CPM_CLKGR_PCM    	(1 << 20)
+#define CPM_CLKGR_MSC1    	(1 << 19)
+#define CPM_CLKGR_SSI0    	(1 << 18)
+#define CPM_CLKGR_UART3    	(1 << 17)
+#define CPM_CLKGR_UART2    	(1 << 16)
+#define CPM_CLKGR_UART1		(1 << 15)
+#define CPM_CLKGR_UHC		(1 << 14)
+#define CPM_CLKGR_IPU		(1 << 13)
+#define CPM_CLKGR_DMAC		(1 << 12)
+#define CPM_CLKGR_UDC		(1 << 11)
+#define CPM_CLKGR_LCD		(1 << 10)
+#define CPM_CLKGR_CIM		(1 << 9)
+#define CPM_CLKGR_SADC		(1 << 8)
+#define CPM_CLKGR_MSC0		(1 << 7)
+#define CPM_CLKGR_AIC1		(1 << 6)
+#define CPM_CLKGR_AIC2		(1 << 5)
+#define CPM_CLKGR_SSI1		(1 << 4)
+#define CPM_CLKGR_I2C		(1 << 3)
+#define CPM_CLKGR_RTC		(1 << 2)
+#define CPM_CLKGR_TCU		(1 << 1)
+#define CPM_CLKGR_UART0		(1 << 0)
+
+/* Oscillator and Power Control Register */
+#define CPM_OPCR_O1ST_BIT	8
+#define CPM_OPCR_O1ST_MASK	(0xff << CPM_SCR_O1ST_BIT)
+#define CPM_OPCR_UHCPHY_DISABLE	(1 << 7)
+#define CPM_OPCR_UDCPHY_ENABLE	(1 << 6)
+#define CPM_OPCR_OSC_ENABLE	(1 << 4)
+#define CPM_OPCR_ERCS           (1 << 2) /* EXCLK/512 clock and RTCLK clock selection */
+#define CPM_OPCR_MOSE           (1 << 1) /* Main Oscillator Enable */
+#define CPM_OPCR_MCS            (1 << 0) /* Main clock source select register */
+
+/* Reset Status Register */
+#define CPM_RSR_HR		(1 << 2)
+#define CPM_RSR_WR		(1 << 1)
+#define CPM_RSR_PR		(1 << 0)
+
+
+/*************************************************************************
+ * TCU (Timer Counter Unit)
+ *************************************************************************/
+#define TCU_TSTR	(TCU_BASE + 0xF0) /* Timer Status Register,Only Used In Tcu2 Mode */
+#define TCU_TSTSR	(TCU_BASE + 0xF4) /* Timer Status Set Register */
+#define TCU_TSTCR	(TCU_BASE + 0xF8) /* Timer Status Clear Register */
+#define TCU_TSR		(TCU_BASE + 0x1C) /* Timer Stop Register */
+#define TCU_TSSR	(TCU_BASE + 0x2C) /* Timer Stop Set Register */
+#define TCU_TSCR	(TCU_BASE + 0x3C) /* Timer Stop Clear Register */
+#define TCU_TER		(TCU_BASE + 0x10) /* Timer Counter Enable Register */
+#define TCU_TESR	(TCU_BASE + 0x14) /* Timer Counter Enable Set Register */
+#define TCU_TECR	(TCU_BASE + 0x18) /* Timer Counter Enable Clear Register */
+#define TCU_TFR		(TCU_BASE + 0x20) /* Timer Flag Register */
+#define TCU_TFSR	(TCU_BASE + 0x24) /* Timer Flag Set Register */
+#define TCU_TFCR	(TCU_BASE + 0x28) /* Timer Flag Clear Register */
+#define TCU_TMR		(TCU_BASE + 0x30) /* Timer Mask Register */
+#define TCU_TMSR	(TCU_BASE + 0x34) /* Timer Mask Set Register */
+#define TCU_TMCR	(TCU_BASE + 0x38) /* Timer Mask Clear Register */
+
+#define TCU_TDFR0	(TCU_BASE + 0x40) /* Timer Data Full Register */
+#define TCU_TDHR0	(TCU_BASE + 0x44) /* Timer Data Half Register */
+#define TCU_TCNT0	(TCU_BASE + 0x48) /* Timer Counter Register */
+#define TCU_TCSR0	(TCU_BASE + 0x4C) /* Timer Control Register */
+#define TCU_TDFR1	(TCU_BASE + 0x50)
+#define TCU_TDHR1	(TCU_BASE + 0x54)
+#define TCU_TCNT1	(TCU_BASE + 0x58)
+#define TCU_TCSR1	(TCU_BASE + 0x5C)
+#define TCU_TDFR2	(TCU_BASE + 0x60)
+#define TCU_TDHR2	(TCU_BASE + 0x64)
+#define TCU_TCNT2	(TCU_BASE + 0x68)
+#define TCU_TCSR2	(TCU_BASE + 0x6C)
+#define TCU_TDFR3	(TCU_BASE + 0x70)
+#define TCU_TDHR3	(TCU_BASE + 0x74)
+#define TCU_TCNT3	(TCU_BASE + 0x78)
+#define TCU_TCSR3	(TCU_BASE + 0x7C)
+#define TCU_TDFR4	(TCU_BASE + 0x80)
+#define TCU_TDHR4	(TCU_BASE + 0x84)
+#define TCU_TCNT4	(TCU_BASE + 0x88)
+#define TCU_TCSR4	(TCU_BASE + 0x8C)
+#define TCU_TDFR5	(TCU_BASE + 0x90)
+#define TCU_TDHR5	(TCU_BASE + 0x94)
+#define TCU_TCNT5	(TCU_BASE + 0x98)
+#define TCU_TCSR5	(TCU_BASE + 0x9C)
+
+#define REG_TCU_TSTR	REG32(TCU_TSTR)
+#define REG_TCU_TSTSR	REG32(TCU_TSTSR)
+#define REG_TCU_TSTCR	REG32(TCU_TSTCR)
+#define REG_TCU_TSR	REG32(TCU_TSR)
+#define REG_TCU_TSSR	REG32(TCU_TSSR)
+#define REG_TCU_TSCR	REG32(TCU_TSCR)
+#define REG_TCU_TER	REG16(TCU_TER)
+#define REG_TCU_TESR	REG32(TCU_TESR)
+#define REG_TCU_TECR	REG32(TCU_TECR)
+#define REG_TCU_TFR	REG32(TCU_TFR)
+#define REG_TCU_TFSR	REG32(TCU_TFSR)
+#define REG_TCU_TFCR	REG32(TCU_TFCR)
+#define REG_TCU_TMR	REG32(TCU_TMR)
+#define REG_TCU_TMSR	REG32(TCU_TMSR)
+#define REG_TCU_TMCR	REG32(TCU_TMCR)
+#define REG_TCU_TDFR0	REG16(TCU_TDFR0)
+#define REG_TCU_TDHR0	REG16(TCU_TDHR0)
+#define REG_TCU_TCNT0	REG16(TCU_TCNT0)
+#define REG_TCU_TCSR0	REG16(TCU_TCSR0)
+#define REG_TCU_TDFR1	REG16(TCU_TDFR1)
+#define REG_TCU_TDHR1	REG16(TCU_TDHR1)
+#define REG_TCU_TCNT1	REG16(TCU_TCNT1)
+#define REG_TCU_TCSR1	REG16(TCU_TCSR1)
+#define REG_TCU_TDFR2	REG16(TCU_TDFR2)
+#define REG_TCU_TDHR2	REG16(TCU_TDHR2)
+#define REG_TCU_TCNT2	REG16(TCU_TCNT2)
+#define REG_TCU_TCSR2	REG16(TCU_TCSR2)
+#define REG_TCU_TDFR3	REG16(TCU_TDFR3)
+#define REG_TCU_TDHR3	REG16(TCU_TDHR3)
+#define REG_TCU_TCNT3	REG16(TCU_TCNT3)
+#define REG_TCU_TCSR3	REG16(TCU_TCSR3)
+#define REG_TCU_TDFR4	REG16(TCU_TDFR4)
+#define REG_TCU_TDHR4	REG16(TCU_TDHR4)
+#define REG_TCU_TCNT4	REG16(TCU_TCNT4)
+#define REG_TCU_TCSR4	REG16(TCU_TCSR4)
+
+// n = 0,1,2,3,4,5
+#define TCU_TDFR(n)	(TCU_BASE + (0x40 + (n)*0x10)) /* Timer Data Full Reg */
+#define TCU_TDHR(n)	(TCU_BASE + (0x44 + (n)*0x10)) /* Timer Data Half Reg */
+#define TCU_TCNT(n)	(TCU_BASE + (0x48 + (n)*0x10)) /* Timer Counter Reg */
+#define TCU_TCSR(n)	(TCU_BASE + (0x4C + (n)*0x10)) /* Timer Control Reg */
+#define TCU_OSTDR	(TCU_BASE + 0xe0) /* Operating System Timer Data Reg */
+#define TCU_OSTCNT	(TCU_BASE + 0xe8) /* Operating System Timer Counter Reg */
+#define TCU_OSTCSR	(TCU_BASE + 0xeC) /* Operating System Timer Control Reg */
+
+#define REG_TCU_TDFR(n)	REG16(TCU_TDFR((n)))
+#define REG_TCU_TDHR(n)	REG16(TCU_TDHR((n)))
+#define REG_TCU_TCNT(n)	REG16(TCU_TCNT((n)))
+#define REG_TCU_TCSR(n)	REG16(TCU_TCSR((n)))
+#define REG_TCU_OSTDR   REG32(TCU_OSTDR)
+#define REG_TCU_OSTCNT  REG32(TCU_OSTCNT)
+#define REG_TCU_OSTCSR  REG32(TCU_OSTCSR)
+
+// Register definitions
+#define TCU_TSTR_REAL2		(1 << 18) /* only used in TCU2 mode */
+#define TCU_TSTR_REAL1		(1 << 17) /* only used in TCU2 mode */
+#define TCU_TSTR_BUSY2		(1 << 2)  /* only used in TCU2 mode */
+#define TCU_TSTR_BUSY1		(1 << 1)  /* only used in TCU2 mode */
+
+#define TCU_TSTSR_REAL2		(1 << 18)
+#define TCU_TSTSR_REAL1		(1 << 17)
+#define TCU_TSTSR_BUSY2		(1 << 2)
+#define TCU_TSTSR_BUSY1		(1 << 1)
+
+#define TCU_TSTCR_REAL2		(1 << 18)
+#define TCU_TSTCR_REAL1		(1 << 17)
+#define TCU_TSTCR_BUSY2		(1 << 2)
+#define TCU_TSTCR_BUSY1		(1 << 1)
+
+#define TCU_TSR_WDTS		(1 << 16) /*the clock supplies to wdt is stopped */
+#define TCU_TSR_OSTS		(1 << 15) /*the clock supplies to osts is stopped */
+#define TCU_TSR_STOP5		(1 << 5)  /*the clock supplies to timer5 is stopped */
+#define TCU_TSR_STOP4		(1 << 4)  /*the clock supplies to timer4 is stopped */
+#define TCU_TSR_STOP3		(1 << 3)  /*the clock supplies to timer3 is stopped */
+#define TCU_TSR_STOP2		(1 << 2)  /*the clock supplies to timer2 is stopped */
+#define TCU_TSR_STOP1		(1 << 1)  /*the clock supplies to timer1 is stopped */
+#define TCU_TSR_STOP0		(1 << 0)  /*the clock supplies to timer0 is stopped */
+
+#define TCU_TSSR_WDTSS		(1 << 16)
+#define TCU_TSSR_OSTSS		(1 << 15)
+#define TCU_TSSR_STPS5		(1 << 5)
+#define TCU_TSSR_STPS4		(1 << 4)
+#define TCU_TSSR_STPS3		(1 << 3)
+#define TCU_TSSR_STPS2		(1 << 2)
+#define TCU_TSSR_STPS1		(1 << 1)
+#define TCU_TSSR_STPS0		(1 << 0)
+
+#define TCU_TSCR_WDTSC		(1 << 16)
+#define TCU_TSCR_OSTSC		(1 << 15)
+#define TCU_TSCR_STPC5		(1 << 5)
+#define TCU_TSCR_STPC4		(1 << 4)
+#define TCU_TSCR_STPC3		(1 << 3)
+#define TCU_TSCR_STPC2		(1 << 2)
+#define TCU_TSCR_STPC1		(1 << 1)
+#define TCU_TSCR_STPC0		(1 << 0)
+
+#define TCU_TER_OSTEN		(1 << 15) /* enable the counter in ost */
+#define TCU_TER_TCEN5		(1 << 5)  /* enable the counter in timer5 */
+#define TCU_TER_TCEN4		(1 << 4)
+#define TCU_TER_TCEN3		(1 << 3)
+#define TCU_TER_TCEN2		(1 << 2)
+#define TCU_TER_TCEN1		(1 << 1)
+#define TCU_TER_TCEN0		(1 << 0)
+
+#define TCU_TESR_OSTST		(1 << 15)
+#define TCU_TESR_TCST5		(1 << 5)
+#define TCU_TESR_TCST4		(1 << 4)
+#define TCU_TESR_TCST3		(1 << 3)
+#define TCU_TESR_TCST2		(1 << 2)
+#define TCU_TESR_TCST1		(1 << 1)
+#define TCU_TESR_TCST0		(1 << 0)
+
+#define TCU_TECR_OSTCL		(1 << 15)
+#define TCU_TECR_TCCL5		(1 << 5)
+#define TCU_TECR_TCCL4		(1 << 4)
+#define TCU_TECR_TCCL3		(1 << 3)
+#define TCU_TECR_TCCL2		(1 << 2)
+#define TCU_TECR_TCCL1		(1 << 1)
+#define TCU_TECR_TCCL0		(1 << 0)
+
+#define TCU_TFR_HFLAG5		(1 << 21) /* half comparison match flag */
+#define TCU_TFR_HFLAG4		(1 << 20)
+#define TCU_TFR_HFLAG3		(1 << 19)
+#define TCU_TFR_HFLAG2		(1 << 18)
+#define TCU_TFR_HFLAG1		(1 << 17)
+#define TCU_TFR_HFLAG0		(1 << 16)
+#define TCU_TFR_OSTFLAG		(1 << 15) /* ost comparison match flag */
+#define TCU_TFR_FFLAG5		(1 << 5)  /* full comparison match flag */
+#define TCU_TFR_FFLAG4		(1 << 4)
+#define TCU_TFR_FFLAG3		(1 << 3)
+#define TCU_TFR_FFLAG2		(1 << 2)
+#define TCU_TFR_FFLAG1		(1 << 1)
+#define TCU_TFR_FFLAG0		(1 << 0)
+
+#define TCU_TFSR_HFST5		(1 << 21)
+#define TCU_TFSR_HFST4		(1 << 20)
+#define TCU_TFSR_HFST3		(1 << 19)
+#define TCU_TFSR_HFST2		(1 << 18)
+#define TCU_TFSR_HFST1		(1 << 17)
+#define TCU_TFSR_HFST0		(1 << 16)
+#define TCU_TFSR_OSTFST		(1 << 15)
+#define TCU_TFSR_FFST5		(1 << 5)
+#define TCU_TFSR_FFST4		(1 << 4)
+#define TCU_TFSR_FFST3		(1 << 3)
+#define TCU_TFSR_FFST2		(1 << 2)
+#define TCU_TFSR_FFST1		(1 << 1)
+#define TCU_TFSR_FFST0		(1 << 0)
+
+#define TCU_TFCR_HFCL5		(1 << 21)
+#define TCU_TFCR_HFCL4		(1 << 20)
+#define TCU_TFCR_HFCL3		(1 << 19)
+#define TCU_TFCR_HFCL2		(1 << 18)
+#define TCU_TFCR_HFCL1		(1 << 17)
+#define TCU_TFCR_HFCL0		(1 << 16)
+#define TCU_TFCR_OSTFCL		(1 << 15)
+#define TCU_TFCR_FFCL5		(1 << 5)
+#define TCU_TFCR_FFCL4		(1 << 4)
+#define TCU_TFCR_FFCL3		(1 << 3)
+#define TCU_TFCR_FFCL2		(1 << 2)
+#define TCU_TFCR_FFCL1		(1 << 1)
+#define TCU_TFCR_FFCL0		(1 << 0)
+
+#define TCU_TMR_HMASK5		(1 << 21) /* half comparison match interrupt mask */
+#define TCU_TMR_HMASK4		(1 << 20)
+#define TCU_TMR_HMASK3		(1 << 19)
+#define TCU_TMR_HMASK2		(1 << 18)
+#define TCU_TMR_HMASK1		(1 << 17)
+#define TCU_TMR_HMASK0		(1 << 16)
+#define TCU_TMR_OSTMASK		(1 << 15) /* ost comparison match interrupt mask */
+#define TCU_TMR_FMASK5		(1 << 5)  /* full comparison match interrupt mask */
+#define TCU_TMR_FMASK4		(1 << 4)
+#define TCU_TMR_FMASK3		(1 << 3)
+#define TCU_TMR_FMASK2		(1 << 2)
+#define TCU_TMR_FMASK1		(1 << 1)
+#define TCU_TMR_FMASK0		(1 << 0)
+
+#define TCU_TMSR_HMST5		(1 << 21)
+#define TCU_TMSR_HMST4		(1 << 20)
+#define TCU_TMSR_HMST3		(1 << 19)
+#define TCU_TMSR_HMST2		(1 << 18)
+#define TCU_TMSR_HMST1		(1 << 17)
+#define TCU_TMSR_HMST0		(1 << 16)
+#define TCU_TMSR_OSTMST		(1 << 15)
+#define TCU_TMSR_FMST5		(1 << 5)
+#define TCU_TMSR_FMST4		(1 << 4)
+#define TCU_TMSR_FMST3		(1 << 3)
+#define TCU_TMSR_FMST2		(1 << 2)
+#define TCU_TMSR_FMST1		(1 << 1)
+#define TCU_TMSR_FMST0		(1 << 0)
+
+#define TCU_TMCR_HMCL5		(1 << 21)
+#define TCU_TMCR_HMCL4		(1 << 20)
+#define TCU_TMCR_HMCL3		(1 << 19)
+#define TCU_TMCR_HMCL2		(1 << 18)
+#define TCU_TMCR_HMCL1		(1 << 17)
+#define TCU_TMCR_HMCL0		(1 << 16)
+#define TCU_TMCR_OSTMCL		(1 << 15)
+#define TCU_TMCR_FMCL5		(1 << 5)
+#define TCU_TMCR_FMCL4		(1 << 4)
+#define TCU_TMCR_FMCL3		(1 << 3)
+#define TCU_TMCR_FMCL2		(1 << 2)
+#define TCU_TMCR_FMCL1		(1 << 1)
+#define TCU_TMCR_FMCL0		(1 << 0)
+
+#define TCU_TCSR_CNT_CLRZ	(1 << 10) /* clear counter to 0, only used in TCU2 mode */
+#define TCU_TCSR_PWM_SD		(1 << 9)  /* shut down the pwm output only used in TCU1 mode */
+#define TCU_TCSR_PWM_INITL_HIGH	(1 << 8)  /* selects an initial output level for pwm output */
+#define TCU_TCSR_PWM_EN		(1 << 7)  /* pwm pin output enable */
+#define TCU_TCSR_PRESCALE_BIT	3         /* select the tcnt count clock frequency*/
+#define TCU_TCSR_PRESCALE_MASK	(0x7 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1	(0x0 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE4	(0x1 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE16	(0x2 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE64	(0x3 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE256	(0x4 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1024	(0x5 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_EXT_EN		(1 << 2)  /* select extal as the timer clock input */
+#define TCU_TCSR_RTC_EN		(1 << 1)  /* select rtcclk as the timer clock input */
+#define TCU_TCSR_PCK_EN		(1 << 0)  /* select pclk as the timer clock input */
+
+#define TCU_TSTR_REAL2		(1 << 18) /* the value read from counter 2 is a real value */
+#define TCU_TSTR_REAL1		(1 << 17)
+#define TCU_TSTR_BUSY2		(1 << 2)  /* the counter 2 is busy now */
+#define TCU_TSTR_BUSY1		(1 << 1)
+
+#define TCU_TSTSR_REALS2	(1 << 18)
+#define TCU_TSTSR_REALS1	(1 << 17)
+#define TCU_TSTSR_BUSYS2	(1 << 2)
+#define TCU_TSTSR_BUSYS1	(1 << 1)
+
+#define TCU_TSTCR_REALC2	(1 << 18)
+#define TCU_TSTCR_REALC1	(1 << 17)
+#define TCU_TSTCR_BUSYC2	(1 << 2)
+#define TCU_TSTCR_BUSYC1	(1 << 1)
+
+#define TCU_OSTCR_CNT_MD		(1 << 15) /* when the value counter is equal to compare value,the counter is go on increasing till overflow,and then icrease from 0 */
+#define TCU_OSTCR_PWM_SD		(1 << 9) /* shut down the pwm output, only used in TCU1 mode */
+#define TCU_OSTCSR_PRESCALE_BIT		3
+#define TCU_OSTCSR_PRESCALE_MASK	(0x7 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE1		(0x0 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE4		(0x1 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE16		(0x2 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE64		(0x3 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE256	(0x4 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE1024	(0x5 << TCU_OSTCSR_PRESCALE_BIT)
+#define TCU_OSTCSR_EXT_EN		(1 << 2) /* select extal as the timer clock input */
+#define TCU_OSTCSR_RTC_EN		(1 << 1) /* select rtcclk as the timer clock input */
+#define TCU_OSTCSR_PCK_EN		(1 << 0) /* select pclk as the timer clock input */
+
+/*************************************************************************
+ * WDT (WatchDog Timer)
+ *************************************************************************/
+#define WDT_TDR		(WDT_BASE + 0x00)
+#define WDT_TCER	(WDT_BASE + 0x04)
+#define WDT_TCNT	(WDT_BASE + 0x08)
+#define WDT_TCSR	(WDT_BASE + 0x0C)
+
+#define REG_WDT_TDR	REG16(WDT_TDR)
+#define REG_WDT_TCER	REG8(WDT_TCER)
+#define REG_WDT_TCNT	REG16(WDT_TCNT)
+#define REG_WDT_TCSR	REG16(WDT_TCSR)
+
+// Register definition
+#define WDT_TCSR_PRESCALE_BIT	3
+#define WDT_TCSR_PRESCALE_MASK	(0x7 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1	(0x0 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE4	(0x1 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE16	(0x2 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE64	(0x3 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE256	(0x4 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1024	(0x5 << WDT_TCSR_PRESCALE_BIT)
+#define WDT_TCSR_EXT_EN		(1 << 2)
+#define WDT_TCSR_RTC_EN		(1 << 1)
+#define WDT_TCSR_PCK_EN		(1 << 0)
+
+#define WDT_TCER_TCEN		(1 << 0)
+
+
+/*************************************************************************
+ * DMAC (DMA Controller)
+ *************************************************************************/
+
+#define MAX_DMA_NUM	12  /* max 12 channels */
+#define HALF_DMA_NUM	6   /* the number of one dma controller's channels */
+
+/* m is the DMA controller index (0, 1), n is the DMA channel index (0 - 11) */
+
+#define DMAC_DSAR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x00 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA source address */
+#define DMAC_DTAR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x04 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA target address */
+#define DMAC_DTCR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x08 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA transfer count */
+#define DMAC_DRSR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x0c + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA request source */
+#define DMAC_DCCSR(n) (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x10 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA control/status */
+#define DMAC_DCMD(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x14 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA command */
+#define DMAC_DDA(n)   (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x18 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA descriptor address */
+#define DMAC_DSD(n)   (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0xc0 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x04)) /* DMA Stride Address */
+
+#define DMAC_DMACR(m)	(DMAC_BASE + 0x0300 + 0x100 * (m))              /* DMA control register */
+#define DMAC_DMAIPR(m)	(DMAC_BASE + 0x0304 + 0x100 * (m))              /* DMA interrupt pending */
+#define DMAC_DMADBR(m)	(DMAC_BASE + 0x0308 + 0x100 * (m))              /* DMA doorbell */
+#define DMAC_DMADBSR(m)	(DMAC_BASE + 0x030C + 0x100 * (m))              /* DMA doorbell set */
+#define DMAC_DMACKE(m)  (DMAC_BASE + 0x0310 + 0x100 * (m))
+
+#define REG_DMAC_DSAR(n)	REG32(DMAC_DSAR((n)))
+#define REG_DMAC_DTAR(n)	REG32(DMAC_DTAR((n)))
+#define REG_DMAC_DTCR(n)	REG32(DMAC_DTCR((n)))
+#define REG_DMAC_DRSR(n)	REG32(DMAC_DRSR((n)))
+#define REG_DMAC_DCCSR(n)	REG32(DMAC_DCCSR((n)))
+#define REG_DMAC_DCMD(n)	REG32(DMAC_DCMD((n)))
+#define REG_DMAC_DDA(n)		REG32(DMAC_DDA((n)))
+#define REG_DMAC_DSD(n)         REG32(DMAC_DSD(n))
+#define REG_DMAC_DMACR(m)	REG32(DMAC_DMACR(m))
+#define REG_DMAC_DMAIPR(m)	REG32(DMAC_DMAIPR(m))
+#define REG_DMAC_DMADBR(m)	REG32(DMAC_DMADBR(m))
+#define REG_DMAC_DMADBSR(m)	REG32(DMAC_DMADBSR(m))
+#define REG_DMAC_DMACKE(m)      REG32(DMAC_DMACKE(m))
+
+// DMA request source register
+#define DMAC_DRSR_RS_BIT	0
+#define DMAC_DRSR_RS_MASK	(0x3f << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_EXT	(0 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_NAND	(1 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_BCH_ENC	(2 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_BCH_DEC	(3 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AUTO	(8 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_TSSIIN	(9 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3OUT	(14 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3IN	(15 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2OUT	(16 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2IN	(17 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1OUT	(18 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1IN	(19 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0OUT	(20 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0IN	(21 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI0OUT	(22 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI0IN	(23 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICOUT	(24 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICIN	(25 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC0OUT	(26 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC0IN	(27 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_TCU	(28 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SADC	(29 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC1OUT	(30 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC1IN	(31 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI1OUT	(32 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI1IN	(33 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PMOUT	(34 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PMIN	(35 << DMAC_DRSR_RS_BIT)
+
+// DMA channel control/status register
+#define DMAC_DCCSR_NDES		(1 << 31) /* descriptor (0) or not (1) ? */
+#define DMAC_DCCSR_DES8    	(1 << 30) /* Descriptor 8 Word */
+#define DMAC_DCCSR_DES4    	(0 << 30) /* Descriptor 4 Word */
+#define DMAC_DCCSR_CDOA_BIT	16        /* copy of DMA offset address */
+#define DMAC_DCCSR_CDOA_MASK	(0xff << DMAC_DCCSR_CDOA_BIT)
+#define DMAC_DCCSR_BERR		(1 << 7)  /* BCH error within this transfer, Only for channel 0 */
+#define DMAC_DCCSR_INV		(1 << 6)  /* descriptor invalid */
+#define DMAC_DCCSR_AR		(1 << 4)  /* address error */
+#define DMAC_DCCSR_TT		(1 << 3)  /* transfer terminated */
+#define DMAC_DCCSR_HLT		(1 << 2)  /* DMA halted */
+#define DMAC_DCCSR_CT		(1 << 1)  /* count terminated */
+#define DMAC_DCCSR_EN		(1 << 0)  /* channel enable bit */
+
+// DMA channel command register 
+#define DMAC_DCMD_EACKS_LOW  	(1 << 31) /* External DACK Output Level Select, active low */
+#define DMAC_DCMD_EACKS_HIGH  	(0 << 31) /* External DACK Output Level Select, active high */
+#define DMAC_DCMD_EACKM_WRITE 	(1 << 30) /* External DACK Output Mode Select, output in write cycle */
+#define DMAC_DCMD_EACKM_READ 	(0 << 30) /* External DACK Output Mode Select, output in read cycle */
+#define DMAC_DCMD_ERDM_BIT      28        /* External DREQ Detection Mode Select */
+#define DMAC_DCMD_ERDM_MASK     (0x03 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_LOW    (0 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_FALL   (1 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_HIGH   (2 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_RISE   (3 << DMAC_DCMD_ERDM_BIT)
+#define DMAC_DCMD_BLAST		(1 << 25) /* BCH last */
+#define DMAC_DCMD_SAI		(1 << 23) /* source address increment */
+#define DMAC_DCMD_DAI		(1 << 22) /* dest address increment */
+#define DMAC_DCMD_RDIL_BIT	16        /* request detection interval length */
+#define DMAC_DCMD_RDIL_MASK	(0x0f << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_IGN	(0 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_2	(1 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_4	(2 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_8	(3 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_12	(4 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_16	(5 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_20	(6 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_24	(7 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_28	(8 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_32	(9 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_48	(10 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_60	(11 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_64	(12 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_124	(13 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_128	(14 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_200	(15 << DMAC_DCMD_RDIL_BIT)
+#define DMAC_DCMD_SWDH_BIT	14  /* source port width */
+#define DMAC_DCMD_SWDH_MASK	(0x03 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_32	(0 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_8	(1 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_16	(2 << DMAC_DCMD_SWDH_BIT)
+#define DMAC_DCMD_DWDH_BIT	12  /* dest port width */
+#define DMAC_DCMD_DWDH_MASK	(0x03 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_32	(0 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_8	(1 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_16	(2 << DMAC_DCMD_DWDH_BIT)
+#define DMAC_DCMD_DS_BIT	8  /* transfer data size of a data unit */
+#define DMAC_DCMD_DS_MASK	(0x07 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BIT	(0 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_8BIT	(1 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BIT	(2 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BYTE	(3 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BYTE	(4 << DMAC_DCMD_DS_BIT)
+#define DMAC_DCMD_STDE   	(1 << 5)  /* Stride Disable/Enable */
+#define DMAC_DCMD_DES_V		(1 << 4)  /* descriptor valid flag */
+#define DMAC_DCMD_DES_VM	(1 << 3)  /* descriptor valid mask: 1:support V-bit */
+#define DMAC_DCMD_DES_VIE	(1 << 2)  /* DMA valid error interrupt enable */
+#define DMAC_DCMD_TIE		(1 << 1)  /* DMA transfer interrupt enable */
+#define DMAC_DCMD_LINK		(1 << 0)  /* descriptor link enable */
+
+// DMA descriptor address register
+#define DMAC_DDA_BASE_BIT	12  /* descriptor base address */
+#define DMAC_DDA_BASE_MASK	(0x0fffff << DMAC_DDA_BASE_BIT)
+#define DMAC_DDA_OFFSET_BIT	4   /* descriptor offset address */
+#define DMAC_DDA_OFFSET_MASK	(0x0ff << DMAC_DDA_OFFSET_BIT)
+
+// DMA stride address register
+#define DMAC_DSD_TSD_BIT        16  /* target stride address */
+#define DMAC_DSD_TSD_MASK      	(0xffff << DMAC_DSD_TSD_BIT)
+#define DMAC_DSD_SSD_BIT        0  /* source stride address */
+#define DMAC_DSD_SSD_MASK      	(0xffff << DMAC_DSD_SSD_BIT)
+
+// DMA control register
+#define DMAC_DMACR_FMSC		(1 << 31)  /* MSC Fast DMA mode */
+#define DMAC_DMACR_FSSI		(1 << 30)  /* SSI Fast DMA mode */
+#define DMAC_DMACR_FTSSI	(1 << 29)  /* TSSI Fast DMA mode */
+#define DMAC_DMACR_FUART	(1 << 28)  /* UART Fast DMA mode */
+#define DMAC_DMACR_FAIC		(1 << 27)  /* AIC Fast DMA mode */
+#define DMAC_DMACR_PR_BIT	8  /* channel priority mode */
+#define DMAC_DMACR_PR_MASK	(0x03 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_012345	(0 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_120345	(1 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_230145	(2 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_340125	(3 << DMAC_DMACR_PR_BIT)
+#define DMAC_DMACR_HLT		(1 << 3)  /* DMA halt flag */
+#define DMAC_DMACR_AR		(1 << 2)  /* address error flag */
+#define DMAC_DMACR_DMAE		(1 << 0)  /* DMA enable bit */
+
+// DMA doorbell register
+#define DMAC_DMADBR_DB5		(1 << 5)  /* doorbell for channel 5 */
+#define DMAC_DMADBR_DB4		(1 << 4)  /* doorbell for channel 4 */
+#define DMAC_DMADBR_DB3		(1 << 3)  /* doorbell for channel 3 */
+#define DMAC_DMADBR_DB2		(1 << 2)  /* doorbell for channel 2 */
+#define DMAC_DMADBR_DB1		(1 << 1)  /* doorbell for channel 1 */
+#define DMAC_DMADBR_DB0		(1 << 0)  /* doorbell for channel 0 */
+
+// DMA doorbell set register
+#define DMAC_DMADBSR_DBS5	(1 << 5)  /* enable doorbell for channel 5 */
+#define DMAC_DMADBSR_DBS4	(1 << 4)  /* enable doorbell for channel 4 */
+#define DMAC_DMADBSR_DBS3	(1 << 3)  /* enable doorbell for channel 3 */
+#define DMAC_DMADBSR_DBS2	(1 << 2)  /* enable doorbell for channel 2 */
+#define DMAC_DMADBSR_DBS1	(1 << 1)  /* enable doorbell for channel 1 */
+#define DMAC_DMADBSR_DBS0	(1 << 0)  /* enable doorbell for channel 0 */
+
+// DMA interrupt pending register
+#define DMAC_DMAIPR_CIRQ5	(1 << 5)  /* irq pending status for channel 5 */
+#define DMAC_DMAIPR_CIRQ4	(1 << 4)  /* irq pending status for channel 4 */
+#define DMAC_DMAIPR_CIRQ3	(1 << 3)  /* irq pending status for channel 3 */
+#define DMAC_DMAIPR_CIRQ2	(1 << 2)  /* irq pending status for channel 2 */
+#define DMAC_DMAIPR_CIRQ1	(1 << 1)  /* irq pending status for channel 1 */
+#define DMAC_DMAIPR_CIRQ0	(1 << 0)  /* irq pending status for channel 0 */
+
+
+/*************************************************************************
+ * GPIO (General-Purpose I/O Ports)
+ *************************************************************************/
+#define MAX_GPIO_NUM	192
+#define GPIO_WAKEUP     (32 * 4 + 30)
+
+//n = 0,1,2,3,4,5 (PORTA, PORTB, PORTC, PORTD, PORTE, PORTF)
+#define GPIO_PXPIN(n)	(GPIO_BASE + (0x00 + (n)*0x100)) /* PIN Level Register */
+#define GPIO_PXDAT(n)	(GPIO_BASE + (0x10 + (n)*0x100)) /* Port Data Register */
+#define GPIO_PXDATS(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Data Set Register */
+#define GPIO_PXDATC(n)	(GPIO_BASE + (0x18 + (n)*0x100)) /* Port Data Clear Register */
+#define GPIO_PXIM(n)	(GPIO_BASE + (0x20 + (n)*0x100)) /* Interrupt Mask Register */
+#define GPIO_PXIMS(n)	(GPIO_BASE + (0x24 + (n)*0x100)) /* Interrupt Mask Set Reg */
+#define GPIO_PXIMC(n)	(GPIO_BASE + (0x28 + (n)*0x100)) /* Interrupt Mask Clear Reg */
+#define GPIO_PXPE(n)	(GPIO_BASE + (0x30 + (n)*0x100)) /* Pull Enable Register */
+#define GPIO_PXPES(n)	(GPIO_BASE + (0x34 + (n)*0x100)) /* Pull Enable Set Reg. */
+#define GPIO_PXPEC(n)	(GPIO_BASE + (0x38 + (n)*0x100)) /* Pull Enable Clear Reg. */
+#define GPIO_PXFUN(n)	(GPIO_BASE + (0x40 + (n)*0x100)) /* Function Register */
+#define GPIO_PXFUNS(n)	(GPIO_BASE + (0x44 + (n)*0x100)) /* Function Set Register */
+#define GPIO_PXFUNC(n)	(GPIO_BASE + (0x48 + (n)*0x100)) /* Function Clear Register */
+#define GPIO_PXSEL(n)	(GPIO_BASE + (0x50 + (n)*0x100)) /* Select Register */
+#define GPIO_PXSELS(n)	(GPIO_BASE + (0x54 + (n)*0x100)) /* Select Set Register */
+#define GPIO_PXSELC(n)	(GPIO_BASE + (0x58 + (n)*0x100)) /* Select Clear Register */
+#define GPIO_PXDIR(n)	(GPIO_BASE + (0x60 + (n)*0x100)) /* Direction Register */
+#define GPIO_PXDIRS(n)	(GPIO_BASE + (0x64 + (n)*0x100)) /* Direction Set Register */
+#define GPIO_PXDIRC(n)	(GPIO_BASE + (0x68 + (n)*0x100)) /* Direction Clear Register */
+#define GPIO_PXTRG(n)	(GPIO_BASE + (0x70 + (n)*0x100)) /* Trigger Register */
+#define GPIO_PXTRGS(n)	(GPIO_BASE + (0x74 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXTRGC(n)	(GPIO_BASE + (0x78 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXFLG(n)	(GPIO_BASE + (0x80 + (n)*0x100)) /* Port Flag Register */
+#define GPIO_PXFLGC(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Flag Clear Register */
+
+#define REG_GPIO_PXPIN(n)	REG32(GPIO_PXPIN((n)))  /* PIN level */
+#define REG_GPIO_PXDAT(n)	REG32(GPIO_PXDAT((n)))  /* 1: interrupt pending */
+#define REG_GPIO_PXDATS(n)	REG32(GPIO_PXDATS((n)))
+#define REG_GPIO_PXDATC(n)	REG32(GPIO_PXDATC((n)))
+#define REG_GPIO_PXIM(n)	REG32(GPIO_PXIM((n)))   /* 1: mask pin interrupt */
+#define REG_GPIO_PXIMS(n)	REG32(GPIO_PXIMS((n)))
+#define REG_GPIO_PXIMC(n)	REG32(GPIO_PXIMC((n)))
+#define REG_GPIO_PXPE(n)	REG32(GPIO_PXPE((n)))   /* 1: disable pull up/down */
+#define REG_GPIO_PXPES(n)	REG32(GPIO_PXPES((n)))
+#define REG_GPIO_PXPEC(n)	REG32(GPIO_PXPEC((n)))
+#define REG_GPIO_PXFUN(n)	REG32(GPIO_PXFUN((n)))  /* 0:GPIO or intr, 1:FUNC */
+#define REG_GPIO_PXFUNS(n)	REG32(GPIO_PXFUNS((n)))
+#define REG_GPIO_PXFUNC(n)	REG32(GPIO_PXFUNC((n)))
+#define REG_GPIO_PXSEL(n)	REG32(GPIO_PXSEL((n))) /* 0:GPIO/Fun0,1:intr/fun1*/
+#define REG_GPIO_PXSELS(n)	REG32(GPIO_PXSELS((n)))
+#define REG_GPIO_PXSELC(n)	REG32(GPIO_PXSELC((n)))
+#define REG_GPIO_PXDIR(n)	REG32(GPIO_PXDIR((n))) /* 0:input/low-level-trig/falling-edge-trig, 1:output/high-level-trig/rising-edge-trig */
+#define REG_GPIO_PXDIRS(n)	REG32(GPIO_PXDIRS((n)))
+#define REG_GPIO_PXDIRC(n)	REG32(GPIO_PXDIRC((n)))
+#define REG_GPIO_PXTRG(n)	REG32(GPIO_PXTRG((n))) /* 0:level-trigger, 1:edge-trigger */
+#define REG_GPIO_PXTRGS(n)	REG32(GPIO_PXTRGS((n)))
+#define REG_GPIO_PXTRGC(n)	REG32(GPIO_PXTRGC((n)))
+#define REG_GPIO_PXFLG(n)	REG32(GPIO_PXFLG((n))) /* interrupt flag */
+#define REG_GPIO_PXFLGC(n)	REG32(GPIO_PXFLGC((n))) /* interrupt flag */
+
+
+/*************************************************************************
+ * UART
+ *************************************************************************/
+
+#define IRDA_BASE	UART0_BASE
+#define UART_BASE	UART0_BASE
+#define UART_OFF	0x1000
+
+/* Register Offset */
+#define OFF_RDR		(0x00)	/* R  8b H'xx */
+#define OFF_TDR		(0x00)	/* W  8b H'xx */
+#define OFF_DLLR	(0x00)	/* RW 8b H'00 */
+#define OFF_DLHR	(0x04)	/* RW 8b H'00 */
+#define OFF_IER		(0x04)	/* RW 8b H'00 */
+#define OFF_ISR		(0x08)	/* R  8b H'01 */
+#define OFF_FCR		(0x08)	/* W  8b H'00 */
+#define OFF_LCR		(0x0C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_LSR		(0x14)	/* R  8b H'00 */
+#define OFF_MSR		(0x18)	/* R  8b H'00 */
+#define OFF_SPR		(0x1C)	/* RW 8b H'00 */
+#define OFF_SIRCR	(0x20)	/* RW 8b H'00, UART0 */
+#define OFF_UMR		(0x24)	/* RW 8b H'00, UART M Register */
+#define OFF_UACR	(0x28)	/* RW 8b H'00, UART Add Cycle Register */
+
+/* Register Address */
+#define UART0_RDR	(UART0_BASE + OFF_RDR)
+#define UART0_TDR	(UART0_BASE + OFF_TDR)
+#define UART0_DLLR	(UART0_BASE + OFF_DLLR)
+#define UART0_DLHR	(UART0_BASE + OFF_DLHR)
+#define UART0_IER	(UART0_BASE + OFF_IER)
+#define UART0_ISR	(UART0_BASE + OFF_ISR)
+#define UART0_FCR	(UART0_BASE + OFF_FCR)
+#define UART0_LCR	(UART0_BASE + OFF_LCR)
+#define UART0_MCR	(UART0_BASE + OFF_MCR)
+#define UART0_LSR	(UART0_BASE + OFF_LSR)
+#define UART0_MSR	(UART0_BASE + OFF_MSR)
+#define UART0_SPR	(UART0_BASE + OFF_SPR)
+#define UART0_SIRCR	(UART0_BASE + OFF_SIRCR)
+#define UART0_UMR	(UART0_BASE + OFF_UMR)
+#define UART0_UACR	(UART0_BASE + OFF_UACR)
+
+#define UART1_RDR	(UART1_BASE + OFF_RDR)
+#define UART1_TDR	(UART1_BASE + OFF_TDR)
+#define UART1_DLLR	(UART1_BASE + OFF_DLLR)
+#define UART1_DLHR	(UART1_BASE + OFF_DLHR)
+#define UART1_IER	(UART1_BASE + OFF_IER)
+#define UART1_ISR	(UART1_BASE + OFF_ISR)
+#define UART1_FCR	(UART1_BASE + OFF_FCR)
+#define UART1_LCR	(UART1_BASE + OFF_LCR)
+#define UART1_MCR	(UART1_BASE + OFF_MCR)
+#define UART1_LSR	(UART1_BASE + OFF_LSR)
+#define UART1_MSR	(UART1_BASE + OFF_MSR)
+#define UART1_SPR	(UART1_BASE + OFF_SPR)
+#define UART1_SIRCR	(UART1_BASE + OFF_SIRCR)
+
+#define UART2_RDR	(UART2_BASE + OFF_RDR)
+#define UART2_TDR	(UART2_BASE + OFF_TDR)
+#define UART2_DLLR	(UART2_BASE + OFF_DLLR)
+#define UART2_DLHR	(UART2_BASE + OFF_DLHR)
+#define UART2_IER	(UART2_BASE + OFF_IER)
+#define UART2_ISR	(UART2_BASE + OFF_ISR)
+#define UART2_FCR	(UART2_BASE + OFF_FCR)
+#define UART2_LCR	(UART2_BASE + OFF_LCR)
+#define UART2_MCR	(UART2_BASE + OFF_MCR)
+#define UART2_LSR	(UART2_BASE + OFF_LSR)
+#define UART2_MSR	(UART2_BASE + OFF_MSR)
+#define UART2_SPR	(UART2_BASE + OFF_SPR)
+#define UART2_SIRCR	(UART2_BASE + OFF_SIRCR)
+
+#define UART3_RDR	(UART3_BASE + OFF_RDR)
+#define UART3_TDR	(UART3_BASE + OFF_TDR)
+#define UART3_DLLR	(UART3_BASE + OFF_DLLR)
+#define UART3_DLHR	(UART3_BASE + OFF_DLHR)
+#define UART3_IER	(UART3_BASE + OFF_IER)
+#define UART3_ISR	(UART3_BASE + OFF_ISR)
+#define UART3_FCR	(UART3_BASE + OFF_FCR)
+#define UART3_LCR	(UART3_BASE + OFF_LCR)
+#define UART3_MCR	(UART3_BASE + OFF_MCR)
+#define UART3_LSR	(UART3_BASE + OFF_LSR)
+#define UART3_MSR	(UART3_BASE + OFF_MSR)
+#define UART3_SPR	(UART3_BASE + OFF_SPR)
+#define UART3_SIRCR	(UART3_BASE + OFF_SIRCR)
+
+
+/*
+ * Define macros for UARTIER
+ * UART Interrupt Enable Register
+ */
+#define UARTIER_RIE	(1 << 0)	/* 0: receive fifo full interrupt disable */
+#define UARTIER_TIE	(1 << 1)	/* 0: transmit fifo empty interrupt disable */
+#define UARTIER_RLIE	(1 << 2)	/* 0: receive line status interrupt disable */
+#define UARTIER_MIE	(1 << 3)	/* 0: modem status interrupt disable */
+#define UARTIER_RTIE	(1 << 4)	/* 0: receive timeout interrupt disable */
+
+/*
+ * Define macros for UARTISR
+ * UART Interrupt Status Register
+ */
+#define UARTISR_IP	(1 << 0)	/* 0: interrupt is pending  1: no interrupt */
+#define UARTISR_IID	(7 << 1)	/* Source of Interrupt */
+#define UARTISR_IID_MSI		(0 << 1)  /* Modem status interrupt */
+#define UARTISR_IID_THRI	(1 << 1)  /* Transmitter holding register empty */
+#define UARTISR_IID_RDI		(2 << 1)  /* Receiver data interrupt */
+#define UARTISR_IID_RLSI	(3 << 1)  /* Receiver line status interrupt */
+#define UARTISR_IID_RTO		(6 << 1)  /* Receive timeout */
+#define UARTISR_FFMS		(3 << 6)  /* FIFO mode select, set when UARTFCR.FE is set to 1 */
+#define UARTISR_FFMS_NO_FIFO	(0 << 6)
+#define UARTISR_FFMS_FIFO_MODE	(3 << 6)
+
+/*
+ * Define macros for UARTFCR
+ * UART FIFO Control Register
+ */
+#define UARTFCR_FE	(1 << 0)	/* 0: non-FIFO mode  1: FIFO mode */
+#define UARTFCR_RFLS	(1 << 1)	/* write 1 to flush receive FIFO */
+#define UARTFCR_TFLS	(1 << 2)	/* write 1 to flush transmit FIFO */
+#define UARTFCR_DMS	(1 << 3)	/* 0: disable DMA mode */
+#define UARTFCR_UUE	(1 << 4)	/* 0: disable UART */
+#define UARTFCR_RTRG	(3 << 6)	/* Receive FIFO Data Trigger */
+#define UARTFCR_RTRG_1	(0 << 6)
+#define UARTFCR_RTRG_4	(1 << 6)
+#define UARTFCR_RTRG_8	(2 << 6)
+#define UARTFCR_RTRG_15	(3 << 6)
+
+/*
+ * Define macros for UARTLCR
+ * UART Line Control Register
+ */
+#define UARTLCR_WLEN	(3 << 0)	/* word length */
+#define UARTLCR_WLEN_5	(0 << 0)
+#define UARTLCR_WLEN_6	(1 << 0)
+#define UARTLCR_WLEN_7	(2 << 0)
+#define UARTLCR_WLEN_8	(3 << 0)
+#define UARTLCR_STOP	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UARTLCR_STOP1	(0 << 2)
+#define UARTLCR_STOP2	(1 << 2)
+#define UARTLCR_PE	(1 << 3)	/* 0: parity disable */
+#define UARTLCR_PROE	(1 << 4)	/* 0: even parity  1: odd parity */
+#define UARTLCR_SPAR	(1 << 5)	/* 0: sticky parity disable */
+#define UARTLCR_SBRK	(1 << 6)	/* write 0 normal, write 1 send break */
+#define UARTLCR_DLAB	(1 << 7)	/* 0: access UARTRDR/TDR/IER  1: access UARTDLLR/DLHR */
+
+/*
+ * Define macros for UARTLSR
+ * UART Line Status Register
+ */
+#define UARTLSR_DR	(1 << 0)	/* 0: receive FIFO is empty  1: receive data is ready */
+#define UARTLSR_ORER	(1 << 1)	/* 0: no overrun error */
+#define UARTLSR_PER	(1 << 2)	/* 0: no parity error */
+#define UARTLSR_FER	(1 << 3)	/* 0; no framing error */
+#define UARTLSR_BRK	(1 << 4)	/* 0: no break detected  1: receive a break signal */
+#define UARTLSR_TDRQ	(1 << 5)	/* 1: transmit FIFO half "empty" */
+#define UARTLSR_TEMT	(1 << 6)	/* 1: transmit FIFO and shift registers empty */
+#define UARTLSR_RFER	(1 << 7)	/* 0: no receive error  1: receive error in FIFO mode */
+
+/*
+ * Define macros for UARTMCR
+ * UART Modem Control Register
+ */
+#define UARTMCR_RTS	(1 << 1)	/* 0: RTS_ output high, 1: RTS_ output low */
+#define UARTMCR_LOOP	(1 << 4)	/* 0: normal  1: loopback mode */
+#define UARTMCR_MCE	(1 << 7)	/* 0: modem function is disable */
+
+/*
+ * Define macros for UARTMSR
+ * UART Modem Status Register
+ */
+#define UARTMSR_CCTS	(1 << 0)        /* 1: a change on CTS_ pin */
+#define UARTMSR_CTS	(1 << 4)	/* 0: CTS_ pin is high */
+
+/*
+ * Define macros for SIRCR
+ * Slow IrDA Control Register
+ */
+#define SIRCR_TSIRE	(1 << 0)  /* 0: transmitter is in UART mode  1: SIR mode */
+#define SIRCR_RSIRE	(1 << 1)  /* 0: receiver is in UART mode  1: SIR mode */
+#define SIRCR_TPWS	(1 << 2)  /* 0: transmit 0 pulse width is 3/16 of bit length
+					   1: 0 pulse width is 1.6us for 115.2Kbps */
+#define SIRCR_TDPL	(1 << 3)  /* 0: encoder generates a positive pulse for 0 */
+#define SIRCR_RDPL	(1 << 4)  /* 0: decoder interprets positive pulse as 0 */
+
+
+/*************************************************************************
+ * AIC (AC97/I2S Controller)
+ *************************************************************************/
+#define	AIC_FR			(AIC_BASE + 0x000)
+#define	AIC_CR			(AIC_BASE + 0x004)
+#define	AIC_ACCR1		(AIC_BASE + 0x008)
+#define	AIC_ACCR2		(AIC_BASE + 0x00C)
+#define	AIC_I2SCR		(AIC_BASE + 0x010)
+#define	AIC_SR			(AIC_BASE + 0x014)
+#define	AIC_ACSR		(AIC_BASE + 0x018)
+#define	AIC_I2SSR		(AIC_BASE + 0x01C)
+#define	AIC_ACCAR		(AIC_BASE + 0x020)
+#define	AIC_ACCDR		(AIC_BASE + 0x024)
+#define	AIC_ACSAR		(AIC_BASE + 0x028)
+#define	AIC_ACSDR		(AIC_BASE + 0x02C)
+#define	AIC_I2SDIV		(AIC_BASE + 0x030)
+#define	AIC_DR			(AIC_BASE + 0x034)
+
+#define	REG_AIC_FR		REG32(AIC_FR)
+#define	REG_AIC_CR		REG32(AIC_CR)
+#define	REG_AIC_ACCR1		REG32(AIC_ACCR1)
+#define	REG_AIC_ACCR2		REG32(AIC_ACCR2)
+#define	REG_AIC_I2SCR		REG32(AIC_I2SCR)
+#define	REG_AIC_SR		REG32(AIC_SR)
+#define	REG_AIC_ACSR		REG32(AIC_ACSR)
+#define	REG_AIC_I2SSR		REG32(AIC_I2SSR)
+#define	REG_AIC_ACCAR		REG32(AIC_ACCAR)
+#define	REG_AIC_ACCDR		REG32(AIC_ACCDR)
+#define	REG_AIC_ACSAR		REG32(AIC_ACSAR)
+#define	REG_AIC_ACSDR		REG32(AIC_ACSDR)
+#define	REG_AIC_I2SDIV		REG32(AIC_I2SDIV)
+#define	REG_AIC_DR		REG32(AIC_DR)
+
+/* AIC Controller Configuration Register (AIC_FR) */
+
+#define	AIC_FR_RFTH_BIT		12        /* Receive FIFO Threshold */
+#define	AIC_FR_RFTH_MASK	(0xf << AIC_FR_RFTH_BIT)
+#define	AIC_FR_TFTH_BIT		8         /* Transmit FIFO Threshold */
+#define	AIC_FR_TFTH_MASK	(0xf << AIC_FR_TFTH_BIT)
+#define	AIC_FR_LSMP		(1 << 6)  /* Play Zero sample or last sample */
+#define	AIC_FR_ICDC		(1 << 5)  /* External(0) or Internal CODEC(1) */
+#define	AIC_FR_AUSEL		(1 << 4)  /* AC97(0) or I2S/MSB-justified(1) */
+#define	AIC_FR_RST		(1 << 3)  /* AIC registers reset */
+#define	AIC_FR_BCKD		(1 << 2)  /* I2S BIT_CLK direction, 0:input,1:output */
+#define	AIC_FR_SYNCD		(1 << 1)  /* I2S SYNC direction, 0:input,1:output */
+#define	AIC_FR_ENB		(1 << 0)  /* AIC enable bit */
+
+/* AIC Controller Common Control Register (AIC_CR) */
+
+#define	AIC_CR_OSS_BIT		19  /* Output Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_OSS_MASK		(0x7 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_8BIT	(0x0 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_16BIT	(0x1 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_18BIT	(0x2 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_20BIT	(0x3 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_24BIT	(0x4 << AIC_CR_OSS_BIT)
+#define	AIC_CR_ISS_BIT		16  /* Input Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_ISS_MASK		(0x7 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_8BIT	(0x0 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_16BIT	(0x1 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_18BIT	(0x2 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_20BIT	(0x3 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_24BIT	(0x4 << AIC_CR_ISS_BIT)
+#define	AIC_CR_RDMS		(1 << 15)  /* Receive DMA enable */
+#define	AIC_CR_TDMS		(1 << 14)  /* Transmit DMA enable */
+#define	AIC_CR_M2S		(1 << 11)  /* Mono to Stereo enable */
+#define	AIC_CR_ENDSW		(1 << 10)  /* Endian switch enable */
+#define	AIC_CR_AVSTSU		(1 << 9)   /* Signed <-> Unsigned toggle enable */
+#define	AIC_CR_FLUSH		(1 << 8)   /* Flush FIFO */
+#define	AIC_CR_EROR		(1 << 6)   /* Enable ROR interrupt */
+#define	AIC_CR_ETUR		(1 << 5)   /* Enable TUR interrupt */
+#define	AIC_CR_ERFS		(1 << 4)   /* Enable RFS interrupt */
+#define	AIC_CR_ETFS		(1 << 3)   /* Enable TFS interrupt */
+#define	AIC_CR_ENLBF		(1 << 2)   /* Enable Loopback Function */
+#define	AIC_CR_ERPL		(1 << 1)   /* Enable Playback Function */
+#define	AIC_CR_EREC		(1 << 0)   /* Enable Record Function */
+
+/* AIC Controller AC-link Control Register 1 (AIC_ACCR1) */
+
+#define	AIC_ACCR1_RS_BIT	16          /* Receive Valid Slots */
+#define	AIC_ACCR1_RS_MASK	(0x3ff << AIC_ACCR1_RS_BIT)
+  #define AIC_ACCR1_RS_SLOT12	  (1 << 25) /* Slot 12 valid bit */
+  #define AIC_ACCR1_RS_SLOT11	  (1 << 24) /* Slot 11 valid bit */
+  #define AIC_ACCR1_RS_SLOT10	  (1 << 23) /* Slot 10 valid bit */
+  #define AIC_ACCR1_RS_SLOT9	  (1 << 22) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_RS_SLOT8	  (1 << 21) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_RS_SLOT7	  (1 << 20) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_RS_SLOT6	  (1 << 19) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_RS_SLOT5	  (1 << 18) /* Slot 5 valid bit */
+  #define AIC_ACCR1_RS_SLOT4	  (1 << 17) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_RS_SLOT3	  (1 << 16) /* Slot 3 valid bit, PCM Left */
+#define	AIC_ACCR1_XS_BIT	0          /* Transmit Valid Slots */
+#define	AIC_ACCR1_XS_MASK	(0x3ff << AIC_ACCR1_XS_BIT)
+  #define AIC_ACCR1_XS_SLOT12	  (1 << 9) /* Slot 12 valid bit */
+  #define AIC_ACCR1_XS_SLOT11	  (1 << 8) /* Slot 11 valid bit */
+  #define AIC_ACCR1_XS_SLOT10	  (1 << 7) /* Slot 10 valid bit */
+  #define AIC_ACCR1_XS_SLOT9	  (1 << 6) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_XS_SLOT8	  (1 << 5) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_XS_SLOT7	  (1 << 4) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_XS_SLOT6	  (1 << 3) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_XS_SLOT5	  (1 << 2) /* Slot 5 valid bit */
+  #define AIC_ACCR1_XS_SLOT4	  (1 << 1) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_XS_SLOT3	  (1 << 0) /* Slot 3 valid bit, PCM Left */
+
+/* AIC Controller AC-link Control Register 2 (AIC_ACCR2) */
+
+#define	AIC_ACCR2_ERSTO		(1 << 18) /* Enable RSTO interrupt */
+#define	AIC_ACCR2_ESADR		(1 << 17) /* Enable SADR interrupt */
+#define	AIC_ACCR2_ECADT		(1 << 16) /* Enable CADT interrupt */
+#define	AIC_ACCR2_OASS_BIT	8  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_OASS_MASK	(0x3 << AIC_ACCR2_OASS_BIT)
+  #define AIC_ACCR2_OASS_20BIT	  (0 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_OASS_18BIT	  (1 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_OASS_16BIT	  (2 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_OASS_8BIT	  (3 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_IASS_BIT	6  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_IASS_MASK	(0x3 << AIC_ACCR2_IASS_BIT)
+  #define AIC_ACCR2_IASS_20BIT	  (0 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_IASS_18BIT	  (1 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_IASS_16BIT	  (2 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_IASS_8BIT	  (3 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_SO		(1 << 3)  /* SDATA_OUT output value */
+#define	AIC_ACCR2_SR		(1 << 2)  /* RESET# pin level */
+#define	AIC_ACCR2_SS		(1 << 1)  /* SYNC pin level */
+#define	AIC_ACCR2_SA		(1 << 0)  /* SYNC and SDATA_OUT alternation */
+
+/* AIC Controller I2S/MSB-justified Control Register (AIC_I2SCR) */
+
+#define	AIC_I2SCR_STPBK		(1 << 12) /* Stop BIT_CLK for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_BIT	1  /* Input/Output Sample Size for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_MASK	(0x7 << AIC_I2SCR_WL_BIT)
+  #define AIC_I2SCR_WL_24BIT	  (0 << AIC_I2SCR_WL_BIT) /* Word Length is 24 bit */
+  #define AIC_I2SCR_WL_20BIT	  (1 << AIC_I2SCR_WL_BIT) /* Word Length is 20 bit */
+  #define AIC_I2SCR_WL_18BIT	  (2 << AIC_I2SCR_WL_BIT) /* Word Length is 18 bit */
+  #define AIC_I2SCR_WL_16BIT	  (3 << AIC_I2SCR_WL_BIT) /* Word Length is 16 bit */
+  #define AIC_I2SCR_WL_8BIT	  (4 << AIC_I2SCR_WL_BIT) /* Word Length is 8 bit */
+#define	AIC_I2SCR_AMSL		(1 << 0) /* 0:I2S, 1:MSB-justified */
+
+/* AIC Controller FIFO Status Register (AIC_SR) */
+
+#define	AIC_SR_RFL_BIT		24  /* Receive FIFO Level */
+#define	AIC_SR_RFL_MASK		(0x3f << AIC_SR_RFL_BIT)
+#define	AIC_SR_TFL_BIT		8   /* Transmit FIFO level */
+#define	AIC_SR_TFL_MASK		(0x3f << AIC_SR_TFL_BIT)
+#define	AIC_SR_ROR		(1 << 6) /* Receive FIFO Overrun */
+#define	AIC_SR_TUR		(1 << 5) /* Transmit FIFO Underrun */
+#define	AIC_SR_RFS		(1 << 4) /* Receive FIFO Service Request */
+#define	AIC_SR_TFS		(1 << 3) /* Transmit FIFO Service Request */
+
+/* AIC Controller AC-link Status Register (AIC_ACSR) */
+
+#define	AIC_ACSR_SLTERR		(1 << 21) /* Slot Error Flag */
+#define	AIC_ACSR_CRDY		(1 << 20) /* External CODEC Ready Flag */
+#define	AIC_ACSR_CLPM		(1 << 19) /* External CODEC low power mode flag */
+#define	AIC_ACSR_RSTO		(1 << 18) /* External CODEC regs read status timeout */
+#define	AIC_ACSR_SADR		(1 << 17) /* External CODEC regs status addr and data received */
+#define	AIC_ACSR_CADT		(1 << 16) /* Command Address and Data Transmitted */
+
+/* AIC Controller I2S/MSB-justified Status Register (AIC_I2SSR) */
+
+#define	AIC_I2SSR_BSY		(1 << 2)  /* AIC Busy in I2S/MSB-justified format */
+
+/* AIC Controller AC97 codec Command Address Register (AIC_ACCAR) */
+
+#define	AIC_ACCAR_CAR_BIT	0
+#define	AIC_ACCAR_CAR_MASK	(0xfffff << AIC_ACCAR_CAR_BIT)
+
+/* AIC Controller AC97 codec Command Data Register (AIC_ACCDR) */
+
+#define	AIC_ACCDR_CDR_BIT	0
+#define	AIC_ACCDR_CDR_MASK	(0xfffff << AIC_ACCDR_CDR_BIT)
+
+/* AIC Controller AC97 codec Status Address Register (AIC_ACSAR) */
+
+#define	AIC_ACSAR_SAR_BIT	0
+#define	AIC_ACSAR_SAR_MASK	(0xfffff << AIC_ACSAR_SAR_BIT)
+
+/* AIC Controller AC97 codec Status Data Register (AIC_ACSDR) */
+
+#define	AIC_ACSDR_SDR_BIT	0
+#define	AIC_ACSDR_SDR_MASK	(0xfffff << AIC_ACSDR_SDR_BIT)
+
+/* AIC Controller I2S/MSB-justified Clock Divider Register (AIC_I2SDIV) */
+
+#define	AIC_I2SDIV_DIV_BIT	0
+#define	AIC_I2SDIV_DIV_MASK	(0x7f << AIC_I2SDIV_DIV_BIT)
+  #define AIC_I2SDIV_BITCLK_3072KHZ	(0x0C << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 3.072MHz */
+  #define AIC_I2SDIV_BITCLK_2836KHZ	(0x0D << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 2.836MHz */
+  #define AIC_I2SDIV_BITCLK_1418KHZ	(0x1A << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.418MHz */
+  #define AIC_I2SDIV_BITCLK_1024KHZ	(0x24 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.024MHz */
+  #define AIC_I2SDIV_BITCLK_7089KHZ	(0x34 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 708.92KHz */
+  #define AIC_I2SDIV_BITCLK_512KHZ	(0x48 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 512.00KHz */
+
+
+/*************************************************************************
+ * ICDC (Internal CODEC)
+ *************************************************************************/
+
+#define	ICDC_CKCFG	  (ICDC_BASE + 0x00a0)  /* Clock Configure Register */
+#define	ICDC_RGADW	  (ICDC_BASE + 0x00a4)  /* internal register access control */
+#define	ICDC_RGDATA	  (ICDC_BASE + 0x00a8)  /* internal register data output */
+
+#define	REG_ICDC_CKCFG		REG32(ICDC_CKCFG)
+#define	REG_ICDC_RGADW		REG32(ICDC_RGADW)
+#define	REG_ICDC_RGDATA		REG32(ICDC_RGDATA)
+
+/* ICDC Clock Configure Register */
+#define	ICDC_CKCFG_CKRDY	(1 << 1) 
+#define	ICDC_CKCFG_SELAD	(1 << 0)
+
+/* ICDC internal register access control Register */
+#define ICDC_RGADW_RGWR         (1 << 16)
+#define ICDC_RGADW_RGADDR_BIT   8
+#define	ICDC_RGADW_RGADDR_MASK	(0x7f << ICDC_RGADW_RGADDR_BIT)
+#define ICDC_RGADW_RGDIN_BIT    0
+#define	ICDC_RGADW_RGDIN_MASK	(0xff << ICDC_RGADW_RGDIN_BIT)
+
+/* ICDC internal register data output Register */
+#define ICDC_RGDATA_IRQ         (1 << 8)
+#define ICDC_RGDATA_RGDOUT_BIT  0
+#define ICDC_RGDATA_RGDOUT_MASK (0xff << ICDC_RGDATA_RGDOUT_BIT)
+
+/*************************************************************************
+ * PCM Controller
+ *************************************************************************/
+
+#define PCM_CTL                 (PCM_BASE + 0x000)
+#define PCM_CFG                 (PCM_BASE + 0x004)
+#define PCM_DP                  (PCM_BASE + 0x008)
+#define PCM_INTC                (PCM_BASE + 0x00c)
+#define PCM_INTS                (PCM_BASE + 0x010)
+#define PCM_DIV                 (PCM_BASE + 0x014)
+
+#define REG_PCM_CTL             REG32(PCM_CTL)
+#define REG_PCM_CFG             REG32(PCM_CFG)
+#define REG_PCM_DP              REG32(PCM_DP)
+#define REG_PCM_INTC            REG32(PCM_INTC)
+#define REG_PCM_INTS            REG32(PCM_INTS)
+#define REG_PCM_DIV             REG32(PCM_DIV)
+
+/* PCM Controller control Register (PCM_CTL) */
+
+#define PCM_CTL_ERDMA		(1 << 9)  /* Enable Receive DMA */
+#define PCM_CTL_ETDMA           (1 << 8)  /* Enable Transmit DMA */
+#define PCM_CTL_LSMP		(1 << 7)  /* Play Zero sample or last sample */
+#define PCM_CTL_ERPL            (1 << 6)  /* Enable Playing Back Function */
+#define PCM_CTL_EREC            (1 << 5)  /* Enable Recording Function */
+#define PCM_CTL_FLUSH           (1 << 4)  /* FIFO flush */
+#define PCM_CTL_RST             (1 << 3)  /* Reset PCM */
+#define PCM_CTL_CLKEN           (1 << 1)  /* Enable the clock division logic */
+#define PCM_CTL_PCMEN           (1 << 0)  /* Enable PCM module */
+
+/* PCM Controller configure Register (PCM_CFG) */
+
+#define PCM_CFG_SLOT_BIT        13
+#define PCM_CFG_SLOT_MASK       (0x3 << PCM_CFG_SLOT_BIT)
+  #define PCM_CFG_SLOT_0	  (0 << PCM_CFG_SLOT_BIT) /* Slot is 0 */
+  #define PCM_CFG_SLOT_1	  (1 << PCM_CFG_SLOT_BIT) /* Slot is 1 */
+  #define PCM_CFG_SLOT_2	  (2 << PCM_CFG_SLOT_BIT) /* Slot is 2 */
+  #define PCM_CFG_SLOT_3	  (3 << PCM_CFG_SLOT_BIT) /* Slot is 3 */
+#define PCM_CFG_ISS_BIT         12
+#define PCM_CFG_ISS_MASK        (0x1 << PCM_CFG_ISS_BIT)
+  #define PCM_CFG_ISS_8           (0 << PCM_CFG_ISS_BIT)
+  #define PCM_CFG_ISS_16          (1 << PCM_CFG_ISS_BIT)
+#define PCM_CFG_OSS_BIT         11
+#define PCM_CFG_OSS_MASK        (0x1 << PCM_CFG_OSS_BIT)
+  #define PCM_CFG_OSS_8           (0 << PCM_CFG_OSS_BIT)
+  #define PCM_CFG_OSS_16          (1 << PCM_CFG_OSS_BIT)
+#define PCM_CFG_IMSBPOS         (1 << 10)
+#define PCM_CFG_OMSBPOS         (1 << 9)
+#define	PCM_CFG_RFTH_BIT	5        /* Receive FIFO Threshold */
+#define	PCM_CFG_RFTH_MASK	(0xf << PCM_CFG_RFTH_BIT)
+#define	PCM_CFG_TFTH_BIT	1         /* Transmit FIFO Threshold */
+#define	PCM_CFG_TFTH_MASK	(0xf << PCM_CFG_TFTH_BIT)
+#define PCM_CFG_MODE            (0x0 << 0)
+
+/* PCM Controller interrupt control Register (PCM_INTC) */
+
+#define PCM_INTC_ETFS           (1 << 3)
+#define PCM_INTC_ETUR           (1 << 2)
+#define PCM_INTC_ERFS           (1 << 1)
+#define PCM_INTC_EROR           (1 << 0)
+
+/* PCM Controller interrupt status Register (PCM_INTS) */
+
+#define PCM_INTS_RSTS		(1 << 14) /* Reset or flush has not complete */
+#define PCM_INTS_TFL_BIT        9
+#define PCM_INTS_TFL_MASK       (0x1f << PCM_INTS_TFL_BIT)
+#define PCM_INTS_TFS		(1 << 8) /* Tranmit FIFO Service Request */
+#define PCM_INTS_TUR		(1 << 7) /* Transmit FIFO Under Run */
+#define PCM_INTS_RFL_BIT        2
+#define PCM_INTS_RFL_MASK       (0x1f << PCM_INTS_RFL_BIT)
+#define PCM_INTS_RFS		(1 << 1) /* Receive FIFO Service Request */
+#define PCM_INTS_ROR		(1 << 0) /* Receive FIFO Over Run */
+
+/* PCM Controller clock division Register (PCM_DIV) */
+#define PCM_DIV_SYNL_BIT        11
+#define PCM_DIV_SYNL_MASK       (0x3f << PCM_DIV_SYNL_BIT)
+#define PCM_DIV_SYNDIV_BIT      6
+#define PCM_DIV_SYNDIV_MASK     (0x1f << PCM_DIV_SYNDIV_BIT)
+#define PCM_DIV_CLKDIV_BIT      0
+#define PCM_DIV_CLKDIV_MASK     (0x3f << PCM_DIV_CLKDIV_BIT)
+
+
+/*************************************************************************
+ * I2C
+ *************************************************************************/
+#define	I2C_DR			(I2C_BASE + 0x000)
+#define	I2C_CR			(I2C_BASE + 0x004)
+#define	I2C_SR			(I2C_BASE + 0x008)
+#define	I2C_GR			(I2C_BASE + 0x00C)
+
+#define	REG_I2C_DR		REG8(I2C_DR)
+#define	REG_I2C_CR		REG8(I2C_CR)
+#define REG_I2C_SR		REG8(I2C_SR)
+#define REG_I2C_GR		REG16(I2C_GR)
+
+/* I2C Control Register (I2C_CR) */
+
+#define I2C_CR_IEN		(1 << 4)
+#define I2C_CR_STA		(1 << 3)
+#define I2C_CR_STO		(1 << 2)
+#define I2C_CR_AC		(1 << 1)
+#define I2C_CR_I2CE		(1 << 0)
+
+/* I2C Status Register (I2C_SR) */
+
+#define I2C_SR_STX		(1 << 4)
+#define I2C_SR_BUSY		(1 << 3)
+#define I2C_SR_TEND		(1 << 2)
+#define I2C_SR_DRF		(1 << 1)
+#define I2C_SR_ACKF		(1 << 0)
+
+
+/*************************************************************************
+ * SSI (Synchronous Serial Interface)
+ *************************************************************************/
+/* n = 0, 1 (SSI0, SSI1) */
+#define	SSI_DR(n)		(SSI_BASE + 0x000 + (n)*0x2000)
+#define	SSI_CR0(n)		(SSI_BASE + 0x004 + (n)*0x2000)
+#define	SSI_CR1(n)		(SSI_BASE + 0x008 + (n)*0x2000)
+#define	SSI_SR(n)		(SSI_BASE + 0x00C + (n)*0x2000)
+#define	SSI_ITR(n)		(SSI_BASE + 0x010 + (n)*0x2000)
+#define	SSI_ICR(n)		(SSI_BASE + 0x014 + (n)*0x2000)
+#define	SSI_GR(n)		(SSI_BASE + 0x018 + (n)*0x2000)
+
+#define	REG_SSI_DR(n)		REG32(SSI_DR(n))
+#define	REG_SSI_CR0(n)		REG16(SSI_CR0(n))
+#define	REG_SSI_CR1(n)		REG32(SSI_CR1(n))
+#define	REG_SSI_SR(n)		REG32(SSI_SR(n))
+#define	REG_SSI_ITR(n)		REG16(SSI_ITR(n))
+#define	REG_SSI_ICR(n)		REG8(SSI_ICR(n))
+#define	REG_SSI_GR(n)		REG16(SSI_GR(n))
+
+/* SSI Data Register (SSI_DR) */
+
+#define	SSI_DR_GPC_BIT		0
+#define	SSI_DR_GPC_MASK		(0x1ff << SSI_DR_GPC_BIT)
+
+#define SSI_MAX_FIFO_ENTRIES 	128 /* 128 txfifo and 128 rxfifo */
+
+/* SSI Control Register 0 (SSI_CR0) */
+
+#define SSI_CR0_SSIE		(1 << 15)
+#define SSI_CR0_TIE		(1 << 14)
+#define SSI_CR0_RIE		(1 << 13)
+#define SSI_CR0_TEIE		(1 << 12)
+#define SSI_CR0_REIE		(1 << 11)
+#define SSI_CR0_LOOP		(1 << 10)
+#define SSI_CR0_RFINE		(1 << 9)
+#define SSI_CR0_RFINC		(1 << 8)
+#define SSI_CR0_EACLRUN		(1 << 7) /* hardware auto clear underrun when TxFifo no empty */
+#define SSI_CR0_FSEL		(1 << 6)
+#define SSI_CR0_TFLUSH		(1 << 2)
+#define SSI_CR0_RFLUSH		(1 << 1)
+#define SSI_CR0_DISREV		(1 << 0)
+
+/* SSI Control Register 1 (SSI_CR1) */
+
+#define SSI_CR1_FRMHL_BIT	30
+#define SSI_CR1_FRMHL_MASK	(0x3 << SSI_CR1_FRMHL_BIT)
+  #define SSI_CR1_FRMHL_CELOW_CE2LOW	(0 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2LOW	(1 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CELOW_CE2HIGH	(2 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid  and SSI_CE2_ is high valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2HIGH	(3 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is high valid */
+#define SSI_CR1_TFVCK_BIT	28
+#define SSI_CR1_TFVCK_MASK	(0x3 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_0	  (0 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_1	  (1 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_2	  (2 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_3	  (3 << SSI_CR1_TFVCK_BIT)
+#define SSI_CR1_TCKFI_BIT	26
+#define SSI_CR1_TCKFI_MASK	(0x3 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_0	  (0 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_1	  (1 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_2	  (2 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_3	  (3 << SSI_CR1_TCKFI_BIT)
+#define SSI_CR1_LFST		(1 << 25)
+#define SSI_CR1_ITFRM		(1 << 24)
+#define SSI_CR1_UNFIN		(1 << 23)
+#define SSI_CR1_MULTS		(1 << 22)
+#define SSI_CR1_FMAT_BIT	20
+#define SSI_CR1_FMAT_MASK	(0x3 << SSI_CR1_FMAT_BIT)
+  #define SSI_CR1_FMAT_SPI	  (0 << SSI_CR1_FMAT_BIT) /* Motorolas SPI format */
+  #define SSI_CR1_FMAT_SSP	  (1 << SSI_CR1_FMAT_BIT) /* TI's SSP format */
+  #define SSI_CR1_FMAT_MW1	  (2 << SSI_CR1_FMAT_BIT) /* National Microwire 1 format */
+  #define SSI_CR1_FMAT_MW2	  (3 << SSI_CR1_FMAT_BIT) /* National Microwire 2 format */
+#define SSI_CR1_TTRG_BIT	16 /* SSI1 TX trigger */
+#define SSI_CR1_TTRG_MASK	(0xf << SSI_CR1_TTRG_BIT) 
+#define SSI_CR1_MCOM_BIT	12
+#define SSI_CR1_MCOM_MASK	(0xf << SSI_CR1_MCOM_BIT)
+  #define SSI_CR1_MCOM_1BIT	  (0x0 << SSI_CR1_MCOM_BIT) /* 1-bit command selected */
+  #define SSI_CR1_MCOM_2BIT	  (0x1 << SSI_CR1_MCOM_BIT) /* 2-bit command selected */
+  #define SSI_CR1_MCOM_3BIT	  (0x2 << SSI_CR1_MCOM_BIT) /* 3-bit command selected */
+  #define SSI_CR1_MCOM_4BIT	  (0x3 << SSI_CR1_MCOM_BIT) /* 4-bit command selected */
+  #define SSI_CR1_MCOM_5BIT	  (0x4 << SSI_CR1_MCOM_BIT) /* 5-bit command selected */
+  #define SSI_CR1_MCOM_6BIT	  (0x5 << SSI_CR1_MCOM_BIT) /* 6-bit command selected */
+  #define SSI_CR1_MCOM_7BIT	  (0x6 << SSI_CR1_MCOM_BIT) /* 7-bit command selected */
+  #define SSI_CR1_MCOM_8BIT	  (0x7 << SSI_CR1_MCOM_BIT) /* 8-bit command selected */
+  #define SSI_CR1_MCOM_9BIT	  (0x8 << SSI_CR1_MCOM_BIT) /* 9-bit command selected */
+  #define SSI_CR1_MCOM_10BIT	  (0x9 << SSI_CR1_MCOM_BIT) /* 10-bit command selected */
+  #define SSI_CR1_MCOM_11BIT	  (0xA << SSI_CR1_MCOM_BIT) /* 11-bit command selected */
+  #define SSI_CR1_MCOM_12BIT	  (0xB << SSI_CR1_MCOM_BIT) /* 12-bit command selected */
+  #define SSI_CR1_MCOM_13BIT	  (0xC << SSI_CR1_MCOM_BIT) /* 13-bit command selected */
+  #define SSI_CR1_MCOM_14BIT	  (0xD << SSI_CR1_MCOM_BIT) /* 14-bit command selected */
+  #define SSI_CR1_MCOM_15BIT	  (0xE << SSI_CR1_MCOM_BIT) /* 15-bit command selected */
+  #define SSI_CR1_MCOM_16BIT	  (0xF << SSI_CR1_MCOM_BIT) /* 16-bit command selected */
+#define SSI_CR1_RTRG_BIT	8 /* SSI RX trigger */
+#define SSI_CR1_RTRG_MASK	(0xf << SSI_CR1_RTRG_BIT)
+#define SSI_CR1_FLEN_BIT	4
+#define SSI_CR1_FLEN_MASK	(0xf << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_2BIT	  (0x0 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_3BIT	  (0x1 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_4BIT	  (0x2 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_5BIT	  (0x3 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_6BIT	  (0x4 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_7BIT	  (0x5 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_8BIT	  (0x6 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_9BIT	  (0x7 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_10BIT	  (0x8 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_11BIT	  (0x9 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_12BIT	  (0xA << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_13BIT	  (0xB << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_14BIT	  (0xC << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_15BIT	  (0xD << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_16BIT	  (0xE << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_17BIT	  (0xF << SSI_CR1_FLEN_BIT)
+#define SSI_CR1_PHA		(1 << 1)
+#define SSI_CR1_POL		(1 << 0)
+
+/* SSI Status Register (SSI_SR) */
+
+#define SSI_SR_TFIFONUM_BIT	16
+#define SSI_SR_TFIFONUM_MASK	(0xff << SSI_SR_TFIFONUM_BIT)
+#define SSI_SR_RFIFONUM_BIT	8
+#define SSI_SR_RFIFONUM_MASK	(0xff << SSI_SR_RFIFONUM_BIT)
+#define SSI_SR_END		(1 << 7)
+#define SSI_SR_BUSY		(1 << 6)
+#define SSI_SR_TFF		(1 << 5)
+#define SSI_SR_RFE		(1 << 4)
+#define SSI_SR_TFHE		(1 << 3)
+#define SSI_SR_RFHF		(1 << 2)
+#define SSI_SR_UNDR		(1 << 1)
+#define SSI_SR_OVER		(1 << 0)
+
+/* SSI Interval Time Control Register (SSI_ITR) */
+
+#define	SSI_ITR_CNTCLK		(1 << 15)
+#define SSI_ITR_IVLTM_BIT	0
+#define SSI_ITR_IVLTM_MASK	(0x7fff << SSI_ITR_IVLTM_BIT)
+
+
+/*************************************************************************
+ * MSC
+ ************************************************************************/
+/* n = 0, 1 (MSC0, MSC1) */
+#define	MSC_STRPCL(n)		(MSC_BASE + (n)*0x1000 + 0x000)
+#define	MSC_STAT(n)		(MSC_BASE + (n)*0x1000 + 0x004)
+#define	MSC_CLKRT(n)		(MSC_BASE + (n)*0x1000 + 0x008)
+#define	MSC_CMDAT(n)		(MSC_BASE + (n)*0x1000 + 0x00C)
+#define	MSC_RESTO(n)		(MSC_BASE + (n)*0x1000 + 0x010)
+#define	MSC_RDTO(n)		(MSC_BASE + (n)*0x1000 + 0x014)
+#define	MSC_BLKLEN(n)		(MSC_BASE + (n)*0x1000 + 0x018)
+#define	MSC_NOB(n)		(MSC_BASE + (n)*0x1000 + 0x01C)
+#define	MSC_SNOB(n)		(MSC_BASE + (n)*0x1000 + 0x020)
+#define	MSC_IMASK(n)		(MSC_BASE + (n)*0x1000 + 0x024)
+#define	MSC_IREG(n)		(MSC_BASE + (n)*0x1000 + 0x028)
+#define	MSC_CMD(n)		(MSC_BASE + (n)*0x1000 + 0x02C)
+#define	MSC_ARG(n)		(MSC_BASE + (n)*0x1000 + 0x030)
+#define	MSC_RES(n)		(MSC_BASE + (n)*0x1000 + 0x034)
+#define	MSC_RXFIFO(n)		(MSC_BASE + (n)*0x1000 + 0x038)
+#define	MSC_TXFIFO(n)		(MSC_BASE + (n)*0x1000 + 0x03C)
+#define	MSC_LPM(n)		(MSC_BASE + (n)*0x1000 + 0x040)
+
+#define	REG_MSC_STRPCL(n)	REG16(MSC_STRPCL(n))
+#define	REG_MSC_STAT(n)		REG32(MSC_STAT(n))
+#define	REG_MSC_CLKRT(n)	REG16(MSC_CLKRT(n))
+#define	REG_MSC_CMDAT(n)	REG32(MSC_CMDAT(n))
+#define	REG_MSC_RESTO(n)	REG16(MSC_RESTO(n))
+#define	REG_MSC_RDTO(n)		REG16(MSC_RDTO(n))
+#define	REG_MSC_BLKLEN(n)	REG16(MSC_BLKLEN(n))
+#define	REG_MSC_NOB(n)		REG16(MSC_NOB(n))
+#define	REG_MSC_SNOB(n)		REG16(MSC_SNOB(n))
+#define	REG_MSC_IMASK(n)	REG32(MSC_IMASK(n))
+#define	REG_MSC_IREG(n)		REG16(MSC_IREG(n))
+#define	REG_MSC_CMD(n)		REG8(MSC_CMD(n))
+#define	REG_MSC_ARG(n)		REG32(MSC_ARG(n))
+#define	REG_MSC_RES(n)		REG16(MSC_RES(n))
+#define	REG_MSC_RXFIFO(n)	REG32(MSC_RXFIFO(n))
+#define	REG_MSC_TXFIFO(n)	REG32(MSC_TXFIFO(n))
+#define	REG_MSC_LPM(n)		REG32(MSC_LPM(n))
+
+/* MSC Clock and Control Register (MSC_STRPCL) */
+#define MSC_STRPCL_SEND_CCSD		(1 << 15) /*send command completion signal disable to ceata */
+#define MSC_STRPCL_SEND_AS_CCSD		(1 << 14) /*send internally generated stop after sending ccsd */
+#define MSC_STRPCL_EXIT_MULTIPLE	(1 << 7)
+#define MSC_STRPCL_EXIT_TRANSFER	(1 << 6)
+#define MSC_STRPCL_START_READWAIT	(1 << 5)
+#define MSC_STRPCL_STOP_READWAIT	(1 << 4)
+#define MSC_STRPCL_RESET		(1 << 3)
+#define MSC_STRPCL_START_OP		(1 << 2)
+#define MSC_STRPCL_CLOCK_CONTROL_BIT	0
+#define MSC_STRPCL_CLOCK_CONTROL_MASK	(0x3 << MSC_STRPCL_CLOCK_CONTROL_BIT)
+  #define MSC_STRPCL_CLOCK_CONTROL_STOP	  (0x1 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Stop MMC/SD clock */
+  #define MSC_STRPCL_CLOCK_CONTROL_START  (0x2 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Start MMC/SD clock */
+
+/* MSC Status Register (MSC_STAT) */
+#define MSC_STAT_AUTO_CMD_DONE		(1 << 31) /*12 is internally generated by controller has finished */
+#define MSC_STAT_IS_RESETTING		(1 << 15)
+#define MSC_STAT_SDIO_INT_ACTIVE	(1 << 14)
+#define MSC_STAT_PRG_DONE		(1 << 13)
+#define MSC_STAT_DATA_TRAN_DONE		(1 << 12)
+#define MSC_STAT_END_CMD_RES		(1 << 11)
+#define MSC_STAT_DATA_FIFO_AFULL	(1 << 10)
+#define MSC_STAT_IS_READWAIT		(1 << 9)
+#define MSC_STAT_CLK_EN			(1 << 8)
+#define MSC_STAT_DATA_FIFO_FULL		(1 << 7)
+#define MSC_STAT_DATA_FIFO_EMPTY	(1 << 6)
+#define MSC_STAT_CRC_RES_ERR		(1 << 5)
+#define MSC_STAT_CRC_READ_ERROR		(1 << 4)
+#define MSC_STAT_CRC_WRITE_ERROR_BIT	2
+#define MSC_STAT_CRC_WRITE_ERROR_MASK	(0x3 << MSC_STAT_CRC_WRITE_ERROR_BIT)
+  #define MSC_STAT_CRC_WRITE_ERROR_NO		(0 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No error on transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR		(1 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* Card observed erroneous transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR_NOSTS	(2 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No CRC status is sent back */
+#define MSC_STAT_TIME_OUT_RES		(1 << 1)
+#define MSC_STAT_TIME_OUT_READ		(1 << 0)
+
+/* MSC Bus Clock Control Register (MSC_CLKRT) */
+#define	MSC_CLKRT_CLK_RATE_BIT		0
+#define	MSC_CLKRT_CLK_RATE_MASK		(0x7 << MSC_CLKRT_CLK_RATE_BIT)
+  #define MSC_CLKRT_CLK_RATE_DIV_1	(0x0 << MSC_CLKRT_CLK_RATE_BIT) /* CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_2	(0x1 << MSC_CLKRT_CLK_RATE_BIT) /* 1/2 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_4	(0x2 << MSC_CLKRT_CLK_RATE_BIT) /* 1/4 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_8	(0x3 << MSC_CLKRT_CLK_RATE_BIT) /* 1/8 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_16	(0x4 << MSC_CLKRT_CLK_RATE_BIT) /* 1/16 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_32	(0x5 << MSC_CLKRT_CLK_RATE_BIT) /* 1/32 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_64	(0x6 << MSC_CLKRT_CLK_RATE_BIT) /* 1/64 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_128	(0x7 << MSC_CLKRT_CLK_RATE_BIT) /* 1/128 of CLK_SRC */
+
+/* MSC Command Sequence Control Register (MSC_CMDAT) */
+#define	MSC_CMDAT_CCS_EXPECTED		(1 << 31) /* interrupts are enabled in ce-ata */
+#define	MSC_CMDAT_READ_CEATA		(1 << 30)
+#define	MSC_CMDAT_SDIO_PRDT		(1 << 17) /* exact 2 cycle */
+#define	MSC_CMDAT_SEND_AS_STOP		(1 << 16)
+#define	MSC_CMDAT_RTRG_BIT		14
+  #define MSC_CMDAT_RTRG_EQUALT_8	(0x0 << MSC_CMDAT_RTRG_BIT)
+  #define MSC_CMDAT_RTRG_EQUALT_16	(0x1 << MSC_CMDAT_RTRG_BIT) /* reset value */
+  #define MSC_CMDAT_RTRG_EQUALT_24	(0x2 << MSC_CMDAT_RTRG_BIT)
+
+#define	MSC_CMDAT_TTRG_BIT		12
+  #define MSC_CMDAT_TTRG_LESS_8		(0x0 << MSC_CMDAT_TTRG_BIT)
+  #define MSC_CMDAT_TTRG_LESS_16	(0x1 << MSC_CMDAT_TTRG_BIT) /*reset value  */
+  #define MSC_CMDAT_TTRG_LESS_24	(0x2 << MSC_CMDAT_TTRG_BIT)
+#define	MSC_CMDAT_STOP_ABORT		(1 << 11)
+#define	MSC_CMDAT_BUS_WIDTH_BIT		9
+#define	MSC_CMDAT_BUS_WIDTH_MASK	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define MSC_CMDAT_BUS_WIDTH_1BIT	(0x0 << MSC_CMDAT_BUS_WIDTH_BIT) /* 1-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_4BIT	(0x2 << MSC_CMDAT_BUS_WIDTH_BIT) /* 4-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_8BIT	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT) /* 8-bit data bus */
+#define	MSC_CMDAT_DMA_EN		(1 << 8)
+#define	MSC_CMDAT_INIT			(1 << 7)
+#define	MSC_CMDAT_BUSY			(1 << 6)
+#define	MSC_CMDAT_STREAM_BLOCK		(1 << 5)
+#define	MSC_CMDAT_WRITE			(1 << 4)
+#define	MSC_CMDAT_READ			(0 << 4)
+#define	MSC_CMDAT_DATA_EN		(1 << 3)
+#define	MSC_CMDAT_RESPONSE_BIT	0
+#define	MSC_CMDAT_RESPONSE_MASK	(0x7 << MSC_CMDAT_RESPONSE_BIT)
+  #define MSC_CMDAT_RESPONSE_NONE (0x0 << MSC_CMDAT_RESPONSE_BIT) /* No response */
+  #define MSC_CMDAT_RESPONSE_R1	  (0x1 << MSC_CMDAT_RESPONSE_BIT) /* Format R1 and R1b */
+  #define MSC_CMDAT_RESPONSE_R2	  (0x2 << MSC_CMDAT_RESPONSE_BIT) /* Format R2 */
+  #define MSC_CMDAT_RESPONSE_R3	  (0x3 << MSC_CMDAT_RESPONSE_BIT) /* Format R3 */
+  #define MSC_CMDAT_RESPONSE_R4	  (0x4 << MSC_CMDAT_RESPONSE_BIT) /* Format R4 */
+  #define MSC_CMDAT_RESPONSE_R5	  (0x5 << MSC_CMDAT_RESPONSE_BIT) /* Format R5 */
+  #define MSC_CMDAT_RESPONSE_R6	  (0x6 << MSC_CMDAT_RESPONSE_BIT) /* Format R6 */
+
+#define	CMDAT_DMA_EN	(1 << 8)
+#define	CMDAT_INIT	(1 << 7)
+#define	CMDAT_BUSY	(1 << 6)
+#define	CMDAT_STREAM	(1 << 5)
+#define	CMDAT_WRITE	(1 << 4)
+#define	CMDAT_DATA_EN	(1 << 3)
+
+/* MSC Interrupts Mask Register (MSC_IMASK) */
+#define	MSC_IMASK_AUTO_CMD_DONE		(1 << 8)
+#define	MSC_IMASK_SDIO			(1 << 7)
+#define	MSC_IMASK_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IMASK_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IMASK_END_CMD_RES		(1 << 2)
+#define	MSC_IMASK_PRG_DONE		(1 << 1)
+#define	MSC_IMASK_DATA_TRAN_DONE	(1 << 0)
+
+/* MSC Interrupts Status Register (MSC_IREG) */
+#define	MSC_IREG_AUTO_CMD_DONE		(1 << 8)
+#define	MSC_IREG_SDIO			(1 << 7)
+#define	MSC_IREG_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IREG_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IREG_END_CMD_RES		(1 << 2)
+#define	MSC_IREG_PRG_DONE		(1 << 1)
+#define	MSC_IREG_DATA_TRAN_DONE		(1 << 0)
+
+/* MSC Low Power Mode Register (MSC_LPM) */
+#define	MSC_SET_LPM			(1 << 0)
+
+/*************************************************************************
+ * EMC (External Memory Controller)
+ *************************************************************************/
+#define EMC_BCR    	(EMC_BASE + 0x00)  /* Bus Control Register */
+#define EMC_SMCR0	(EMC_BASE + 0x10)  /* Static Memory Control Register 0 */
+#define EMC_SMCR1	(EMC_BASE + 0x14)  /* Static Memory Control Register 1 */
+#define EMC_SMCR2	(EMC_BASE + 0x18)  /* Static Memory Control Register 2 */
+#define EMC_SMCR3	(EMC_BASE + 0x1c)  /* Static Memory Control Register 3 */
+#define EMC_SMCR4	(EMC_BASE + 0x20)  /* Static Memory Control Register 4 */
+#define EMC_SACR0	(EMC_BASE + 0x30)  /* Static Memory Bank 0 Addr Config Reg */
+#define EMC_SACR1	(EMC_BASE + 0x34)  /* Static Memory Bank 1 Addr Config Reg */
+#define EMC_SACR2	(EMC_BASE + 0x38)  /* Static Memory Bank 2 Addr Config Reg */
+#define EMC_SACR3	(EMC_BASE + 0x3c)  /* Static Memory Bank 3 Addr Config Reg */
+#define EMC_SACR4	(EMC_BASE + 0x40)  /* Static Memory Bank 4 Addr Config Reg */
+
+#define EMC_NFCSR	(EMC_BASE + 0x050) /* NAND Flash Control/Status Register */
+
+#define EMC_DMCR	(EMC_BASE + 0x80)  /* DRAM Control Register */
+#define EMC_RTCSR	(EMC_BASE + 0x84)  /* Refresh Time Control/Status Register */
+#define EMC_RTCNT	(EMC_BASE + 0x88)  /* Refresh Timer Counter */
+#define EMC_RTCOR	(EMC_BASE + 0x8c)  /* Refresh Time Constant Register */
+#define EMC_DMAR0	(EMC_BASE + 0x90)  /* SDRAM Bank 0 Addr Config Register */
+#define EMC_DMAR1	(EMC_BASE + 0x94)  /* SDRAM Bank 1 Addr Config Register */
+#define EMC_SDMR0	(EMC_BASE + 0xa000) /* Mode Register of SDRAM bank 0 */
+
+#define REG_EMC_BCR 	REG32(EMC_BCR)
+#define REG_EMC_SMCR0	REG32(EMC_SMCR0)
+#define REG_EMC_SMCR1	REG32(EMC_SMCR1)
+#define REG_EMC_SMCR2	REG32(EMC_SMCR2)
+#define REG_EMC_SMCR3	REG32(EMC_SMCR3)
+#define REG_EMC_SMCR4	REG32(EMC_SMCR4)
+#define REG_EMC_SACR0	REG32(EMC_SACR0)
+#define REG_EMC_SACR1	REG32(EMC_SACR1)
+#define REG_EMC_SACR2	REG32(EMC_SACR2)
+#define REG_EMC_SACR3	REG32(EMC_SACR3)
+#define REG_EMC_SACR4	REG32(EMC_SACR4)
+
+#define REG_EMC_NFCSR	REG32(EMC_NFCSR)
+
+#define REG_EMC_DMCR	REG32(EMC_DMCR)
+#define REG_EMC_RTCSR	REG16(EMC_RTCSR)
+#define REG_EMC_RTCNT	REG16(EMC_RTCNT)
+#define REG_EMC_RTCOR	REG16(EMC_RTCOR)
+#define REG_EMC_DMAR0	REG32(EMC_DMAR0)
+#define REG_EMC_DMAR1	REG32(EMC_DMAR1)
+
+/* Bus Control Register */
+#define EMC_BCR_BT_SEL_BIT      30
+#define EMC_BCR_BT_SEL_MASK     (0x3 << EMC_BCR_BT_SEL_BIT)
+#define EMC_BCR_PK_SEL          (1 << 24)
+#define EMC_BCR_BSR_MASK          (1 << 2)  /* Nand and SDRAM Bus Share Select: 0, share; 1, unshare */
+  #define EMC_BCR_BSR_SHARE       (0 << 2)
+  #define EMC_BCR_BSR_UNSHARE     (1 << 2)
+#define EMC_BCR_BRE             (1 << 1)
+#define EMC_BCR_ENDIAN          (1 << 0)
+
+/* Static Memory Control Register */
+#define EMC_SMCR_STRV_BIT	24
+#define EMC_SMCR_STRV_MASK	(0x0f << EMC_SMCR_STRV_BIT)
+#define EMC_SMCR_TAW_BIT	20
+#define EMC_SMCR_TAW_MASK	(0x0f << EMC_SMCR_TAW_BIT)
+#define EMC_SMCR_TBP_BIT	16
+#define EMC_SMCR_TBP_MASK	(0x0f << EMC_SMCR_TBP_BIT)
+#define EMC_SMCR_TAH_BIT	12
+#define EMC_SMCR_TAH_MASK	(0x07 << EMC_SMCR_TAH_BIT)
+#define EMC_SMCR_TAS_BIT	8
+#define EMC_SMCR_TAS_MASK	(0x07 << EMC_SMCR_TAS_BIT)
+#define EMC_SMCR_BW_BIT		6
+#define EMC_SMCR_BW_MASK	(0x03 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_8BIT	(0 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_16BIT	(1 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_32BIT	(2 << EMC_SMCR_BW_BIT)
+#define EMC_SMCR_BCM		(1 << 3)
+#define EMC_SMCR_BL_BIT		1
+#define EMC_SMCR_BL_MASK	(0x03 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_4		(0 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_8		(1 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_16	(2 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_32	(3 << EMC_SMCR_BL_BIT)
+#define EMC_SMCR_SMT		(1 << 0)
+
+/* Static Memory Bank Addr Config Reg */
+#define EMC_SACR_BASE_BIT	8
+#define EMC_SACR_BASE_MASK	(0xff << EMC_SACR_BASE_BIT)
+#define EMC_SACR_MASK_BIT	0
+#define EMC_SACR_MASK_MASK	(0xff << EMC_SACR_MASK_BIT)
+
+/* NAND Flash Control/Status Register */
+#define EMC_NFCSR_NFCE4		(1 << 7) /* NAND Flash Enable */
+#define EMC_NFCSR_NFE4		(1 << 6) /* NAND Flash FCE# Assertion Enable */
+#define EMC_NFCSR_NFCE3		(1 << 5)
+#define EMC_NFCSR_NFE3		(1 << 4)
+#define EMC_NFCSR_NFCE2		(1 << 3)
+#define EMC_NFCSR_NFE2		(1 << 2)
+#define EMC_NFCSR_NFCE1		(1 << 1)
+#define EMC_NFCSR_NFE1		(1 << 0)
+
+/* DRAM Control Register */
+#define EMC_DMCR_BW_BIT		31
+#define EMC_DMCR_BW		(1 << EMC_DMCR_BW_BIT)
+#define EMC_DMCR_CA_BIT		26
+#define EMC_DMCR_CA_MASK	(0x07 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_8		(0 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_9		(1 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_10	(2 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_11	(3 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_12	(4 << EMC_DMCR_CA_BIT)
+#define EMC_DMCR_RMODE		(1 << 25)
+#define EMC_DMCR_RFSH		(1 << 24)
+#define EMC_DMCR_MRSET		(1 << 23)
+#define EMC_DMCR_RA_BIT		20
+#define EMC_DMCR_RA_MASK	(0x03 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_11	(0 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_12	(1 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_13	(2 << EMC_DMCR_RA_BIT)
+#define EMC_DMCR_BA_BIT		19
+#define EMC_DMCR_BA		(1 << EMC_DMCR_BA_BIT)
+#define EMC_DMCR_PDM		(1 << 18)
+#define EMC_DMCR_EPIN		(1 << 17)
+#define EMC_DMCR_MBSEL		(1 << 16)
+#define EMC_DMCR_TRAS_BIT	13
+#define EMC_DMCR_TRAS_MASK	(0x07 << EMC_DMCR_TRAS_BIT)
+#define EMC_DMCR_RCD_BIT	11
+#define EMC_DMCR_RCD_MASK	(0x03 << EMC_DMCR_RCD_BIT)
+#define EMC_DMCR_TPC_BIT	8
+#define EMC_DMCR_TPC_MASK	(0x07 << EMC_DMCR_TPC_BIT)
+#define EMC_DMCR_TRWL_BIT	5
+#define EMC_DMCR_TRWL_MASK	(0x03 << EMC_DMCR_TRWL_BIT)
+#define EMC_DMCR_TRC_BIT	2
+#define EMC_DMCR_TRC_MASK	(0x07 << EMC_DMCR_TRC_BIT)
+#define EMC_DMCR_TCL_BIT	0
+#define EMC_DMCR_TCL_MASK	(0x03 << EMC_DMCR_TCL_BIT)
+
+/* Refresh Time Control/Status Register */
+#define EMC_RTCSR_SFR		(1 << 8)    /* self refresh flag */
+#define EMC_RTCSR_CMF		(1 << 7)
+#define EMC_RTCSR_CKS_BIT	0
+#define EMC_RTCSR_CKS_MASK	(0x07 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_DISABLE	(0 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4	(1 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_16	(2 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_64	(3 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_256	(4 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_1024	(5 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_2048	(6 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4096	(7 << EMC_RTCSR_CKS_BIT)
+
+/* SDRAM Bank Address Configuration Register */
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_BIT	0
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+/* Mode Register of SDRAM bank 0 */
+#define EMC_SDMR_BM		(1 << 9) /* Write Burst Mode */
+#define EMC_SDMR_OM_BIT		7        /* Operating Mode */
+#define EMC_SDMR_OM_MASK	(3 << EMC_SDMR_OM_BIT)
+  #define EMC_SDMR_OM_NORMAL	(0 << EMC_SDMR_OM_BIT)
+#define EMC_SDMR_CAS_BIT	4        /* CAS Latency */
+#define EMC_SDMR_CAS_MASK	(7 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_1	(1 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_2	(2 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_3	(3 << EMC_SDMR_CAS_BIT)
+#define EMC_SDMR_BT_BIT		3        /* Burst Type */
+#define EMC_SDMR_BT_MASK	(1 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_SEQ	(0 << EMC_SDMR_BT_BIT) /* Sequential */
+  #define EMC_SDMR_BT_INT	(1 << EMC_SDMR_BT_BIT) /* Interleave */
+#define EMC_SDMR_BL_BIT		0        /* Burst Length */
+#define EMC_SDMR_BL_MASK	(7 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_1		(0 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_2		(1 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_4		(2 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_8		(3 << EMC_SDMR_BL_BIT)
+
+#define EMC_SDMR_CAS2_16BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS2_32BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+#define EMC_SDMR_CAS3_16BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS3_32BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+
+
+/*************************************************************************
+ * CIM
+ *************************************************************************/
+#define	CIM_CFG			(CIM_BASE + 0x0000)
+#define	CIM_CTRL		(CIM_BASE + 0x0004)
+#define	CIM_STATE		(CIM_BASE + 0x0008)
+#define	CIM_IID			(CIM_BASE + 0x000C)
+#define	CIM_RXFIFO		(CIM_BASE + 0x0010)
+#define	CIM_DA			(CIM_BASE + 0x0020)
+#define	CIM_FA			(CIM_BASE + 0x0024)
+#define	CIM_FID			(CIM_BASE + 0x0028)
+#define	CIM_CMD			(CIM_BASE + 0x002C)
+#define	CIM_SIZE		(CIM_BASE + 0x0030)
+#define	CIM_OFFSET		(CIM_BASE + 0x0034)
+#define	CIM_RAM_ADDR		(CIM_BASE + 0x1000)
+
+#define	REG_CIM_CFG		REG32(CIM_CFG)
+#define	REG_CIM_CTRL		REG32(CIM_CTRL)
+#define	REG_CIM_STATE		REG32(CIM_STATE)
+#define	REG_CIM_IID		REG32(CIM_IID)
+#define	REG_CIM_RXFIFO		REG32(CIM_RXFIFO)
+#define	REG_CIM_DA		REG32(CIM_DA)
+#define	REG_CIM_FA		REG32(CIM_FA)
+#define	REG_CIM_FID		REG32(CIM_FID)
+#define	REG_CIM_CMD		REG32(CIM_CMD)
+#define	REG_CIM_SIZE		REG32(CIM_SIZE)
+#define	REG_CIM_OFFSET		REG32(CIM_OFFSET)
+
+/* CIM Configuration Register  (CIM_CFG) */
+
+#define	CIM_CFG_ORDER_BIT	18
+#define	CIM_CFG_ORDER_MASK	(0x3 << CIM_CFG_ORDER_BIT)
+  #define CIM_CFG_ORDER_0	  (0x0 << CIM_CFG_ORDER_BIT)
+  #define CIM_CFG_ORDER_1	  (0x1 << CIM_CFG_ORDER_BIT)
+  #define CIM_CFG_ORDER_2	  (0x2 << CIM_CFG_ORDER_BIT)
+  #define CIM_CFG_ORDER_3	  (0x3 << CIM_CFG_ORDER_BIT)
+#define	CIM_CFG_DF_BIT		16
+#define	CIM_CFG_DF_MASK		  (0x3 << CIM_CFG_DF_BIT)
+  #define CIM_CFG_DF_RGB	  (0x0 << CIM_CFG_DF_BIT)
+  #define CIM_CFG_DF_RAWRGB	  CIM_CFG_DF_RGB
+  #define CIM_CFG_DF_BAYERRGB	  CIM_CFG_DF_RGB
+  #define CIM_CFG_DF_YUV444	  (0x1 << CIM_CFG_DF_BIT)
+  #define CIM_CFG_DF_YUV422	  (0x2 << CIM_CFG_DF_BIT)
+  #define CIM_CFG_DF_ITU656	  (0x3 << CIM_CFG_DF_BIT)
+#define	CIM_CFG_INV_DAT		(1 << 15)
+#define	CIM_CFG_VSP		(1 << 14)
+#define	CIM_CFG_HSP		(1 << 13)
+#define	CIM_CFG_PCP		(1 << 12) /* PCLK working edge */
+#define	CIM_CFG_DMA_BUSRT_TYPE_BIT	10
+#define	CIM_CFG_DMA_BUSRT_TYPE_MASK	(0x3 << CIM_CFG_DMA_BUSRT_TYPE_BIT)
+#define	CIM_CFG_DMA_BUSRT_INCR		(0 << CIM_CFG_DMA_BUSRT_TYPE_BIT)
+#define	CIM_CFG_DMA_BUSRT_INCR4		(1 << CIM_CFG_DMA_BUSRT_TYPE_BIT)
+#define	CIM_CFG_DMA_BUSRT_INCR8		(2 << CIM_CFG_DMA_BUSRT_TYPE_BIT)
+#define	CIM_CFG_DUMMY_ZERO	(1 << 9)
+#define	CIM_CFG_EXT_VSYNC	(1 << 8)
+#define	CIM_CFG_PACK_BIT	4
+#define	CIM_CFG_PACK_MASK	(0x7 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_0	  (0 << CIM_CFG_PACK_BIT) /* 11 22 33 44 */
+  #define CIM_CFG_PACK_1	  (1 << CIM_CFG_PACK_BIT) /* 22 33 44 11 */
+  #define CIM_CFG_PACK_2	  (2 << CIM_CFG_PACK_BIT) /* 33 44 11 22 */
+  #define CIM_CFG_PACK_3	  (3 << CIM_CFG_PACK_BIT) /* 44 11 22 33 */
+  #define CIM_CFG_PACK_4	  (4 << CIM_CFG_PACK_BIT) /* 44 33 22 11 */
+  #define CIM_CFG_PACK_5	  (5 << CIM_CFG_PACK_BIT) /* 33 22 11 44 */
+  #define CIM_CFG_PACK_6	  (6 << CIM_CFG_PACK_BIT) /* 22 11 44 33 */
+  #define CIM_CFG_PACK_7	  (7 << CIM_CFG_PACK_BIT) /* 11 44 33 22 */
+#define	CIM_CFG_BYPASS_BIT	2
+#define	CIM_CFG_BYPASS_MASK	(1 << CIM_CFG_BYPASS_BIT)
+  #define CIM_CFG_BYPASS	  (1 << CIM_CFG_BYPASS_BIT)
+#define	CIM_CFG_DSM_BIT		0
+#define	CIM_CFG_DSM_MASK	(0x3 << CIM_CFG_DSM_BIT)
+  #define CIM_CFG_DSM_CPM	  (0 << CIM_CFG_DSM_BIT) /* CCIR656 Progressive Mode */
+  #define CIM_CFG_DSM_CIM	  (1 << CIM_CFG_DSM_BIT) /* CCIR656 Interlace Mode */
+  #define CIM_CFG_DSM_GCM	  (2 << CIM_CFG_DSM_BIT) /* Gated Clock Mode */
+  #define CIM_CFG_DSM_NGCM	  (3 << CIM_CFG_DSM_BIT) /* Non-Gated Clock Mode */
+
+/* CIM Control Register  (CIM_CTRL) */
+
+#define	CIM_CTRL_MCLKDIV_BIT	24
+#define	CIM_CTRL_MCLKDIV_MASK	(0xff << CIM_CTRL_MCLKDIV_BIT)
+#define	CIM_CTRL_FRC_BIT	16
+#define	CIM_CTRL_FRC_MASK	(0xf << CIM_CTRL_FRC_BIT)
+  #define CIM_CTRL_FRC_1	  (0x0 << CIM_CTRL_FRC_BIT) /* Sample every frame */
+  #define CIM_CTRL_FRC_2	  (0x1 << CIM_CTRL_FRC_BIT) /* Sample 1/2 frame */
+  #define CIM_CTRL_FRC_3	  (0x2 << CIM_CTRL_FRC_BIT) /* Sample 1/3 frame */
+  #define CIM_CTRL_FRC_4	  (0x3 << CIM_CTRL_FRC_BIT) /* Sample 1/4 frame */
+  #define CIM_CTRL_FRC_5	  (0x4 << CIM_CTRL_FRC_BIT) /* Sample 1/5 frame */
+  #define CIM_CTRL_FRC_6	  (0x5 << CIM_CTRL_FRC_BIT) /* Sample 1/6 frame */
+  #define CIM_CTRL_FRC_7	  (0x6 << CIM_CTRL_FRC_BIT) /* Sample 1/7 frame */
+  #define CIM_CTRL_FRC_8	  (0x7 << CIM_CTRL_FRC_BIT) /* Sample 1/8 frame */
+  #define CIM_CTRL_FRC_9	  (0x8 << CIM_CTRL_FRC_BIT) /* Sample 1/9 frame */
+  #define CIM_CTRL_FRC_10	  (0x9 << CIM_CTRL_FRC_BIT) /* Sample 1/10 frame */
+  #define CIM_CTRL_FRC_11	  (0xA << CIM_CTRL_FRC_BIT) /* Sample 1/11 frame */
+  #define CIM_CTRL_FRC_12	  (0xB << CIM_CTRL_FRC_BIT) /* Sample 1/12 frame */
+  #define CIM_CTRL_FRC_13	  (0xC << CIM_CTRL_FRC_BIT) /* Sample 1/13 frame */
+  #define CIM_CTRL_FRC_14	  (0xD << CIM_CTRL_FRC_BIT) /* Sample 1/14 frame */
+  #define CIM_CTRL_FRC_15	  (0xE << CIM_CTRL_FRC_BIT) /* Sample 1/15 frame */
+  #define CIM_CTRL_FRC_16	  (0xF << CIM_CTRL_FRC_BIT) /* Sample 1/16 frame */
+#define	CIM_CTRL_SIZEEN_BIT	14
+#define	CIM_CTRL_SIZEEN_MASK	(0x1 << CIM_CTRL_SIZEEN_BIT)
+#define	CIM_CTRL_SIZEEN		(0x1 << CIM_CTRL_SIZEEN_BIT)
+#define	CIM_CTRL_VDDM		(1 << 13) /* VDD interrupt enable */
+#define	CIM_CTRL_DMA_SOFM	(1 << 12)
+#define	CIM_CTRL_DMA_EOFM	(1 << 11)
+#define	CIM_CTRL_DMA_STOPM	(1 << 10)
+#define	CIM_CTRL_RXF_TRIGM	(1 << 9)
+#define	CIM_CTRL_RXF_OFM	(1 << 8)
+#define	CIM_CTRL_RXF_TRIG_BIT	4
+#define	CIM_CTRL_RXF_TRIG_MASK	(0x7 << CIM_CTRL_RXF_TRIG_BIT)
+  #define CIM_CTRL_RXF_TRIG_4	  (0 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 4 */
+  #define CIM_CTRL_RXF_TRIG_8	  (1 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 8 */
+  #define CIM_CTRL_RXF_TRIG_12	  (2 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 12 */
+  #define CIM_CTRL_RXF_TRIG_16	  (3 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 16 */
+  #define CIM_CTRL_RXF_TRIG_20	  (4 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 20 */
+  #define CIM_CTRL_RXF_TRIG_24	  (5 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 24 */
+  #define CIM_CTRL_RXF_TRIG_28	  (6 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 28 */
+  #define CIM_CTRL_RXF_TRIG_32	  (7 << CIM_CTRL_RXF_TRIG_BIT) /* RXFIFO Trigger Value is 32 */
+#define	CIM_CTRL_FAST_MODE_MASK	(1 << 3) /* CIM fast mode mask */
+#define	CIM_CTRL_FAST_MODE	(1 << 3) /* CIM works in fast mode */
+#define	CIM_CTRL_NORMAL_MODE	(0 << 3) /* CIM works in normal mode */
+#define	CIM_CTRL_DMA_EN		(1 << 2) /* Enable DMA */
+#define	CIM_CTRL_RXF_RST	(1 << 1) /* RxFIFO reset */
+#define	CIM_CTRL_ENA		(1 << 0) /* Enable CIM */
+
+/* CIM State Register  (CIM_STATE) */
+
+#define	CIM_STATE_DMA_SOF	(1 << 6) /* DMA start irq */
+#define	CIM_STATE_DMA_EOF	(1 << 5) /* DMA end irq */
+#define	CIM_STATE_DMA_STOP	(1 << 4) /* DMA stop irq */
+#define	CIM_STATE_RXF_OF	(1 << 3) /* RXFIFO over flow irq */
+#define	CIM_STATE_RXF_TRIG	(1 << 2) /* RXFIFO triger meet irq */
+#define	CIM_STATE_RXF_EMPTY	(1 << 1) /* RXFIFO empty irq */
+#define	CIM_STATE_VDD		(1 << 0) /* CIM disabled irq */
+
+/* CIM DMA Command Register (CIM_CMD) */
+
+#define	CIM_CMD_SOFINT		(1 << 31) /* enable DMA start irq */
+#define	CIM_CMD_EOFINT		(1 << 30) /* enable DMA end irq */
+#define	CIM_CMD_STOP		(1 << 28) /* enable DMA stop irq */
+#define	CIM_CMD_LEN_BIT		0
+#define	CIM_CMD_LEN_MASK	(0xffffff << CIM_CMD_LEN_BIT)
+
+/* CIM Image Size Register  (CIM_SIZE) */
+#define	CIM_SIZE_LPF_BIT	16 /* Lines per freame for csc output image */
+#define	CIM_SIZE_LPF_MASK	(0x1fff << CIM_SIZE_LPF_BIT)
+#define	CIM_SIZE_PPL_BIT	0 /* Pixels per line for csc output image, should be an even number */
+#define	CIM_SIZE_PPL_MASK	(0x1fff << CIM_SIZE_PPL_BIT)
+
+/* CIM Image Offset Register  (CIM_OFFSET) */
+#define	CIM_OFFSET_V_BIT	16 /* Vertical offset */
+#define	CIM_OFFSET_V_MASK	(0xfff << CIM_OFFSET_V_BIT)
+#define	CIM_OFFSET_H_BIT	0 /* Horizontal offset, should be an enen number */
+#define	CIM_OFFSET_H_MASK	(0xfff << CIM_OFFSET_H_BIT) /*OFFSET_H should be even number*/
+
+/*************************************************************************
+ * SADC (Smart A/D Controller)
+ *************************************************************************/
+
+#define SADC_ENA	(SADC_BASE + 0x00)  /* ADC Enable Register */
+#define SADC_CFG	(SADC_BASE + 0x04)  /* ADC Configure Register */
+#define SADC_CTRL	(SADC_BASE + 0x08)  /* ADC Control Register */
+#define SADC_STATE	(SADC_BASE + 0x0C)  /* ADC Status Register*/
+#define SADC_SAMETIME	(SADC_BASE + 0x10)  /* ADC Same Point Time Register */
+#define SADC_WAITTIME	(SADC_BASE + 0x14)  /* ADC Wait Time Register */
+#define SADC_TSDAT	(SADC_BASE + 0x18)  /* ADC Touch Screen Data Register */
+#define SADC_BATDAT	(SADC_BASE + 0x1C)  /* ADC PBAT Data Register */
+#define SADC_SADDAT	(SADC_BASE + 0x20)  /* ADC SADCIN Data Register */
+#define SADC_ADCLK	(SADC_BASE + 0x28)  /* ADC Clock Divide Register */
+
+#define REG_SADC_ENA		REG8(SADC_ENA)
+#define REG_SADC_CFG		REG32(SADC_CFG)
+#define REG_SADC_CTRL		REG8(SADC_CTRL)
+#define REG_SADC_STATE		REG8(SADC_STATE)
+#define REG_SADC_SAMETIME	REG16(SADC_SAMETIME)
+#define REG_SADC_WAITTIME	REG16(SADC_WAITTIME)
+#define REG_SADC_TSDAT		REG32(SADC_TSDAT)
+#define REG_SADC_BATDAT		REG16(SADC_BATDAT)
+#define REG_SADC_SADDAT		REG16(SADC_SADDAT)
+#define REG_SADC_ADCLK		REG32(SADC_ADCLK)
+
+/* ADC Enable Register */
+#define SADC_ENA_ADEN		(1 << 7)  /* Touch Screen Enable */
+#define SADC_ENA_ENTR_SLP	(1 << 6)  /* Touch Screen Enable */
+#define SADC_ENA_EXIT_SLP	(1 << 5)  /* Touch Screen Enable */
+#define SADC_ENA_TSEN		(1 << 2)  /* Touch Screen Enable */
+#define SADC_ENA_PBATEN		(1 << 1)  /* PBAT Enable */
+#define SADC_ENA_SADCINEN	(1 << 0)  /* SADCIN Enable */
+
+/* ADC Configure Register */
+#define SADC_CFG_EXIN           (1 << 30)
+#define SADC_CFG_CLKOUT_NUM_BIT	16
+#define SADC_CFG_CLKOUT_NUM_MASK (0x7 << SADC_CFG_CLKOUT_NUM_BIT)
+#define SADC_CFG_TS_DMA		(1 << 15)  /* Touch Screen DMA Enable */
+#define SADC_CFG_XYZ_BIT	13  /* XYZ selection */
+#define SADC_CFG_XYZ_MASK	(0x3 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XY		(0 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ		(1 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ1Z2	(2 << SADC_CFG_XYZ_BIT)
+#define SADC_CFG_SNUM_BIT	10  /* Sample Number */
+#define SADC_CFG_SNUM_MASK	(0x7 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_1	(0x0 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_2	(0x1 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_3	(0x2 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_4	(0x3 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_5	(0x4 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_6	(0x5 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_8	(0x6 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_9	(0x7 << SADC_CFG_SNUM_BIT)
+#define SADC_CFG_CLKDIV_BIT	5  /* AD Converter frequency clock divider */
+#define SADC_CFG_CLKDIV_MASK	(0x1f << SADC_CFG_CLKDIV_BIT)
+#define SADC_CFG_PBAT_HIGH	(0 << 4)  /* PBAT >= 2.5V */
+#define SADC_CFG_PBAT_LOW	(1 << 4)  /* PBAT < 2.5V */
+#define SADC_CFG_CMD_BIT	0  /* ADC Command */
+#define SADC_CFG_CMD_MASK	(0xf << SADC_CFG_CMD_BIT)
+  #define SADC_CFG_CMD_X_SE	(0x0 << SADC_CFG_CMD_BIT) /* X Single-End */
+  #define SADC_CFG_CMD_Y_SE	(0x1 << SADC_CFG_CMD_BIT) /* Y Single-End */
+  #define SADC_CFG_CMD_X_DIFF	(0x2 << SADC_CFG_CMD_BIT) /* X Differential */
+  #define SADC_CFG_CMD_Y_DIFF	(0x3 << SADC_CFG_CMD_BIT) /* Y Differential */
+  #define SADC_CFG_CMD_Z1_DIFF	(0x4 << SADC_CFG_CMD_BIT) /* Z1 Differential */
+  #define SADC_CFG_CMD_Z2_DIFF	(0x5 << SADC_CFG_CMD_BIT) /* Z2 Differential */
+  #define SADC_CFG_CMD_Z3_DIFF	(0x6 << SADC_CFG_CMD_BIT) /* Z3 Differential */
+  #define SADC_CFG_CMD_Z4_DIFF	(0x7 << SADC_CFG_CMD_BIT) /* Z4 Differential */
+  #define SADC_CFG_CMD_TP_SE	(0x8 << SADC_CFG_CMD_BIT) /* Touch Pressure */
+  #define SADC_CFG_CMD_PBATH_SE	(0x9 << SADC_CFG_CMD_BIT) /* PBAT >= 2.5V */
+  #define SADC_CFG_CMD_PBATL_SE	(0xa << SADC_CFG_CMD_BIT) /* PBAT < 2.5V */
+  #define SADC_CFG_CMD_SADCIN_SE (0xb << SADC_CFG_CMD_BIT) /* Measure SADCIN */
+  #define SADC_CFG_CMD_INT_PEN	(0xc << SADC_CFG_CMD_BIT) /* INT_PEN Enable */
+
+/* ADC Control Register */
+#define SADC_CTRL_SLPENDM	(1 << 5)  /* sleep Interrupt Mask */
+#define SADC_CTRL_PENDM		(1 << 4)  /* Pen Down Interrupt Mask */
+#define SADC_CTRL_PENUM		(1 << 3)  /* Pen Up Interrupt Mask */
+#define SADC_CTRL_TSRDYM	(1 << 2)  /* Touch Screen Data Ready Interrupt Mask */
+#define SADC_CTRL_PBATRDYM	(1 << 1)  /* PBAT Data Ready Interrupt Mask */
+#define SADC_CTRL_SRDYM		(1 << 0)  /* SADCIN Data Ready Interrupt Mask */
+
+/* ADC Status Register */
+#define SADC_STATE_SLEEPND	(1 << 5)  /* Pen Down Interrupt Flag */
+#define SADC_STATE_PEND		(1 << 4)  /* Pen Down Interrupt Flag */
+#define SADC_STATE_PENU		(1 << 3)  /* Pen Up Interrupt Flag */
+#define SADC_STATE_TSRDY	(1 << 2)  /* Touch Screen Data Ready Interrupt Flag */
+#define SADC_STATE_PBATRDY	(1 << 1)  /* PBAT Data Ready Interrupt Flag */
+#define SADC_STATE_SRDY		(1 << 0)  /* SADCIN Data Ready Interrupt Flag */
+
+/* ADC Touch Screen Data Register */
+#define SADC_TSDAT_DATA0_BIT	0
+#define SADC_TSDAT_DATA0_MASK	(0xfff << SADC_TSDAT_DATA0_BIT)
+#define SADC_TSDAT_TYPE0	(1 << 15)
+#define SADC_TSDAT_DATA1_BIT	16
+#define SADC_TSDAT_DATA1_MASK	(0xfff << SADC_TSDAT_DATA1_BIT)
+#define SADC_TSDAT_TYPE1	(1 << 31)
+
+/* ADC Clock Divide Register */
+#define SADC_ADCLK_CLKDIV_10_BIT	16
+#define SADC_ADCLK_CLKDIV_10_MASK	(0x7f << SADC_ADCLK_CLKDIV_10_BIT)
+#define SADC_ADCLK_CLKDIV_BIT		0
+#define SADC_ADCLK_CLKDIV_MASK		(0x3f << SADC_ADCLK_CLKDIV_BIT)
+
+/*************************************************************************
+ * SLCD (Smart LCD Controller)
+ *************************************************************************/
+
+#define SLCD_CFG	(SLCD_BASE + 0xA0)  /* SLCD Configure Register */
+#define SLCD_CTRL	(SLCD_BASE + 0xA4)  /* SLCD Control Register */
+#define SLCD_STATE	(SLCD_BASE + 0xA8)  /* SLCD Status Register */
+#define SLCD_DATA	(SLCD_BASE + 0xAC)  /* SLCD Data Register */
+
+#define REG_SLCD_CFG	REG32(SLCD_CFG)
+#define REG_SLCD_CTRL	REG8(SLCD_CTRL)
+#define REG_SLCD_STATE	REG8(SLCD_STATE)
+#define REG_SLCD_DATA	REG32(SLCD_DATA)
+
+/* SLCD Configure Register */
+#define SLCD_CFG_DWIDTH_BIT	10
+#define SLCD_CFG_DWIDTH_MASK	(0x7 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_18BIT	(0 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_16BIT	(1 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8BIT_x3	(2 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8BIT_x2	(3 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8BIT_x1	(4 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_24BIT	(5 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_9BIT_x2	(7 << SLCD_CFG_DWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_BIT	(8)
+#define SLCD_CFG_CWIDTH_MASK	(0x7 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_16BIT	(0 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_8BIT	(1 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_18BIT	(2 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_24BIT	(3 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CS_ACTIVE_LOW	(0 << 4)
+#define SLCD_CFG_CS_ACTIVE_HIGH	(1 << 4)
+#define SLCD_CFG_RS_CMD_LOW	(0 << 3)
+#define SLCD_CFG_RS_CMD_HIGH	(1 << 3)
+#define SLCD_CFG_CLK_ACTIVE_FALLING	(0 << 1)
+#define SLCD_CFG_CLK_ACTIVE_RISING	(1 << 1)
+#define SLCD_CFG_TYPE_PARALLEL	(0 << 0)
+#define SLCD_CFG_TYPE_SERIAL	(1 << 0)
+
+/* SLCD Control Register */
+#define SLCD_CTRL_DMA_EN	(1 << 0)
+
+/* SLCD Status Register */
+#define SLCD_STATE_BUSY		(1 << 0)
+
+/* SLCD Data Register */
+#define SLCD_DATA_RS_DATA	(0 << 31)
+#define SLCD_DATA_RS_COMMAND	(1 << 31)
+
+/*************************************************************************
+ * LCD (LCD Controller)
+ *************************************************************************/
+#define LCD_CFG		(LCD_BASE + 0x00) /* LCD Configure Register */
+#define LCD_CTRL	(LCD_BASE + 0x30) /* LCD Control Register */
+#define LCD_STATE	(LCD_BASE + 0x34) /* LCD Status Register */
+
+#define LCD_OSDC	(LCD_BASE + 0x100) /* LCD OSD Configure Register */
+#define LCD_OSDCTRL	(LCD_BASE + 0x104) /* LCD OSD Control Register */
+#define LCD_OSDS	(LCD_BASE + 0x108) /* LCD OSD Status Register */
+#define LCD_BGC		(LCD_BASE + 0x10C) /* LCD Background Color Register */
+#define LCD_KEY0	(LCD_BASE + 0x110) /* LCD Foreground Color Key Register 0 */
+#define LCD_KEY1	(LCD_BASE + 0x114) /* LCD Foreground Color Key Register 1 */
+#define LCD_ALPHA	(LCD_BASE + 0x118) /* LCD ALPHA Register */
+#define LCD_IPUR	(LCD_BASE + 0x11C) /* LCD IPU Restart Register */
+
+#define LCD_VAT		(LCD_BASE + 0x0c) /* Virtual Area Setting Register */
+#define LCD_DAH		(LCD_BASE + 0x10) /* Display Area Horizontal Start/End Point */
+#define LCD_DAV		(LCD_BASE + 0x14) /* Display Area Vertical Start/End Point */
+
+#define LCD_XYP0	(LCD_BASE + 0x120) /* Foreground 0 XY Position Register */
+#define LCD_XYP1	(LCD_BASE + 0x124) /* Foreground 1 XY Position Register */
+#define LCD_SIZE0	(LCD_BASE + 0x128) /* Foreground 0 Size Register */
+#define LCD_SIZE1	(LCD_BASE + 0x12C) /* Foreground 1 Size Register */
+#define LCD_RGBC	(LCD_BASE + 0x90) /* RGB Controll Register */
+
+#define LCD_VSYNC	(LCD_BASE + 0x04) /* Vertical Synchronize Register */
+#define LCD_HSYNC	(LCD_BASE + 0x08) /* Horizontal Synchronize Register */
+#define LCD_PS		(LCD_BASE + 0x18) /* PS Signal Setting */
+#define LCD_CLS		(LCD_BASE + 0x1c) /* CLS Signal Setting */
+#define LCD_SPL		(LCD_BASE + 0x20) /* SPL Signal Setting */
+#define LCD_REV		(LCD_BASE + 0x24) /* REV Signal Setting */
+#define LCD_IID		(LCD_BASE + 0x38) /* Interrupt ID Register */
+#define LCD_DA0		(LCD_BASE + 0x40) /* Descriptor Address Register 0 */
+#define LCD_SA0		(LCD_BASE + 0x44) /* Source Address Register 0 */
+#define LCD_FID0	(LCD_BASE + 0x48) /* Frame ID Register 0 */
+#define LCD_CMD0	(LCD_BASE + 0x4c) /* DMA Command Register 0 */
+#define LCD_DA1		(LCD_BASE + 0x50) /* Descriptor Address Register 1 */
+#define LCD_SA1		(LCD_BASE + 0x54) /* Source Address Register 1 */
+#define LCD_FID1	(LCD_BASE + 0x58) /* Frame ID Register 1 */
+#define LCD_CMD1	(LCD_BASE + 0x5c) /* DMA Command Register 1 */
+
+#define LCD_OFFS0	(LCD_BASE + 0x60) /* DMA Offsize Register 0 */
+#define LCD_PW0		(LCD_BASE + 0x64) /* DMA Page Width Register 0 */
+#define LCD_CNUM0	(LCD_BASE + 0x68) /* DMA Command Counter Register 0 */
+#define LCD_DESSIZE0	(LCD_BASE + 0x6C) /* Foreground Size in Descriptor 0 Register*/
+#define LCD_OFFS1	(LCD_BASE + 0x70) /* DMA Offsize Register 1 */
+#define LCD_PW1		(LCD_BASE + 0x74) /* DMA Page Width Register 1 */
+#define LCD_CNUM1	(LCD_BASE + 0x78) /* DMA Command Counter Register 1 */
+#define LCD_DESSIZE1	(LCD_BASE + 0x7C) /* Foreground Size in Descriptor 1 Register*/
+
+#define REG_LCD_CFG	REG32(LCD_CFG)
+#define REG_LCD_CTRL	REG32(LCD_CTRL)
+#define REG_LCD_STATE	REG32(LCD_STATE)
+
+#define REG_LCD_OSDC	REG16(LCD_OSDC)
+#define REG_LCD_OSDCTRL	REG16(LCD_OSDCTRL)
+#define REG_LCD_OSDS	REG16(LCD_OSDS)
+#define REG_LCD_BGC	REG32(LCD_BGC)
+#define REG_LCD_KEY0	REG32(LCD_KEY0)
+#define REG_LCD_KEY1	REG32(LCD_KEY1)
+#define REG_LCD_ALPHA	REG8(LCD_ALPHA)
+#define REG_LCD_IPUR	REG32(LCD_IPUR)
+
+#define REG_LCD_VAT	REG32(LCD_VAT)
+#define REG_LCD_DAH	REG32(LCD_DAH)
+#define REG_LCD_DAV	REG32(LCD_DAV)
+
+#define REG_LCD_XYP0	REG32(LCD_XYP0)
+#define REG_LCD_XYP1	REG32(LCD_XYP1)
+#define REG_LCD_SIZE0	REG32(LCD_SIZE0)
+#define REG_LCD_SIZE1	REG32(LCD_SIZE1)
+#define REG_LCD_RGBC	REG16(LCD_RGBC)
+
+#define REG_LCD_VSYNC	REG32(LCD_VSYNC)
+#define REG_LCD_HSYNC	REG32(LCD_HSYNC)
+#define REG_LCD_PS	REG32(LCD_PS)
+#define REG_LCD_CLS	REG32(LCD_CLS)
+#define REG_LCD_SPL	REG32(LCD_SPL)
+#define REG_LCD_REV	REG32(LCD_REV)
+#define REG_LCD_IID	REG32(LCD_IID)
+#define REG_LCD_DA0	REG32(LCD_DA0)
+#define REG_LCD_SA0	REG32(LCD_SA0)
+#define REG_LCD_FID0	REG32(LCD_FID0)
+#define REG_LCD_CMD0	REG32(LCD_CMD0)
+#define REG_LCD_DA1	REG32(LCD_DA1)
+#define REG_LCD_SA1	REG32(LCD_SA1)
+#define REG_LCD_FID1	REG32(LCD_FID1)
+#define REG_LCD_CMD1	REG32(LCD_CMD1)
+
+#define REG_LCD_OFFS0	REG32(LCD_OFFS0)
+#define REG_LCD_PW0	REG32(LCD_PW0)
+#define REG_LCD_CNUM0	REG32(LCD_CNUM0)
+#define REG_LCD_DESSIZE0	REG32(LCD_DESSIZE0)
+#define REG_LCD_OFFS1	REG32(LCD_OFFS1)
+#define REG_LCD_PW1	REG32(LCD_PW1)
+#define REG_LCD_CNUM1	REG32(LCD_CNUM1)
+#define REG_LCD_DESSIZE1	REG32(LCD_DESSIZE1)
+
+/* LCD Configure Register */
+#define LCD_CFG_LCDPIN_BIT	31  /* LCD pins selection */
+#define LCD_CFG_LCDPIN_MASK	(0x1 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_LCD	(0x0 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_SLCD	(0x1 << LCD_CFG_LCDPIN_BIT)
+#define LCD_CFG_TVEPEH		(1 << 30) /* TVE PAL enable extra halfline signal */
+#define LCD_CFG_FUHOLD		(1 << 29) /* hold pixel clock when outFIFO underrun */
+#define LCD_CFG_NEWDES		(1 << 28) /* use new descripter. old: 4words, new:8words */
+#define LCD_CFG_PALBP		(1 << 27) /* bypass data format and alpha blending */
+#define LCD_CFG_TVEN		(1 << 26) /* indicate the terminal is lcd or tv */
+#define LCD_CFG_RECOVER		(1 << 25) /* Auto recover when output fifo underrun */
+#define LCD_CFG_DITHER		(1 << 24) /* Dither function */
+#define LCD_CFG_PSM		(1 << 23) /* PS signal mode */
+#define LCD_CFG_CLSM		(1 << 22) /* CLS signal mode */
+#define LCD_CFG_SPLM		(1 << 21) /* SPL signal mode */
+#define LCD_CFG_REVM		(1 << 20) /* REV signal mode */
+#define LCD_CFG_HSYNM		(1 << 19) /* HSYNC signal mode */
+#define LCD_CFG_PCLKM		(1 << 18) /* PCLK signal mode */
+#define LCD_CFG_INVDAT		(1 << 17) /* Inverse output data */
+#define LCD_CFG_SYNDIR_IN	(1 << 16) /* VSYNC&HSYNC direction */
+#define LCD_CFG_PSP		(1 << 15) /* PS pin reset state */
+#define LCD_CFG_CLSP		(1 << 14) /* CLS pin reset state */
+#define LCD_CFG_SPLP		(1 << 13) /* SPL pin reset state */
+#define LCD_CFG_REVP		(1 << 12) /* REV pin reset state */
+#define LCD_CFG_HSP		(1 << 11) /* HSYNC polarity:0-active high,1-active low */
+#define LCD_CFG_PCP		(1 << 10) /* PCLK polarity:0-rising,1-falling */
+#define LCD_CFG_DEP		(1 << 9)  /* DE polarity:0-active high,1-active low */
+#define LCD_CFG_VSP		(1 << 8)  /* VSYNC polarity:0-rising,1-falling */
+#define LCD_CFG_MODE_TFT_18BIT 	(1 << 7)  /* 18bit TFT */
+#define LCD_CFG_MODE_TFT_16BIT 	(0 << 7)  /* 16bit TFT */
+#define LCD_CFG_MODE_TFT_24BIT 	(1 << 6)  /* 24bit TFT */
+#define LCD_CFG_PDW_BIT		4  /* STN pins utilization */
+#define LCD_CFG_PDW_MASK	(0x3 << LCD_DEV_PDW_BIT)
+#define LCD_CFG_PDW_1		(0 << LCD_CFG_PDW_BIT) /* LCD_D[0] */
+  #define LCD_CFG_PDW_2		(1 << LCD_CFG_PDW_BIT) /* LCD_D[0:1] */
+  #define LCD_CFG_PDW_4		(2 << LCD_CFG_PDW_BIT) /* LCD_D[0:3]/LCD_D[8:11] */
+  #define LCD_CFG_PDW_8		(3 << LCD_CFG_PDW_BIT) /* LCD_D[0:7]/LCD_D[8:15] */
+#define LCD_CFG_MODE_BIT	0  /* Display Device Mode Select */
+#define LCD_CFG_MODE_MASK	(0x0f << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_GENERIC_TFT	(0 << LCD_CFG_MODE_BIT) /* 16,18 bit TFT */
+  #define LCD_CFG_MODE_SPECIAL_TFT_1	(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_2	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_3	(3 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_NONINTER_CCIR656	(4 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_INTER_CCIR656	(6 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_CSTN	(8 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_MSTN	(9 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_CSTN	(10 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_MSTN	(11 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SERIAL_TFT	(12 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_LCM  		(13 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SLCD  		LCD_CFG_MODE_LCM
+
+/* LCD Control Register */
+#define LCD_CTRL_BST_BIT	28  /* Burst Length Selection */
+#define LCD_CTRL_BST_MASK	(0x03 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_4	(0 << LCD_CTRL_BST_BIT) /* 4-word */
+  #define LCD_CTRL_BST_8	(1 << LCD_CTRL_BST_BIT) /* 8-word */
+  #define LCD_CTRL_BST_16	(2 << LCD_CTRL_BST_BIT) /* 16-word */
+  #define LCD_CTRL_BST_32	(3 << LCD_CTRL_BST_BIT) /* 32-word */
+#define LCD_CTRL_RGB565		(0 << 27) /* RGB565 mode(foreground 0 in OSD mode) */
+#define LCD_CTRL_RGB555		(1 << 27) /* RGB555 mode(foreground 0 in OSD mode) */
+#define LCD_CTRL_OFUP		(1 << 26) /* Output FIFO underrun protection enable */
+#define LCD_CTRL_FRC_BIT	24  /* STN FRC Algorithm Selection */
+#define LCD_CTRL_FRC_MASK	(0x03 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_16	(0 << LCD_CTRL_FRC_BIT) /* 16 grayscale */
+  #define LCD_CTRL_FRC_4	(1 << LCD_CTRL_FRC_BIT) /* 4 grayscale */
+  #define LCD_CTRL_FRC_2	(2 << LCD_CTRL_FRC_BIT) /* 2 grayscale */
+#define LCD_CTRL_PDD_BIT	16  /* Load Palette Delay Counter */
+#define LCD_CTRL_PDD_MASK	(0xff << LCD_CTRL_PDD_BIT)
+#define LCD_CTRL_EOFM		(1 << 13) /* EOF interrupt mask */
+#define LCD_CTRL_SOFM		(1 << 12) /* SOF interrupt mask */
+#define LCD_CTRL_OFUM		(1 << 11) /* Output FIFO underrun interrupt mask */
+#define LCD_CTRL_IFUM0		(1 << 10) /* Input FIFO 0 underrun interrupt mask */
+#define LCD_CTRL_IFUM1		(1 << 9)  /* Input FIFO 1 underrun interrupt mask */
+#define LCD_CTRL_LDDM		(1 << 8)  /* LCD disable done interrupt mask */
+#define LCD_CTRL_QDM		(1 << 7)  /* LCD quick disable done interrupt mask */
+#define LCD_CTRL_BEDN		(1 << 6)  /* Endian selection */
+#define LCD_CTRL_PEDN		(1 << 5)  /* Endian in byte:0-msb first, 1-lsb first */
+#define LCD_CTRL_DIS		(1 << 4)  /* Disable indicate bit */
+#define LCD_CTRL_ENA		(1 << 3)  /* LCD enable bit */
+#define LCD_CTRL_BPP_BIT	0  /* Bits Per Pixel */
+#define LCD_CTRL_BPP_MASK	(0x07 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_1	(0 << LCD_CTRL_BPP_BIT) /* 1 bpp */
+  #define LCD_CTRL_BPP_2	(1 << LCD_CTRL_BPP_BIT) /* 2 bpp */
+  #define LCD_CTRL_BPP_4	(2 << LCD_CTRL_BPP_BIT) /* 4 bpp */
+  #define LCD_CTRL_BPP_8	(3 << LCD_CTRL_BPP_BIT) /* 8 bpp */
+  #define LCD_CTRL_BPP_16	(4 << LCD_CTRL_BPP_BIT) /* 15/16 bpp */
+  #define LCD_CTRL_BPP_18_24	(5 << LCD_CTRL_BPP_BIT) /* 18/24/32 bpp */
+
+/* LCD Status Register */
+#define LCD_STATE_QD		(1 << 7) /* Quick Disable Done */
+#define LCD_STATE_EOF		(1 << 5) /* EOF Flag */
+#define LCD_STATE_SOF		(1 << 4) /* SOF Flag */
+#define LCD_STATE_OFU		(1 << 3) /* Output FIFO Underrun */
+#define LCD_STATE_IFU0		(1 << 2) /* Input FIFO 0 Underrun */
+#define LCD_STATE_IFU1		(1 << 1) /* Input FIFO 1 Underrun */
+#define LCD_STATE_LDD		(1 << 0) /* LCD Disabled */
+
+/* OSD Configure Register */
+#define LCD_OSDC_SOFM1		(1 << 15) /* Start of frame interrupt mask for foreground 1 */
+#define LCD_OSDC_EOFM1		(1 << 14) /* End of frame interrupt mask for foreground 1 */
+#define LCD_OSDC_REM1		(1 << 13) /* Real end of frame mask for foreground 1 */
+#define LCD_OSDC_SOFM0		(1 << 11) /* Start of frame interrupt mask for foreground 0 */
+#define LCD_OSDC_EOFM0		(1 << 10) /* End of frame interrupt mask for foreground 0 */
+#define LCD_OSDC_REM0		(1 << 9) /* Real end of frame mask for foreground 0 */
+#define LCD_OSDC_REMB		(1 << 7) /* Real end of frame mask for background */
+#define LCD_OSDC_F1EN		(1 << 4) /* enable foreground 1 */
+#define LCD_OSDC_F0EN		(1 << 3) /* enable foreground 0 */
+#define LCD_OSDC_ALPHAEN		(1 << 2) /* enable alpha blending */
+#define LCD_OSDC_ALPHAMD		(1 << 1) /* alpha blending mode */
+#define LCD_OSDC_OSDEN		(1 << 0) /* OSD mode enable */
+
+/* OSD Controll Register */
+#define LCD_OSDCTRL_IPU		(1 << 15) /* input data from IPU */
+#define LCD_OSDCTRL_RGB565	(0 << 4) /* foreground 1, 16bpp, 0-RGB565, 1-RGB555 */
+#define LCD_OSDCTRL_RGB555	(1 << 4) /* foreground 1, 16bpp, 0-RGB565, 1-RGB555 */
+#define LCD_OSDCTRL_CHANGES	(1 << 3) /* Change size flag */
+#define LCD_OSDCTRL_OSDBPP_BIT	0 	 /* Bits Per Pixel of OSD Channel 1 */
+#define LCD_OSDCTRL_OSDBPP_MASK	(0x7<<LCD_OSDCTRL_OSDBPP_BIT) 	 /* Bits Per Pixel of OSD Channel 1's MASK */
+  #define LCD_OSDCTRL_OSDBPP_16	(4 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 15,16 bit*/
+  #define LCD_OSDCTRL_OSDBPP_15_16	(4 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 15,16 bit*/
+  #define LCD_OSDCTRL_OSDBPP_18_24	(5 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 18,24 bit*/
+
+/* OSD State Register */
+#define LCD_OSDS_SOF1		(1 << 15) /* Start of frame flag for foreground 1 */
+#define LCD_OSDS_EOF1		(1 << 14) /* End of frame flag for foreground 1 */
+#define LCD_OSDS_SOF0		(1 << 11) /* Start of frame flag for foreground 0 */
+#define LCD_OSDS_EOF0		(1 << 10) /* End of frame flag for foreground 0 */
+#define LCD_OSDS_READY		(1 << 0)  /* Read for accept the change */
+
+/* Background Color Register */
+#define LCD_BGC_RED_OFFSET	(1 << 16)  /* Red color offset */
+#define LCD_BGC_RED_MASK	(0xFF<<LCD_BGC_RED_OFFSET)
+#define LCD_BGC_GREEN_OFFSET	(1 << 8)   /* Green color offset */
+#define LCD_BGC_GREEN_MASK	(0xFF<<LCD_BGC_GREEN_OFFSET)
+#define LCD_BGC_BLUE_OFFSET	(1 << 0)   /* Blue color offset */
+#define LCD_BGC_BLUE_MASK	(0xFF<<LCD_BGC_BLUE_OFFSET)
+
+/* Foreground Color Key Register 0,1(foreground 0, foreground 1) */
+#define LCD_KEY_KEYEN		(1 << 31)   /* enable color key */
+#define LCD_KEY_KEYMD		(1 << 30)   /* color key mode */
+#define LCD_KEY_RED_OFFSET	16  /* Red color offset */
+#define LCD_KEY_RED_MASK	(0xFF<<LCD_KEY_RED_OFFSET)
+#define LCD_KEY_GREEN_OFFSET	8   /* Green color offset */
+#define LCD_KEY_GREEN_MASK	(0xFF<<LCD_KEY_GREEN_OFFSET)
+#define LCD_KEY_BLUE_OFFSET	0   /* Blue color offset */
+#define LCD_KEY_BLUE_MASK	(0xFF<<LCD_KEY_BLUE_OFFSET)
+#define LCD_KEY_MASK		(LCD_KEY_RED_MASK|LCD_KEY_GREEN_MASK|LCD_KEY_BLUE_MASK)
+
+/* IPU Restart Register */
+#define LCD_IPUR_IPUREN		(1 << 31)   /* IPU restart function enable*/
+#define LCD_IPUR_IPURMASK	(0xFFFFFF)   /* IPU restart value mask*/
+
+/* RGB Control Register */
+#define LCD_RGBC_RGBDM		(1 << 15)   /* enable RGB Dummy data */
+#define LCD_RGBC_DMM		(1 << 14)   /* RGB Dummy mode */
+#define LCD_RGBC_YCC		(1 << 8)    /* RGB to YCC */
+#define LCD_RGBC_ODDRGB_BIT	4	/* odd line serial RGB data arrangement */
+#define LCD_RGBC_ODDRGB_MASK	(0x7<<LCD_RGBC_ODDRGB_BIT)
+  #define LCD_RGBC_ODD_RGB	0
+  #define LCD_RGBC_ODD_RBG	1
+  #define LCD_RGBC_ODD_GRB	2
+  #define LCD_RGBC_ODD_GBR	3
+  #define LCD_RGBC_ODD_BRG	4
+  #define LCD_RGBC_ODD_BGR	5
+#define LCD_RGBC_EVENRGB_BIT	0	/* even line serial RGB data arrangement */
+#define LCD_RGBC_EVENRGB_MASK	(0x7<<LCD_RGBC_EVENRGB_BIT)
+  #define LCD_RGBC_EVEN_RGB	0
+  #define LCD_RGBC_EVEN_RBG	1
+  #define LCD_RGBC_EVEN_GRB	2
+  #define LCD_RGBC_EVEN_GBR	3
+  #define LCD_RGBC_EVEN_BRG	4
+  #define LCD_RGBC_EVEN_BGR	5
+
+/* Vertical Synchronize Register */
+#define LCD_VSYNC_VPS_BIT	16  /* VSYNC pulse start in line clock, fixed to 0 */
+#define LCD_VSYNC_VPS_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+#define LCD_VSYNC_VPE_BIT	0   /* VSYNC pulse end in line clock */
+#define LCD_VSYNC_VPE_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+
+/* Horizontal Synchronize Register */
+#define LCD_HSYNC_HPS_BIT	16  /* HSYNC pulse start position in dot clock */
+#define LCD_HSYNC_HPS_MASK	(0xffff << LCD_HSYNC_HPS_BIT)
+#define LCD_HSYNC_HPE_BIT	0   /* HSYNC pulse end position in dot clock */
+#define LCD_HSYNC_HPE_MASK	(0xffff << LCD_HSYNC_HPE_BIT)
+
+/* Virtual Area Setting Register */
+#define LCD_VAT_HT_BIT		16  /* Horizontal Total size in dot clock */
+#define LCD_VAT_HT_MASK		(0xffff << LCD_VAT_HT_BIT)
+#define LCD_VAT_VT_BIT		0   /* Vertical Total size in dot clock */
+#define LCD_VAT_VT_MASK		(0xffff << LCD_VAT_VT_BIT)
+
+/* Display Area Horizontal Start/End Point Register */
+#define LCD_DAH_HDS_BIT		16  /* Horizontal display area start in dot clock */
+#define LCD_DAH_HDS_MASK	(0xffff << LCD_DAH_HDS_BIT)
+#define LCD_DAH_HDE_BIT		0   /* Horizontal display area end in dot clock */
+#define LCD_DAH_HDE_MASK	(0xffff << LCD_DAH_HDE_BIT)
+
+/* Display Area Vertical Start/End Point Register */
+#define LCD_DAV_VDS_BIT		16  /* Vertical display area start in line clock */
+#define LCD_DAV_VDS_MASK	(0xffff << LCD_DAV_VDS_BIT)
+#define LCD_DAV_VDE_BIT		0   /* Vertical display area end in line clock */
+#define LCD_DAV_VDE_MASK	(0xffff << LCD_DAV_VDE_BIT)
+
+/* Foreground XY Position Register */
+#define LCD_XYP_YPOS_BIT	16  /* Y position bit of foreground 0 or 1 */
+#define LCD_XYP_YPOS_MASK	(0xffff << LCD_XYP_YPOS_BIT)
+#define LCD_XYP_XPOS_BIT	0   /* X position bit of foreground 0 or 1 */
+#define LCD_XYP_XPOS_MASK	(0xffff << LCD_XYP_XPOS_BIT)
+
+/* PS Signal Setting */
+#define LCD_PS_PSS_BIT		16  /* PS signal start position in dot clock */
+#define LCD_PS_PSS_MASK		(0xffff << LCD_PS_PSS_BIT)
+#define LCD_PS_PSE_BIT		0   /* PS signal end position in dot clock */
+#define LCD_PS_PSE_MASK		(0xffff << LCD_PS_PSE_BIT)
+
+/* CLS Signal Setting */
+#define LCD_CLS_CLSS_BIT	16  /* CLS signal start position in dot clock */
+#define LCD_CLS_CLSS_MASK	(0xffff << LCD_CLS_CLSS_BIT)
+#define LCD_CLS_CLSE_BIT	0   /* CLS signal end position in dot clock */
+#define LCD_CLS_CLSE_MASK	(0xffff << LCD_CLS_CLSE_BIT)
+
+/* SPL Signal Setting */
+#define LCD_SPL_SPLS_BIT	16  /* SPL signal start position in dot clock */
+#define LCD_SPL_SPLS_MASK	(0xffff << LCD_SPL_SPLS_BIT)
+#define LCD_SPL_SPLE_BIT	0   /* SPL signal end position in dot clock */
+#define LCD_SPL_SPLE_MASK	(0xffff << LCD_SPL_SPLE_BIT)
+
+/* REV Signal Setting */
+#define LCD_REV_REVS_BIT	16  /* REV signal start position in dot clock */
+#define LCD_REV_REVS_MASK	(0xffff << LCD_REV_REVS_BIT)
+
+/* DMA Command Register */
+#define LCD_CMD_SOFINT		(1 << 31)
+#define LCD_CMD_EOFINT		(1 << 30)
+#define LCD_CMD_CMD		(1 << 29) /* indicate command in slcd mode */
+#define LCD_CMD_PAL		(1 << 28)
+#define LCD_CMD_LEN_BIT		0
+#define LCD_CMD_LEN_MASK	(0xffffff << LCD_CMD_LEN_BIT)
+
+/* DMA Offsize Register 0,1 */
+
+/* DMA Page Width Register 0,1 */
+
+/* DMA Command Counter Register 0,1 */
+
+/* Foreground 0,1 Size Register */
+#define LCD_DESSIZE_HEIGHT_BIT	16  /* height of foreground 1 */
+#define LCD_DESSIZE_HEIGHT_MASK	(0xffff << LCD_DESSIZE_HEIGHT_BIT)
+#define LCD_DESSIZE_WIDTH_BIT	0  /* width of foreground 1 */
+#define LCD_DESSIZE_WIDTH_MASK	(0xffff << LCD_DESSIZE_WIDTH_BIT)
+
+/*************************************************************************
+ * TVE (TV Encoder Controller)
+ *************************************************************************/
+#define TVE_CTRL	(TVE_BASE + 0x40) /* TV Encoder Control register */
+#define TVE_FRCFG	(TVE_BASE + 0x44) /* Frame configure register */
+#define TVE_SLCFG1	(TVE_BASE + 0x50) /* TV signal level configure register 1 */
+#define TVE_SLCFG2	(TVE_BASE + 0x54) /* TV signal level configure register 2*/
+#define TVE_SLCFG3	(TVE_BASE + 0x58) /* TV signal level configure register 3*/
+#define TVE_LTCFG1	(TVE_BASE + 0x60) /* Line timing configure register 1 */
+#define TVE_LTCFG2	(TVE_BASE + 0x64) /* Line timing configure register 2 */
+#define TVE_CFREQ	(TVE_BASE + 0x70) /* Chrominance sub-carrier frequency configure register */
+#define TVE_CPHASE	(TVE_BASE + 0x74) /* Chrominance sub-carrier phase configure register */
+#define TVE_CBCRCFG	(TVE_BASE + 0x78) /* Chrominance filter configure register */
+#define TVE_WSSCR	(TVE_BASE + 0x80) /* Wide screen signal control register */
+#define TVE_WSSCFG1	(TVE_BASE + 0x84) /* Wide screen signal configure register 1 */
+#define TVE_WSSCFG2	(TVE_BASE + 0x88) /* Wide screen signal configure register 2 */
+#define TVE_WSSCFG3	(TVE_BASE + 0x8c) /* Wide screen signal configure register 3 */
+
+#define REG_TVE_CTRL     REG32(TVE_CTRL)
+#define REG_TVE_FRCFG    REG32(TVE_FRCFG)
+#define REG_TVE_SLCFG1   REG32(TVE_SLCFG1)
+#define REG_TVE_SLCFG2   REG32(TVE_SLCFG2)
+#define REG_TVE_SLCFG3   REG32(TVE_SLCFG3)
+#define REG_TVE_LTCFG1   REG32(TVE_LTCFG1)
+#define REG_TVE_LTCFG2   REG32(TVE_LTCFG2)
+#define REG_TVE_CFREQ    REG32(TVE_CFREQ)
+#define REG_TVE_CPHASE   REG32(TVE_CPHASE)
+#define REG_TVE_CBCRCFG	 REG32(TVE_CBCRCFG)
+#define REG_TVE_WSSCR    REG32(TVE_WSSCR)
+#define REG_TVE_WSSCFG1  REG32(TVE_WSSCFG1)
+#define REG_TVE_WSSCFG2	 REG32(TVE_WSSCFG2)
+#define REG_TVE_WSSCFG3  REG32(TVE_WSSCFG3)
+
+/* TV Encoder Control register */
+#define TVE_CTRL_ECVBS          (1 << 24)    /* cvbs_enable */
+#define TVE_CTRL_DAPD3	        (1 << 23)    /* DAC 3 power down, not exist in jz4750 */
+#define TVE_CTRL_DAPD2	        (1 << 22)    /* DAC 2 power down */	
+#define TVE_CTRL_DAPD1	        (1 << 21)    /* DAC 1 power down */	
+#define TVE_CTRL_DAPD           (1 << 20)    /* power down all DACs */
+#define TVE_CTRL_YCDLY_BIT      16
+#define TVE_CTRL_YCDLY_MASK     (0x7 << TVE_CTRL_YCDLY_BIT)
+#define TVE_CTRL_CGAIN_BIT      14
+#define TVE_CTRL_CGAIN_MASK     (0x3 << TVE_CTRL_CGAIN_BIT)
+  #define TVE_CTRL_CGAIN_FULL		(0 << TVE_CTRL_CGAIN_BIT) /* gain = 1 */
+  #define TVE_CTRL_CGAIN_QUTR		(1 << TVE_CTRL_CGAIN_BIT) /* gain = 1/4 */
+  #define TVE_CTRL_CGAIN_HALF		(2 << TVE_CTRL_CGAIN_BIT) /* gain = 1/2 */
+  #define TVE_CTRL_CGAIN_THREE_QURT	(3 << TVE_CTRL_CGAIN_BIT) /* gain = 3/4 */
+#define TVE_CTRL_CBW_BIT        12
+#define TVE_CTRL_CBW_MASK       (0x3 << TVE_CTRL_CBW_BIT)
+  #define TVE_CTRL_CBW_NARROW	(0 << TVE_CTRL_CBW_BIT) /* Narrow band */
+  #define TVE_CTRL_CBW_WIDE	(1 << TVE_CTRL_CBW_BIT) /* Wide band */
+  #define TVE_CTRL_CBW_EXTRA	(2 << TVE_CTRL_CBW_BIT) /* Extra wide band */
+  #define TVE_CTRL_CBW_ULTRA	(3 << TVE_CTRL_CBW_BIT) /* Ultra wide band */
+#define TVE_CTRL_SYNCT          (1 << 9)
+#define TVE_CTRL_PAL            (1 << 8)
+#define TVE_CTRL_FINV           (1 << 7) /* invert_top:1-invert top and bottom fields. */
+#define TVE_CTRL_ZBLACK         (1 << 6) /* bypass_yclamp:1-Black of luminance (Y) input is 0.*/
+#define TVE_CTRL_CR1ST          (1 << 5) /* uv_order:0-Cb before Cr,1-Cr before Cb */
+#define TVE_CTRL_CLBAR          (1 << 4) /* Color bar mode:0-Output input video to TV,1-Output color bar to TV */
+#define TVE_CTRL_SWRST          (1 << 0) /* Software reset:1-TVE is reset */
+
+/* Signal level configure register 1 */
+#define TVE_SLCFG1_BLACKL_BIT   0
+#define TVE_SLCFG1_BLACKL_MASK  (0x3ff << TVE_SLCFG1_BLACKL_BIT)
+#define TVE_SLCFG1_WHITEL_BIT   16
+#define TVE_SLCFG1_WHITEL_MASK  (0x3ff << TVE_SLCFG1_WHITEL_BIT)
+
+/* Signal level configure register 2 */
+#define TVE_SLCFG2_BLANKL_BIT    0
+#define TVE_SLCFG2_BLANKL_MASK   (0x3ff << TVE_SLCFG2_BLANKL_BIT)
+#define TVE_SLCFG2_VBLANKL_BIT   16
+#define TVE_SLCFG2_VBLANKL_MASK  (0x3ff << TVE_SLCFG2_VBLANKL_BIT)
+
+/* Signal level configure register 3 */
+#define TVE_SLCFG3_SYNCL_BIT   0
+#define TVE_SLCFG3_SYNCL_MASK  (0xff << TVE_SLCFG3_SYNCL_BIT)
+
+/* Line timing configure register 1 */
+#define TVE_LTCFG1_BACKP_BIT   0
+#define TVE_LTCFG1_BACKP_MASK  (0x7f << TVE_LTCFG1_BACKP_BIT)
+#define TVE_LTCFG1_HSYNCW_BIT   8
+#define TVE_LTCFG1_HSYNCW_MASK  (0x7f << TVE_LTCFG1_HSYNCW_BIT)
+#define TVE_LTCFG1_FRONTP_BIT   16
+#define TVE_LTCFG1_FRONTP_MASK  (0x1f << TVE_LTCFG1_FRONTP_BIT)
+
+/* Line timing configure register 2 */
+#define TVE_LTCFG2_BURSTW_BIT    0
+#define TVE_LTCFG2_BURSTW_MASK   (0x3f << TVE_LTCFG2_BURSTW_BIT)
+#define TVE_LTCFG2_PREBW_BIT     8
+#define TVE_LTCFG2_PREBW_MASK    (0x1f << TVE_LTCFG2_PREBW_BIT)
+#define TVE_LTCFG2_ACTLIN_BIT    16
+#define TVE_LTCFG2_ACTLIN_MASK	(0x7ff << TVE_LTCFG2_ACTLIN_BIT)
+
+/* Chrominance sub-carrier phase configure register */
+#define TVE_CPHASE_CCRSTP_BIT    0
+#define TVE_CPHASE_CCRSTP_MASK   (0x3 << TVE_CPHASE_CCRSTP_BIT)
+  #define TVE_CPHASE_CCRSTP_8	(0 << TVE_CPHASE_CCRSTP_BIT) /* Every 8 field */
+  #define TVE_CPHASE_CCRSTP_4	(1 << TVE_CPHASE_CCRSTP_BIT) /* Every 4 field */
+  #define TVE_CPHASE_CCRSTP_2	(2 << TVE_CPHASE_CCRSTP_BIT) /* Every 2 lines */
+  #define TVE_CPHASE_CCRSTP_0	(3 << TVE_CPHASE_CCRSTP_BIT) /* Never */
+#define TVE_CPHASE_ACTPH_BIT     16
+#define TVE_CPHASE_ACTPH_MASK    (0xff << TVE_CPHASE_ACTPH_BIT)
+#define TVE_CPHASE_INITPH_BIT    24
+#define TVE_CPHASE_INITPH_MASK   (0xff << TVE_CPHASE_INITPH_BIT)
+
+/* Chrominance filter configure register */
+#define TVE_CBCRCFG_CRGAIN_BIT       0
+#define TVE_CBCRCFG_CRGAIN_MASK      (0xff << TVE_CBCRCFG_CRGAIN_BIT)
+#define TVE_CBCRCFG_CBGAIN_BIT       8
+#define TVE_CBCRCFG_CBGAIN_MASK      (0xff << TVE_CBCRCFG_CBGAIN_BIT)
+#define TVE_CBCRCFG_CRBA_BIT         16
+#define TVE_CBCRCFG_CRBA_MASK        (0xff << TVE_CBCRCFG_CRBA_BIT)
+#define TVE_CBCRCFG_CBBA_BIT         24
+#define TVE_CBCRCFG_CBBA_MASK        (0xff << TVE_CBCRCFG_CBBA_BIT)
+
+/* Frame configure register */
+#define TVE_FRCFG_NLINE_BIT          0
+#define TVE_FRCFG_NLINE_MASK         (0x3ff << TVE_FRCFG_NLINE_BIT)
+#define TVE_FRCFG_L1ST_BIT           16
+#define TVE_FRCFG_L1ST_MASK          (0xff << TVE_FRCFG_L1ST_BIT)
+
+/* Wide screen signal control register */
+#define TVE_WSSCR_EWSS0_BIT	0
+#define TVE_WSSCR_EWSS1_BIT	1
+#define TVE_WSSCR_WSSTP_BIT	2
+#define TVE_WSSCR_WSSCKBP_BIT	3
+#define TVE_WSSCR_WSSEDGE_BIT	4
+#define TVE_WSSCR_WSSEDGE_MASK	(0x7 << TVE_WSSCR_WSSEDGE_BIT)
+#define TVE_WSSCR_ENCH_BIT	8
+#define TVE_WSSCR_NCHW_BIT	9
+#define TVE_WSSCR_NCHFREQ_BIT	12
+#define TVE_WSSCR_NCHFREQ_MASK	(0x7 << TVE_WSSCR_NCHFREQ_BIT)
+
+/*************************************************************************
+ * USB Device
+ *************************************************************************/
+#define USB_BASE  UDC_BASE
+
+#define USB_REG_FADDR		(USB_BASE + 0x00) /* Function Address 8-bit */
+#define USB_REG_POWER		(USB_BASE + 0x01) /* Power Managemetn 8-bit */
+#define USB_REG_INTRIN		(USB_BASE + 0x02) /* Interrupt IN 16-bit */
+#define USB_REG_INTROUT		(USB_BASE + 0x04) /* Interrupt OUT 16-bit */
+#define USB_REG_INTRINE		(USB_BASE + 0x06) /* Intr IN enable 16-bit */
+#define USB_REG_INTROUTE	(USB_BASE + 0x08) /* Intr OUT enable 16-bit */
+#define USB_REG_INTRUSB		(USB_BASE + 0x0a) /* Interrupt USB 8-bit */
+#define USB_REG_INTRUSBE	(USB_BASE + 0x0b) /* Interrupt USB Enable 8-bit */
+#define USB_REG_FRAME		(USB_BASE + 0x0c) /* Frame number 16-bit */
+#define USB_REG_INDEX		(USB_BASE + 0x0e) /* Index register 8-bit */
+#define USB_REG_TESTMODE	(USB_BASE + 0x0f) /* USB test mode 8-bit */
+
+#define USB_REG_CSR0		(USB_BASE + 0x12) /* EP0 CSR 8-bit */
+#define USB_REG_INMAXP		(USB_BASE + 0x10) /* EP1-2 IN Max Pkt Size 16-bit */
+#define USB_REG_INCSR		(USB_BASE + 0x12) /* EP1-2 IN CSR LSB 8/16bit */
+#define USB_REG_INCSRH		(USB_BASE + 0x13) /* EP1-2 IN CSR MSB 8-bit */
+#define USB_REG_OUTMAXP		(USB_BASE + 0x14) /* EP1 OUT Max Pkt Size 16-bit */
+#define USB_REG_OUTCSR		(USB_BASE + 0x16) /* EP1 OUT CSR LSB 8/16bit */
+#define USB_REG_OUTCSRH		(USB_BASE + 0x17) /* EP1 OUT CSR MSB 8-bit */
+#define USB_REG_OUTCOUNT	(USB_BASE + 0x18) /* bytes in EP0/1 OUT FIFO 16-bit */
+
+#define USB_FIFO_EP0		(USB_BASE + 0x20)
+#define USB_FIFO_EP1		(USB_BASE + 0x24)
+#define USB_FIFO_EP2		(USB_BASE + 0x28)
+
+#define USB_REG_EPINFO		(USB_BASE + 0x78) /* Endpoint information */
+#define USB_REG_RAMINFO		(USB_BASE + 0x79) /* RAM information */
+
+#define USB_REG_INTR		(USB_BASE + 0x200) /* DMA pending interrupts */
+#define USB_REG_CNTL1		(USB_BASE + 0x204) /* DMA channel 1 control */
+#define USB_REG_ADDR1		(USB_BASE + 0x208) /* DMA channel 1 AHB memory addr */
+#define USB_REG_COUNT1		(USB_BASE + 0x20c) /* DMA channel 1 byte count */
+#define USB_REG_CNTL2		(USB_BASE + 0x214) /* DMA channel 2 control */
+#define USB_REG_ADDR2		(USB_BASE + 0x218) /* DMA channel 2 AHB memory addr */
+#define USB_REG_COUNT2		(USB_BASE + 0x21c) /* DMA channel 2 byte count */
+
+
+/* Power register bit masks */
+#define USB_POWER_SUSPENDM	0x01
+#define USB_POWER_RESUME	0x04
+#define USB_POWER_HSMODE	0x10
+#define USB_POWER_HSENAB	0x20
+#define USB_POWER_SOFTCONN	0x40
+
+/* Interrupt register bit masks */
+#define USB_INTR_SUSPEND	0x01
+#define USB_INTR_RESUME		0x02
+#define USB_INTR_RESET		0x04
+
+#define USB_INTR_EP0		0x0001
+#define USB_INTR_INEP1		0x0002
+#define USB_INTR_INEP2		0x0004
+#define USB_INTR_OUTEP1		0x0002
+
+/* CSR0 bit masks */
+#define USB_CSR0_OUTPKTRDY	0x01
+#define USB_CSR0_INPKTRDY	0x02
+#define USB_CSR0_SENTSTALL	0x04
+#define USB_CSR0_DATAEND	0x08
+#define USB_CSR0_SETUPEND	0x10
+#define USB_CSR0_SENDSTALL	0x20
+#define USB_CSR0_SVDOUTPKTRDY	0x40
+#define USB_CSR0_SVDSETUPEND	0x80
+
+/* Endpoint CSR register bits */
+#define USB_INCSRH_AUTOSET	0x80
+#define USB_INCSRH_ISO		0x40
+#define USB_INCSRH_MODE		0x20
+#define USB_INCSRH_DMAREQENAB	0x10
+#define USB_INCSRH_DMAREQMODE	0x04
+#define USB_INCSR_CDT		0x40
+#define USB_INCSR_SENTSTALL	0x20
+#define USB_INCSR_SENDSTALL	0x10
+#define USB_INCSR_FF		0x08
+#define USB_INCSR_UNDERRUN	0x04
+#define USB_INCSR_FFNOTEMPT	0x02
+#define USB_INCSR_INPKTRDY	0x01
+#define USB_OUTCSRH_AUTOCLR	0x80
+#define USB_OUTCSRH_ISO		0x40
+#define USB_OUTCSRH_DMAREQENAB	0x20
+#define USB_OUTCSRH_DNYT	0x10
+#define USB_OUTCSRH_DMAREQMODE	0x08
+#define USB_OUTCSR_CDT		0x80
+#define USB_OUTCSR_SENTSTALL	0x40
+#define USB_OUTCSR_SENDSTALL	0x20
+#define USB_OUTCSR_FF		0x10
+#define USB_OUTCSR_DATAERR	0x08
+#define USB_OUTCSR_OVERRUN	0x04
+#define USB_OUTCSR_FFFULL	0x02
+#define USB_OUTCSR_OUTPKTRDY	0x01
+
+/* Testmode register bits */
+#define USB_TEST_SE0NAK		0x01
+#define USB_TEST_J		0x02
+#define USB_TEST_K		0x04
+#define USB_TEST_PACKET		0x08
+
+/* DMA control bits */
+#define USB_CNTL_ENA		0x01
+#define USB_CNTL_DIR_IN		0x02
+#define USB_CNTL_MODE_1		0x04
+#define USB_CNTL_INTR_EN	0x08
+#define USB_CNTL_EP(n)		((n) << 4)
+#define USB_CNTL_BURST_0	(0 << 9)
+#define USB_CNTL_BURST_4	(1 << 9)
+#define USB_CNTL_BURST_8	(2 << 9)
+#define USB_CNTL_BURST_16	(3 << 9)
+
+/*************************************************************************
+ * BCH
+ *************************************************************************/
+#define	BCH_CR         	(BCH_BASE + 0x00) /* BCH Control register */
+#define	BCH_CRS       	(BCH_BASE + 0x04) /* BCH Control Set register */
+#define	BCH_CRC       	(BCH_BASE + 0x08) /* BCH Control Clear register */
+#define	BCH_CNT    	(BCH_BASE + 0x0C) /* BCH ENC/DEC Count register */
+#define	BCH_DR     	(BCH_BASE + 0x10) /* BCH data register */
+#define	BCH_PAR0    	(BCH_BASE + 0x14) /* BCH Parity 0 register */
+#define	BCH_PAR1    	(BCH_BASE + 0x18) /* BCH Parity 1 register */
+#define	BCH_PAR2    	(BCH_BASE + 0x1C) /* BCH Parity 2 register */
+#define	BCH_PAR3    	(BCH_BASE + 0x20) /* BCH Parity 3 register */
+#define	BCH_INTS    	(BCH_BASE + 0x24) /* BCH Interrupt Status register */
+#define	BCH_ERR0        (BCH_BASE + 0x28) /* BCH Error Report 0 register */
+#define	BCH_ERR1        (BCH_BASE + 0x2C) /* BCH Error Report 1 register */
+#define	BCH_ERR2        (BCH_BASE + 0x30) /* BCH Error Report 2 register */
+#define	BCH_ERR3        (BCH_BASE + 0x34) /* BCH Error Report 3 register */
+#define	BCH_INTE        (BCH_BASE + 0x38) /* BCH Interrupt Enable register */
+#define	BCH_INTES       (BCH_BASE + 0x3C) /* BCH Interrupt Set register */
+#define	BCH_INTEC       (BCH_BASE + 0x40) /* BCH Interrupt Clear register */
+
+#define	REG_BCH_CR      REG32(BCH_CR)
+#define	REG_BCH_CRS     REG32(BCH_CRS)
+#define	REG_BCH_CRC     REG32(BCH_CRC)
+#define	REG_BCH_CNT     REG32(BCH_CNT)
+#define	REG_BCH_DR      REG8(BCH_DR)
+#define	REG_BCH_PAR0    REG32(BCH_PAR0)
+#define	REG_BCH_PAR1    REG32(BCH_PAR1)
+#define	REG_BCH_PAR2    REG32(BCH_PAR2)
+#define	REG_BCH_PAR3    REG32(BCH_PAR3)
+#define	REG_BCH_INTS    REG32(BCH_INTS)
+#define	REG_BCH_ERR0    REG32(BCH_ERR0)
+#define	REG_BCH_ERR1    REG32(BCH_ERR1)
+#define	REG_BCH_ERR2    REG32(BCH_ERR2)
+#define	REG_BCH_ERR3    REG32(BCH_ERR3)
+#define	REG_BCH_INTE    REG32(BCH_INTE)
+#define	REG_BCH_INTEC   REG32(BCH_INTEC)
+#define	REG_BCH_INTES   REG32(BCH_INTES)
+
+/* BCH Control Register*/
+#define	BCH_CR_DMAE              (1 << 4)  /* BCH DMA Enable */
+#define	BCH_CR_ENCE              (1 << 3)  /* BCH Encoding Select */
+#define	BCH_CR_DECE              (0 << 3)  /* BCH Decoding Select */
+#define	BCH_CR_BSEL8             (1 << 2)  /* 8 Bit BCH Select */
+#define	BCH_CR_BSEL4             (0 << 2)  /* 4 Bit BCH Select */
+#define	BCH_CR_BRST              (1 << 1)  /* BCH Reset */
+#define	BCH_CR_BCHE              (1 << 0)  /* BCH Enable */
+
+/* BCH Interrupt Status Register */
+#define	BCH_INTS_ERRC_BIT        28
+#define	BCH_INTS_ERRC_MASK       (0xf << BCH_INTS_ERRC_BIT)
+#define	BCH_INTS_ALL0            (1 << 5)
+#define	BCH_INTS_ALLf            (1 << 4)
+#define	BCH_INTS_DECF            (1 << 3)
+#define	BCH_INTS_ENCF            (1 << 2)
+#define	BCH_INTS_UNCOR           (1 << 1)
+#define	BCH_INTS_ERR             (1 << 0)
+
+/* BCH ENC/DEC Count Register */
+#define BCH_CNT_DEC_BIT          16
+#define BCH_CNT_DEC_MASK         (0x3ff << BCH_CNT_DEC_BIT)
+#define BCH_CNT_ENC_BIT          0
+#define BCH_CNT_ENC_MASK         (0x3ff << BCH_CNT_ENC_BIT)
+
+/* BCH Error Report Register */
+#define BCH_ERR_INDEX_ODD_BIT    16
+#define BCH_ERR_INDEX_ODD_MASK   (0x1fff << BCH_ERR_INDEX_ODD_BIT)
+#define BCH_ERR_INDEX_EVEN_BIT   0
+#define BCH_ERR_INDEX_EVEN_MASK  (0x1fff << BCH_ERR_INDEX_EVEN_BIT)
+
+/*************************************************************************
+ * OWI (One-wire Bus Controller )
+ *************************************************************************/
+#define OWI_CFG (OWI_BASE + 0x00) /* OWI Configure Register */
+#define OWI_CTL (OWI_BASE + 0x04) /* OWI Control Register */
+#define OWI_STS (OWI_BASE + 0x08) /* OWI Status Register */
+#define OWI_DAT (OWI_BASE + 0x0c) /* OWI Data Register */
+#define OWI_DIV (OWI_BASE + 0x10) /* OWI Clock Divide Register */
+
+#define REG_OWI_CFG  REG8(OWI_CFG)
+#define REG_OWI_CTL  REG8(OWI_CTL)
+#define REG_OWI_STS  REG8(OWI_STS)
+#define REG_OWI_DAT  REG8(OWI_DAT)
+#define REG_OWI_DIV  REG8(OWI_DIV)
+
+/* OWI Configure Register */
+#define OWI_CFG_MODE      (1 << 7) /*  0: Regular speed mode  1: Overdrive  speed mode */
+#define OWI_CFG_RDDATA    (1 << 6) /* 1: receive data from one-wire bus and stored in OWDAT*/
+#define OWI_CFG_WRDATA    (1 << 5) /* 1: transmit the data in OWDAT */
+#define OWI_CFG_RDST      (1 << 4) /* 1: was sampled during a read */
+#define OWI_CFG_WR1RD     (1 << 3) /* 1: generate write 1 sequence on line */
+#define OWI_CFG_WR0       (1 << 2) /* 1: generate write 0 sequence on line */
+#define OWI_CFG_RST       (1 << 1) /* 1: generate reset pulse and sample slaves presence pulse*/
+#define OWI_CFG_ENA       (1 << 0) /* 1: enable the OWI operation */
+
+/* OWI Control Register */
+#define OWI_CTL_EBYTE     (1 << 2) /* enable byte write/read interrupt */
+#define OWI_CTL_EBIT      (1 << 1) /* enable bit write/read interrupt */
+#define OWI_CTL_ERST      (1 << 0) /* enable reset sequence finished interrupt */
+
+/* OWI Status Register */
+#define OWI_STS_PST       (1 << 7) /* 1: one-wire bus has device on it */
+#define OWI_STS_BYTE_RDY  (1 << 2) /* 1: have received or transmitted a data */
+#define OWI_STS_BIT_RDY   (1 << 1) /* 1: have received or transmitted a bit */
+#define OWI_STS_PST_RDY   (1 << 0) /* 1: have finished a reset pulse */
+
+/* OWI Clock Divide Register */
+#define OWI_DIV_CLKDIV_BIT  5
+
+
+/*************************************************************************
+ * MC (Motion Compensation)
+ *************************************************************************/
+#define MC_CTRL		(MC_BASE + 0x00) /* MC Control Register */
+#define MC_STAT		(MC_BASE + 0x04) /* MC Status Register */
+#define MC_REF_ADDR	(MC_BASE + 0x08) /* MC Reference Block Address Register */
+#define MC_REF2_ADDR	(MC_BASE + 0x0C) /* MC 2nd Reference Block Address Register */
+#define MC_CURR_ADDR	(MC_BASE + 0x10) /* MC Current Block Address Register */
+#define MC_REF_STRD	(MC_BASE + 0x14) /* MC Reference Frame Stride Register */
+#define MC_CURR_STRD	(MC_BASE + 0x18) /* MC Current Frame Stride Register */
+#define MC_ITP_INFO	(MC_BASE + 0x1C) /* MC Block Interpolation Information Register */
+#define MC_TAP_COEF1	(MC_BASE + 0x20) /* MC TAP Filter Coefficient 1 Register */
+#define MC_TAP_COEF2	(MC_BASE + 0x24) /* MC TAP Filter Coefficient 2 Register */
+
+#define REG_MC_CTRL		REG32(MC_CTRL)
+#define REG_MC_STAT		REG32(MC_STAT)
+#define REG_MC_REF_ADDR		REG32(MC_REF_ADDR)
+#define REG_MC_REF2_ADDR	REG32(MC_REF2_ADDR)
+#define REG_MC_CURR_ADDR	REG32(MC_CURR_ADDR)
+#define REG_MC_REF_STRD		REG32(MC_REF_STRD)
+#define REG_MC_CURR_STRD	REG32(MC_CURR_STRD)
+#define REG_MC_ITP_INFO		REG32(MC_ITP_INFO)
+#define REG_MC_TAP_COEF1	REG32(MC_TAP_COEF1)
+#define REG_MC_TAP_COEF2	REG32(MC_TAP_COEF2)
+
+/* MC Control Register */
+#define MC_CTRL_CACHECLR	(1 << 2) /* MC Cache clear */
+#define MC_CTRL_RESET		(1 << 1) /* MC Reset */
+#define MC_CTRL_ENABLE		(1 << 0) /* MC enable */
+
+/* MC Status Register */
+#define MC_STAT_OUT_END		(1 << 0) /* Output DMA termination flag */
+
+/* MC Reference Frame Stride Register, unit: byte */
+#define MC_REF_STRD_BIT		16
+#define MC_REF_STRD_MASK	(0xfff << MC_REF_STRD_BIT)
+#define MC_REF_STRD2_BIT	0
+#define MC_REF_STRD2_MASK	(0xfff << MC_REF_STRD2_BIT)
+
+/* MC Current Frame Stride Register, unit: byte */
+#define MC_CURR_STRD_BIT	0
+#define MC_CURR_STRD_MASK	(0xfff << MC_CURR_STRD_BIT)
+
+/* MC Block Interpolation Information Register */
+#define MC_ITP_INFO_RND1_BIT	24  /* Rounding data during interpolation */
+#define MC_ITP_INFO_RND1_MASK	(0xff << MC_ITP_INFO_RND1_BIT)
+#define MC_ITP_INFO_RND0_BIT	16  /* Rounding data during interpolation */
+#define MC_ITP_INFO_RND0_MASK	(0xff << MC_ITP_INFO_RND0_BIT)
+#define MC_ITP_INFO_AVG		(1 << 12)  /* 0: output interpolated data directly; 1: doing average operation with 2nd source data after interpolating and output */
+#define MC_ITP_INFO_FMT_BIT	8  /* Indicate current interpolation's type */
+#define MC_ITP_INFO_RMT_MASK	(0xf << MC_ITP_INFO_RMT_BIT)
+  #define MC_ITP_INFO_FMT_MPEG_HPEL  (0x0 << MC_ITP_INFO_RMT_BIT) /* MPEG Half-pixel interpolation */
+  #define MC_ITP_INFO_FMT_MPEG_QPEL  (0x1 << MC_ITP_INFO_RMT_BIT) /* MPEG 8-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_H264_QPEL  (0x2 << MC_ITP_INFO_RMT_BIT) /* H264 6-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_H264_EPEL  (0x3 << MC_ITP_INFO_RMT_BIT) /* H264 2-tap Eight-pixel interpolation */
+  #define MC_ITP_INFO_FMT_H264_WPDT  (0x4 << MC_ITP_INFO_RMT_BIT) /* H264 Weighted-prediction */
+  #define MC_ITP_INFO_FMT_WMV2_QPEL  (0x5 << MC_ITP_INFO_RMT_BIT) /* WMV2 4-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_VC1_QPEL   (0x6 << MC_ITP_INFO_RMT_BIT) /* VC1 4-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_RV8_TPEL   (0x7 << MC_ITP_INFO_RMT_BIT) /* RV8 4-tap Third-pixel interpolation */
+  #define MC_ITP_INFO_FMT_RV8_CHROM  (0x8 << MC_ITP_INFO_RMT_BIT) /* RV8 2-tap Third-pixel interpolation */
+  #define MC_ITP_INFO_FMT_RV9_QPEL   (0x9 << MC_ITP_INFO_RMT_BIT) /* RV9 6-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_RV9_CHROM  (0xa << MC_ITP_INFO_RMT_BIT) /* RV9 2-tap Quarter-pixel interpolation */
+#define MC_ITP_INFO_BLK_W_BIT	6  /* Indicate reference block's width, unit: pixel */
+#define MC_ITP_INFO_BLK_W_MASK	(0x3 << MC_ITP_INFO_BLK_W_BIT)
+  #define MC_ITP_INFO_BLK_W_2	(0x0 << MC_ITP_INFO_BLK_W_BIT)
+  #define MC_ITP_INFO_BLK_W_4	(0x1 << MC_ITP_INFO_BLK_W_BIT)
+  #define MC_ITP_INFO_BLK_W_8	(0x2 << MC_ITP_INFO_BLK_W_BIT)
+  #define MC_ITP_INFO_BLK_W_16	(0x3 << MC_ITP_INFO_BLK_W_BIT)
+#define MC_ITP_INFO_BLK_H_BIT	4  /* Indicate reference block's height, unit: pixel */
+#define MC_ITP_INFO_BLK_H_MASK	(0x3 << MC_ITP_INFO_BLK_H_BIT)
+  #define MC_ITP_INFO_BLK_H_2	(0x0 << MC_ITP_INFO_BLK_H_BIT)
+  #define MC_ITP_INFO_BLK_H_4	(0x1 << MC_ITP_INFO_BLK_H_BIT)
+  #define MC_ITP_INFO_BLK_H_8	(0x2 << MC_ITP_INFO_BLK_H_BIT)
+  #define MC_ITP_INFO_BLK_H_16	(0x3 << MC_ITP_INFO_BLK_H_BIT)
+#define MC_ITP_INFO_ITP_CASE_BIT	0  /* Indicate interpolation final destination pixel position */
+#define MC_ITP_INFO_ITP_CASE_MASK	(0xf << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H0V0	(0x0 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H1V0	(0x1 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H2V0	(0x2 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H3V0	(0x3 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H0V1	(0x4 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H1V1	(0x5 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H2V1	(0x6 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H3V1	(0x7 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H0V2	(0x8 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H1V2	(0x9 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H2V2	(0xa << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H3V2	(0xb << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H0V3	(0xc << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H1V3	(0xd << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H2V3	(0xe << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H3V3	(0xf << MC_ITP_INFO_ITP_CASE_BIT)
+
+/* MC TAP Filter Coefficient 1 Register */
+#define MC_TAP_COEF1_TAP_COEF4_BIT	24
+#define MC_TAP_COEF1_TAP_COEF4_MASK	(0xff << MC_TAP_COEF1_TAP_COEF4_BIT)
+#define MC_TAP_COEF1_TAP_COEF3_BIT	16
+#define MC_TAP_COEF1_TAP_COEF3_MASK	(0xff << MC_TAP_COEF1_TAP_COEF3_BIT)
+#define MC_TAP_COEF1_TAP_COEF2_BIT	8
+#define MC_TAP_COEF1_TAP_COEF2_MASK	(0xff << MC_TAP_COEF1_TAP_COEF2_BIT)
+#define MC_TAP_COEF1_TAP_COEF1_BIT	0
+#define MC_TAP_COEF1_TAP_COEF1_MASK	(0xff << MC_TAP_COEF1_TAP_COEF1_BIT)
+
+/* MC TAP Filter Coefficient 2 Register */
+#define MC_TAP_COEF2_TAP_COEF8_BIT	24
+#define MC_TAP_COEF2_TAP_COEF8_MASK	(0xff << MC_TAP_COEF2_TAP_COEF8_BIT)
+#define MC_TAP_COEF2_TAP_COEF7_BIT	16
+#define MC_TAP_COEF2_TAP_COEF7_MASK	(0xff << MC_TAP_COEF2_TAP_COEF7_BIT)
+#define MC_TAP_COEF2_TAP_COEF6_BIT	8
+#define MC_TAP_COEF2_TAP_COEF6_MASK	(0xff << MC_TAP_COEF2_TAP_COEF6_BIT)
+#define MC_TAP_COEF2_TAP_COEF5_BIT	0
+#define MC_TAP_COEF2_TAP_COEF5_MASK	(0xff << MC_TAP_COEF2_TAP_COEF5_BIT)
+
+
+/*************************************************************************
+ * ME (Motion Estimation)
+ *************************************************************************/
+#define ME_CTRL		(ME_BASE + 0x00) /* ME Control Register */
+#define ME_REF_ADDR	(ME_BASE + 0x04) /* ME Reference Block Address Register */
+#define ME_CURR_ADDR	(ME_BASE + 0x08) /* ME Current Block Address Register */
+#define ME_DIFF_ADDR	(ME_BASE + 0x0C) /* ME Difference Address Register */
+#define ME_REF_STRD	(ME_BASE + 0x10) /* ME Reference Frame Stride Register */
+#define ME_CURR_STRD	(ME_BASE + 0x14) /* ME Current Frame Stride Register */
+#define ME_DIFF_STRD	(ME_BASE + 0x18) /* ME Difference Frame Stride Register */
+#define ME_SETTINGS	(ME_BASE + 0x1C) /* ME Settings Register */
+#define ME_MVD		(ME_BASE + 0x20) /* ME Motion Vector Difference Register */
+#define ME_FLAG		(ME_BASE + 0x24) /* ME Flag Register */
+
+#define REG_ME_CTRL		REG32(ME_CTRL)
+#define REG_ME_REF_ADDR		REG32(ME_REF_ADDR)
+#define REG_ME_CURR_ADDR	REG32(ME_CURR_ADDR)
+#define REG_ME_DIFF_ADDR	REG32(ME_DIFF_ADDR)
+#define REG_ME_REF_STRD		REG32(ME_REF_STRD)
+#define REG_ME_CURR_STRD	REG32(ME_CURR_STRD)
+#define REG_ME_DIFF_STRD	REG32(ME_DIFF_STRD)
+#define REG_ME_SETTINGS		REG32(ME_SETTINGS)
+#define REG_ME_MVD		REG32(ME_MVD)
+#define REG_ME_FLAG		REG32(ME_FLAG)
+
+
+/* ME Control Register */
+#define ME_CTRL_FLUSH		(1 << 2) /* ME cache clear */
+#define ME_CTRL_RESET		(1 << 1) /* ME reset */
+#define ME_CTRL_ENABLE		(1 << 0) /* ME enable */
+
+/* ME Settings Register */
+#define ME_SETTINGS_SAD_GATE_BIT	16 /* The max SAD value which can be accepted */
+#define ME_SETTINGS_SAD_GATE_MASK	(0xffff << ME_SETTINGS_SAD_GATE_BIT)
+#define ME_SETTINGS_STEP_NUM_BIT	0  /* The max step number the search process can not exceed */
+#define ME_SETTINGS_STEP_NUM_MASK	(0x3f << ME_SETTINGS_STEP_NUM_BIT)
+
+/* ME Motion Vector Difference Register */
+#define ME_MVD_MVDY_BIT		16 /* The MVD value of coordinate-Y */
+#define ME_MVD_MVDY_MASK	(0xffff << ME_MVD_MVDY_BIT)
+#define ME_MVD_MVDX_BIT		0  /* The MVD value of coordinate-X */
+#define ME_MVD_MVDX_MASK	(0xffff << ME_MVD_MVDX_BIT)
+
+/* ME Flag Register */
+#define ME_FLAG_INTRA		(1 << 1) /* Indicate the current MB will be predicted in intra mode */
+#define ME_FLAG_COMPLETED	(1 << 0) /* The ME of the current part of the MB is completed */
+
+
+/*************************************************************************
+ * OTP (One Time Programmable Module)
+ *************************************************************************/
+#define OTP_ID0		(OTP_BASE + 0x00) /* ID0 Register */
+#define OTP_ID1		(OTP_BASE + 0x04) /* ID1 Register */
+#define OTP_ID2		(OTP_BASE + 0x08) /* ID2 Register */
+#define OTP_ID3		(OTP_BASE + 0x0C) /* ID3 Register */
+#define OTP_BR0		(OTP_BASE + 0x10) /* BOOTROM0 Register */
+#define OTP_BR1		(OTP_BASE + 0x14) /* BOOTROM1 Register */
+#define OTP_HW0		(OTP_BASE + 0x18) /* Chip Hardware 0 Register */
+#define OTP_HW1		(OTP_BASE + 0x1C) /* Chip Hardware 1 Register */
+
+#define REG_OTP_ID0	REG32(OTP_ID0)
+#define REG_OTP_ID1	REG32(OTP_ID1)
+#define REG_OTP_ID2	REG32(OTP_ID2)
+#define REG_OTP_ID3	REG32(OTP_ID3)
+#define REG_OTP_BR0	REG32(OTP_BR0)
+#define REG_OTP_BR1	REG32(OTP_BR1)
+#define REG_OTP_HW0	REG32(OTP_HW0)
+#define REG_OTP_HW1	REG32(OTP_HW1)
+
+/* ID0 Register */
+#define OTP_ID0_WID_BIT		24 /* Wafer ID */
+#define OTP_ID0_WID_MASK	(0xff << OTP_ID0_WID_BIT)
+#define OTP_ID0_MID_BIT		16 /* MASK ID */
+#define OTP_ID0_MID_MASK	(0xff << OTP_ID0_MID_BIT)
+#define OTP_ID0_FID_BIT		8 /* Foundary ID */
+#define OTP_ID0_FID_MASK	(0xff << OTP_ID0_FID_BIT)
+#define OTP_ID0_PID_BIT		0 /* Product ID */
+#define OTP_ID0_PID_MASK	(0xff << OTP_ID0_PID_BIT)
+
+/* ID1 Register */
+#define OTP_ID1_LID_BIT		8 /* Lot ID */
+#define OTP_ID1_LID_MASK	(0xffffff << OTP_ID1_LID_BIT)
+#define OTP_ID1_TID_BIT		0 /* Test House ID */
+#define OTP_ID1_TID_MASK	(0xff << OTP_ID1_TID_BIT)
+
+/* ID2 Register */
+#define OTP_ID2_XADR_BIT	24 /* Die X-dir Address */
+#define OTP_ID2_XADR_MASK	(0xff << OTP_ID2_XADR_BIT)
+#define OTP_ID2_YADR_BIT	16 /* Die Y-dir Address */
+#define OTP_ID2_YADR_MASK	(0xff << OTP_ID2_YADR_BIT)
+#define OTP_ID2_TDATE_BIT	0  /* Testing Date */
+#define OTP_ID2_TDATE_MASK	(0xffff << OTP_ID2_TDATE_BIT)
+
+/* ID3 Register */
+#define OTP_ID3_CID_BIT		16 /* Customer ID */
+#define OTP_ID3_CID_MASK	(0xffff << OTP_ID3_CID_BIT)
+#define OTP_ID3_CP_BIT		0 /* Chip Parameters */
+#define OTP_ID3_CP_MASK		(0xffff << OTP_ID3_CP_BIT)
+
+/* BOOTROM1 Register */
+#define OTP_BR1_UDCBOOT_BIT	0
+#define OTP_BR1_UDCBOOT_MASK	(0xff << OTP_BR1_UDCBOOT_BIT)
+  #define OTP_BR1_UDCBOOT_AUTO	(0xf0 << OTP_BR1_UDCBOOT_BIT)
+  #define OTP_BR1_UDCBOOT_24M	(0x0f << OTP_BR1_UDCBOOT_BIT) /* 24MHz OSC */
+  #define OTP_BR1_UDCBOOT_13M	(0x0c << OTP_BR1_UDCBOOT_BIT) /* 13MHz OSC */
+  #define OTP_BR1_UDCBOOT_26M	(0x03 << OTP_BR1_UDCBOOT_BIT) /* 26MHz OSC */
+  #define OTP_BR1_UDCBOOT_27M	(0x00 << OTP_BR1_UDCBOOT_BIT) /* 27MHz OSC */
+
+/* Chip Hardware 1 Register */
+#define OTP_HW1_MC_EN		(0x3 << 30) /* MC is enabled */
+#define OTP_HW1_ME_EN		(0x3 << 28)
+#define OTP_HW1_DE_EN		(0x3 << 26)
+#define OTP_HW1_IDCT_EN		(0x3 << 24)
+#define OTP_HW1_UART3_EN	(0x3 << 22)
+#define OTP_HW1_UART2_EN	(0x3 << 20)
+#define OTP_HW1_UART1_EN	(0x3 << 18)
+#define OTP_HW1_UART0_EN	(0x3 << 16)
+#define OTP_HW1_SSI1_EN		(0x3 << 14)
+#define OTP_HW1_SSI0_EN		(0x3 << 12)
+#define OTP_HW1_MSC1_EN		(0x3 << 10)
+#define OTP_HW1_MSC0_EN		(0x3 << 8)
+#define OTP_HW1_UHC_EN		(0x3 << 6)
+#define OTP_HW1_TVE_EN		(0x3 << 4)
+#define OTP_HW1_TSSI_EN		(0x3 << 2)
+#define OTP_HW1_CIM_EN		(0x3 << 0)
+
+
+/*************************************************************************
+ * TSSI MPEG 2-TS slave interface
+ *************************************************************************/
+#define TSSI_ENA       ( TSSI_BASE + 0x00 )   /* TSSI enable register */
+#define TSSI_CFG       ( TSSI_BASE + 0x04 )   /* TSSI configure register */
+#define TSSI_CTRL      ( TSSI_BASE + 0x08 )   /* TSSI control register */
+#define TSSI_STAT      ( TSSI_BASE + 0x0c )   /* TSSI state register */
+#define TSSI_FIFO      ( TSSI_BASE + 0x10 )   /* TSSI FIFO register */
+#define TSSI_PEN       ( TSSI_BASE + 0x14 )   /* TSSI PID enable register */
+#define TSSI_PID(n)    ( TSSI_BASE + 0x20 + 4*(n) )   /* TSSI PID filter register */
+#define TSSI_PID0      ( TSSI_BASE + 0x20 )
+#define TSSI_PID1      ( TSSI_BASE + 0x24 )
+#define TSSI_PID2      ( TSSI_BASE + 0x28 )
+#define TSSI_PID3      ( TSSI_BASE + 0x2c )
+#define TSSI_PID4      ( TSSI_BASE + 0x30 )
+#define TSSI_PID5      ( TSSI_BASE + 0x34 )
+#define TSSI_PID6      ( TSSI_BASE + 0x38 )
+#define TSSI_PID7      ( TSSI_BASE + 0x3c )
+#define TSSI_PID_MAX   8	/* max PID: 7 */
+ 
+#define REG_TSSI_ENA       REG8( TSSI_ENA )
+#define REG_TSSI_CFG       REG16( TSSI_CFG )
+#define REG_TSSI_CTRL      REG8( TSSI_CTRL )
+#define REG_TSSI_STAT      REG8( TSSI_STAT )
+#define REG_TSSI_FIFO      REG32( TSSI_FIFO )
+#define REG_TSSI_PEN       REG32( TSSI_PEN )
+#define REG_TSSI_PID(n)    REG32( TSSI_PID(n) )
+#define REG_TSSI_PID0      REG32( TSSI_PID0 )
+#define REG_TSSI_PID1      REG32( TSSI_PID1 )
+#define REG_TSSI_PID2      REG32( TSSI_PID2 )
+#define REG_TSSI_PID3      REG32( TSSI_PID3 )
+#define REG_TSSI_PID4      REG32( TSSI_PID4 )
+#define REG_TSSI_PID5      REG32( TSSI_PID5 )
+#define REG_TSSI_PID6      REG32( TSSI_PID6 )
+#define REG_TSSI_PID7      REG32( TSSI_PID7 )
+
+/* TSSI enable register */
+#define TSSI_ENA_SFT_RST 	( 1 << 7 )      /* soft reset bit */
+#define TSSI_ENA_PID_EN 	( 1 << 2 )      /* soft filtering function enable bit */
+#define TSSI_ENA_DMA_EN 	( 1 << 1 )      /* DMA enable bit */
+#define TSSI_ENA_ENA 		( 1 << 0 )      /* TSSI enable bit */
+
+/* TSSI configure register */
+#define TSSI_CFG_TRIG_BIT 	14 /* fifo trig number */
+#define TSSI_CFG_TRIG_MASK 	( 0x3 << TSSI_CFG_TRIG_BIT)
+#define TSSI_CFG_TRIG_4 	( 0 << TSSI_CFG_TRIG_BIT)
+#define TSSI_CFG_TRIG_8 	( 1 << TSSI_CFG_TRIG_BIT)
+#define TSSI_CFG_TRIG_16 	( 2 << TSSI_CFG_TRIG_BIT)
+#define TSSI_CFG_END_WD 	( 1 << 9 )      /* order of data in word */
+#define TSSI_CFG_END_BT 	( 1 << 8 )      /* order of data in byte */
+#define TSSI_CFG_TSDI_H 	( 1 << 7 )      /* data pin polarity */
+#define TSSI_CFG_USE_0 		( 1 << 6 )      /* serial mode data pin select */
+#define TSSI_CFG_USE_TSDI0 	( 0 << 6 )      /* TSDI0 as serial mode data pin */
+#define TSSI_CFG_USE_TSDI7 	( 1 << 6 )      /* TSDI7 as serial mode data pin */
+#define TSSI_CFG_TSCLK_CH 	( 1 << 5 )      /* clk channel select */
+#define TSSI_CFG_PARAL 		( 1 << 4 )      /* mode select */
+#define TSSI_CFG_PARAL_MODE 	( 1 << 4 )      /* parallel select */
+#define TSSI_CFG_SERIAL_MODE 	( 0 << 4 )      /* serial select */
+#define TSSI_CFG_TSCLK_P 	( 1 << 3 )      /* clk edge select */
+#define TSSI_CFG_TSFRM_H 	( 1 << 2 )      /* TSFRM polarity select */
+#define TSSI_CFG_TSSTR_H 	( 1 << 1 )      /* TSSTR polarity select */
+#define TSSI_CFG_TSFAIL_H 	( 1 << 0 )      /* TSFAIL polarity select */
+
+/* TSSI control register */
+#define TSSI_CTRL_OVRNM 	( 1 << 1 )      /* FIFO overrun interrupt mask bit */
+#define TSSI_CTRL_TRIGM 	( 1 << 0 )      /* FIFO trigger interrupt mask bit */
+
+/* TSSI state register */
+#define TSSI_STAT_OVRN 		( 1 << 1 )      /* FIFO overrun interrupt flag bit */
+#define TSSI_STAT_TRIG 		( 1 << 0 )      /* FIFO trigger interrupt flag bit */
+
+/* TSSI PID enable register */
+#define TSSI_PEN_EN00 	( 1 << 0 )      /* enable PID n */
+#define TSSI_PEN_EN10 	( 1 << 1 )      
+#define TSSI_PEN_EN20 	( 1 << 2 )      
+#define TSSI_PEN_EN30 	( 1 << 3 )      
+#define TSSI_PEN_EN40 	( 1 << 4 )      
+#define TSSI_PEN_EN50 	( 1 << 5 )      
+#define TSSI_PEN_EN60 	( 1 << 6 )      
+#define TSSI_PEN_EN70 	( 1 << 7 )      
+#define TSSI_PEN_EN01 	( 1 << 16 )      
+#define TSSI_PEN_EN11 	( 1 << 17 )      
+#define TSSI_PEN_EN21 	( 1 << 18 )     
+#define TSSI_PEN_EN31 	( 1 << 19 )      
+#define TSSI_PEN_EN41 	( 1 << 20 )     
+#define TSSI_PEN_EN51 	( 1 << 21 )      
+#define TSSI_PEN_EN61 	( 1 << 22 )     
+#define TSSI_PEN_EN71 	( 1 << 23 )      
+#define TSSI_PEN_PID0 	( 1 << 31 ) /* PID filter enable PID0 */
+
+/* TSSI PID Filter Registers */
+#define TSSI_PID_PID1_BIT 	16
+#define TSSI_PID_PID1_MASK 	(0x1FFF<<TSSI_PID_PID1_BIT)
+#define TSSI_PID_PID0_BIT 	0
+#define TSSI_PID_PID0_MASK 	(0x1FFF<<TSSI_PID_PID0_BIT)
+
+
+/*************************************************************************
+ * IPU (Image Processing Unit)
+ *************************************************************************/
+#define IPU_V_BASE		0xB3080000
+#define IPU_P_BASE		0x13080000
+
+/* Register offset */
+#define REG_CTRL		0x0  /* IPU Control Register */
+#define REG_STATUS		0x4  /* IPU Status Register */
+#define REG_D_FMT		0x8  /* Data Format Register */
+#define REG_Y_ADDR		0xc  /* Input Y or YUV422 Packaged Data Address Register */
+#define REG_U_ADDR		0x10 /* Input U Data Address Register */
+#define REG_V_ADDR		0x14 /* Input V Data Address Register */
+#define REG_IN_FM_GS		0x18 /* Input Geometric Size Register */
+#define REG_Y_STRIDE		0x1c /* Input Y Data Line Stride Register */
+#define REG_UV_STRIDE		0x20 /* Input UV Data Line Stride Register */
+#define REG_OUT_ADDR		0x24 /* Output Frame Start Address Register */
+#define REG_OUT_GS		0x28 /* Output Geometric Size Register */
+#define REG_OUT_STRIDE		0x2c /* Output Data Line Stride Register */
+#define REG_RSZ_COEF_INDEX	0x30 /* Resize Coefficients Table Index Register */
+#define REG_CSC_CO_COEF		0x34 /* CSC C0 Coefficient Register */
+#define REG_CSC_C1_COEF		0x38 /* CSC C1 Coefficient Register */
+#define REG_CSC_C2_COEF 	0x3c /* CSC C2 Coefficient Register */
+#define REG_CSC_C3_COEF 	0x40 /* CSC C3 Coefficient Register */
+#define REG_CSC_C4_COEF 	0x44 /* CSC C4 Coefficient Register */
+#define HRSZ_LUT_BASE 		0x48 /* Horizontal Resize Coefficients Look Up Table Register group */
+#define VRSZ_LUT_BASE 		0x4c /* Virtical Resize Coefficients Look Up Table Register group */
+#define REG_CSC_OFSET_PARA	0x50 /* CSC Offset Parameter Register */
+#define REG_Y_PHY_T_ADDR	0x54 /* Input Y Physical Table Address Register */
+#define REG_U_PHY_T_ADDR	0x58 /* Input U Physical Table Address Register */
+#define REG_V_PHY_T_ADDR	0x5c /* Input V Physical Table Address Register */
+#define REG_OUT_PHY_T_ADDR	0x60 /* Output Physical Table Address Register */
+
+/* REG_CTRL: IPU Control Register */
+#define IPU_CE_SFT	0x0
+#define IPU_CE_MSK	0x1
+#define IPU_RUN_SFT	0x1
+#define IPU_RUN_MSK	0x1
+#define HRSZ_EN_SFT	0x2
+#define HRSZ_EN_MSK	0x1
+#define VRSZ_EN_SFT	0x3
+#define VRSZ_EN_MSK	0x1
+#define CSC_EN_SFT	0x4
+#define CSC_EN_MSK	0x1
+#define FM_IRQ_EN_SFT	0x5
+#define FM_IRQ_EN_MSK	0x1
+#define IPU_RST_SFT	0x6
+#define IPU_RST_MSK	0x1
+#define H_SCALE_SFT	0x8
+#define H_SCALE_MSK	0x1
+#define V_SCALE_SFT	0x9
+#define V_SCALE_MSK	0x1
+#define PKG_SEL_SFT	0xA
+#define PKG_SEL_MSK	0x1
+#define LCDC_SEL_SFT	0xB
+#define LCDC_SEL_MSK	0x1
+#define SPAGE_MAP_SFT	0xC
+#define SPAGE_MAP_MSK	0x1
+#define DPAGE_SEL_SFT	0xD
+#define DPAGE_SEL_MSK	0x1
+#define DISP_SEL_SFT	0xE
+#define DISP_SEL_MSK	0x1
+#define FIELD_CONF_EN_SFT 15
+#define FIELD_CONF_EN_MSK 1
+#define FIELD_SEL_SFT	16
+#define FIELD_SEL_MSK	1
+#define DFIX_SEL_SFT	17
+#define DFIX_SEL_MSK	1
+
+/* REG_STATUS: IPU Status Register */
+#define OUT_END_SFT	0x0
+#define OUT_END_MSK	0x1
+#define FMT_ERR_SFT	0x1
+#define FMT_ERR_MSK	0x1
+#define SIZE_ERR_SFT	0x2
+#define SIZE_ERR_MSK	0x1
+
+/* D_FMT: Data Format Register */
+#define IN_FMT_SFT	0x0
+#define IN_FMT_MSK 	0x3
+#define IN_OFT_SFT 	0x2
+#define IN_OFT_MSK 	0x3
+#define YUV_PKG_OUT_SFT	0x10
+#define YUV_PKG_OUT_MSK	0x7
+#define OUT_FMT_SFT 	0x13
+#define OUT_FMT_MSK 	0x3
+#define RGB_OUT_OFT_SFT	0x15
+#define RGB_OUT_OFT_MSK	0x7
+#define RGB888_FMT_SFT	0x18
+#define RGB888_FMT_MSK	0x1
+
+/* IN_FM_GS: Input Geometric Size Register */
+#define IN_FM_H_SFT	0x0
+#define IN_FM_H_MSK	0xFFF
+#define IN_FM_W_SFT	0x10
+#define IN_FM_W_MSK	0xFFF
+
+/* Y_STRIDE: Input Y Data Line Stride Register */
+#define Y_S_SFT		0x0
+#define Y_S_MSK		0x3FFF
+
+/* UV_STRIDE: Input UV Data Line Stride Register */
+#define V_S_SFT		0x0
+#define V_S_MSK		0x1FFF
+#define U_S_SFT 	0x10
+#define U_S_MSK		0x1FFF
+
+/* OUT_GS: Output Geometric Size Register */
+#define OUT_FM_H_SFT	0x0
+#define OUT_FM_H_MSK	0x1FFF
+#define OUT_FM_W_SFT	0x10
+#define OUT_FM_W_MSK	0x7FFF
+
+/* OUT_STRIDE: Output Data Line Stride Register */
+#define OUT_S_SFT	0x0
+#define OUT_S_MSK	0xFFFF
+
+/* RSZ_COEF_INDEX: Resize Coefficients Table Index Register */
+#define VE_IDX_SFT	0x0
+#define VE_IDX_MSK	0x1F
+#define HE_IDX_SFT	0x10
+#define HE_IDX_MSK	0x1F
+
+/* CSC_CX_COEF: CSC CX Coefficient Register */
+#define CX_COEF_SFT	0x0
+#define CX_COEF_MSK	0xFFF
+
+/* HRSZ_LUT_BASE, VRSZ_LUT_BASE: Resize Coefficients Look Up Table Register group */
+#define LUT_LEN		20
+
+#define OUT_N_SFT	0x0
+#define OUT_N_MSK	0x1
+#define IN_N_SFT	0x1
+#define IN_N_MSK	0x1
+#define W_COEF_SFT	0x2
+#define W_COEF_MSK	0x3FF
+
+/* CSC_OFSET_PARA: CSC Offset Parameter Register */
+#define CHROM_OF_SFT	0x10
+#define CHROM_OF_MSK	0xFF
+#define LUMA_OF_SFT	0x00
+#define LUMA_OF_MSK	0xFF
+
+
+#endif /* __JZ4750_REGS_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750/serial.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750/serial.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,30 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750/serial.h
+ *
+ *  Ingenic's JZ4750 common include.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_BOARD_SERIAL_H__
+#define __ASM_BOARD_SERIAL_H__
+
+#ifndef CONFIG_SERIAL_MANY_PORTS
+#undef RS_TABLE_SIZE
+#define RS_TABLE_SIZE  1
+#endif
+
+#define JZ_BASE_BAUD	(12000000/16)
+
+#define JZ_SERIAL_PORT_DEFNS \
+	{ .baud_base = JZ_BASE_BAUD, .irq = IRQ_UART0, \
+	  .flags = STD_COM_FLAGS, .iomem_base = (u8 *)UART0_BASE, \
+	  .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM },
+
+#endif /* __ASM_BORAD_SERIAL_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750/war.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750/war.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_JZ4740_WAR_H
+#define __ASM_MIPS_MACH_JZ4740_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_JZ4740_WAR_H */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750d/board-fuwa1.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750d/board-fuwa1.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,124 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750d/board-fuwa1.h
+ *
+ *  JZ4750D-based FUWA1 board ver 1.x definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750D_FUWA1_H__
+#define __ASM_JZ4750D_FUWA1_H__
+
+#define CONFIG_FPGA	 /* fuwa is an FPGA board */
+
+/*====================================================================== 
+ * Frequencies of on-board oscillators
+ */
+#define JZ_EXTAL		48000000  /* Main extal freq: 12 MHz */
+#define JZ_EXTAL2		32768     /* RTC extal freq: 32.768 KHz */
+#define CFG_DIV                 1         /* hclk=pclk=mclk=CFG_EXTAL/CFG_DIV, just for FPGA board */
+
+
+/*====================================================================== 
+ * GPIO
+ */
+#define GPIO_SD0_VCC_EN_N	(32*2+10) /* GPC10 */
+#define GPIO_SD0_CD_N		(32*2+11) /* GPC11 */
+#define GPIO_SD0_WP		(32*2+12) /* GPC12 */
+#define GPIO_SD1_VCC_EN_N	(32*2+13) /* GPC13 */
+#define GPIO_SD1_CD_N		(32*2+14) /* GPC14 */
+#define GPIO_USB_DETE		102 /* GPD6 */
+#define GPIO_DC_DETE_N		103 /* GPD7 */
+#define GPIO_CHARG_STAT_N	111 /* GPD15 */
+#define GPIO_DISP_OFF_N		121 /* GPD25, LCD_REV */
+//#define GPIO_LED_EN       	124 /* GPD28 */
+
+#define GPIO_UDC_HOTPLUG	GPIO_USB_DETE
+
+/*====================================================================== 
+ * LCD backlight
+ */
+#define GPIO_LCD_PWM   		(32*4+20) /* GPE20 */
+
+#define LCD_PWM_CHN 0    /* pwm channel */
+#define LCD_PWM_FULL 101
+/* 100 level: 0,1,...,100 */
+#define __lcd_set_backlight_level(n)	\
+do {					\
+	__gpio_as_output(GPIO_LCD_PWM);	\
+	__gpio_set_pin(GPIO_LCD_PWM);	\
+} while (0)
+
+#define __lcd_close_backlight()		\
+do {					\
+	__gpio_as_output(GPIO_LCD_PWM);	\
+	__gpio_clear_pin(GPIO_LCD_PWM);	\
+} while (0)
+
+/*====================================================================== 
+ * MMC/SD
+ */
+
+#define MSC0_WP_PIN		GPIO_SD0_WP
+#define MSC0_HOTPLUG_PIN	GPIO_SD0_CD_N
+#define MSC0_HOTPLUG_IRQ	(IRQ_GPIO_0 + GPIO_SD0_CD_N)
+
+#define MSC1_WP_PIN		GPIO_SD1_WP
+#define MSC1_HOTPLUG_PIN	GPIO_SD1_CD_N
+#define MSC1_HOTPLUG_IRQ	(IRQ_GPIO_0 + GPIO_SD1_CD_N)
+
+#define __msc0_init_io()			\
+do {						\
+	__gpio_as_output(GPIO_SD0_VCC_EN_N);	\
+	__gpio_as_input(GPIO_SD0_CD_N);		\
+} while (0)
+
+#define __msc0_enable_power()			\
+do {						\
+	__gpio_clear_pin(GPIO_SD0_VCC_EN_N);	\
+} while (0)
+
+#define __msc0_disable_power()			\
+do {						\
+	__gpio_set_pin(GPIO_SD0_VCC_EN_N);	\
+} while (0)
+
+#define __msc0_card_detected(s)			\
+({						\
+	int detected = 1;			\
+	if (__gpio_get_pin(GPIO_SD0_CD_N))	\
+		detected = 0;			\
+	detected;				\
+})
+
+#define __msc1_init_io()			\
+do {						\
+	/*	__gpio_as_output(GPIO_SD1_VCC_EN_N);*/	\
+	/*      __gpio_as_input(GPIO_SD1_CD_N);*/	\
+} while (0)
+
+#define __msc1_enable_power()			\
+do {						\
+	/*	__gpio_clear_pin(GPIO_SD1_VCC_EN_N);*/	\
+} while (0)
+
+#define __msc1_disable_power()			\
+do {						\
+	/*	__gpio_set_pin(GPIO_SD1_VCC_EN_N);*/	\
+} while (0)
+
+#define __msc1_card_detected(s)			\
+({						\
+	int detected = 0;			\
+	if (__gpio_get_pin(GPIO_SD1_CD_N))	\
+		detected = 1;			\
+	detected;				\
+})
+
+#endif /* __ASM_JZ4750d_FUWA1_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750d/clock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750d/clock.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,230 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750d/clock.h
+ *
+ *  JZ4750D clocks definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750D_CLOCK_H__
+#define __ASM_JZ4750D_CLOCK_H__
+
+#ifndef JZ_EXTAL
+#define JZ_EXTAL		12000000   /* 3.6864 MHz */
+#endif
+#ifndef JZ_EXTAL2
+#define JZ_EXTAL2		32768     /* 32.768 KHz */
+#endif
+
+/*
+ * JZ4750D clocks structure
+ */
+typedef struct {
+	unsigned int cclk;      /* CPU clock */
+	unsigned int hclk;      /* System bus clock */
+	unsigned int pclk;      /* Peripheral bus clock */
+	unsigned int mclk;      /* Flash/SRAM/SDRAM clock */
+	unsigned int lcdclk;    /* LCDC module clock */
+	unsigned int pixclk;    /* LCD pixel clock */
+	unsigned int i2sclk;    /* AIC module clock */
+	unsigned int usbclk;    /* USB module clock */
+	unsigned int mscclk;    /* MSC module clock */
+	unsigned int extalclk;  /* EXTAL clock for UART,I2C,SSI,TCU,USB-PHY */
+	unsigned int rtcclk;    /* RTC clock for CPM,INTC,RTC,TCU,WDT */
+} jz_clocks_t;
+
+extern jz_clocks_t jz_clocks;
+
+
+/* PLL output frequency */
+static __inline__ unsigned int __cpm_get_pllout(void)
+{
+#if defined(CONFIG_FPGA)
+	return JZ_EXTAL/CFG_DIV;
+#else
+	unsigned long m, n, no, pllout;
+	unsigned long cppcr = REG_CPM_CPPCR;
+	unsigned long od[4] = {1, 2, 2, 4};
+	if ((cppcr & CPM_CPPCR_PLLEN) && !(cppcr & CPM_CPPCR_PLLBP)) {
+		m = __cpm_get_pllm() + 2;
+		n = __cpm_get_plln() + 2;
+		no = od[__cpm_get_pllod()];
+		pllout = ((JZ_EXTAL) / (n * no)) * m;
+	} else
+		pllout = JZ_EXTAL;
+	return pllout;
+#endif
+}
+
+/* PLL output frequency for MSC/I2S/LCD/USB */
+static __inline__ unsigned int __cpm_get_pllout2(void)
+{
+#if defined(CONFIG_FPGA)
+	return JZ_EXTAL/CFG_DIV;
+#else
+	if (REG_CPM_CPCCR & CPM_CPCCR_PCS)
+		return __cpm_get_pllout();
+	else
+		return __cpm_get_pllout()/2;
+#endif
+}
+
+/* CPU core clock */
+static __inline__ unsigned int __cpm_get_cclk(void)
+{
+
+#if defined(CONFIG_FGPA)
+	return JZ_EXTAL;
+#else
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	return __cpm_get_pllout() / div[__cpm_get_cdiv()];
+#endif
+}
+
+/* AHB system bus clock */
+static __inline__ unsigned int __cpm_get_hclk(void)
+{
+#if defined(CONFIG_FPGA)
+	return JZ_EXTAL/CFG_DIV;
+#else
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_hdiv()];
+#endif
+
+}
+
+/* Memory bus clock */
+static __inline__ unsigned int __cpm_get_mclk(void)
+{
+#if defined(CONFIG_FPGA)
+	return JZ_EXTAL/CFG_DIV;
+#else
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_mdiv()];
+#endif
+}
+
+/* APB peripheral bus clock */
+static __inline__ unsigned int __cpm_get_pclk(void)
+{
+#if defined(CONFIG_FPGA)
+	return JZ_EXTAL/CFG_DIV;
+#else
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+
+	return __cpm_get_pllout() / div[__cpm_get_pdiv()];
+#endif
+}
+
+/* LCDC module clock */
+static __inline__ unsigned int __cpm_get_lcdclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_ldiv() + 1);
+}
+
+/* LCD pixel clock */
+static __inline__ unsigned int __cpm_get_pixclk(void)
+{
+	return __cpm_get_pllout2() / (__cpm_get_pixdiv() + 1);
+}
+
+/* I2S clock */
+static __inline__ unsigned int __cpm_get_i2sclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_I2CS) {
+		return __cpm_get_pllout2() / (__cpm_get_i2sdiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* USB clock */
+static __inline__ unsigned int __cpm_get_usbclk(void)
+{
+	if (REG_CPM_CPCCR & CPM_CPCCR_UCS) {
+		return __cpm_get_pllout2() / (__cpm_get_udiv() + 1);
+	}
+	else {
+		return JZ_EXTAL;
+	}
+}
+
+/* 
+ * MSC clock
+ * @n: the index of MMC/SD controller 
+ */
+static __inline__ unsigned int __cpm_get_mscclk(int n)
+{
+	return __cpm_get_pllout2() / (__cpm_get_mscdiv(n) + 1);
+}
+
+/* EXTAL clock */
+static __inline__ unsigned int __cpm_get_extalclk0(void)
+{
+	return JZ_EXTAL;
+}
+
+/* EXTAL clock for UART,I2C,SSI,TCU,USB-PHY */
+static __inline__ unsigned int __cpm_get_extalclk(void)
+{
+#if defined(CONFIG_FPGA)
+	return __cpm_get_pllout();
+#else
+	if (REG_CPM_CPCCR & CPM_CPCCR_ECS)
+		return __cpm_get_extalclk0()/2;
+	else
+		return __cpm_get_extalclk0();
+#endif
+
+}
+
+/* RTC clock for CPM,INTC,RTC,TCU,WDT */
+static __inline__ unsigned int __cpm_get_rtcclk(void)
+{
+	return JZ_EXTAL2;
+}
+
+/*
+ * Output 24MHz for SD and 16MHz for MMC.
+ * @n: the index of MMC/SD controller
+ */
+static inline void __cpm_select_msc_clk(int n, int sd)
+{
+	unsigned int pllout2 = __cpm_get_pllout2();
+	unsigned int div = 0;
+
+	if (sd) {
+		div = pllout2 / 24000000;
+	}
+	else {
+		div = pllout2 / 16000000;
+	}
+
+	REG_CPM_MSCCDR(n) = div - 1;
+	REG_CPM_CPCCR |= CPM_CPCCR_CE;
+}
+
+/*
+ * Output 48MHz for high speed card.
+ */
+static inline void __cpm_select_msc_clk_high(int n, int sd)
+{
+	unsigned int pllout2 = __cpm_get_pllout2();
+	unsigned int div = 0;
+
+	div = pllout2 / 48000000;
+
+	REG_CPM_MSCCDR(n) = div - 1;
+	REG_CPM_CPCCR |= CPM_CPCCR_CE;
+}
+
+#endif /* __ASM_JZ4750D_CLOCK_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750d/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750d/dma.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,307 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750d/dma.h
+ *
+ *  JZ4750D DMA definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750D_DMA_H__
+#define __ASM_JZ4750D_DMA_H__
+
+#include <linux/interrupt.h>
+#include <asm/io.h>			/* need byte IO */
+#include <linux/spinlock.h>		/* And spinlocks */
+#include <linux/delay.h>
+#include <asm/system.h>
+
+/*
+ * Descriptor structure for JZ4750D DMA engine
+ * Note: this structure must always be aligned to a 16-bytes boundary.
+ */
+
+/* old descriptor 4-word */
+typedef struct {
+	volatile u32 dcmd;	/* DCMD value for the current transfer */
+	volatile u32 dsadr;	/* DSAR value for the current transfer */
+	volatile u32 dtadr;	/* DTAR value for the current transfer */
+	volatile u32 ddadr;	/* Points to the next descriptor + transfer count */
+} jz_dma_desc;
+
+/* new descriptor 8-word */
+typedef struct {
+	volatile u32 dcmd;	/* DCMD value for the current transfer */
+	volatile u32 dsadr;	/* DSAR value for the current transfer */
+	volatile u32 dtadr;	/* DTAR value for the current transfer */
+	volatile u32 ddadr;	/* Points to the next descriptor + transfer count */
+	volatile u32 dstrd;     /* DMA source and target stride address */
+	volatile u32 dreqt;     /* DMA request type for current transfer */
+	volatile u32 reserved0;	/* Reserved */
+	volatile u32 reserved1;	/* Reserved */
+} jz_dma_desc_8word;
+
+/* DMA Device ID's follow */
+enum {
+	DMA_ID_EXT = 0,		/* External request with DREQn */
+	DMA_ID_NAND,		/* NAND DMA request */
+	DMA_ID_BCH_ENC,		/* BCH Encoding DMA request */
+	DMA_ID_BCH_DEC,		/* BCH Decoding DMA request */
+	DMA_ID_AUTO,		/* Auto-request */
+//	DMA_ID_TSSI_RX,		/* TSSI receive fifo full request */
+	DMA_ID_UART3_TX,	/* UART3 transmit-fifo-empty request */
+	DMA_ID_UART3_RX,	/* UART3 receve-fifo-full request */
+	DMA_ID_UART2_TX,	/* UART2 transmit-fifo-empty request */
+	DMA_ID_UART2_RX,	/* UART2 receve-fifo-full request */
+	DMA_ID_UART1_TX,	/* UART1 transmit-fifo-empty request */
+	DMA_ID_UART1_RX,	/* UART1 receve-fifo-full request */
+	DMA_ID_UART0_TX,	/* UART0 transmit-fifo-empty request */
+	DMA_ID_UART0_RX,	/* UART0 receve-fifo-full request */
+	DMA_ID_SSI0_TX,		/* SSI0 transmit-fifo-full request */
+	DMA_ID_SSI0_RX,		/* SSI0 receive-fifo-empty request */
+	DMA_ID_AIC_TX,		/* AIC transmit-fifo-full request */
+	DMA_ID_AIC_RX,		/* AIC receive-fifo-empty request */
+	DMA_ID_MSC0_TX,		/* MSC0 transmit-fifo-full request */
+	DMA_ID_MSC0_RX,		/* MSC0 receive-fifo-empty request */
+	DMA_ID_TCU_OVERFLOW,	/* TCU channel n overflow interrupt */
+	DMA_ID_SADC,		/* SADC transfer request */
+	DMA_ID_MSC1_TX,		/* MSC1 transmit-fifo-full request */
+	DMA_ID_MSC1_RX,		/* MSC1 receive-fifo-empty request */
+	DMA_ID_SSI1_TX,		/* SSI1 transmit-fifo-full request */
+	DMA_ID_SSI1_RX,		/* SSI1 receive-fifo-empty request */
+	DMA_ID_PCM_TX,		/* PM transmit-fifo-full request */
+	DMA_ID_PCM_RX,		/* PM receive-fifo-empty request */
+	DMA_ID_RAW_SET,
+	DMA_ID_MAX
+};
+
+/* DMA modes, simulated by sw */
+#define DMA_MODE_READ	0x0  /* I/O to memory, no autoinit, increment, single mode */
+#define DMA_MODE_WRITE	0x1  /* memory to I/O, no autoinit, increment, single mode */
+#define DMA_AUTOINIT	0x2
+#define DMA_MODE_MASK	0x3
+
+struct jz_dma_chan {
+	int dev_id;	/* DMA ID: this channel is allocated if >=0, free otherwise */ 
+	unsigned int io;        /* DMA channel number */
+	const char *dev_str;    /* string describes the DMA channel */
+	int irq;                /* DMA irq number */
+	void *irq_dev;          /* DMA private device structure */
+	unsigned int fifo_addr; /* physical fifo address of the requested device */
+	unsigned int cntl;	/* DMA controll */
+	unsigned int mode;      /* DMA configuration */
+	unsigned int source;    /* DMA request source */
+};
+
+extern struct jz_dma_chan jz_dma_table[];
+
+
+#define DMA_8BIT_RX_CMD					\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_8 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_8BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_8BIT_TX_CMD					\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_8 |		\
+	DMAC_DCMD_DS_8BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BIT_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BIT_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BIT_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BIT_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_8 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_16BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_8 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_8 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_32BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_8 |		\
+	DMAC_DCMD_DS_32BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_32_32BYTE_TX_CMD		       	\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_32BYTE | DMAC_DCMD_RDIL_IGN
+#define DMA_AIC_32_16BYTE_TX_CMD		       	\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_32_16BYTE_RX_CMD			\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BIT_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BIT_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BIT | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BYTE_RX_CMD				\
+	DMAC_DCMD_DAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BYTE_TX_CMD				\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_16 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+#define DMA_AIC_16BYTE_TX_CMD_UC			\
+	DMAC_DCMD_SAI |					\
+	DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_16 |		\
+	DMAC_DCMD_DS_16BYTE | DMAC_DCMD_RDIL_IGN
+
+extern int jz_request_dma(int dev_id,
+			  const char *dev_str,
+			  irqreturn_t (*irqhandler)(int, void *),
+			  unsigned long irqflags,
+			  void *irq_dev_id);
+extern void jz_free_dma(unsigned int dmanr);
+
+extern int jz_dma_read_proc(char *buf, char **start, off_t fpos,
+			      int length, int *eof, void *data);
+extern void dump_jz_dma_channel(unsigned int dmanr);
+
+extern void enable_dma(unsigned int dmanr);
+extern void disable_dma(unsigned int dmanr);
+extern void set_dma_addr(unsigned int dmanr, unsigned int phyaddr);
+extern void set_dma_count(unsigned int dmanr, unsigned int bytecnt);
+extern void set_dma_mode(unsigned int dmanr, unsigned int mode);
+extern void jz_set_oss_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt);
+extern void jz_set_alsa_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt);
+extern void jz_set_dma_src_width(int dmanr, int nbit);
+extern void jz_set_dma_dest_width(int dmanr, int nbit);
+extern void jz_set_dma_block_size(int dmanr, int nbyte);
+extern unsigned int get_dma_residue(unsigned int dmanr);
+
+extern spinlock_t  dma_spin_lock;
+
+static __inline__ unsigned long claim_dma_lock(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dma_spin_lock, flags);
+	return flags;
+}
+
+static __inline__ void release_dma_lock(unsigned long flags)
+{
+	spin_unlock_irqrestore(&dma_spin_lock, flags);
+}
+
+/* Clear the 'DMA Pointer Flip Flop'.
+ * Write 0 for LSB/MSB, 1 for MSB/LSB access.
+ */
+#define clear_dma_ff(channel)
+
+static __inline__ struct jz_dma_chan *get_dma_chan(unsigned int dmanr)
+{
+	if (dmanr > MAX_DMA_NUM
+	    || jz_dma_table[dmanr].dev_id < 0)
+		return NULL;
+	return &jz_dma_table[dmanr];
+}
+
+static __inline__ int dma_halted(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 1;
+	return  __dmac_channel_transmit_halt_detected(dmanr) ? 1 : 0;
+}
+
+static __inline__ unsigned int get_dma_mode(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+	return chan->mode;
+}
+
+static __inline__ void clear_dma_done(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+}
+
+static __inline__ void clear_dma_halt(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT);
+	REG_DMAC_DMACR((chan->io)/HALF_DMA_NUM) &= ~(DMAC_DMACR_HLT);
+}
+
+static __inline__ void clear_dma_flag(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+	REG_DMAC_DMACR((chan->io)/HALF_DMA_NUM) &= ~(DMAC_DMACR_HLT | DMAC_DMACR_AR);
+}
+
+static __inline__ void set_dma_page(unsigned int dmanr, char pagenr)
+{
+}
+
+static __inline__ unsigned int get_dma_done_status(unsigned int dmanr)
+{
+	unsigned long dccsr;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+	dccsr = REG_DMAC_DCCSR(chan->io);
+	return dccsr & (DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+}
+
+static __inline__ int get_dma_done_irq(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return -1;
+	return chan->irq;
+}
+
+#endif  /* __ASM_JZ4750D_DMA_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750d/jz4750d.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750d/jz4750d.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750d/jz4750d.h
+ *
+ *  JZ4750 common definition.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750_H__
+#define __ASM_JZ4750_H__
+
+#include <asm/mach-jz4750d/regs.h>
+#include <asm/mach-jz4750d/ops.h>
+#include <asm/mach-jz4750d/dma.h>
+#include <asm/mach-jz4750d/misc.h>
+
+/*------------------------------------------------------------------
+ * Platform definitions
+ */
+#ifdef CONFIG_JZ4750D_FUWA1
+#include <asm/mach-jz4750d/board-fuwa1.h>
+#endif
+
+/* Add other platform definition here ... */
+
+
+/*------------------------------------------------------------------
+ * Follows are related to platform definitions
+ */
+
+#include <asm/mach-jz4750d/clock.h>
+#include <asm/mach-jz4750d/serial.h>
+
+#endif /* __ASM_JZ4750_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750d/misc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750d/misc.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,44 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750d/misc.h
+ *
+ *  Ingenic's JZ4750D common include.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_JZ4750D_MISC_H__
+#define __ASM_JZ4750D_MISC_H__
+
+/*==========================================================
+ * I2C
+ *===========================================================*/
+
+#define I2C_EEPROM_DEV	0xA	/* b'1010 */
+#define I2C_RTC_DEV	0xD	/* b'1101 */
+#define DIMM0_SPD_ADDR	0
+#define DIMM1_SPD_ADDR	1
+#define DIMM2_SPD_ADDR	2
+#define DIMM3_SPD_ADDR	3
+#define JZ_HCI_ADDR	7
+
+#define DIMM_SPD_LEN	128
+#define JZ_HCI_LEN	512    /* 4K bits E2PROM */
+#define I2C_RTC_LEN	16
+#define HCI_MAC_OFFSET	64
+
+extern void i2c_open(void);
+extern void i2c_close(void);
+extern void i2c_setclk(unsigned int i2cclk);
+
+extern int i2c_read(unsigned char device, unsigned char *buf,
+		    unsigned char address, int count);
+extern int i2c_write(unsigned char device, unsigned char *buf,
+		     unsigned char address, int count);
+
+#endif /* __ASM_JZ4750D_MISC_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750d/ops.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750d/ops.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,3450 @@
+/*
+ * linux/include/asm-mips/mach-jz4750d/ops.h
+ *
+ * JZ4750D register definition.
+ *
+ * Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef __JZ4750D_OPS_H__
+#define __JZ4750D_OPS_H__
+
+/*
+ * Definition of Module Operations
+ */
+
+/***************************************************************************
+ * EMC
+ ***************************************************************************/
+#define is_share_mode() ((REG_EMC_BCR & EMC_BCR_BSR_MASK) == EMC_BCR_BSR_SHARE)
+
+/***************************************************************************
+ * GPIO
+ ***************************************************************************/
+
+//------------------------------------------------------
+// GPIO Pins Description
+//
+// PORT 0:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		D0		-
+//	1		D1		-
+//	2		D2		-
+//	3		D3		-
+//	4		D4		-
+//	5		D5		-
+//	6		D6		-
+//	7		D7		-
+//	8		D8		-
+//	9		D9		-
+//	10		D10		-
+//	11		D11		-
+//	12		D12		-
+//	13		D13		-
+//	14		D14		-
+//	15		D15		-
+//	16		D16		-
+//	17		D17		-
+//	18		D18		-
+//	19		D19		-
+//	20		D20		-
+//	21		D21		-
+//	22		D22		-
+//	23		D23		-
+//	24		D24		-
+//	25		D25		-
+//	26		D26		-
+//	27		D27		-
+//	28		D28		-
+//	29		D29		-
+//	30		D30		-
+//	31		D31		-
+//
+//------------------------------------------------------
+// PORT 1:
+//
+// PIN/BIT N		FUNC0		FUNC1	       FUNC2         NOTE
+//	0		A0		-              -
+//	1		A1		-              -
+//	2		A2		-              -
+//	3		A3		-              -
+//	4		A4		-              -
+//	5		A5		-              -
+//	6		A6		-              -
+//	7		A7		-              -
+//	8		A8		-              -
+//	9		A9		-              -
+//	10		A10		-              -
+//	11		A11		-              -
+//	12		A12		-              -
+//	13		A13		-              -
+//	14		A14		-              -
+//	15		A15/CLE		CL(unshare)    MSC0_CLK
+//	16		DCS0#		-              -
+//	17		RAS#		-              -
+//	18		CAS#		-              -
+//	19		SDWE#/BUFD#	-              -
+//	20		WE0#		-              -
+//	21		WE1#		-              -
+//	22		WE2#		-              -
+//	23		WE3#		-              -
+//	24		CKO		-	       -              Note1
+//	25		CKE		-              -
+//	26		SSI_CLK	        MSC1_CLK       -
+//	27		SSI_DT		MSC1_D1        -
+//	28		SSI_DR		MSC1_D0        -
+//	29		SSI_CE0#	MSC1_CMD       -
+//	30		SSI_GPC	        MSC1_D2        -
+//	31		SSI_CE1#	MSC1_D3        -
+//
+// Note1: BIT24: it is CKO when chip is reset
+//
+//------------------------------------------------------
+// PORT 2:
+//
+// PIN/BIT N		FUNC0		FUNC1		FUNC2         NOTE
+//	0		SD0		A20             -
+//	1		SD1		A21             -
+//	2		SD2		A22             -
+//	3		SD3		A23             -
+//	4		SD4		A24             -
+//	5		SD5		A25             -
+//	6		SD6		-               -
+//	7		SD7		-               -
+//	8		SD8		TSDI0           -
+//	9		SD9		TSDI1           -
+//	10		SD10		TSDI2           -
+//	11		SD11		TSDI3           -
+//	12		SD12		TSDI4           -
+//	13		SD13		TSDI5           -
+//	14		SD14		TSDI6           -
+//	15		SD15		TSDI7           -
+//	16		A16/ALE		AL(unshare)     MSC0_CMD
+//	17		A17             MSC0_D3         -
+//	18		A18             DREQ            -
+//	19		A19             DACK            -
+//	20		WAIT#		-		-             Note2
+//	21		CS1#		-               - 
+//	22		CS2#		-               -
+//	23		CS3#		-               -
+//	24		CS4#		-               -
+//	25		RD#		-               -
+//	26		WR#		-               -
+//	27		FRB#		-		-             Note3
+//	28		FRE#		MSC0_D0         -
+//	29		FWE#		MSC0_D1         -
+//	30		-       	-		-             Note4
+//	31		-       	-		-             Note5
+//
+// Note2: BIT20: it is WIAT# pin when chip is reset
+//
+// Note3: BIT27: when NAND is used, it should connect to NANF FRB#.
+//
+// Note4: BIT30: it is BOOT_SEL0 which would be set as input without pulling when chip is reset.
+//
+// Note5: BIT31: it is BOOT_SEL1 which would be set as input without pulling when chip is reset.
+//
+//------------------------------------------------------
+// PORT 3:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	0		LCD_B2		-
+//	1		LCD_B3		-
+//	2		LCD_B4		-
+//	3		LCD_B5		-
+//	4		LCD_B6		-
+//	5		LCD_B7		-
+//	6		LCD_G2		-
+//	7		LCD_G3		-
+//	8		LCD_G4		-
+//	9		LCD_G5		-
+//	10		LCD_G6		-
+//	11		LCD_G7		-
+//	12		LCD_R2		-
+//	13		LCD_R3		-
+//	14		LCD_R4		-
+//	15		LCD_R5		-
+//	16		LCD_R6		-
+//	17		LCD_R7		-
+//	18		LCD_PCLK	-
+//	19		LCD_HSYNC	-
+//	20		LCD_VSYNC	-
+//	21		LCD_DE		-
+//	22		LCD_CLS		LCD_R1
+//	23		LCD_SPL		LCD_G0
+//	24		LCD_PS		LCD_G1
+//	25		LCD_REV		LCD_B1
+//	26		LCD_B0   	-
+//	27		LCD_R0		-
+//	28		UART0_RXD	TSCLK
+//	29		UART0_TXD	TSSTR
+//	30		UART0_CTS	TSFRM
+//	31		UART0_RTS	TSFAIL
+//
+//------------------------------------------------------
+// PORT 4:
+//
+// PIN/BIT N		FUNC0		FUNC1	       FUNC2         NOTE
+//	0		CIM_D0		TSDI0          -
+//	1		CIM_D1		TSDI1          -
+//	2		CIM_D2		TSDI2          -
+//	3		CIM_D3		TSDI3          -
+//	4		CIM_D4		TSDI4          -
+//	5		CIM_D5		TSDI5          -
+//	6		CIM_D6		TSDI6          -
+//	7		CIM_D7		TSDI7          -
+//	8		CIM_MCLK	TSFAIL         -
+//	9		CIM_PCLK	TSCLK          -
+//	10		CIM_VSYNC	TSSTR          -
+//	11		CIM_HSYNC	TSFRM          -
+//	12		I2C_SDA		-              -
+//	13		I2C_SCK		-              -
+//	18		SDATO           -              -
+//	19		SDATI           -              -
+//	20		PWM0		-              -
+//	22		PWM2		SYNC           -
+//	23		PWM3		UART1_RxD      BCLK
+//	24		PWM4		-              -
+//	25		PWM5		UART1_TxD      SCLK_RSTN
+//	28		DCS1#		-              -
+//	29		-        	-              -              Note6
+//	30		WKUP		-	       -              Note7
+//	31		-		-	       -              Note8
+//
+// Note6: BIT29: it is BOOT_SEL2 which would be set as input without pulling when chip is reset.
+// Note7: BIT30: it is only used as input and interrupt, and with no pull-up and pull-down
+// Note8: BIT31: it is used to select the function of UART or JTAG set by PESEL[31]
+//        PESEL[31] = 0, select JTAG function
+//        PESEL[31] = 1, select UART function
+//
+//------------------------------------------------------
+// PORT 5:
+//
+// PIN/BIT N		FUNC0		FUNC1		NOTE
+//	10		SSI_CLK		-
+//	11	        SSI_DT		PWM1
+//	12		SSI_DR		-
+//	13		SSI_CE0#	-
+//	14		SSI_GPC 	-
+//	15		SSI_CE2#	-
+//
+//////////////////////////////////////////////////////////
+
+/*----------------------------------------------------------------
+ * p is the port number (0,1,2,3,4,5)
+ * o is the pin offset (0-31) inside the port
+ * n is the absolute number of a pin (0-127), regardless of the port
+ */
+
+//-------------------------------------------
+// Function Pins Mode
+
+#define __gpio_as_func0(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXSELC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_func1(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_func2(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFUNS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXSELC(p) = (1 << o);		\
+} while (0)
+
+/*
+ * D0 ~ D31, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ */
+#define __gpio_as_sdram_32bit()			\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0xffffffff;	\
+	REG_GPIO_PXSELC(0) = 0xffffffff;	\
+	REG_GPIO_PXPES(0) = 0xffffffff;		\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;	\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;	\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;		\
+} while (0)
+
+
+/*
+ * D0 ~ D31, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ * !!!!DCS1#
+ */
+#define __gpio_as_sdram_x2_32bit()		\
+do {						\
+	REG_GPIO_PXFUNS(0) = 0xffffffff;	\
+	REG_GPIO_PXSELC(0) = 0xffffffff;	\
+	REG_GPIO_PXPES(0) = 0xffffffff;		\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;	\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;	\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;		\
+	REG_GPIO_PXFUNS(4) = 0x10000000;	\
+	REG_GPIO_PXSELC(4) = 0x10000000;	\
+	REG_GPIO_PXPES(4) = 0x10000000;		\
+} while (0)
+
+/*
+ * D0 ~ D15, A0 ~ A14, DCS0#, RAS#, CAS#, 
+ * RDWE#, WE0#, WE1#, WE2#, WE3#, CKO#, CKE#
+ */
+#define __gpio_as_sdram_16bit()						\
+do {								        \
+		/* 32/16-bit data normal order */			\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;				\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;				\
+	REG_GPIO_PXPES(0) = 0x0000ffff;					\
+	REG_GPIO_PXFUNS(1) = 0x03ff7fff;				\
+	REG_GPIO_PXSELC(1) = 0x03ff7fff;				\
+	REG_GPIO_PXPES(1) = 0x03ff7fff;					\
+} while (0)
+
+/*
+ * D0 ~ D7, CS1#, CLE, ALE, FRE#, FWE#, FRB#, RDWE#/BUFD#
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nand_8bit(n)						\
+do {		              						\
+	if (!is_share_mode()) {						\
+		/* unshare mode */					\
+		REG_GPIO_PXFUNS(2) = 0x000000ff; /* SD0~SD7 */		\
+		REG_GPIO_PXSELS(2) = 0x000000ff;			\
+		REG_GPIO_PXPES(2) = 0x000000ff;				\
+		REG_GPIO_PXFUNS(1) = 0x00008000; /* CLE(SA3) */		\
+		REG_GPIO_PXSELS(1) = 0x00008000;			\
+		REG_GPIO_PXPES(1) = 0x00008000;				\
+		REG_GPIO_PXFUNS(2) = 0x00010000; /* ALE(SA4) */		\
+		REG_GPIO_PXSELS(2) = 0x00010000;			\
+		REG_GPIO_PXPES(2) = 0x00010000;				\
+	} else {							\
+		/* 32/16-bit data bus */				\
+		REG_GPIO_PXFUNS(0) = 0x000000ff; /* D0~D7 */		\
+		REG_GPIO_PXSELC(0) = 0x000000ff;			\
+		REG_GPIO_PXPES(0) = 0x000000ff;				\
+		REG_GPIO_PXFUNS(1) = 0x00008000; /* CLE(A15) */		\
+		REG_GPIO_PXSELC(1) = 0x00008000;			\
+		REG_GPIO_PXPES(1) = 0x00008000;				\
+		REG_GPIO_PXFUNS(2) = 0x00010000; /* ALE(A16) */		\
+		REG_GPIO_PXSELC(2) = 0x00010000;			\
+		REG_GPIO_PXPES(2) = 0x00010000;				\
+	}								\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+        REG_GPIO_PXFUNS(1) = 0x00080000; /* RDWE#/BUFD# */		\
+        REG_GPIO_PXSELC(1) = 0x00080000;				\
+	REG_GPIO_PXPES(1) = 0x00080000;					\
+	REG_GPIO_PXFUNS(2) = 0x30000000; /* FRE#, FWE# */		\
+	REG_GPIO_PXSELC(2) = 0x30000000;				\
+	REG_GPIO_PXPES(2) = 0x30000000;					\
+	REG_GPIO_PXFUNC(2) = 0x08000000; /* FRB#(input) */		\
+	REG_GPIO_PXSELC(2) = 0x08000000;				\
+	REG_GPIO_PXDIRC(2) = 0x08000000;				\
+	REG_GPIO_PXPES(2) = 0x08000000;					\
+} while (0)
+
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D7
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nor_8bit(n)						\
+do {								        \
+	/* 32/16-bit data bus */					\
+	REG_GPIO_PXFUNS(0) = 0x000000ff;				\
+	REG_GPIO_PXSELC(0) = 0x000000ff;				\
+	REG_GPIO_PXPES(0) = 0x000000ff;					\
+									\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+	REG_GPIO_PXFUNS(1) = 0x0000ffff; /* A0~A15 */			\
+	REG_GPIO_PXSELC(1) = 0x0000ffff;				\
+	REG_GPIO_PXPES(1) = 0x0000ffff;					\
+	REG_GPIO_PXFUNS(2) = 0x06110007; /* RD#, WR#, WAIT#, A20~A22 */	\
+	REG_GPIO_PXSELC(2) = 0x06110007;				\
+	REG_GPIO_PXPES(2) = 0x06110007;					\
+	REG_GPIO_PXFUNS(2) = 0x000e0000; /* A17~A19 */	        	\
+	REG_GPIO_PXSELS(2) = 0x000e0000;				\
+	REG_GPIO_PXPES(2) = 0x000e0000;					\
+} while (0)
+
+/*
+ * CS4#, RD#, WR#, WAIT#, A0 ~ A22, D0 ~ D15
+ * @n: chip select number(1 ~ 4)
+ */
+#define __gpio_as_nor_16bit(n)						\
+do {	               							\
+	/* 32/16-bit data normal order */				\
+	REG_GPIO_PXFUNS(0) = 0x0000ffff;				\
+	REG_GPIO_PXSELC(0) = 0x0000ffff;				\
+	REG_GPIO_PXPES(0) = 0x0000ffff;					\
+									\
+	REG_GPIO_PXFUNS(2) = 0x00200000 << ((n)-1); /* CSn */		\
+	REG_GPIO_PXSELC(2) = 0x00200000 << ((n)-1);			\
+	REG_GPIO_PXPES(2) = 0x00200000 << ((n)-1);			\
+									\
+	REG_GPIO_PXFUNS(1) = 0x0000ffff; /* A0~A15 */			\
+	REG_GPIO_PXSELC(1) = 0x0000ffff;				\
+	REG_GPIO_PXPES(1) = 0x0000ffff;					\
+	REG_GPIO_PXFUNS(2) = 0x06110007; /* RD#, WR#, WAIT#, A20~A22 */	\
+	REG_GPIO_PXSELC(2) = 0x06110007;				\
+	REG_GPIO_PXPES(2) = 0x06110007;					\
+	REG_GPIO_PXFUNS(2) = 0x000e0000; /* A17~A19 */	        	\
+	REG_GPIO_PXSELS(2) = 0x000e0000;				\
+	REG_GPIO_PXPES(2) = 0x000e0000;					\
+} while (0)
+
+/*
+ * UART0_TxD, UART0_RxD
+ */
+#define __gpio_as_uart0()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x30000000;	\
+	REG_GPIO_PXSELC(3) = 0x30000000;	\
+	REG_GPIO_PXPES(3) = 0x30000000;		\
+} while (0)
+
+/*
+ * UART0_TxD, UART0_RxD, UART0_CTS, UART0_RTS
+ */
+#define __gpio_as_uart0_ctsrts()		\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0xf0000000;	\
+	REG_GPIO_PXSELC(3) = 0xf0000000;	\
+	REG_GPIO_PXPES(3) = 0xf0000000;		\
+} while (0)
+
+/*
+ * UART1_TxD, UART1_RxD
+ */
+#define __gpio_as_uart1()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x02800000;	\
+	REG_GPIO_PXSELC(4) = 0x02800000;	\
+	REG_GPIO_PXPES(4) = 0x02800000;		\
+} while (0)
+
+/*
+ * UART2_TxD, UART2_RxD, UART2_CTS, UART2_RTS using JTAG pins
+ */
+#define __gpio_as_uart2()			\
+do {						\
+	REG_GPIO_PXSELS(4) = 0x80000000;	\
+} while (0)
+
+/*
+ * TSCLK, TSSTR, TSFRM, TSFAIL, TSDI0~7
+ */
+#define __gpio_as_tssi()			\
+do {						\
+	REG_GPIO_PXFUNS(2) = 0x0000ff00;	\
+	REG_GPIO_PXSELS(2) = 0x0000ff00;	\
+	REG_GPIO_PXPES(2) = 0x0000ff00;		\
+	REG_GPIO_PXFUNS(5) = 0x00f00000;	\
+	REG_GPIO_PXSELC(5) = 0x00f00000;	\
+	REG_GPIO_PXPES(5) = 0x00f00000;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D7, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_8bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003c00ff;	\
+	REG_GPIO_PXTRGC(3) = 0x003c00ff;	\
+	REG_GPIO_PXSELC(3) = 0x003c00ff;	\
+	REG_GPIO_PXPES(3) = 0x003c00ff;		\
+} while (0)
+
+/*
+ * LCD_D0~LCD_D15, LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_16bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003cffff;	\
+	REG_GPIO_PXTRGC(3) = 0x003cffff;	\
+	REG_GPIO_PXSELC(3) = 0x003cffff;	\
+	REG_GPIO_PXPES(3) = 0x003cffff;		\
+} while (0)
+
+/*
+ * LCD_R2~LCD_R7, LCD_G2~LCD_G7, LCD_B2~LCD_B7,
+ * LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_18bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x003fffff;	\
+	REG_GPIO_PXTRGC(3) = 0x003fffff;	\
+	REG_GPIO_PXSELC(3) = 0x003fffff;	\
+	REG_GPIO_PXPES(3) = 0x003fffff;		\
+} while (0)
+
+/*
+ * LCD_R0~LCD_R7, LCD_G0~LCD_G7, LCD_B0~LCD_B7,
+ * LCD_PCLK, LCD_HSYNC, LCD_VSYNC, LCD_DE
+ */
+#define __gpio_as_lcd_24bit()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x0fffffff;	\
+	REG_GPIO_PXTRGC(3) = 0x0fffffff;	\
+	REG_GPIO_PXSELC(3) = 0x0c3fffff;	\
+	REG_GPIO_PXSELS(3) = 0x03c00000;	\
+	REG_GPIO_PXPES(3) = 0x0fffffff;		\
+} while (0)
+
+/*
+ *  LCD_CLS, LCD_SPL, LCD_PS, LCD_REV
+ */
+#define __gpio_as_lcd_special()			\
+do {						\
+	REG_GPIO_PXFUNS(3) = 0x03C00000;	\
+	REG_GPIO_PXSELC(3) = 0x03C00000;	\
+	REG_GPIO_PXPES(3)  = 0x03C00000;	\
+} while (0)
+
+/*
+ * CIM_D0~CIM_D7, CIM_MCLK, CIM_PCLK, CIM_VSYNC, CIM_HSYNC
+ */
+#define __gpio_as_cim()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00000fff;	\
+	REG_GPIO_PXSELC(4) = 0x00000fff;	\
+	REG_GPIO_PXPES(4)  = 0x00000fff;	\
+} while (0)
+
+/* 
+ * SDATO, SDATI, BCLK, SYNC, SCLK_RSTN(gpio sepc) or
+ * SDATA_OUT, SDATA_IN, BIT_CLK, SYNC, SCLK_RESET(aic spec)
+ */
+#define __gpio_as_aic()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x16c00000;	\
+	REG_GPIO_PXTRGC(4) = 0x02c00000;	\
+	REG_GPIO_PXTRGS(4) = 0x14000000;	\
+	REG_GPIO_PXSELC(4) = 0x14c00000;	\
+	REG_GPIO_PXSELS(4) = 0x02000000;	\
+	REG_GPIO_PXPES(4)  = 0x16c00000;	\
+} while (0)
+
+/*
+ * MSC0_CMD, MSC0_CLK, MSC0_D0 ~ MSC0_D3
+ */
+#define __gpio_as_msc0_4bit()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0x00008000;	\
+	REG_GPIO_PXTRGS(1) = 0x00008000;	\
+	REG_GPIO_PXSELC(1) = 0x00008000;	\
+	REG_GPIO_PXPES(1)  = 0x00008000;	\
+	REG_GPIO_PXFUNS(2) = 0x38030000;	\
+	REG_GPIO_PXTRGS(2) = 0x00010000;	\
+	REG_GPIO_PXTRGC(2) = 0x38020000;	\
+	REG_GPIO_PXSELC(2) = 0x08010000;	\
+	REG_GPIO_PXSELS(2) = 0x30020000;	\
+	REG_GPIO_PXPES(2)  = 0x38030000;	\
+} while (0)
+
+
+/*
+ * MSC1_CMD, MSC1_CLK, MSC1_D0 ~ MSC1_D3
+ */
+#define __gpio_as_msc1_4bit()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0xfc000000;	\
+	REG_GPIO_PXTRGC(1) = 0xfc000000;	\
+	REG_GPIO_PXSELS(1) = 0xfc000000;	\
+	REG_GPIO_PXPES(1)  = 0xfc000000;	\
+} while (0)
+
+#define __gpio_as_msc 	__gpio_as_msc0_4bit /* default as msc0 4bit */
+#define __gpio_as_msc0 	__gpio_as_msc0_4bit /* msc0 default as 4bit */
+#define __gpio_as_msc1 	__gpio_as_msc1_4bit /* msc1 only support 4bit */
+
+/*
+ * SSI_CE0, SSI_CE1, SSI_GPC, SSI_CLK, SSI_DT, SSI_DR
+ */
+#define __gpio_as_ssi()			\
+do {						\
+	REG_GPIO_PXFUNS(1) = 0xfc000000;	\
+	REG_GPIO_PXTRGC(1) = 0xfc000000;	\
+	REG_GPIO_PXSELC(1) = 0xfc000000;	\
+	REG_GPIO_PXPES(1)  = 0xfc000000;	\
+} while (0)
+
+/*
+ * SSI_CE0, SSI_CE2, SSI_GPC, SSI_CLK, SSI_DT, SSI1_DR
+ */
+#define __gpio_as_ssi_1()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x0000fc00;	\
+	REG_GPIO_PXTRGC(5) = 0x0000fc00;	\
+	REG_GPIO_PXSELC(5) = 0x0000fc00;	\
+	REG_GPIO_PXPES(5)  = 0x0000fc00;	\
+} while (0)
+
+/*
+ * I2C_SCK, I2C_SDA
+ */
+#define __gpio_as_i2c()				\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00003000;	\
+	REG_GPIO_PXSELC(4) = 0x00003000;	\
+	REG_GPIO_PXPES(4)  = 0x00003000;	\
+} while (0)
+
+/*
+ * PWM0
+ */
+#define __gpio_as_pwm0()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00100000;	\
+	REG_GPIO_PXSELC(4) = 0x00100000;	\
+	REG_GPIO_PXPES(4) = 0x00100000;		\
+} while (0)
+
+/*
+ * PWM1
+ */
+#define __gpio_as_pwm1()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x00000800;	\
+	REG_GPIO_PXSELC(5) = 0x00000800;	\
+	REG_GPIO_PXPES(5) = 0x00000800;		\
+} while (0)
+
+/*
+ * PWM2
+ */
+#define __gpio_as_pwm2()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00400000;	\
+	REG_GPIO_PXSELC(4) = 0x00400000;	\
+	REG_GPIO_PXPES(4) = 0x00400000;		\
+} while (0)
+
+/*
+ * PWM3
+ */
+#define __gpio_as_pwm3()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x00800000;	\
+	REG_GPIO_PXSELC(4) = 0x00800000;	\
+	REG_GPIO_PXPES(4) = 0x00800000;		\
+} while (0)
+
+/*
+ * PWM4
+ */
+#define __gpio_as_pwm4()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x01000000;	\
+	REG_GPIO_PXSELC(4) = 0x01000000;	\
+	REG_GPIO_PXPES(4) = 0x01000000;		\
+} while (0)
+
+/*
+ * PWM5
+ */
+#define __gpio_as_pwm5()			\
+do {						\
+	REG_GPIO_PXFUNS(4) = 0x02000000;	\
+	REG_GPIO_PXSELC(4) = 0x02000000;	\
+	REG_GPIO_PXPES(4) = 0x02000000;		\
+} while (0)
+
+/*
+ * n = 0 ~ 5
+ */
+#define __gpio_as_pwm(n)	__gpio_as_pwm##n()
+
+/*
+ * DREQ
+ */
+#define __gpio_as_dreq()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x00000004;	\
+	REG_GPIO_PXSELS(5) = 0x00000004;	\
+	REG_GPIO_PXPES(5) = 0x00000004;		\
+} while (0)
+
+/*
+ * DACK
+ */
+#define __gpio_as_dack()			\
+do {						\
+	REG_GPIO_PXFUNS(5) = 0x00000008;	\
+	REG_GPIO_PXSELS(5) = 0x00000008;	\
+	REG_GPIO_PXPES(5) = 0x00000008;		\
+} while (0)
+
+/*
+ * GPIO or Interrupt Mode
+ */
+#define __gpio_get_port(p)	(REG_GPIO_PXPIN(p))
+
+#define __gpio_port_as_output(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRS(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_port_as_input(p, o)		\
+do {						\
+    REG_GPIO_PXFUNC(p) = (1 << (o));		\
+    REG_GPIO_PXSELC(p) = (1 << (o));		\
+    REG_GPIO_PXDIRC(p) = (1 << (o));		\
+} while (0)
+
+#define __gpio_as_output(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_output(p, o);		\
+} while (0)
+
+#define __gpio_as_input(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	__gpio_port_as_input(p, o);		\
+} while (0)
+
+#define __gpio_set_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_clear_pin(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXDATC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_pin(n)			\
+({						\
+	unsigned int p, o, v;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	if (__gpio_get_port(p) & (1 << o))	\
+		v = 1;				\
+	else					\
+		v = 0;				\
+	v;					\
+})
+
+#define __gpio_as_irq_high_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_low_level(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGC(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_rise_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRS(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_as_irq_fall_edge(n)		\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+	REG_GPIO_PXTRGS(p) = (1 << o);		\
+	REG_GPIO_PXFUNC(p) = (1 << o);		\
+	REG_GPIO_PXSELS(p) = (1 << o);		\
+	REG_GPIO_PXDIRC(p) = (1 << o);		\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_mask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMS(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_unmask_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXIMC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_ack_irq(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXFLGC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_get_irq()			\
+({						\
+	unsigned int p, i, tmp, v = 0;		\
+	for (p = 3; p >= 0; p--) {		\
+		tmp = REG_GPIO_PXFLG(p);	\
+		for (i = 0; i < 32; i++)	\
+			if (tmp & (1 << i))	\
+				v = (32*p + i);	\
+	}					\
+	v;					\
+})
+
+#define __gpio_group_irq(n)			\
+({						\
+	register int tmp, i;			\
+	tmp = REG_GPIO_PXFLG((n));		\
+	for (i=31;i>=0;i--)			\
+		if (tmp & (1 << i))		\
+			break;			\
+	i;					\
+})
+
+#define __gpio_enable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPEC(p) = (1 << o);		\
+} while (0)
+
+#define __gpio_disable_pull(n)			\
+do {						\
+	unsigned int p, o;			\
+	p = (n) / 32;				\
+	o = (n) % 32;				\
+	REG_GPIO_PXPES(p) = (1 << o);		\
+} while (0)
+
+
+/***************************************************************************
+ * CPM
+ ***************************************************************************/
+#define __cpm_get_pllm() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLM_MASK) >> CPM_CPPCR_PLLM_BIT)
+#define __cpm_get_plln() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLN_MASK) >> CPM_CPPCR_PLLN_BIT)
+#define __cpm_get_pllod() \
+	((REG_CPM_CPPCR & CPM_CPPCR_PLLOD_MASK) >> CPM_CPPCR_PLLOD_BIT)
+
+#define __cpm_get_cdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_CDIV_MASK) >> CPM_CPCCR_CDIV_BIT)
+#define __cpm_get_hdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_HDIV_MASK) >> CPM_CPCCR_HDIV_BIT)
+#define __cpm_get_pdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_PDIV_MASK) >> CPM_CPCCR_PDIV_BIT)
+#define __cpm_get_mdiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_MDIV_MASK) >> CPM_CPCCR_MDIV_BIT)
+#define __cpm_get_ldiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_LDIV_MASK) >> CPM_CPCCR_LDIV_BIT)
+#define __cpm_get_udiv() \
+	((REG_CPM_CPCCR & CPM_CPCCR_UDIV_MASK) >> CPM_CPCCR_UDIV_BIT)
+#define __cpm_get_i2sdiv() \
+	((REG_CPM_I2SCDR & CPM_I2SCDR_I2SDIV_MASK) >> CPM_I2SCDR_I2SDIV_BIT)
+#define __cpm_get_pixdiv() \
+	((REG_CPM_LPCDR & CPM_LPCDR_PIXDIV_MASK) >> CPM_LPCDR_PIXDIV_BIT)
+#define __cpm_get_mscdiv(n) \
+	((REG_CPM_MSCCDR(n) & CPM_MSCCDR_MSCDIV_MASK) >> CPM_MSCCDR_MSCDIV_BIT)
+#define __cpm_get_uhcdiv() \
+	((REG_CPM_UHCCDR & CPM_UHCCDR_UHCDIV_MASK) >> CPM_UHCCDR_UHCDIV_BIT)
+#define __cpm_get_ssidiv() \
+	((REG_CPM_SSICCDR & CPM_SSICDR_SSICDIV_MASK) >> CPM_SSICDR_SSIDIV_BIT)
+#define __cpm_get_pcmdiv(v) \
+	((REG_CPM_PCMCDR & CPM_PCMCDR_PCMCD_MASK) >> CPM_PCMCDR_PCMCD_BIT)
+
+#define __cpm_set_cdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_CDIV_MASK) | ((v) << (CPM_CPCCR_CDIV_BIT)))
+#define __cpm_set_hdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_HDIV_MASK) | ((v) << (CPM_CPCCR_HDIV_BIT)))
+#define __cpm_set_pdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_PDIV_MASK) | ((v) << (CPM_CPCCR_PDIV_BIT)))
+#define __cpm_set_mdiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_MDIV_MASK) | ((v) << (CPM_CPCCR_MDIV_BIT)))
+#define __cpm_set_ldiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_LDIV_MASK) | ((v) << (CPM_CPCCR_LDIV_BIT)))
+#define __cpm_set_udiv(v) \
+	(REG_CPM_CPCCR = (REG_CPM_CPCCR & ~CPM_CPCCR_UDIV_MASK) | ((v) << (CPM_CPCCR_UDIV_BIT)))
+#define __cpm_set_i2sdiv(v) \
+	(REG_CPM_I2SCDR = (REG_CPM_I2SCDR & ~CPM_I2SCDR_I2SDIV_MASK) | ((v) << (CPM_I2SCDR_I2SDIV_BIT)))
+#define __cpm_set_pixdiv(v) \
+	(REG_CPM_LPCDR = (REG_CPM_LPCDR & ~CPM_LPCDR_PIXDIV_MASK) | ((v) << (CPM_LPCDR_PIXDIV_BIT)))
+#define __cpm_set_mscdiv(n, v) \
+	(REG_CPM_MSCCDR(n) = (REG_CPM_MSCCDR(n) & ~CPM_MSCCDR_MSCDIV_MASK) | ((v) << (CPM_MSCCDR_MSCDIV_BIT)))
+#define __cpm_set_uhcdiv(v) \
+	(REG_CPM_UHCCDR = (REG_CPM_UHCCDR & ~CPM_UHCCDR_UHCDIV_MASK) | ((v) << (CPM_UHCCDR_UHCDIV_BIT)))
+#define __cpm_set_ssidiv(v) \
+	(REG_CPM_SSICDR = (REG_CPM_SSICDR & ~CPM_SSICDR_SSIDIV_MASK) | ((v) << (CPM_SSICDR_SSIDIV_BIT)))
+#define __cpm_set_pcmdiv(v) \
+	(REG_CPM_PCMCDR = (REG_CPM_PCMCDR & ~CPM_PCMCDR_PCMCD_MASK) | ((v) << (CPM_PCMCDR_PCMCD_BIT)))
+
+#define __cpm_select_pcmclk_pll() 	(REG_CPM_PCMCDR |= CPM_PCMCDR_PCMS)
+#define __cpm_select_pcmclk_exclk() 	(REG_CPM_PCMCDR &= ~CPM_PCMCDR_PCMS)
+#define __cpm_select_pixclk_ext()	(REG_CPM_LPCDR |= CPM_LPCDR_LPCS)
+#define __cpm_select_pixclk_pll()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LPCS)
+#define __cpm_select_tveclk_exclk()	(REG_CPM_LPCDR |= CPM_CPCCR_LSCS)
+#define __cpm_select_tveclk_pll()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LSCS)
+#define __cpm_select_pixclk_lcd()	(REG_CPM_LPCDR &= ~CPM_LPCDR_LTCS)
+#define __cpm_select_pixclk_tve()	(REG_CPM_LPCDR |= CPM_LPCDR_LTCS)
+#define __cpm_select_i2sclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_I2CS)
+#define __cpm_select_i2sclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_I2CS)
+#define __cpm_select_usbclk_exclk()	(REG_CPM_CPCCR &= ~CPM_CPCCR_UCS)
+#define __cpm_select_usbclk_pll()	(REG_CPM_CPCCR |= CPM_CPCCR_UCS)
+
+#define __cpm_enable_cko()
+#define __cpm_exclk_direct()		(REG_CPM_CPCCR &= ~CPM_CPCCR_ECS)
+#define __cpm_exclk_div2()             	(REG_CPM_CPCCR |= CPM_CPCCR_ECS)
+#define __cpm_enable_pll_change()	(REG_CPM_CPCCR |= CPM_CPCCR_CE)
+#define __cpm_pllout_direct()		(REG_CPM_CPCCR |= CPM_CPCCR_PCS)
+#define __cpm_pllout_div2()		(REG_CPM_CPCCR &= ~CPM_CPCCR_PCS)
+#define __cpm_pll_enable()		(REG_CPM_CPPCR |= CPM_CPPCR_PLLEN)
+
+#define __cpm_pll_is_off()		(REG_CPM_CPPSR & CPM_CPPSR_PLLOFF)
+#define __cpm_pll_is_on()		(REG_CPM_CPPSR & CPM_CPPSR_PLLON)
+#define __cpm_pll_bypass()		(REG_CPM_CPPSR |= CPM_CPPSR_PLLBP)
+
+#define __cpm_get_cclk_doze_duty() \
+	((REG_CPM_LCR & CPM_LCR_DOZE_DUTY_MASK) >> CPM_LCR_DOZE_DUTY_BIT)
+#define __cpm_set_cclk_doze_duty(v) \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_DOZE_DUTY_MASK) | ((v) << (CPM_LCR_DOZE_DUTY_BIT)))
+
+#define __cpm_doze_mode()		(REG_CPM_LCR |= CPM_LCR_DOZE_ON)
+#define __cpm_idle_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_IDLE)
+#define __cpm_sleep_mode() \
+	(REG_CPM_LCR = (REG_CPM_LCR & ~CPM_LCR_LPM_MASK) | CPM_LCR_LPM_SLEEP)
+
+#define __cpm_stop_all() 	(REG_CPM_CLKGR = 0x1fffffff)
+#define __cpm_stop_cimram()	(REG_CPM_CLKGR |= CPM_CLKGR_CIMRAM)
+#define __cpm_stop_idct()	(REG_CPM_CLKGR |= CPM_CLKGR_IDCT)
+#define __cpm_stop_db()	        (REG_CPM_CLKGR |= CPM_CLKGR_DB)
+#define __cpm_stop_me()	        (REG_CPM_CLKGR |= CPM_CLKGR_ME)
+#define __cpm_stop_mc()	        (REG_CPM_CLKGR |= CPM_CLKGR_MC)
+#define __cpm_stop_tve()        (REG_CPM_CLKGR |= CPM_CLKGR_TVE)
+#define __cpm_stop_tssi()       (REG_CPM_CLKGR |= CPM_CLKGR_TSSI)
+#define __cpm_stop_owi()        (REG_CPM_CLKGR |= CPM_CLKGR_OWI)
+#define __cpm_stop_pcm()        (REG_CPM_CLKGR |= CPM_CLKGR_PCM)
+#define __cpm_stop_uart3()	(REG_CPM_CLKGR |= CPM_CLKGR_UART3)
+#define __cpm_stop_uart2()	(REG_CPM_CLKGR |= CPM_CLKGR_UART2)
+#define __cpm_stop_uart1()	(REG_CPM_CLKGR |= CPM_CLKGR_UART1)
+#define __cpm_stop_uhc()	(REG_CPM_CLKGR |= CPM_CLKGR_UHC)
+#define __cpm_stop_ipu()	(REG_CPM_CLKGR |= CPM_CLKGR_IPU)
+#define __cpm_stop_dmac()	(REG_CPM_CLKGR |= CPM_CLKGR_DMAC)
+#define __cpm_stop_udc()	(REG_CPM_CLKGR |= CPM_CLKGR_UDC)
+#define __cpm_stop_lcd()	(REG_CPM_CLKGR |= CPM_CLKGR_LCD)
+#define __cpm_stop_cim()	(REG_CPM_CLKGR |= CPM_CLKGR_CIM)
+#define __cpm_stop_sadc()	(REG_CPM_CLKGR |= CPM_CLKGR_SADC)
+#define __cpm_stop_msc(n)	(REG_CPM_CLKGR |= CPM_CLKGR_MSC##n)
+#define __cpm_stop_aic1()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC1)
+#define __cpm_stop_aic2()	(REG_CPM_CLKGR |= CPM_CLKGR_AIC2)
+#define __cpm_stop_ssi(n)	(REG_CPM_CLKGR |= CPM_CLKGR_SSI##n)
+#define __cpm_stop_i2c()	(REG_CPM_CLKGR |= CPM_CLKGR_I2C)
+#define __cpm_stop_rtc()	(REG_CPM_CLKGR |= CPM_CLKGR_RTC)
+#define __cpm_stop_tcu()	(REG_CPM_CLKGR |= CPM_CLKGR_TCU)
+#define __cpm_stop_uart0()	(REG_CPM_CLKGR |= CPM_CLKGR_UART0)
+
+#define __cpm_start_all() 	(REG_CPM_CLKGR = 0x0)
+#define __cpm_start_cimram()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIMRAM)
+#define __cpm_start_idct()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IDCT)
+#define __cpm_start_db()        (REG_CPM_CLKGR &= ~CPM_CLKGR_DB)
+#define __cpm_start_me()        (REG_CPM_CLKGR &= ~CPM_CLKGR_ME)
+#define __cpm_start_mc()        (REG_CPM_CLKGR &= ~CPM_CLKGR_MC)
+#define __cpm_start_tve()        (REG_CPM_CLKGR &= ~CPM_CLKGR_TVE)
+#define __cpm_start_tssi()       (REG_CPM_CLKGR &= ~CPM_CLKGR_TSSI)
+#define __cpm_start_owi()        (REG_CPM_CLKGR &= ~CPM_CLKGR_OWI)
+#define __cpm_start_pcm()        (REG_CPM_CLKGR &= ~CPM_CLKGR_PCM)
+#define __cpm_start_uart3()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART3)
+#define __cpm_start_uart2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART2)
+#define __cpm_start_uart1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART1)
+#define __cpm_start_uhc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UHC)
+#define __cpm_start_ipu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_IPU)
+#define __cpm_start_dmac()	(REG_CPM_CLKGR &= ~CPM_CLKGR_DMAC)
+#define __cpm_start_udc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UDC)
+#define __cpm_start_lcd()	(REG_CPM_CLKGR &= ~CPM_CLKGR_LCD)
+#define __cpm_start_cim()	(REG_CPM_CLKGR &= ~CPM_CLKGR_CIM)
+#define __cpm_start_sadc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_SADC)
+#define __cpm_start_msc(n)	(REG_CPM_CLKGR &= ~CPM_CLKGR_MSC##n)
+#define __cpm_start_aic1()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC1)
+#define __cpm_start_aic2()	(REG_CPM_CLKGR &= ~CPM_CLKGR_AIC2)
+#define __cpm_start_ssi(n)	(REG_CPM_CLKGR &= ~CPM_CLKGR_SSI##n)
+#define __cpm_start_i2c()	(REG_CPM_CLKGR &= ~CPM_CLKGR_I2C)
+#define __cpm_start_rtc()	(REG_CPM_CLKGR &= ~CPM_CLKGR_RTC)
+#define __cpm_start_tcu()	(REG_CPM_CLKGR &= ~CPM_CLKGR_TCU)
+#define __cpm_start_uart0()	(REG_CPM_CLKGR &= ~CPM_CLKGR_UART0)
+
+#define __cpm_get_o1st() \
+	((REG_CPM_OPCR & CPM_OPCR_O1ST_MASK) >> CPM_OPCR_O1ST_BIT)
+#define __cpm_set_o1st(v) \
+	(REG_CPM_OPCR = (REG_CPM_OPCR & ~CPM_OPCR_O1ST_MASK) | ((v) << (CPM_OPCR_O1ST_BIT)))
+#define __cpm_enable_uhcphy()		(REG_CPM_OPCR &= ~CPM_OPCR_UHCPHY_DISABLE)
+#define __cpm_suspend_uhcphy()		(REG_CPM_OPCR |= CPM_OPCR_UHCPHY_DISABLE)
+#define __cpm_enable_udcphy()		(REG_CPM_OPCR |= CPM_OPCR_UDCPHY_ENABLE)
+#define __cpm_suspend_udcphy()		(REG_CPM_OPCR &= ~CPM_OPCR_UDCPHY_ENABLE)
+#define __cpm_enable_osc_in_sleep()	(REG_CPM_OPCR |= CPM_OPCR_OSC_ENABLE)
+#define __cpm_disable_osc_in_sleep()	(REG_CPM_OPCR &= ~CPM_OPCR_OSC_ENABLE)
+#define __cpm_select_rtcclk_rtc()	(REG_CPM_OPCR |= CPM_OPCR_ERCS)
+#define __cpm_select_rtcclk_exclk()	(REG_CPM_OPCR &= ~CPM_OPCR_ERCS)
+
+
+/***************************************************************************
+ * TCU
+ ***************************************************************************/
+// where 'n' is the TCU channel
+#define __tcu_select_extalclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_EXT_EN)
+#define __tcu_select_rtcclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_RTC_EN)
+#define __tcu_select_pclk(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~(TCU_TCSR_EXT_EN | TCU_TCSR_RTC_EN | TCU_TCSR_PCK_EN)) | TCU_TCSR_PCK_EN)
+#define __tcu_disable_pclk(n) \
+	REG_TCU_TCSR(n) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PCK_EN);
+#define __tcu_select_clk_div1(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1)
+#define __tcu_select_clk_div4(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE4)
+#define __tcu_select_clk_div16(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE16)
+#define __tcu_select_clk_div64(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE64)
+#define __tcu_select_clk_div256(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE256)
+#define __tcu_select_clk_div1024(n) \
+	(REG_TCU_TCSR((n)) = (REG_TCU_TCSR((n)) & ~TCU_TCSR_PRESCALE_MASK) | TCU_TCSR_PRESCALE1024)
+
+#define __tcu_enable_pwm_output(n)	(REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_EN)
+#define __tcu_disable_pwm_output(n)	(REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_EN)
+
+#define __tcu_init_pwm_output_high(n)	(REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_INITL_HIGH)
+#define __tcu_init_pwm_output_low(n)	(REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_INITL_HIGH)
+
+#define __tcu_set_pwm_output_shutdown_graceful(n)	(REG_TCU_TCSR((n)) &= ~TCU_TCSR_PWM_SD)
+#define __tcu_set_pwm_output_shutdown_abrupt(n)		(REG_TCU_TCSR((n)) |= TCU_TCSR_PWM_SD)
+
+#define __tcu_clear_counter_to_zero(n)	(REG_TCU_TCSR((n)) |= TCU_TCSR_CNT_CLRZ)
+
+#define __tcu_ost_enabled()		(REG_TCU_TER & TCU_TER_OSTEN)
+#define __tcu_enable_ost()		(REG_TCU_TESR = TCU_TESR_OSTST)
+#define __tcu_disable_ost()		(REG_TCU_TECR = TCU_TECR_OSTCL)
+
+#define __tcu_counter_enabled(n)	(REG_TCU_TER & (1 << (n)))
+#define __tcu_start_counter(n)		(REG_TCU_TESR |= (1 << (n)))
+#define __tcu_stop_counter(n)		(REG_TCU_TECR |= (1 << (n)))
+
+#define __tcu_half_match_flag(n)	(REG_TCU_TFR & (1 << ((n) + 16)))
+#define __tcu_full_match_flag(n)	(REG_TCU_TFR & (1 << (n)))
+#define __tcu_set_half_match_flag(n)	(REG_TCU_TFSR = (1 << ((n) + 16)))
+#define __tcu_set_full_match_flag(n)	(REG_TCU_TFSR = (1 << (n)))
+#define __tcu_clear_half_match_flag(n)	(REG_TCU_TFCR = (1 << ((n) + 16)))
+#define __tcu_clear_full_match_flag(n)	(REG_TCU_TFCR = (1 << (n)))
+#define __tcu_mask_half_match_irq(n)	(REG_TCU_TMSR = (1 << ((n) + 16)))
+#define __tcu_mask_full_match_irq(n)	(REG_TCU_TMSR = (1 << (n)))
+#define __tcu_unmask_half_match_irq(n)	(REG_TCU_TMCR = (1 << ((n) + 16)))
+#define __tcu_unmask_full_match_irq(n)	(REG_TCU_TMCR = (1 << (n)))
+
+#define __tcu_ost_match_flag()		(REG_TCU_TFR & TCU_TFR_OSTFLAG)
+#define __tcu_set_ost_match_flag()	(REG_TCU_TFSR = TCU_TFSR_OSTFST)
+#define __tcu_clear_ost_match_flag()	(REG_TCU_TFCR = TCU_TFCR_OSTFCL)
+#define __tcu_ost_match_irq_masked()	(REG_TCU_TMR & TCU_TMR_OSTMASK)
+#define __tcu_mask_ost_match_irq()	(REG_TCU_TMSR = TCU_TMSR_OSTMST)
+#define __tcu_unmask_ost_match_irq()	(REG_TCU_TMCR = TCU_TMCR_OSTMCL)
+
+#define __tcu_wdt_clock_stopped()	(REG_TCU_TSR & TCU_TSSR_WDTSC)
+#define __tcu_ost_clock_stopped()	(REG_TCU_TSR & TCU_TSR_OST)
+#define __tcu_timer_clock_stopped(n)	(REG_TCU_TSR & (1 << (n)))
+
+#define __tcu_start_wdt_clock()		(REG_TCU_TSCR = TCU_TSSR_WDTSC)
+#define __tcu_start_ost_clock()		(REG_TCU_TSCR = TCU_TSCR_OSTSC)
+#define __tcu_start_timer_clock(n)	(REG_TCU_TSCR = (1 << (n)))
+
+#define __tcu_stop_wdt_clock()		(REG_TCU_TSSR = TCU_TSSR_WDTSC)
+#define __tcu_stop_ost_clock()		(REG_TCU_TSSR = TCU_TSSR_OSTSS)
+#define __tcu_stop_timer_clock(n)	(REG_TCU_TSSR = (1 << (n)))
+
+#define __tcu_get_count(n)		(REG_TCU_TCNT((n)))
+#define __tcu_set_count(n,v)		(REG_TCU_TCNT((n)) = (v))
+#define __tcu_set_full_data(n,v)	(REG_TCU_TDFR((n)) = (v))
+#define __tcu_set_half_data(n,v)	(REG_TCU_TDHR((n)) = (v))
+
+/* TCU2, counter 1, 2*/
+#define __tcu_read_real_value(n)	(REG_TCU_TSTR & (1 << ((n) + 16)))
+#define __tcu_read_false_value(n)	(REG_TCU_TSTR & (1 << ((n) + 16)))
+#define __tcu_counter_busy(n)		(REG_TCU_TSTR & (1 << (n)))
+#define __tcu_counter_ready(n)		(REG_TCU_TSTR & (1 << (n)))
+
+#define __tcu_set_read_real_value(n)	(REG_TCU_TSTSR = (1 << ((n) + 16)))
+#define __tcu_set_read_false_value(n)	(REG_TCU_TSTCR = (1 << ((n) + 16)))
+#define __tcu_set_counter_busy(n)	(REG_TCU_TSTSR = (1 << (n)))
+#define __tcu_set_counter_ready(n)	(REG_TCU_TSTCR = (1 << (n)))
+
+/* ost counter */
+#define __ostcu_set_pwm_output_shutdown_graceful()	(REG_TCU_OSTCSR &= ~TCU_TCSR_PWM_SD)
+#define __ostcu_set_ost_output_shutdown_abrupt()	(REG_TCU_OSTCSR |= TCU_TCSR_PWM_SD)
+#define __ostcu_select_clk_div1() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE1)
+#define __ostcu_select_clk_div4() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE4)
+#define __ostcu_select_clk_div16() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE16)
+#define __ostcu_select_clk_div64() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE64)
+#define __ostcu_select_clk_div256() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE256)
+#define __ostcu_select_clk_div1024() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~TCU_OSTCSR_PRESCALE_MASK) | TCU_OSTCSR_PRESCALE1024)
+#define __ostcu_select_rtcclk() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~(TCU_OSTCSR_EXT_EN | TCU_OSTCSR_RTC_EN | TCU_OSTCSR_PCK_EN)) | TCU_OSTCSR_RTC_EN)
+#define __ostcu_select_extalclk() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~(TCU_OSTCSR_EXT_EN | TCU_OSTCSR_RTC_EN | TCU_OSTCSR_PCK_EN)) | TCU_OSTCSR_EXT_EN)
+#define __ostcu_select_pclk() \
+	(REG_TCU_OSTCSR = (REG_TCU_OSTCSR & ~(TCU_OSTCSR_EXT_EN | TCU_OSTCSR_RTC_EN | TCU_OSTCSR_PCK_EN)) | TCU_OSTCSR_PCK_EN)
+
+
+/***************************************************************************
+ * WDT
+ ***************************************************************************/
+#define __wdt_start()			( REG_WDT_TCER |= WDT_TCER_TCEN )
+#define __wdt_stop()			( REG_WDT_TCER &= ~WDT_TCER_TCEN )
+#define __wdt_set_count(v)		( REG_WDT_TCNT = (v) )
+#define __wdt_set_data(v)		( REG_WDT_TDR = (v) )
+
+#define __wdt_select_extalclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_EXT_EN)
+#define __wdt_select_rtcclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_RTC_EN)
+#define __wdt_select_pclk() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~(WDT_TCSR_EXT_EN | WDT_TCSR_RTC_EN | WDT_TCSR_PCK_EN)) | WDT_TCSR_PCK_EN)
+
+#define __wdt_select_clk_div1() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1)
+#define __wdt_select_clk_div4() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE4)
+#define __wdt_select_clk_div16() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE16)
+#define __wdt_select_clk_div64() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE64)
+#define __wdt_select_clk_div256() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE256)
+#define __wdt_select_clk_div1024() \
+	(REG_WDT_TCSR = (REG_WDT_TCSR & ~WDT_TCSR_PRESCALE_MASK) | WDT_TCSR_PRESCALE1024)
+
+
+/***************************************************************************
+ * UART
+ ***************************************************************************/
+
+#define __uart_enable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) |= UARTFCR_UUE | UARTFCR_FE )
+#define __uart_disable(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_FCR) = ~UARTFCR_UUE )
+
+#define __uart_enable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_TIE )
+#define __uart_disable_transmit_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~UARTIER_TIE )
+
+#define __uart_enable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) |= UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE )
+#define __uart_disable_receive_irq(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_IER) &= ~(UARTIER_RIE | UARTIER_RLIE | UARTIER_RTIE) )
+
+#define __uart_enable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) |= UARTMCR_LOOP )
+#define __uart_disable_loopback(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_MCR) &= ~UARTMCR_LOOP )
+
+#define __uart_set_8n1(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) = UARTLCR_WLEN_8 )
+
+#define __uart_set_baud(n, devclk, baud)						\
+  do {											\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) |= UARTLCR_DLAB;			\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLLR) = (devclk / 16 / baud) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_DLHR) = ((devclk / 16 / baud) >> 8) & 0xff;	\
+	REG8(UART_BASE + UART_OFF*(n) + OFF_LCR) &= ~UARTLCR_DLAB;			\
+  } while (0)
+
+#define __uart_parity_error(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_PER) != 0 )
+
+#define __uart_clear_errors(n) \
+  ( REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) &= ~(UARTLSR_ORER | UARTLSR_BRK | UARTLSR_FER | UARTLSR_PER | UARTLSR_RFER) )
+
+#define __uart_transmit_fifo_empty(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TDRQ) != 0 )
+
+#define __uart_transmit_end(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_TEMT) != 0 )
+
+#define __uart_transmit_char(n, ch) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_TDR) = (ch)
+
+#define __uart_receive_fifo_full(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_ready(n) \
+  ( (REG8(UART_BASE + UART_OFF*(n) + OFF_LSR) & UARTLSR_DR) != 0 )
+
+#define __uart_receive_char(n) \
+  REG8(UART_BASE + UART_OFF*(n) + OFF_RDR)
+
+#define __uart_disable_irda() \
+  ( REG8(IRDA_BASE + OFF_SIRCR) &= ~(SIRCR_TSIRE | SIRCR_RSIRE) )
+#define __uart_enable_irda() \
+  /* Tx high pulse as 0, Rx low pulse as 0 */ \
+  ( REG8(IRDA_BASE + OFF_SIRCR) = SIRCR_TSIRE | SIRCR_RSIRE | SIRCR_RXPL | SIRCR_TPWS )
+
+
+/***************************************************************************
+ * DMAC
+ ***************************************************************************/
+
+/* m is the DMA controller index (0, 1), n is the DMA channel index (0 - 11) */
+
+#define __dmac_enable_module(m) \
+	( REG_DMAC_DMACR(m) |= DMAC_DMACR_DMAE | DMAC_DMACR_PR_012345 )
+#define __dmac_disable_module(m) \
+	( REG_DMAC_DMACR(m) &= ~DMAC_DMACR_DMAE )
+
+/* p=0,1,2,3 */
+#define __dmac_set_priority(m,p)			\
+do {							\
+	REG_DMAC_DMACR(m) &= ~DMAC_DMACR_PR_MASK;	\
+	REG_DMAC_DMACR(m) |= ((p) << DMAC_DMACR_PR_BIT);	\
+} while (0)
+
+#define __dmac_test_halt_error(m) ( REG_DMAC_DMACR(m) & DMAC_DMACR_HLT )
+#define __dmac_test_addr_error(m) ( REG_DMAC_DMACR(m) & DMAC_DMACR_AR )
+
+#define __dmac_channel_enable_clk(n) \
+	REG_DMAC_DMACKE((n)/HALF_DMA_NUM) |= 1 << ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM);
+
+#define __dmac_enable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_NDES )
+#define __dmac_disable_descriptor(n) \
+  ( REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_NDES )
+
+#define __dmac_enable_channel(n)                 \
+do {                                             \
+	REG_DMAC_DCCSR((n)) |= DMAC_DCCSR_EN;    \
+} while (0)
+#define __dmac_disable_channel(n)                \
+do {                                             \
+	REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_EN;   \
+} while (0)
+#define __dmac_channel_enabled(n) \
+  ( REG_DMAC_DCCSR((n)) & DMAC_DCCSR_EN )
+
+#define __dmac_channel_enable_irq(n) \
+  ( REG_DMAC_DCMD((n)) |= DMAC_DCMD_TIE )
+#define __dmac_channel_disable_irq(n) \
+  ( REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_TIE )
+
+#define __dmac_channel_transmit_halt_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_HLT )
+#define __dmac_channel_transmit_end_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_TT )
+#define __dmac_channel_address_error_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_AR )
+#define __dmac_channel_count_terminated_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_CT )
+#define __dmac_channel_descriptor_invalid_detected(n) \
+  (  REG_DMAC_DCCSR((n)) & DMAC_DCCSR_INV )
+
+#define __dmac_channel_clear_transmit_halt(n)				\
+	do {								\
+		/* clear both channel halt error and globle halt error */ \
+		REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_HLT;			\
+		REG_DMAC_DMACR(n/HALF_DMA_NUM) &= ~DMAC_DMACR_HLT;	\
+	} while (0)
+#define __dmac_channel_clear_transmit_end(n) \
+  (  REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_TT )
+#define __dmac_channel_clear_address_error(n)				\
+	do {								\
+		REG_DMAC_DDA(n) = 0; /* clear descriptor address register */ \
+		REG_DMAC_DSAR(n) = 0; /* clear source address register */ \
+		REG_DMAC_DTAR(n) = 0; /* clear target address register */ \
+		/* clear both channel addr error and globle address error */ \
+		REG_DMAC_DCCSR(n) &= ~DMAC_DCCSR_AR;			\
+		REG_DMAC_DMACR(n/HALF_DMA_NUM) &= ~DMAC_DMACR_AR;	\
+	} while (0)
+#define __dmac_channel_clear_count_terminated(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_CT )
+#define __dmac_channel_clear_descriptor_invalid(n) \
+  (  REG_DMAC_DCCSR((n)) &= ~DMAC_DCCSR_INV )
+
+#define __dmac_channel_set_transfer_unit_32bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_8bit(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_8BIT;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_16byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_16BYTE;	\
+} while (0)
+
+#define __dmac_channel_set_transfer_unit_32byte(n)	\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DS_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DS_32BYTE;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_dest_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_DWDH_##w;	\
+} while (0)
+
+/* w=8,16,32 */
+#define __dmac_channel_set_src_port_width(n,w)		\
+do {							\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SWDH_MASK;	\
+	REG_DMAC_DCMD((n)) |= DMAC_DCMD_SWDH_##w;	\
+} while (0)
+
+/* v=0-15 */
+#define __dmac_channel_set_rdil(n,v)				\
+do {								\
+	REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_RDIL_MASK;		\
+	REG_DMAC_DCMD((n) |= ((v) << DMAC_DCMD_RDIL_BIT);	\
+} while (0)
+
+#define __dmac_channel_dest_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_DAI )
+#define __dmac_channel_dest_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_DAI )
+
+#define __dmac_channel_src_addr_fixed(n) \
+  (  REG_DMAC_DCMD((n)) &= ~DMAC_DCMD_SAI )
+#define __dmac_channel_src_addr_increment(n) \
+  (  REG_DMAC_DCMD((n)) |= DMAC_DCMD_SAI )
+
+#define __dmac_channel_set_doorbell(n)	\
+	(  REG_DMAC_DMADBSR((n)/HALF_DMA_NUM) = (1 << ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM)) )
+
+#define __dmac_channel_irq_detected(n)  ( REG_DMAC_DMAIPR((n)/HALF_DMA_NUM) & (1 << ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM)) )
+#define __dmac_channel_ack_irq(n)       ( REG_DMAC_DMAIPR((n)/HALF_DMA_NUM) &= ~(1 <<((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM)) )
+
+static __inline__ int __dmac_get_irq(void)
+{
+	int i;
+	for (i = 0; i < MAX_DMA_NUM; i++)
+		if (__dmac_channel_irq_detected(i))
+			return i;
+	return -1;
+}
+
+
+/***************************************************************************
+ * AIC (AC'97 & I2S Controller)
+ ***************************************************************************/
+
+#define __aic_enable()		( REG_AIC_FR |= AIC_FR_ENB )
+#define __aic_disable()		( REG_AIC_FR &= ~AIC_FR_ENB )
+
+#define __aic_select_ac97()	( REG_AIC_FR &= ~AIC_FR_AUSEL )
+#define __aic_select_i2s()	( REG_AIC_FR |= AIC_FR_AUSEL )
+
+#define __aic_play_zero()	( REG_AIC_FR &= ~AIC_FR_LSMP )
+#define __aic_play_lastsample()	( REG_AIC_FR |= AIC_FR_LSMP )
+
+#define __i2s_as_master()	( REG_AIC_FR |= AIC_FR_BCKD | AIC_FR_SYNCD )
+#define __i2s_as_slave()	( REG_AIC_FR &= ~(AIC_FR_BCKD | AIC_FR_SYNCD) )
+#define __aic_reset_status()          ( REG_AIC_FR & AIC_FR_RST )
+
+#define __aic_reset()                                   \
+do {                                                    \
+        REG_AIC_FR |= AIC_FR_RST;                       \
+} while(0)
+
+
+#define __aic_set_transmit_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_TFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_TFTH_BIT);		\
+} while(0)
+
+#define __aic_set_receive_trigger(n) 			\
+do {							\
+	REG_AIC_FR &= ~AIC_FR_RFTH_MASK;		\
+	REG_AIC_FR |= ((n) << AIC_FR_RFTH_BIT);		\
+} while(0)
+
+#define __aic_enable_record()	( REG_AIC_CR |= AIC_CR_EREC )
+#define __aic_disable_record()	( REG_AIC_CR &= ~AIC_CR_EREC )
+#define __aic_enable_replay()	( REG_AIC_CR |= AIC_CR_ERPL )
+#define __aic_disable_replay()	( REG_AIC_CR &= ~AIC_CR_ERPL )
+#define __aic_enable_loopback()	( REG_AIC_CR |= AIC_CR_ENLBF )
+#define __aic_disable_loopback() ( REG_AIC_CR &= ~AIC_CR_ENLBF )
+
+#define __aic_flush_fifo()	( REG_AIC_CR |= AIC_CR_FLUSH )
+#define __aic_unflush_fifo()	( REG_AIC_CR &= ~AIC_CR_FLUSH )
+
+#define __aic_enable_transmit_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_disable_transmit_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ETFS | AIC_CR_ETUR) )
+#define __aic_enable_receive_intr() \
+  ( REG_AIC_CR |= (AIC_CR_ERFS | AIC_CR_EROR) )
+#define __aic_disable_receive_intr() \
+  ( REG_AIC_CR &= ~(AIC_CR_ERFS | AIC_CR_EROR) )
+
+#define __aic_enable_transmit_dma()  ( REG_AIC_CR |= AIC_CR_TDMS )
+#define __aic_disable_transmit_dma() ( REG_AIC_CR &= ~AIC_CR_TDMS )
+#define __aic_enable_receive_dma()   ( REG_AIC_CR |= AIC_CR_RDMS )
+#define __aic_disable_receive_dma()  ( REG_AIC_CR &= ~AIC_CR_RDMS )
+
+#define __aic_enable_mono2stereo()   ( REG_AIC_CR |= AIC_CR_M2S )
+#define __aic_disable_mono2stereo()  ( REG_AIC_CR &= ~AIC_CR_M2S )
+#define __aic_enable_byteswap()      ( REG_AIC_CR |= AIC_CR_ENDSW )
+#define __aic_disable_byteswap()     ( REG_AIC_CR &= ~AIC_CR_ENDSW )
+#define __aic_enable_unsignadj()     ( REG_AIC_CR |= AIC_CR_AVSTSU )
+#define __aic_disable_unsignadj()    ( REG_AIC_CR &= ~AIC_CR_AVSTSU )
+
+#define AC97_PCM_XS_L_FRONT   	AIC_ACCR1_XS_SLOT3
+#define AC97_PCM_XS_R_FRONT   	AIC_ACCR1_XS_SLOT4
+#define AC97_PCM_XS_CENTER    	AIC_ACCR1_XS_SLOT6
+#define AC97_PCM_XS_L_SURR    	AIC_ACCR1_XS_SLOT7
+#define AC97_PCM_XS_R_SURR    	AIC_ACCR1_XS_SLOT8
+#define AC97_PCM_XS_LFE       	AIC_ACCR1_XS_SLOT9
+
+#define AC97_PCM_RS_L_FRONT   	AIC_ACCR1_RS_SLOT3
+#define AC97_PCM_RS_R_FRONT   	AIC_ACCR1_RS_SLOT4
+#define AC97_PCM_RS_CENTER    	AIC_ACCR1_RS_SLOT6
+#define AC97_PCM_RS_L_SURR    	AIC_ACCR1_RS_SLOT7
+#define AC97_PCM_RS_R_SURR    	AIC_ACCR1_RS_SLOT8
+#define AC97_PCM_RS_LFE       	AIC_ACCR1_RS_SLOT9
+
+#define __ac97_set_xs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK )
+#define __ac97_set_xs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_R_FRONT;				\
+} while(0)
+#define __ac97_set_xs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_XS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_XS_L_FRONT | AC97_PCM_XS_R_FRONT;	\
+} while(0)
+
+/* In fact, only stereo is support now. */ 
+#define __ac97_set_rs_none()	( REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK )
+#define __ac97_set_rs_mono() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_R_FRONT;				\
+} while(0)
+#define __ac97_set_rs_stereo() 						\
+do {									\
+	REG_AIC_ACCR1 &= ~AIC_ACCR1_RS_MASK;				\
+	REG_AIC_ACCR1 |= AC97_PCM_RS_L_FRONT | AC97_PCM_RS_R_FRONT;	\
+} while(0)
+
+#define __ac97_warm_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SA;		\
+	REG_AIC_ACCR2 |= AIC_ACCR2_SS;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SS;		\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SA;		\
+ } while (0)
+
+#define __ac97_cold_reset_codec()		\
+ do {						\
+	REG_AIC_ACCR2 |=  AIC_ACCR2_SR;		\
+	udelay(2);				\
+	REG_AIC_ACCR2 &= ~AIC_ACCR2_SR;		\
+ } while (0)
+
+/* n=8,16,18,20 */
+#define __ac97_set_iass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_IASS_MASK) | AIC_ACCR2_IASS_##n##BIT )
+#define __ac97_set_oass(n) \
+ ( REG_AIC_ACCR2 = (REG_AIC_ACCR2 & ~AIC_ACCR2_OASS_MASK) | AIC_ACCR2_OASS_##n##BIT )
+
+#define __i2s_select_i2s()            ( REG_AIC_I2SCR &= ~AIC_I2SCR_AMSL )
+#define __i2s_select_msbjustified()   ( REG_AIC_I2SCR |= AIC_I2SCR_AMSL )
+
+/* n=8,16,18,20,24 */
+/*#define __i2s_set_sample_size(n) \
+ ( REG_AIC_I2SCR |= (REG_AIC_I2SCR & ~AIC_I2SCR_WL_MASK) | AIC_I2SCR_WL_##n##BIT )*/
+
+#define __i2s_set_oss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_OSS_MASK) | AIC_CR_OSS_##n##BIT )
+#define __i2s_set_iss_sample_size(n) \
+ ( REG_AIC_CR = (REG_AIC_CR & ~AIC_CR_ISS_MASK) | AIC_CR_ISS_##n##BIT )
+
+#define __i2s_stop_bitclk()   ( REG_AIC_I2SCR |= AIC_I2SCR_STPBK )
+#define __i2s_start_bitclk()  ( REG_AIC_I2SCR &= ~AIC_I2SCR_STPBK )
+
+#define __aic_transmit_request()  ( REG_AIC_SR & AIC_SR_TFS )
+#define __aic_receive_request()   ( REG_AIC_SR & AIC_SR_RFS )
+#define __aic_transmit_underrun() ( REG_AIC_SR & AIC_SR_TUR )
+#define __aic_receive_overrun()   ( REG_AIC_SR & AIC_SR_ROR )
+
+#define __aic_clear_errors()      ( REG_AIC_SR &= ~(AIC_SR_TUR | AIC_SR_ROR) )
+
+#define __aic_get_transmit_resident() \
+  ( (REG_AIC_SR & AIC_SR_TFL_MASK) >> AIC_SR_TFL_BIT )
+#define __aic_get_receive_count() \
+  ( (REG_AIC_SR & AIC_SR_RFL_MASK) >> AIC_SR_RFL_BIT )
+
+#define __ac97_command_transmitted()     ( REG_AIC_ACSR & AIC_ACSR_CADT )
+#define __ac97_status_received()         ( REG_AIC_ACSR & AIC_ACSR_SADR )
+#define __ac97_status_receive_timeout()  ( REG_AIC_ACSR & AIC_ACSR_RSTO )
+#define __ac97_codec_is_low_power_mode() ( REG_AIC_ACSR & AIC_ACSR_CLPM )
+#define __ac97_codec_is_ready()          ( REG_AIC_ACSR & AIC_ACSR_CRDY )
+#define __ac97_slot_error_detected()     ( REG_AIC_ACSR & AIC_ACSR_SLTERR )
+#define __ac97_clear_slot_error()        ( REG_AIC_ACSR &= ~AIC_ACSR_SLTERR )
+
+#define __i2s_is_busy()         ( REG_AIC_I2SSR & AIC_I2SSR_BSY )
+
+#define CODEC_READ_CMD	        (1 << 19)
+#define CODEC_WRITE_CMD	        (0 << 19)
+#define CODEC_REG_INDEX_BIT     12
+#define CODEC_REG_INDEX_MASK	(0x7f << CODEC_REG_INDEX_BIT)	/* 18:12 */
+#define CODEC_REG_DATA_BIT      4
+#define CODEC_REG_DATA_MASK	(0x0ffff << 4)	/* 19:4 */
+
+#define __ac97_out_rcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_READ_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_wcmd_addr(reg) 					\
+do { 									\
+    REG_AIC_ACCAR = CODEC_WRITE_CMD | ((reg) << CODEC_REG_INDEX_BIT); 	\
+} while (0)
+
+#define __ac97_out_data(value) 						\
+do { 									\
+    REG_AIC_ACCDR = ((value) << CODEC_REG_DATA_BIT); 			\
+} while (0)
+
+#define __ac97_in_data() \
+ ( (REG_AIC_ACSDR & CODEC_REG_DATA_MASK) >> CODEC_REG_DATA_BIT )
+
+#define __ac97_in_status_addr() \
+ ( (REG_AIC_ACSAR & CODEC_REG_INDEX_MASK) >> CODEC_REG_INDEX_BIT )
+
+#define __i2s_set_sample_rate(i2sclk, sync) \
+  ( REG_AIC_I2SDIV = ((i2sclk) / (4*64)) / (sync) )
+
+#define __aic_write_tfifo(v)  ( REG_AIC_DR = (v) )
+#define __aic_read_rfifo()    ( REG_AIC_DR )
+
+#define __aic_internal_codec()  ( REG_AIC_FR |= AIC_FR_ICDC ) 
+#define __aic_external_codec()  ( REG_AIC_FR &= ~AIC_FR_ICDC )
+
+//
+// Define next ops for AC97 compatible
+//
+
+#define AC97_ACSR	AIC_ACSR
+
+#define __ac97_enable()		__aic_enable(); __aic_select_ac97()
+#define __ac97_disable()	__aic_disable()
+#define __ac97_reset()		__aic_reset()
+
+#define __ac97_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __ac97_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __ac97_enable_record()		__aic_enable_record()
+#define __ac97_disable_record()		__aic_disable_record()
+#define __ac97_enable_replay()		__aic_enable_replay()
+#define __ac97_disable_replay()		__aic_disable_replay()
+#define __ac97_enable_loopback()	__aic_enable_loopback()
+#define __ac97_disable_loopback()	__aic_disable_loopback()
+
+#define __ac97_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __ac97_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __ac97_enable_receive_dma()	__aic_enable_receive_dma()
+#define __ac97_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __ac97_transmit_request()	__aic_transmit_request()
+#define __ac97_receive_request()	__aic_receive_request()
+#define __ac97_transmit_underrun()	__aic_transmit_underrun()
+#define __ac97_receive_overrun()	__aic_receive_overrun()
+
+#define __ac97_clear_errors()		__aic_clear_errors()
+
+#define __ac97_get_transmit_resident()	__aic_get_transmit_resident()
+#define __ac97_get_receive_count()	__aic_get_receive_count()
+
+#define __ac97_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __ac97_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __ac97_enable_receive_intr()	__aic_enable_receive_intr()
+#define __ac97_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __ac97_write_tfifo(v)		__aic_write_tfifo(v)
+#define __ac97_read_rfifo()		__aic_read_rfifo()
+
+//
+// Define next ops for I2S compatible
+//
+
+#define I2S_ACSR	AIC_I2SSR
+
+#define __i2s_enable()		 __aic_enable(); __aic_select_i2s()
+#define __i2s_disable()		__aic_disable()
+#define __i2s_reset()		__aic_reset()
+
+#define __i2s_set_transmit_trigger(n)	__aic_set_transmit_trigger(n)
+#define __i2s_set_receive_trigger(n)	__aic_set_receive_trigger(n)
+
+#define __i2s_enable_record()		__aic_enable_record()
+#define __i2s_disable_record()		__aic_disable_record()
+#define __i2s_enable_replay()		__aic_enable_replay()
+#define __i2s_disable_replay()		__aic_disable_replay()
+#define __i2s_enable_loopback()		__aic_enable_loopback()
+#define __i2s_disable_loopback()	__aic_disable_loopback()
+
+#define __i2s_enable_transmit_dma()	__aic_enable_transmit_dma()
+#define __i2s_disable_transmit_dma()	__aic_disable_transmit_dma()
+#define __i2s_enable_receive_dma()	__aic_enable_receive_dma()
+#define __i2s_disable_receive_dma()	__aic_disable_receive_dma()
+
+#define __i2s_transmit_request()	__aic_transmit_request()
+#define __i2s_receive_request()		__aic_receive_request()
+#define __i2s_transmit_underrun()	__aic_transmit_underrun()
+#define __i2s_receive_overrun()		__aic_receive_overrun()
+
+#define __i2s_clear_errors()		__aic_clear_errors()
+
+#define __i2s_get_transmit_resident()	__aic_get_transmit_resident()
+#define __i2s_get_receive_count()	__aic_get_receive_count()
+
+#define __i2s_enable_transmit_intr()	__aic_enable_transmit_intr()
+#define __i2s_disable_transmit_intr()	__aic_disable_transmit_intr()
+#define __i2s_enable_receive_intr()	__aic_enable_receive_intr()
+#define __i2s_disable_receive_intr()	__aic_disable_receive_intr()
+
+#define __i2s_write_tfifo(v)		__aic_write_tfifo(v)
+#define __i2s_read_rfifo()		__aic_read_rfifo()
+
+#define __i2s_reset_codec()			\
+ do {						\
+ } while (0)
+
+/*************************************************************************
+ * PCM Controller operation
+ *************************************************************************/
+
+#define __pcm_enable()          ( REG_PCM_CTL |= PCM_CTL_PCMEN )
+#define __pcm_disable()         ( REG_PCM_CTL &= ~PCM_CTL_PCMEN )
+
+#define __pcm_clk_enable()      ( REG_PCM_CTL |= PCM_CTL_CLKEN )
+#define __pcm_clk_disable()     ( REG_PCM_CTL &= ~PCM_CTL_CLKEN )
+
+#define __pcm_reset()           ( REG_PCM_CTL |= PCM_CTL_RST )
+#define __pcm_flush_fifo()	( REG_PCM_CTL |= PCM_CTL_FLUSH )
+
+#define __pcm_enable_record()		( REG_PCM_CTL |= PCM_CTL_EREC )
+#define __pcm_disable_record()		( REG_PCM_CTL &= ~PCM_CTL_EREC )
+#define __pcm_enable_playback()		( REG_PCM_CTL |= PCM_CTL_ERPL )
+#define __pcm_disable_playback()	( REG_PCM_CTL &= ~PCM_CTL_ERPL )
+
+#define __pcm_enable_rxfifo()           __pcm_enable_record()
+#define __pcm_disable_rxfifo()          __pcm_disable_record()
+#define __pcm_enable_txfifo()           __pcm_enable_playback()
+#define __pcm_disable_txfifo()          __pcm_disable_playback()
+
+#define __pcm_last_sample()     ( REG_PCM_CTL |= PCM_CTL_LSMP )
+#define __pcm_zero_sample()     ( REG_PCM_CTL &= ~PCM_CTL_LSMP )
+
+#define __pcm_enable_transmit_dma()    ( REG_PCM_CTL |= PCM_CTL_ETDMA )
+#define __pcm_disable_transmit_dma()   ( REG_PCM_CTL &= ~PCM_CTL_ETDMA )
+#define __pcm_enable_receive_dma()     ( REG_PCM_CTL |= PCM_CTL_ERDMA )
+#define __pcm_disable_receive_dma()    ( REG_PCM_CTL &= ~PCM_CTL_ERDMA )
+
+#define __pcm_as_master()     ( REG_PCM_CFG &= PCM_CFG_MODE )
+#define __pcm_as_slave()      ( REG_PCM_CFG |= ~PCM_CFG_MODE )
+
+#define __pcm_set_transmit_trigger(n) 			\
+do {							\
+	REG_PCM_CFG &= ~PCM_CFG_TFTH_MASK;		\
+	REG_PCM_CFG |= ((n) << PCM_CFG_TFTH_BIT);	\
+} while(0)
+
+#define __pcm_set_receive_trigger(n) 			\
+do {							\
+	REG_PCM_CFG &= ~PCM_CFG_RFTH_MASK;		\
+	REG_PCM_CFG |= ((n) << PCM_CFG_RFTH_BIT);	\
+} while(0)
+
+#define __pcm_omsb_same_sync()   ( REG_PCM_CFG &= ~PCM_CFG_OMSBPOS )
+#define __pcm_omsb_next_sync()   ( REG_PCM_CFG |= PCM_CFG_OMSBPOS )
+
+#define __pcm_imsb_same_sync()   ( REG_PCM_CFG &= ~PCM_CFG_IMSBPOS )
+#define __pcm_imsb_next_sync()   ( REG_PCM_CFG |= PCM_CFG_IMSBPOS )
+
+/* set input sample size 8 or 16*/
+#define __pcm_set_iss(n) \
+( REG_PCM_CFG = (REG_PCM_CFG & ~PCM_CFG_ISS_MASK) | PCM_CFG_ISS_##n )
+/* set output sample size 8 or 16*/
+#define __pcm_set_oss(n) \
+( REG_PCM_CFG = (REG_PCM_CFG & ~PCM_CFG_OSS_MASK) | PCM_CFG_OSS_##n )
+
+#define __pcm_set_valid_slot(n) \
+( REG_PCM_CFG = (REG_PCM_CFG & ~PCM_CFG_SLOT_MASK) | PCM_CFG_SLOT_##n )
+
+#define __pcm_write_data(v)           ( REG_PCM_DP = (v) )
+#define __pcm_read_data()             ( REG_PCM_DP )
+
+#define __pcm_enable_tfs_intr()       ( REG_PCM_INTC |= PCM_INTC_ETFS )
+#define __pcm_disable_tfs_intr()      ( REG_PCM_INTC &= ~PCM_INTC_ETFS )
+
+#define __pcm_enable_tur_intr()       ( REG_PCM_INTC |= PCM_INTC_ETUR )
+#define __pcm_disable_tur_intr()      ( REG_PCM_INTC &= ~PCM_INTC_ETUR )
+
+#define __pcm_enable_rfs_intr()       ( REG_PCM_INTC |= PCM_INTC_ERFS )
+#define __pcm_disable_rfs_intr()      ( REG_PCM_INTC &= ~PCM_INTC_ERFS )
+
+#define __pcm_enable_ror_intr()       ( REG_PCM_INTC |= PCM_INTC_EROR )
+#define __pcm_disable_ror_intr()      ( REG_PCM_INTC &= ~PCM_INTC_EROR )
+
+#define __pcm_ints_valid_tx() \
+( ((REG_PCM_INTS & PCM_INTS_TFL_MASK) >> PCM_INTS_TFL_BIT) )
+#define __pcm_ints_valid_rx() \
+( ((REG_PCM_INTS & PCM_INTS_RFL_MASK) >> PCM_INTS_RFL_BIT) )
+
+#define __pcm_set_clk_div(n) \
+( REG_PCM_DIV = (REG_PCM_DIV & ~PCM_DIV_CLKDIV_MASK) | ((n) << PCM_DIV_CLKDIV_BIT) )
+
+/* sysclk(cpm_pcm_sysclk) Hz is created by cpm logic, and pcmclk Hz is the pcm in/out clock wanted */
+#define __pcm_set_clk_rate(sysclk, pcmclk) \
+__pcm_set_clk_div(((sysclk) / (pcmclk) - 1)) 
+
+#define __pcm_set_sync_div(n) \
+( REG_PCM_DIV = (REG_PCM_DIV & ~PCM_DIV_SYNDIV_MASK) | ((n) << PCM_DIV_SYNDIV_BIT) )
+
+/* pcmclk is source clock Hz, and sync is the frame sync clock Hz wanted */
+#define __pcm_set_sync_rate(pcmclk, sync) \
+__pcm_set_sync_div(((pcmclk) / (8 * (sync)) - 1))
+
+ /* set sync length in pcmclk n = 0 ... 63 */
+#define __pcm_set_sync_len(n) \
+( REG_PCM_DIV = (REG_PCM_DIV & ~PCM_DIV_SYNL_MASK) | (n << PCM_DIV_SYNL_BIT) )
+
+
+/***************************************************************************
+ * ICDC
+ ***************************************************************************/
+#define __i2s_internal_codec()         __aic_internal_codec()
+#define __i2s_external_codec()         __aic_external_codec()
+
+#define __icdc_clk_ready()             ( REG_ICDC_CKCFG & ICDC_CKCFG_CKRDY )
+#define __icdc_sel_adc()               ( REG_ICDC_CKCFG |= ICDC_CKCFG_SELAD )
+#define __icdc_sel_dac()               ( REG_ICDC_CKCFG &= ~ICDC_CKCFG_SELAD )
+
+#define __icdc_set_rgwr()              ( REG_ICDC_RGADW |= ICDC_RGADW_RGWR )
+#define __icdc_clear_rgwr()            ( REG_ICDC_RGADW &= ~ICDC_RGADW_RGWR )
+#define __icdc_rgwr_ready()            ( REG_ICDC_RGADW & ICDC_RGADW_RGWR )
+
+#define __icdc_set_addr(n)				\
+do {          						\
+	REG_ICDC_RGADW &= ~ICDC_RGADW_RGADDR_MASK;	\
+	REG_ICDC_RGADW |= (n) << ICDC_RGADW_RGADDR_BIT;	\
+} while(0)
+
+#define __icdc_set_cmd(n)				\
+do {          						\
+	REG_ICDC_RGADW &= ~ICDC_RGADW_RGDIN_MASK;	\
+	REG_ICDC_RGADW |= (n) << ICDC_RGADW_RGDIN_BIT;	\
+} while(0)
+
+#define __icdc_irq_pending()            ( REG_ICDC_RGDATA & ICDC_RGDATA_IRQ )
+#define __icdc_get_value()              ( REG_ICDC_RGDATA & ICDC_RGDATA_RGDOUT_MASK )
+
+/***************************************************************************
+ * INTC
+ ***************************************************************************/
+#define __intc_unmask_irq(n)	( REG_INTC_IMCR = (1 << (n)) )
+#define __intc_mask_irq(n)	( REG_INTC_IMSR = (1 << (n)) )
+#define __intc_ack_irq(n)	( REG_INTC_IPR = (1 << (n)) ) /* A dummy ack, as the Pending Register is Read Only. Should we remove __intc_ack_irq() */
+
+
+/***************************************************************************
+ * I2C
+ ***************************************************************************/
+
+#define __i2c_enable()		( REG_I2C_CR |= I2C_CR_I2CE )
+#define __i2c_disable()		( REG_I2C_CR &= ~I2C_CR_I2CE )
+
+#define __i2c_send_start()	( REG_I2C_CR |= I2C_CR_STA )
+#define __i2c_send_stop()	( REG_I2C_CR |= I2C_CR_STO )
+#define __i2c_send_ack()	( REG_I2C_CR &= ~I2C_CR_AC )
+#define __i2c_send_nack()	( REG_I2C_CR |= I2C_CR_AC )
+
+#define __i2c_set_drf()		( REG_I2C_SR |= I2C_SR_DRF )
+#define __i2c_clear_drf()	( REG_I2C_SR &= ~I2C_SR_DRF )
+#define __i2c_check_drf()	( REG_I2C_SR & I2C_SR_DRF )
+
+#define __i2c_received_ack()	( !(REG_I2C_SR & I2C_SR_ACKF) )
+#define __i2c_is_busy()		( REG_I2C_SR & I2C_SR_BUSY )
+#define __i2c_transmit_ended()	( REG_I2C_SR & I2C_SR_TEND )
+
+#define __i2c_set_clk(dev_clk, i2c_clk) \
+  ( REG_I2C_GR = (dev_clk) / (16*(i2c_clk)) - 1 )
+
+#define __i2c_read()		( REG_I2C_DR )
+#define __i2c_write(val)	( REG_I2C_DR = (val) )
+
+
+/***************************************************************************
+ * MSC
+ ***************************************************************************/
+/* n = 0, 1 (MSC0, MSC1) */
+
+#define __msc_start_op(n) \
+	( REG_MSC_STRPCL(n) = MSC_STRPCL_START_OP | MSC_STRPCL_CLOCK_CONTROL_START )
+
+#define __msc_set_resto(n, to)  	( REG_MSC_RESTO(n) = to )
+#define __msc_set_rdto(n, to)   	( REG_MSC_RDTO(n) = to )
+#define __msc_set_cmd(n, cmd)   	( REG_MSC_CMD(n) = cmd )
+#define __msc_set_arg(n, arg)   	( REG_MSC_ARG(n) = arg )
+#define __msc_set_nob(n, nob)      	( REG_MSC_NOB(n) = nob )
+#define __msc_get_nob(n)        	( REG_MSC_NOB(n) )
+#define __msc_set_blklen(n, len)        ( REG_MSC_BLKLEN(n) = len )
+#define __msc_set_cmdat(n, cmdat)   	( REG_MSC_CMDAT(n) = cmdat )
+#define __msc_set_cmdat_ioabort(n) 	( REG_MSC_CMDAT(n) |= MSC_CMDAT_IO_ABORT )
+#define __msc_clear_cmdat_ioabort(n) 	( REG_MSC_CMDAT(n) &= ~MSC_CMDAT_IO_ABORT )
+
+#define __msc_set_cmdat_bus_width1(n) 			\
+do { 							\
+	REG_MSC_CMDAT(n) &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT(n) |= MSC_CMDAT_BUS_WIDTH_1BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_bus_width4(n) 			\
+do { 							\
+	REG_MSC_CMDAT(n) &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
+	REG_MSC_CMDAT(n) |= MSC_CMDAT_BUS_WIDTH_4BIT; 	\
+} while(0)
+
+#define __msc_set_cmdat_dma_en(n)       ( REG_MSC_CMDAT(n) |= MSC_CMDAT_DMA_EN )
+#define __msc_set_cmdat_init(n) 	( REG_MSC_CMDAT(n) |= MSC_CMDAT_INIT )
+#define __msc_set_cmdat_busy(n) 	( REG_MSC_CMDAT(n) |= MSC_CMDAT_BUSY )
+#define __msc_set_cmdat_stream(n)       ( REG_MSC_CMDAT(n) |= MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_block(n)        ( REG_MSC_CMDAT(n) &= ~MSC_CMDAT_STREAM_BLOCK )
+#define __msc_set_cmdat_read(n) 	( REG_MSC_CMDAT(n) &= ~MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_write(n)        ( REG_MSC_CMDAT(n) |= MSC_CMDAT_WRITE_READ )
+#define __msc_set_cmdat_data_en(n)      ( REG_MSC_CMDAT(n) |= MSC_CMDAT_DATA_EN )
+
+/* r is MSC_CMDAT_RESPONSE_FORMAT_Rx or MSC_CMDAT_RESPONSE_FORMAT_NONE */
+#define __msc_set_cmdat_res_format(n, r)				\
+do { 								\
+	REG_MSC_CMDAT(n) &= ~MSC_CMDAT_RESPONSE_FORMAT_MASK; 	\
+	REG_MSC_CMDAT(n) |= (r); 					\
+} while(0)
+
+#define __msc_clear_cmdat(n) \
+  REG_MSC_CMDAT(n) &= ~( MSC_CMDAT_IO_ABORT | MSC_CMDAT_DMA_EN | MSC_CMDAT_INIT| \
+  MSC_CMDAT_BUSY | MSC_CMDAT_STREAM_BLOCK | MSC_CMDAT_WRITE_READ | \
+  MSC_CMDAT_DATA_EN | MSC_CMDAT_RESPONSE_FORMAT_MASK )
+
+#define __msc_get_imask(n) 		( REG_MSC_IMASK(n) )
+#define __msc_mask_all_intrs(n) 	( REG_MSC_IMASK(n) = 0xff )
+#define __msc_unmask_all_intrs(n) 	( REG_MSC_IMASK(n) = 0x00 )
+#define __msc_mask_rd(n) 		( REG_MSC_IMASK(n) |= MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_unmask_rd(n) 		( REG_MSC_IMASK(n) &= ~MSC_IMASK_RXFIFO_RD_REQ )
+#define __msc_mask_wr(n) 		( REG_MSC_IMASK(n) |= MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_unmask_wr(n) 		( REG_MSC_IMASK(n) &= ~MSC_IMASK_TXFIFO_WR_REQ )
+#define __msc_mask_endcmdres(n) 	( REG_MSC_IMASK(n) |= MSC_IMASK_END_CMD_RES )
+#define __msc_unmask_endcmdres(n) 	( REG_MSC_IMASK(n) &= ~MSC_IMASK_END_CMD_RES )
+#define __msc_mask_datatrandone(n) 	( REG_MSC_IMASK(n) |= MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_unmask_datatrandone(n) 	( REG_MSC_IMASK(n) &= ~MSC_IMASK_DATA_TRAN_DONE )
+#define __msc_mask_prgdone(n) 		( REG_MSC_IMASK(n) |= MSC_IMASK_PRG_DONE )
+#define __msc_unmask_prgdone(n) 	( REG_MSC_IMASK(n) &= ~MSC_IMASK_PRG_DONE )
+
+/* m=0,1,2,3,4,5,6,7 */
+#define __msc_set_clkrt(n, m) 	\
+do { 				\
+	REG_MSC_CLKRT(n) = m;	\
+} while(0)
+
+#define __msc_get_ireg(n) 	        	( REG_MSC_IREG(n) )
+#define __msc_ireg_rd(n) 	        	( REG_MSC_IREG(n) & MSC_IREG_RXFIFO_RD_REQ )
+#define __msc_ireg_wr(n) 	        	( REG_MSC_IREG(n) & MSC_IREG_TXFIFO_WR_REQ )
+#define __msc_ireg_end_cmd_res(n)       	( REG_MSC_IREG(n) & MSC_IREG_END_CMD_RES )
+#define __msc_ireg_data_tran_done(n)     	( REG_MSC_IREG(n) & MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_prg_done(n) 	        	( REG_MSC_IREG(n) & MSC_IREG_PRG_DONE )
+#define __msc_ireg_clear_end_cmd_res(n)         ( REG_MSC_IREG(n) = MSC_IREG_END_CMD_RES )
+#define __msc_ireg_clear_data_tran_done(n)      ( REG_MSC_IREG(n) = MSC_IREG_DATA_TRAN_DONE )
+#define __msc_ireg_clear_prg_done(n)     	( REG_MSC_IREG(n) = MSC_IREG_PRG_DONE )
+
+#define __msc_get_stat(n) 		( REG_MSC_STAT(n) )
+#define __msc_stat_not_end_cmd_res(n) 	( (REG_MSC_STAT(n) & MSC_STAT_END_CMD_RES) == 0)
+#define __msc_stat_crc_err(n) \
+  ( REG_MSC_STAT(n) & (MSC_STAT_CRC_RES_ERR | MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR_YES) )
+#define __msc_stat_res_crc_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_CRC_RES_ERR )
+#define __msc_stat_rd_crc_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_CRC_READ_ERROR )
+#define __msc_stat_wr_crc_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_CRC_WRITE_ERROR_YES )
+#define __msc_stat_resto_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_TIME_OUT_RES )
+#define __msc_stat_rdto_err(n) 		( REG_MSC_STAT(n) & MSC_STAT_TIME_OUT_READ )
+
+#define __msc_rd_resfifo(n) 		( REG_MSC_RES(n) )
+#define __msc_rd_rxfifo(n)  		( REG_MSC_RXFIFO(n) )
+#define __msc_wr_txfifo(n, v)  		( REG_MSC_TXFIFO(n) = v )
+
+#define __msc_reset(n) 						\
+do { 								\
+	REG_MSC_STRPCL(n) = MSC_STRPCL_RESET;			\
+ 	while (REG_MSC_STAT(n) & MSC_STAT_IS_RESETTING);		\
+} while (0)
+
+#define __msc_start_clk(n) 					\
+do { 								\
+	REG_MSC_STRPCL(n) = MSC_STRPCL_CLOCK_CONTROL_START;	\
+} while (0)
+
+#define __msc_stop_clk(n) 					\
+do { 								\
+	REG_MSC_STRPCL(n) = MSC_STRPCL_CLOCK_CONTROL_STOP;	\
+} while (0)
+
+#define MMC_CLK 19169200
+#define SD_CLK  24576000
+
+/* msc_clk should little than pclk and little than clk retrieve from card */
+#define __msc_calc_clk_divisor(type,dev_clk,msc_clk,lv)		\
+do {								\
+	unsigned int rate, pclk, i;				\
+	pclk = dev_clk;						\
+	rate = type?SD_CLK:MMC_CLK;				\
+  	if (msc_clk && msc_clk < pclk)				\
+    		pclk = msc_clk;					\
+	i = 0;							\
+  	while (pclk < rate)					\
+    	{							\
+      		i ++;						\
+      		rate >>= 1;					\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+/* divide rate to little than or equal to 400kHz */
+#define __msc_calc_slow_clk_divisor(type, lv)			\
+do {								\
+	unsigned int rate, i;					\
+	rate = (type?SD_CLK:MMC_CLK)/1000/400;			\
+	i = 0;							\
+	while (rate > 0)					\
+    	{							\
+      		rate >>= 1;					\
+      		i ++;						\
+    	}							\
+  	lv = i;							\
+} while(0)
+
+
+/***************************************************************************
+ * SSI (Synchronous Serial Interface)
+ ***************************************************************************/
+/* n = 0, 1 (SSI0, SSI1) */
+#define __ssi_enable(n) 	( REG_SSI_CR0(n) |= SSI_CR0_SSIE )
+#define __ssi_disable(n) 	( REG_SSI_CR0(n) &= ~SSI_CR0_SSIE )
+#define __ssi_select_ce(n) 	( REG_SSI_CR0(n) &= ~SSI_CR0_FSEL )
+
+#define __ssi_normal_mode(n) ( REG_SSI_ITR(n) &= ~SSI_ITR_IVLTM_MASK )
+
+#define __ssi_select_ce2(n) 		\
+do { 					\
+	REG_SSI_CR0(n) |= SSI_CR0_FSEL; 	\
+	REG_SSI_CR1(n) &= ~SSI_CR1_MULTS;	\
+} while (0)
+
+#define __ssi_select_gpc(n) 			\
+do { 						\
+	REG_SSI_CR0(n) &= ~SSI_CR0_FSEL;	\
+	REG_SSI_CR1(n) |= SSI_CR1_MULTS;	\
+} while (0)
+
+#define __ssi_underrun_auto_clear(n) 		\
+do { 						\
+	REG_SSI_CR0(n) |= SSI_CR0_EACLRUN; 	\
+} while (0)
+
+#define __ssi_underrun_clear_manually(n) 	\
+do { 						\
+	REG_SSI_CR0(n) &= ~SSI_CR0_EACLRUN; 	\
+} while (0)
+
+#define __ssi_enable_tx_intr(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_TIE | SSI_CR0_TEIE )
+
+#define __ssi_disable_tx_intr(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_TIE | SSI_CR0_TEIE) )
+
+#define __ssi_enable_rx_intr(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_RIE | SSI_CR0_REIE )
+
+#define __ssi_disable_rx_intr(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_RIE | SSI_CR0_REIE) )
+
+#define __ssi_enable_txfifo_half_empty_intr(n)  \
+	( REG_SSI_CR0(n) |= SSI_CR0_TIE )
+#define __ssi_disable_txfifo_half_empty_intr(n)	\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_TIE )
+#define __ssi_enable_tx_error_intr(n)		\
+	( REG_SSI_CR0(n) |= SSI_CR0_TEIE )
+#define __ssi_disable_tx_error_intr(n)		\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_TEIE )
+#define __ssi_enable_rxfifo_half_full_intr(n)	\
+	( REG_SSI_CR0(n) |= SSI_CR0_RIE )
+#define __ssi_disable_rxfifo_half_full_intr(n)  \
+	( REG_SSI_CR0(n) &= ~SSI_CR0_RIE )
+#define __ssi_enable_rx_error_intr(n)		\
+	( REG_SSI_CR0(n) |= SSI_CR0_REIE )
+#define __ssi_disable_rx_error_intr(n)		\
+	( REG_SSI_CR0(n) &= ~SSI_CR0_REIE )
+
+#define __ssi_enable_loopback(n)  ( REG_SSI_CR0(n) |= SSI_CR0_LOOP )
+#define __ssi_disable_loopback(n) ( REG_SSI_CR0(n) &= ~SSI_CR0_LOOP )
+
+#define __ssi_enable_receive(n)   ( REG_SSI_CR0(n) &= ~SSI_CR0_DISREV )
+#define __ssi_disable_receive(n)  ( REG_SSI_CR0(n) |= SSI_CR0_DISREV )
+
+#define __ssi_finish_receive(n)					\
+	( REG_SSI_CR0(n) |= (SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_disable_recvfinish(n)				\
+	( REG_SSI_CR0(n) &= ~(SSI_CR0_RFINE | SSI_CR0_RFINC) )
+
+#define __ssi_flush_txfifo(n)   	( REG_SSI_CR0(n) |= SSI_CR0_TFLUSH )
+#define __ssi_flush_rxfifo(n)   	( REG_SSI_CR0(n) |= SSI_CR0_RFLUSH )
+
+#define __ssi_flush_fifo(n)					\
+	( REG_SSI_CR0(n) |= SSI_CR0_TFLUSH | SSI_CR0_RFLUSH )
+
+#define __ssi_finish_transmit(n) 	( REG_SSI_CR1(n) &= ~SSI_CR1_UNFIN )
+#define __ssi_wait_transmit(n) 		( REG_SSI_CR1(n) |= SSI_CR1_UNFIN )
+#define __ssi_use_busy_wait_mode(n) 	__ssi_wait_transmit(n)
+#define __ssi_unset_busy_wait_mode(n) 	__ssi_finish_transmit(n)
+
+#define __ssi_spi_format(n)						\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSI_CR1_FMAT_MASK; 			\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_SPI;			\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK); \
+		REG_SSI_CR1(n) |= (SSI_CR1_TFVCK_1 | SSI_CR1_TCKFI_1);	\
+	} while (0)
+
+/* TI's SSP format, must clear SSI_CR1.UNFIN */
+#define __ssi_ssp_format(n)						\
+	do { 								\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_FMAT_MASK | SSI_CR1_UNFIN);	\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_SSP;			\
+	} while (0)
+
+/* National's Microwire format, must clear SSI_CR0.RFINE, and set max delay */
+#define __ssi_microwire_format(n)					\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSI_CR1_FMAT_MASK; 			\
+		REG_SSI_CR1(n) |= SSI_CR1_FMAT_MW1;			\
+		REG_SSI_CR1(n) &= ~(SSI_CR1_TFVCK_MASK|SSI_CR1_TCKFI_MASK); \
+		REG_SSI_CR1(n) |= (SSI_CR1_TFVCK_3 | SSI_CR1_TCKFI_3);	\
+		REG_SSI_CR0(n) &= ~SSI_CR0_RFINE;			\
+	} while (0)
+
+/* CE# level (FRMHL), CE# in interval time (ITFRM),
+   clock phase and polarity (PHA POL),
+   interval time (SSIITR), interval characters/frame (SSIICR) */
+
+/* frmhl,endian,mcom,flen,pha,pol MASK */
+#define SSICR1_MISC_MASK 					\
+	( SSI_CR1_FRMHL_MASK | SSI_CR1_LFST | SSI_CR1_MCOM_MASK	\
+	  | SSI_CR1_FLEN_MASK | SSI_CR1_PHA | SSI_CR1_POL )	
+
+#define __ssi_spi_set_misc(n,frmhl,endian,flen,mcom,pha,pol)		\
+	do {								\
+		REG_SSI_CR1(n) &= ~SSICR1_MISC_MASK;			\
+		REG_SSI_CR1(n) |= ((frmhl) << 30) | ((endian) << 25) | 	\
+			(((mcom) - 1) << 12) | (((flen) - 2) << 4) | 	\
+			((pha) << 1) | (pol); 				\
+	} while(0)
+
+/* Transfer with MSB or LSB first */
+#define __ssi_set_msb(n) ( REG_SSI_CR1(n) &= ~SSI_CR1_LFST )
+#define __ssi_set_lsb(n) ( REG_SSI_CR1(n) |= SSI_CR1_LFST )
+
+#define __ssi_set_frame_length(n, m)					\
+	REG_SSI_CR1(n) = (REG_SSI_CR1(n) & ~SSI_CR1_FLEN_MASK) | (((m) - 2) << 4) 
+
+/* m = 1 - 16 */
+#define __ssi_set_microwire_command_length(n,m)				\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_MCOM_MASK) | SSI_CR1_MCOM_##m##BIT) )
+
+/* Set the clock phase for SPI */
+#define __ssi_set_spi_clock_phase(n, m)					\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_PHA) | (((m)&0x1)<< 1)))
+
+/* Set the clock polarity for SPI */
+#define __ssi_set_spi_clock_polarity(n, p)				\
+	( REG_SSI_CR1(n) = ((REG_SSI_CR1(n) & ~SSI_CR1_POL) | ((p)&0x1)) )
+
+/* SSI tx trigger, m = i x 8 */
+#define __ssi_set_tx_trigger(n, m)				\
+	do {							\
+		REG_SSI_CR1(n) &= ~SSI_CR1_TTRG_MASK;		\
+		REG_SSI_CR1(n) |= ((m)/8)<<SSI_CR1_TTRG_BIT;	\
+	} while (0)
+
+/* SSI rx trigger, m = i x 8 */
+#define __ssi_set_rx_trigger(n, m)				\
+	do {							\
+		REG_SSI_CR1(n) &= ~SSI_CR1_RTRG_MASK;		\
+		REG_SSI_CR1(n) |= ((m)/8)<<SSI_CR1_RTRG_BIT;	\
+	} while (0)
+
+#define __ssi_get_txfifo_count(n)					\
+	( (REG_SSI_SR(n) & SSI_SR_TFIFONUM_MASK) >> SSI_SR_TFIFONUM_BIT )
+
+#define __ssi_get_rxfifo_count(n)					\
+	( (REG_SSI_SR(n) & SSI_SR_RFIFONUM_MASK) >> SSI_SR_RFIFONUM_BIT )
+
+#define __ssi_transfer_end(n)		( REG_SSI_SR(n) & SSI_SR_END )
+#define __ssi_is_busy(n)		( REG_SSI_SR(n) & SSI_SR_BUSY )
+
+#define __ssi_txfifo_full(n)		( REG_SSI_SR(n) & SSI_SR_TFF )
+#define __ssi_rxfifo_empty(n)		( REG_SSI_SR(n) & SSI_SR_RFE )
+#define __ssi_rxfifo_half_full(n)	( REG_SSI_SR(n) & SSI_SR_RFHF )
+#define __ssi_txfifo_half_empty(n)	( REG_SSI_SR(n) & SSI_SR_TFHE )
+#define __ssi_underrun(n)		( REG_SSI_SR(n) & SSI_SR_UNDR )
+#define __ssi_overrun(n)		( REG_SSI_SR(n) & SSI_SR_OVER )
+#define __ssi_clear_underrun(n)		( REG_SSI_SR(n) = ~SSI_SR_UNDR )
+#define __ssi_clear_overrun(n)		( REG_SSI_SR(n) = ~SSI_SR_OVER )
+#define __ssi_clear_errors(n)		( REG_SSI_SR(n) &= ~(SSI_SR_UNDR | SSI_SR_OVER) )
+
+#define __ssi_set_clk(n, dev_clk, ssi_clk)			\
+	( REG_SSI_GR(n) = (dev_clk) / (2*(ssi_clk)) - 1 )
+
+#define __ssi_receive_data(n) 		REG_SSI_DR(n)
+#define __ssi_transmit_data(n, v) 	(REG_SSI_DR(n) = (v))
+
+
+/***************************************************************************
+ * CIM
+ ***************************************************************************/
+
+#define __cim_enable()	( REG_CIM_CTRL |= CIM_CTRL_ENA )
+#define __cim_disable()	( REG_CIM_CTRL &= ~CIM_CTRL_ENA )
+
+/* n = 0, 1, 2, 3 */
+#define __cim_set_input_data_stream_order(n)				\
+	do {								\
+		REG_CIM_CFG &= CIM_CFG_ORDER_MASK;			\
+		REG_CIM_CFG |= ((n)<<CIM_CFG_ORDER_BIT)&CIM_CFG_ORDER_MASK; \
+	} while (0)
+
+#define __cim_input_data_format_select_RGB()	\
+	do {					\
+		REG_CIM_CFG &= CIM_CFG_DF_MASK;	\
+		REG_CIM_CFG |= CIM_CFG_DF_RGB;	\
+	} while (0)
+
+#define __cim_input_data_format_select_YUV444()		\
+	do {						\
+		REG_CIM_CFG &= CIM_CFG_DF_MASK;		\
+		REG_CIM_CFG |= CIM_CFG_DF_YUV444;	\
+	} while (0)
+
+#define __cim_input_data_format_select_YUV422()		\
+	do {						\
+		REG_CIM_CFG &= CIM_CFG_DF_MASK;		\
+		REG_CIM_CFG |= CIM_CFG_DF_YUV422;	\
+	} while (0)
+
+#define __cim_input_data_format_select_ITU656()		\
+	do {						\
+		REG_CIM_CFG &= CIM_CFG_DF_MASK;		\
+		REG_CIM_CFG |= CIM_CFG_DF_ITU656;	\
+	} while (0)
+
+#define __cim_input_data_inverse()	( REG_CIM_CFG |= CIM_CFG_INV_DAT )
+#define __cim_input_data_normal()	( REG_CIM_CFG &= ~CIM_CFG_INV_DAT )
+
+#define __cim_vsync_active_low()	( REG_CIM_CFG |= CIM_CFG_VSP )
+#define __cim_vsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_VSP )
+
+#define __cim_hsync_active_low()	( REG_CIM_CFG |= CIM_CFG_HSP )
+#define __cim_hsync_active_high()	( REG_CIM_CFG &= ~CIM_CFG_HSP )
+
+#define __cim_sample_data_at_pclk_falling_edge() \
+	( REG_CIM_CFG |= CIM_CFG_PCP )
+#define __cim_sample_data_at_pclk_rising_edge() \
+	( REG_CIM_CFG &= ~CIM_CFG_PCP )
+
+#define __cim_enable_dummy_zero()	( REG_CIM_CFG |= CIM_CFG_DUMMY_ZERO )
+#define __cim_disable_dummy_zero()	( REG_CIM_CFG &= ~CIM_CFG_DUMMY_ZERO )
+
+#define __cim_select_external_vsync()	( REG_CIM_CFG |= CIM_CFG_EXT_VSYNC )
+#define __cim_select_internal_vsync()	( REG_CIM_CFG &= ~CIM_CFG_EXT_VSYNC )
+
+/* n=0-7 */
+#define __cim_set_data_packing_mode(n) 		\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_PACK_MASK;	\
+	REG_CIM_CFG |= (CIM_CFG_PACK_##n);	\
+} while (0)
+
+#define __cim_enable_bypass_func() 	(REG_CIM_CFG |= CIM_CFG_BYPASS)
+#define __cim_disable_bypass_func() 	(REG_CIM_CFG &= ~CIM_CFG_BYPASS_MASK)
+
+#define __cim_enable_ccir656_progressive_mode()	\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_DSM_MASK;	\
+	REG_CIM_CFG |= CIM_CFG_DSM_CPM;		\
+} while (0)
+
+#define __cim_enable_ccir656_interlace_mode()	\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_DSM_MASK;	\
+	REG_CIM_CFG |= CIM_CFG_DSM_CIM;		\
+} while (0)
+
+#define __cim_enable_gated_clock_mode()		\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_DSM_MASK;	\
+	REG_CIM_CFG |= CIM_CFG_DSM_GCM;		\
+} while (0)
+
+#define __cim_enable_nongated_clock_mode()	\
+do {						\
+	REG_CIM_CFG &= ~CIM_CFG_DSM_MASK;	\
+	REG_CIM_CFG |= CIM_CFG_DSM_NGCM;	\
+} while (0)
+
+/* sclk:system bus clock
+ * mclk: CIM master clock
+ */
+#define __cim_set_master_clk(sclk, mclk)			\
+do {								\
+	REG_CIM_CTRL &= ~CIM_CTRL_MCLKDIV_MASK;				\
+	REG_CIM_CTRL |= (((sclk)/(mclk) - 1) << CIM_CTRL_MCLKDIV_BIT);	\
+} while (0)
+/* n=1-16 */
+#define __cim_set_frame_rate(n) 		\
+do {						\
+	REG_CIM_CTRL &= ~CIM_CTRL_FRC_MASK; 	\
+	REG_CIM_CTRL |= CIM_CTRL_FRC_##n;	\
+} while (0)
+
+#define __cim_enable_size_func() \
+	( REG_CIM_CTRL |= CIM_CTRL_SIZEEN )
+#define __cim_disable_size_func() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_SIZEEN_MASK )
+
+#define __cim_enable_vdd_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_VDDM )
+#define __cim_disable_vdd_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_VDDM )
+
+#define __cim_enable_sof_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_DMA_SOFM )
+#define __cim_disable_sof_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_DMA_SOFM )
+
+#define __cim_enable_eof_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_DMA_EOFM )
+#define __cim_disable_eof_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EOFM )
+
+#define __cim_enable_eeof_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_DMA_EEOFM )
+#define __cim_disable_eeof_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EEOFM )
+
+#define __cim_enable_stop_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_DMA_STOPM )
+#define __cim_disable_stop_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_DMA_STOPM )
+
+#define __cim_enable_trig_intr() \
+	( REG_CIM_CTRL |= CIM_CTRL_RXF_TRIGM )
+#define __cim_disable_trig_intr() \
+	( REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIGM )
+
+#define __cim_enable_rxfifo_overflow_intr()	\
+	( REG_CIM_CTRL |= CIM_CTRL_RXF_OFM )
+#define __cim_disable_rxfifo_overflow_intr()	\
+	( REG_CIM_CTRL &= ~CIM_CTRL_RXF_OFM )
+
+/* n=4,8,12,16,20,24,28,32 */
+#define __cim_set_rxfifo_trigger(n) 		\
+do {						\
+	REG_CIM_CTRL &= ~CIM_CTRL_RXF_TRIG_MASK; 	\
+	REG_CIM_CTRL |= CIM_CTRL_RXF_TRIG_##n;		\
+} while (0)
+#define __cim_enable_fast_mode() 	( REG_CIM_CTRL |= CIM_CTRL_FAST_MODE )
+#define __cim_disable_fast_mode() 	( REG_CIM_CTRL &= ~CIM_CTRL_FAST_MODE )
+#define __cim_use_normal_mode() 	__cim_disable_fast_mode()
+#define __cim_enable_dma()   ( REG_CIM_CTRL |= CIM_CTRL_DMA_EN )
+#define __cim_disable_dma()  ( REG_CIM_CTRL &= ~CIM_CTRL_DMA_EN )
+#define __cim_reset_rxfifo() ( REG_CIM_CTRL |= CIM_CTRL_RXF_RST )
+#define __cim_unreset_rxfifo() ( REG_CIM_CTRL &= ~CIM_CTRL_RXF_RST )
+
+#define __cim_clear_state()   	     ( REG_CIM_STATE = 0 )
+
+#define __cim_disable_done()   	     ( REG_CIM_STATE & CIM_STATE_VDD )
+#define __cim_rxfifo_empty()   	     ( REG_CIM_STATE & CIM_STATE_RXF_EMPTY )
+#define __cim_rxfifo_reach_trigger() ( REG_CIM_STATE & CIM_STATE_RXF_TRIG )
+#define __cim_rxfifo_overflow()      ( REG_CIM_STATE & CIM_STATE_RXF_OF )
+#define __cim_clear_rxfifo_overflow() ( REG_CIM_STATE &= ~CIM_STATE_RXF_OF )
+#define __cim_dma_stop()   	     ( REG_CIM_STATE & CIM_STATE_DMA_STOP )
+#define __cim_dma_eof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_EOF )
+#define __cim_dma_sof()   	     ( REG_CIM_STATE & CIM_STATE_DMA_SOF )
+
+#define __cim_get_iid()   	     ( REG_CIM_IID )
+#define __cim_get_fid()   	     ( REG_CIM_FID )
+#define __cim_get_image_data()       ( REG_CIM_RXFIFO )
+#define __cim_get_dma_cmd()          ( REG_CIM_CMD )
+
+#define __cim_set_da(a)              ( REG_CIM_DA = (a) )
+
+#define __cim_set_line(a) 	( REG_CIM_SIZE = (REG_CIM_SIZE&(~CIM_SIZE_LPF_MASK))|((a)<<CIM_SIZE_LPF_BIT) )
+#define __cim_set_pixel(a) 	( REG_CIM_SIZE = (REG_CIM_SIZE&(~CIM_SIZE_PPL_MASK))|((a)<<CIM_SIZE_PPL_BIT) )
+#define __cim_get_line() 	((REG_CIM_SIZE&CIM_SIZE_LPF_MASK)>>CIM_SIZE_LPF_BIT)
+#define __cim_get_pixel() 	((REG_CIM_SIZE&CIM_SIZE_PPL_MASK)>>CIM_SIZE_PPL_BIT)
+
+#define __cim_set_v_offset(a) 	( REG_CIM_OFFSET = (REG_CIM_OFFSET&(~CIM_OFFSET_V_MASK)) | ((a)<<CIM_OFFSET_V_BIT) )
+#define __cim_set_h_offset(a) 	( REG_CIM_OFFSET = (REG_CIM_OFFSET&(~CIM_OFFSET_H_MASK)) | ((a)<<CIM_OFFSET_H_BIT) )
+#define __cim_get_v_offset() 	((REG_CIM_OFFSET&CIM_OFFSET_V_MASK)>>CIM_OFFSET_V_BIT)
+#define __cim_get_h_offset() 	((REG_CIM_OFFSET&CIM_OFFSET_H_MASK)>>CIM_OFFSET_H_BIT)
+
+/*************************************************************************
+ * SLCD (Smart LCD Controller)
+ *************************************************************************/
+#define __slcd_set_data_18bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_18BIT )
+#define __slcd_set_data_16bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_16BIT )
+#define __slcd_set_data_8bit_x3() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_8BIT_x3 )
+#define __slcd_set_data_8bit_x2() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_8BIT_x2 )
+#define __slcd_set_data_8bit_x1() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_8BIT_x1 )
+#define __slcd_set_data_24bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_24BIT )
+#define __slcd_set_data_9bit_x2() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_DWIDTH_MASK) | SLCD_CFG_DWIDTH_9BIT_x2 )
+
+#define __slcd_set_cmd_16bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_CWIDTH_MASK) | SLCD_CFG_CWIDTH_16BIT )
+#define __slcd_set_cmd_8bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_CWIDTH_MASK) | SLCD_CFG_CWIDTH_8BIT )
+#define __slcd_set_cmd_18bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_CWIDTH_MASK) | SLCD_CFG_CWIDTH_18BIT )
+#define __slcd_set_cmd_24bit() \
+  ( REG_SLCD_CFG = (REG_SLCD_CFG & ~SLCD_CFG_CWIDTH_MASK) | SLCD_CFG_CWIDTH_24BIT )
+
+#define __slcd_set_cs_high()        ( REG_SLCD_CFG |= SLCD_CFG_CS_ACTIVE_HIGH )
+#define __slcd_set_cs_low()         ( REG_SLCD_CFG &= ~SLCD_CFG_CS_ACTIVE_HIGH )
+
+#define __slcd_set_rs_high()        ( REG_SLCD_CFG |= SLCD_CFG_RS_CMD_HIGH )
+#define __slcd_set_rs_low()         ( REG_SLCD_CFG &= ~SLCD_CFG_RS_CMD_HIGH )
+
+#define __slcd_set_clk_falling()    ( REG_SLCD_CFG &= ~SLCD_CFG_CLK_ACTIVE_RISING )
+#define __slcd_set_clk_rising()     ( REG_SLCD_CFG |= SLCD_CFG_CLK_ACTIVE_RISING )
+
+#define __slcd_set_parallel_type()  ( REG_SLCD_CFG &= ~SLCD_CFG_TYPE_SERIAL )
+#define __slcd_set_serial_type()    ( REG_SLCD_CFG |= SLCD_CFG_TYPE_SERIAL )
+
+/* SLCD Control Register */
+#define __slcd_enable_dma()         ( REG_SLCD_CTRL |= SLCD_CTRL_DMA_EN )
+#define __slcd_disable_dma()        ( REG_SLCD_CTRL &= ~SLCD_CTRL_DMA_EN )
+
+/* SLCD Status Register */
+#define __slcd_is_busy()            ( REG_SLCD_STATE & SLCD_STATE_BUSY )
+
+/* SLCD Data Register */
+#define __slcd_set_cmd_rs()         ( REG_SLCD_DATA |= SLCD_DATA_RS_COMMAND)
+#define __slcd_set_data_rs()        ( REG_SLCD_DATA &= ~SLCD_DATA_RS_COMMAND)
+
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+
+/***************************************************************************
+ * LCD
+ ***************************************************************************/
+#define __lcd_as_smart_lcd() 		( REG_LCD_CFG |= ( LCD_CFG_LCDPIN_SLCD | LCD_CFG_MODE_SLCD))
+#define __lcd_as_general_lcd() 		( REG_LCD_CFG &= ~( LCD_CFG_LCDPIN_SLCD | LCD_CFG_MODE_SLCD))
+
+#define __lcd_enable_tvepeh() 		( REG_LCD_CFG |= LCD_CFG_TVEPEH )
+#define __lcd_disable_tvepeh() 		( REG_LCD_CFG &= ~LCD_CFG_TVEPEH )
+
+#define __lcd_enable_fuhold() 		( REG_LCD_CFG |= LCD_CFG_FUHOLD )
+#define __lcd_disable_fuhold() 		( REG_LCD_CFG &= ~LCD_CFG_FUHOLD )
+
+#define __lcd_des_8word() 		( REG_LCD_CFG |= LCD_CFG_NEWDES )
+#define __lcd_des_4word() 		( REG_LCD_CFG &= ~LCD_CFG_NEWDES )
+
+#define __lcd_enable_bypass_pal() 	( REG_LCD_CFG |= LCD_CFG_PALBP )
+#define __lcd_disable_bypass_pal() 	( REG_LCD_CFG &= ~LCD_CFG_PALBP )
+
+#define __lcd_set_lcdpnl_term()		( REG_LCD_CTRL |= LCD_CFG_TVEN )
+#define __lcd_set_tv_term()		( REG_LCD_CTRL &= ~LCD_CFG_TVEN )
+
+#define __lcd_enable_auto_recover() 	( REG_LCD_CFG |= LCD_CFG_RECOVER )
+#define __lcd_disable_auto_recover() 	( REG_LCD_CFG &= ~LCD_CFG_RECOVER )
+
+#define __lcd_enable_dither() 	        ( REG_LCD_CFG |= LCD_CFG_DITHER )
+#define __lcd_disable_dither() 	        ( REG_LCD_CFG &= ~LCD_CFG_DITHER )
+
+#define __lcd_disable_ps_mode()	        ( REG_LCD_CFG |= LCD_CFG_PSM )
+#define __lcd_enable_ps_mode()	        ( REG_LCD_CFG &= ~LCD_CFG_PSM )
+
+#define __lcd_disable_cls_mode() 	( REG_LCD_CFG |= LCD_CFG_CLSM )
+#define __lcd_enable_cls_mode()	        ( REG_LCD_CFG &= ~LCD_CFG_CLSM )
+
+#define __lcd_disable_spl_mode() 	( REG_LCD_CFG |= LCD_CFG_SPLM )
+#define __lcd_enable_spl_mode()	        ( REG_LCD_CFG &= ~LCD_CFG_SPLM )
+
+#define __lcd_disable_rev_mode() 	( REG_LCD_CFG |= LCD_CFG_REVM )
+#define __lcd_enable_rev_mode()	        ( REG_LCD_CFG &= ~LCD_CFG_REVM )
+
+#define __lcd_disable_hsync_mode() 	( REG_LCD_CFG |= LCD_CFG_HSYNM )
+#define __lcd_enable_hsync_mode()	( REG_LCD_CFG &= ~LCD_CFG_HSYNM )
+
+#define __lcd_disable_pclk_mode() 	( REG_LCD_CFG |= LCD_CFG_PCLKM )
+#define __lcd_enable_pclk_mode()	( REG_LCD_CFG &= ~LCD_CFG_PCLKM )
+
+#define __lcd_normal_outdata()          ( REG_LCD_CFG &= ~LCD_CFG_INVDAT )
+#define __lcd_inverse_outdata()         ( REG_LCD_CFG |= LCD_CFG_INVDAT )
+
+#define __lcd_sync_input()              ( REG_LCD_CFG |= LCD_CFG_SYNDIR_IN )
+#define __lcd_sync_output()             ( REG_LCD_CFG &= ~LCD_CFG_SYNDIR_IN )
+
+#define __lcd_hsync_active_high()       ( REG_LCD_CFG &= ~LCD_CFG_HSP )
+#define __lcd_hsync_active_low()        ( REG_LCD_CFG |= LCD_CFG_HSP )
+
+#define __lcd_pclk_rising()             ( REG_LCD_CFG &= ~LCD_CFG_PCP )
+#define __lcd_pclk_falling()            ( REG_LCD_CFG |= LCD_CFG_PCP )
+
+#define __lcd_de_active_high()          ( REG_LCD_CFG &= ~LCD_CFG_DEP )
+#define __lcd_de_active_low()           ( REG_LCD_CFG |= LCD_CFG_DEP )
+
+#define __lcd_vsync_rising()            ( REG_LCD_CFG &= ~LCD_CFG_VSP )
+#define __lcd_vsync_falling()           ( REG_LCD_CFG |= LCD_CFG_VSP )
+
+#define __lcd_set_16_tftpnl() \
+  ( REG_LCD_CFG = (REG_LCD_CFG & ~LCD_CFG_MODE_TFT_MASK) | LCD_CFG_MODE_TFT_16BIT )
+
+#define __lcd_set_18_tftpnl() \
+  ( REG_LCD_CFG = (REG_LCD_CFG & ~LCD_CFG_MODE_TFT_MASK) | LCD_CFG_MODE_TFT_18BIT )
+
+#define __lcd_set_24_tftpnl()		( REG_LCD_CFG |= LCD_CFG_MODE_TFT_24BIT )
+
+/* 
+ * n=1,2,4,8 for single mono-STN 
+ * n=4,8 for dual mono-STN
+ */
+#define __lcd_set_panel_datawidth(n) 		\
+do { 						\
+	REG_LCD_CFG &= ~LCD_CFG_PDW_MASK; 	\
+	REG_LCD_CFG |= LCD_CFG_PDW_n##;		\
+} while (0)
+
+/* m = LCD_CFG_MODE_GENERUIC_TFT_xxx */
+#define __lcd_set_panel_mode(m) 		\
+do {						\
+	REG_LCD_CFG &= ~LCD_CFG_MODE_MASK;	\
+	REG_LCD_CFG |= (m);			\
+} while(0)
+
+/* n=4,8,16 */
+#define __lcd_set_burst_length(n) 		\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_BST_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_BST_n##;	\
+} while (0)
+
+#define __lcd_select_rgb565()		( REG_LCD_CTRL &= ~LCD_CTRL_RGB555 )
+#define __lcd_select_rgb555()		( REG_LCD_CTRL |= LCD_CTRL_RGB555 )
+
+#define __lcd_set_ofup()		( REG_LCD_CTRL |= LCD_CTRL_OFUP )
+#define __lcd_clr_ofup()		( REG_LCD_CTRL &= ~LCD_CTRL_OFUP )
+
+/* n=2,4,16 */
+#define __lcd_set_stn_frc(n) 			\
+do {						\
+	REG_LCD_CTRL &= ~LCD_CTRL_FRC_MASK;	\
+	REG_LCD_CTRL |= LCD_CTRL_FRC_n##;	\
+} while (0)
+
+#define __lcd_enable_eof_intr()		( REG_LCD_CTRL |= LCD_CTRL_EOFM )
+#define __lcd_disable_eof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_EOFM )
+
+#define __lcd_enable_sof_intr()		( REG_LCD_CTRL |= LCD_CTRL_SOFM )
+#define __lcd_disable_sof_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_SOFM )
+
+#define __lcd_enable_ofu_intr()		( REG_LCD_CTRL |= LCD_CTRL_OFUM )
+#define __lcd_disable_ofu_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_OFUM )
+
+#define __lcd_enable_ifu0_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM0 )
+#define __lcd_disable_ifu0_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM0 )
+
+#define __lcd_enable_ifu1_intr()	( REG_LCD_CTRL |= LCD_CTRL_IFUM1 )
+#define __lcd_disable_ifu1_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_IFUM1 )
+
+#define __lcd_enable_ldd_intr()		( REG_LCD_CTRL |= LCD_CTRL_LDDM )
+#define __lcd_disable_ldd_intr()	( REG_LCD_CTRL &= ~LCD_CTRL_LDDM )
+
+#define __lcd_enable_qd_intr()		( REG_LCD_CTRL |= LCD_CTRL_QDM )
+#define __lcd_disable_qd_intr()		( REG_LCD_CTRL &= ~LCD_CTRL_QDM )
+
+#define __lcd_reverse_byte_endian()	( REG_LCD_CTRL |= LCD_CTRL_BEDN )
+#define __lcd_normal_byte_endian()	( REG_LCD_CTRL &= ~LCD_CTRL_BEDN )
+
+#define __lcd_pixel_endian_little()	( REG_LCD_CTRL |= LCD_CTRL_PEDN )
+#define __lcd_pixel_endian_big()	( REG_LCD_CTRL &= ~LCD_CTRL_PEDN )
+
+#define __lcd_set_dis()			( REG_LCD_CTRL |= LCD_CTRL_DIS )
+#define __lcd_clr_dis()			( REG_LCD_CTRL &= ~LCD_CTRL_DIS )
+
+#define __lcd_set_ena()			( REG_LCD_CTRL |= LCD_CTRL_ENA )
+#define __lcd_clr_ena()			( REG_LCD_CTRL &= ~LCD_CTRL_ENA )
+
+/* n=1,2,4,8,16 */
+#define __lcd_set_bpp(n) \
+  ( REG_LCD_CTRL = (REG_LCD_CTRL & ~LCD_CTRL_BPP_MASK) | LCD_CTRL_BPP_##n )
+
+/* LCD status register indication */
+
+#define __lcd_quick_disable_done()	( REG_LCD_STATE & LCD_STATE_QD )
+#define __lcd_disable_done()		( REG_LCD_STATE & LCD_STATE_LDD )
+#define __lcd_infifo0_underrun()	( REG_LCD_STATE & LCD_STATE_IFU0 )
+#define __lcd_infifo1_underrun()	( REG_LCD_STATE & LCD_STATE_IFU1 )
+#define __lcd_outfifo_underrun()	( REG_LCD_STATE & LCD_STATE_OFU )
+#define __lcd_start_of_frame()		( REG_LCD_STATE & LCD_STATE_SOF )
+#define __lcd_end_of_frame()		( REG_LCD_STATE & LCD_STATE_EOF )
+
+#define __lcd_clr_outfifounderrun()	( REG_LCD_STATE &= ~LCD_STATE_OFU )
+#define __lcd_clr_sof()			( REG_LCD_STATE &= ~LCD_STATE_SOF )
+#define __lcd_clr_eof()			( REG_LCD_STATE &= ~LCD_STATE_EOF )
+
+/* OSD functions */
+#define __lcd_enable_osd() 	(REG_LCD_OSDC |= LCD_OSDC_OSDEN)
+#define __lcd_enable_f0() 	(REG_LCD_OSDC |= LCD_OSDC_F0EN)
+#define __lcd_enable_f1()	(REG_LCD_OSDC |= LCD_OSDC_F1EN)
+#define __lcd_enable_alpha() 	(REG_LCD_OSDC |= LCD_OSDC_ALPHAEN)
+#define __lcd_enable_alphamd()	(REG_LCD_OSDC |= LCD_OSDC_ALPHAMD)
+
+#define __lcd_disable_osd()	(REG_LCD_OSDC &= ~LCD_OSDC_OSDEN)
+#define __lcd_disable_f0() 	(REG_LCD_OSDC &= ~LCD_OSDC_F0EN)
+#define __lcd_disable_f1() 	(REG_LCD_OSDC &= ~LCD_OSDC_F1EN)
+#define __lcd_disable_alpha()	(REG_LCD_OSDC &= ~LCD_OSDC_ALPHAEN)
+#define __lcd_disable_alphamd()	(REG_LCD_OSDC &= ~LCD_OSDC_ALPHAMD)
+
+/* OSD Controll Register */
+#define __lcd_fg1_use_ipu() 		(REG_LCD_OSDCTRL |= LCD_OSDCTRL_IPU)
+#define __lcd_fg1_use_dma_chan1() 	(REG_LCD_OSDCTRL &= ~LCD_OSDCTRL_IPU)
+#define __lcd_fg1_unuse_ipu() 		__lcd_fg1_use_dma_chan1()
+#define __lcd_osd_rgb555_mode()         ( REG_LCD_OSDCTRL |= LCD_OSDCTRL_RGB555 )
+#define __lcd_osd_rgb565_mode()         ( REG_LCD_OSDCTRL &= ~LCD_OSDCTRL_RGB555 )
+#define __lcd_osd_change_size()         ( REG_LCD_OSDCTRL |= LCD_OSDCTRL_CHANGES )
+#define __lcd_osd_bpp_15_16() \
+  ( REG_LCD_OSDCTRL = (REG_LCD_OSDCTRL & ~LCD_OSDCTRL_OSDBPP_MASK) | LCD_OSDCTRL_OSDBPP_15_16 )
+#define __lcd_osd_bpp_18_24() \
+  ( REG_LCD_OSDCTRL = (REG_LCD_OSDCTRL & ~LCD_OSDCTRL_OSDBPP_MASK) | LCD_OSDCTRL_OSDBPP_18_24 )
+
+/* OSD State Register */
+#define __lcd_start_of_fg1()		( REG_LCD_STATE & LCD_OSDS_SOF1 )
+#define __lcd_end_of_fg1()		( REG_LCD_STATE & LCD_OSDS_EOF1 )
+#define __lcd_start_of_fg0()		( REG_LCD_STATE & LCD_OSDS_SOF0 )
+#define __lcd_end_of_fg0()		( REG_LCD_STATE & LCD_OSDS_EOF0 )
+#define __lcd_change_is_rdy()		( REG_LCD_STATE & LCD_OSDS_READY )
+
+/* Foreground Color Key Register 0,1(foreground 0, foreground 1) */
+#define __lcd_enable_colorkey0()	(REG_LCD_KEY0 |= LCD_KEY_KEYEN)
+#define __lcd_enable_colorkey1()	(REG_LCD_KEY1 |= LCD_KEY_KEYEN)
+#define __lcd_enable_colorkey0_md() 	(REG_LCD_KEY0 |= LCD_KEY_KEYMD)
+#define __lcd_enable_colorkey1_md() 	(REG_LCD_KEY1 |= LCD_KEY_KEYMD)
+#define __lcd_set_colorkey0(key) 	(REG_LCD_KEY0 = (REG_LCD_KEY0&~0xFFFFFF)|(key))
+#define __lcd_set_colorkey1(key) 	(REG_LCD_KEY1 = (REG_LCD_KEY1&~0xFFFFFF)|(key))
+
+#define __lcd_disable_colorkey0() 	(REG_LCD_KEY0 &= ~LCD_KEY_KEYEN)
+#define __lcd_disable_colorkey1() 	(REG_LCD_KEY1 &= ~LCD_KEY_KEYEN)
+#define __lcd_disable_colorkey0_md() 	(REG_LCD_KEY0 &= ~LCD_KEY_KEYMD)
+#define __lcd_disable_colorkey1_md() 	(REG_LCD_KEY1 &= ~LCD_KEY_KEYMD)
+
+/* IPU Restart Register */
+#define __lcd_enable_ipu_restart() 	(REG_LCD_IPUR |= LCD_IPUR_IPUREN)
+#define __lcd_disable_ipu_restart() 	(REG_LCD_IPUR &= ~LCD_IPUR_IPUREN)
+#define __lcd_set_ipu_restart_triger(n)	(REG_LCD_IPUR = (REG_LCD_IPUR&(~0xFFFFFF))|(n))
+
+/* RGB Control Register */
+#define __lcd_enable_rgb_dummy() 	(REG_LCD_RGBC |= LCD_RGBC_RGBDM)
+#define __lcd_disable_rgb_dummy() 	(REG_LCD_RGBC &= ~LCD_RGBC_RGBDM)
+
+#define __lcd_dummy_rgb() 	(REG_LCD_RGBC |= LCD_RGBC_DMM)
+#define __lcd_rgb_dummy() 	(REG_LCD_RGBC &= ~LCD_RGBC_DMM)
+
+#define __lcd_rgb2ycc() 	(REG_LCD_RGBC |= LCD_RGBC_YCC)
+#define __lcd_notrgb2ycc() 	(REG_LCD_RGBC &= ~LCD_RGBC_YCC)
+
+#define __lcd_odd_mode_rgb() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_RGB )
+#define __lcd_odd_mode_rbg() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_RBG )
+#define __lcd_odd_mode_grb() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_GRB)
+
+#define __lcd_odd_mode_gbr() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_GBR)
+#define __lcd_odd_mode_brg() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_BRG)
+#define __lcd_odd_mode_bgr() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_ODDRGB_MASK) | LCD_RGBC_ODD_BGR)
+
+#define __lcd_even_mode_rgb() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_RGB )
+#define __lcd_even_mode_rbg() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_RBG )
+#define __lcd_even_mode_grb() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_GRB)
+
+#define __lcd_even_mode_gbr() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_GBR)
+#define __lcd_even_mode_brg() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_BRG)
+#define __lcd_even_mode_bgr() \
+  ( REG_LCD_RGBC = (REG_LCD_RGBC & ~LCD_RGBC_EVENRGB_MASK) | LCD_RGBC_EVEN_BGR)
+
+/* Vertical Synchronize Register */
+#define __lcd_vsync_get_vps() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPS_MASK) >> LCD_VSYNC_VPS_BIT )
+
+#define __lcd_vsync_get_vpe() \
+  ( (REG_LCD_VSYNC & LCD_VSYNC_VPE_MASK) >> LCD_VSYNC_VPE_BIT )
+#define __lcd_vsync_set_vpe(n) 				\
+do {							\
+	REG_LCD_VSYNC &= ~LCD_VSYNC_VPE_MASK;		\
+	REG_LCD_VSYNC |= (n) << LCD_VSYNC_VPE_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hps() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPS_MASK) >> LCD_HSYNC_HPS_BIT )
+#define __lcd_hsync_set_hps(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPS_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPS_BIT;	\
+} while (0)
+
+#define __lcd_hsync_get_hpe() \
+  ( (REG_LCD_HSYNC & LCD_HSYNC_HPE_MASK) >> LCD_VSYNC_HPE_BIT )
+#define __lcd_hsync_set_hpe(n) 				\
+do {							\
+	REG_LCD_HSYNC &= ~LCD_HSYNC_HPE_MASK;		\
+	REG_LCD_HSYNC |= (n) << LCD_HSYNC_HPE_BIT;	\
+} while (0)
+
+#define __lcd_vat_get_ht() \
+  ( (REG_LCD_VAT & LCD_VAT_HT_MASK) >> LCD_VAT_HT_BIT )
+#define __lcd_vat_set_ht(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_HT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_HT_BIT;		\
+} while (0)
+
+#define __lcd_vat_get_vt() \
+  ( (REG_LCD_VAT & LCD_VAT_VT_MASK) >> LCD_VAT_VT_BIT )
+#define __lcd_vat_set_vt(n) 				\
+do {							\
+	REG_LCD_VAT &= ~LCD_VAT_VT_MASK;		\
+	REG_LCD_VAT |= (n) << LCD_VAT_VT_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hds() \
+  ( (REG_LCD_DAH & LCD_DAH_HDS_MASK) >> LCD_DAH_HDS_BIT )
+#define __lcd_dah_set_hds(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDS_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDS_BIT;		\
+} while (0)
+
+#define __lcd_dah_get_hde() \
+  ( (REG_LCD_DAH & LCD_DAH_HDE_MASK) >> LCD_DAH_HDE_BIT )
+#define __lcd_dah_set_hde(n) 				\
+do {							\
+	REG_LCD_DAH &= ~LCD_DAH_HDE_MASK;		\
+	REG_LCD_DAH |= (n) << LCD_DAH_HDE_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vds() \
+  ( (REG_LCD_DAV & LCD_DAV_VDS_MASK) >> LCD_DAV_VDS_BIT )
+#define __lcd_dav_set_vds(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDS_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDS_BIT;		\
+} while (0)
+
+#define __lcd_dav_get_vde() \
+  ( (REG_LCD_DAV & LCD_DAV_VDE_MASK) >> LCD_DAV_VDE_BIT )
+#define __lcd_dav_set_vde(n) 				\
+do {							\
+	REG_LCD_DAV &= ~LCD_DAV_VDE_MASK;		\
+	REG_LCD_DAV |= (n) << LCD_DAV_VDE_BIT;		\
+} while (0)
+
+/* DMA Command Register */
+#define __lcd_cmd0_set_sofint()		( REG_LCD_CMD0 |= LCD_CMD_SOFINT )
+#define __lcd_cmd0_clr_sofint()		( REG_LCD_CMD0 &= ~LCD_CMD_SOFINT )
+#define __lcd_cmd1_set_sofint()		( REG_LCD_CMD1 |= LCD_CMD_SOFINT )
+#define __lcd_cmd1_clr_sofint()		( REG_LCD_CMD1 &= ~LCD_CMD_SOFINT )
+
+#define __lcd_cmd0_set_eofint()		( REG_LCD_CMD0 |= LCD_CMD_EOFINT )
+#define __lcd_cmd0_clr_eofint()		( REG_LCD_CMD0 &= ~LCD_CMD_EOFINT )
+#define __lcd_cmd1_set_eofint()		( REG_LCD_CMD1 |= LCD_CMD_EOFINT )
+#define __lcd_cmd1_clr_eofint()		( REG_LCD_CMD1 &= ~LCD_CMD_EOFINT )
+
+#define __lcd_cmd0_set_pal()		( REG_LCD_CMD0 |= LCD_CMD_PAL )
+#define __lcd_cmd0_clr_pal()		( REG_LCD_CMD0 &= ~LCD_CMD_PAL )
+
+#define __lcd_cmd0_get_len() \
+  ( (REG_LCD_CMD0 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+#define __lcd_cmd1_get_len() \
+  ( (REG_LCD_CMD1 & LCD_CMD_LEN_MASK) >> LCD_CMD_LEN_BIT )
+
+/*************************************************************************
+ * TVE (TV Encoder Controller) ops
+ *************************************************************************/
+/* TV Encoder Control register ops */
+#define __tve_soft_reset()		(REG_TVE_CTRL |= TVE_CTRL_SWRST)
+
+#define __tve_output_colorbar()		(REG_TVE_CTRL |= TVE_CTRL_CLBAR)
+#define __tve_output_video()		(REG_TVE_CTRL &= ~TVE_CTRL_CLBAR)
+
+#define __tve_input_cr_first()		(REG_TVE_CTRL |= TVE_CTRL_CR1ST)
+#define __tve_input_cb_first()		(REG_TVE_CTRL &= ~TVE_CTRL_CR1ST)
+
+#define __tve_set_0_as_black()		(REG_TVE_CTRL |= TVE_CTRL_ZBLACK)
+#define __tve_set_16_as_black()		(REG_TVE_CTRL &= ~TVE_CTRL_ZBLACK)
+
+#define __tve_ena_invert_top_bottom()	(REG_TVE_CTRL |= TVE_CTRL_FINV)
+#define __tve_dis_invert_top_bottom()	(REG_TVE_CTRL &= ~TVE_CTRL_FINV)
+
+#define __tve_set_pal_mode()		(REG_TVE_CTRL |= TVE_CTRL_PAL)
+#define __tve_set_ntsc_mode()		(REG_TVE_CTRL &= ~TVE_CTRL_PAL)
+
+#define __tve_set_pal_dura()		(REG_TVE_CTRL |= TVE_CTRL_SYNCT)
+#define __tve_set_ntsc_dura()		(REG_TVE_CTRL &= ~TVE_CTRL_SYNCT)
+
+/* n = 0 ~ 3 */
+#define __tve_set_c_bandwidth(n) \
+do {\
+	REG_TVE_CTRL &= ~TVE_CTRL_CBW_MASK;\
+	REG_TVE_CTRL |= (n) << TVE_CTRL_CBW_BIT;	\
+}while(0)
+
+/* n = 0 ~ 3 */
+#define __tve_set_c_gain(n) \
+do {\
+	REG_TVE_CTRL &= ~TVE_CTRL_CGAIN_MASK;\
+	(REG_TVE_CTRL |= (n) << TVE_CTRL_CGAIN_BIT;	\
+}while(0)
+
+/* n = 0 ~ 7 */
+#define __tve_set_yc_delay(n)				\
+do {							\
+	REG_TVE_CTRL &= ~TVE_CTRL_YCDLY_MASK		\
+	REG_TVE_CTRL |= ((n) << TVE_CTRL_YCDLY_BIT);	\
+} while(0)
+
+#define __tve_disable_all_dacs()	(REG_TVE_CTRL |= TVE_CTRL_DAPD)
+#define __tve_disable_dac1()		(REG_TVE_CTRL |= TVE_CTRL_DAPD1)
+#define __tve_enable_dac1()		(REG_TVE_CTRL &= ~TVE_CTRL_DAPD1)
+#define __tve_disable_dac2()		(REG_TVE_CTRL |= TVE_CTRL_DAPD2)
+#define __tve_enable_dac2()		(REG_TVE_CTRL &= ~TVE_CTRL_DAPD2)
+#define __tve_disable_dac3()		(REG_TVE_CTRL |= TVE_CTRL_DAPD3)
+#define __tve_enable_dac3()		(REG_TVE_CTRL &= ~TVE_CTRL_DAPD3)
+
+#define __tve_enable_svideo_fmt()	(REG_TVE_CTRL |= TVE_CTRL_ECVBS)
+#define __tve_enable_cvbs_fmt()		(REG_TVE_CTRL &= ~TVE_CTRL_ECVBS)
+
+/* TV Encoder Frame Configure register ops */
+/* n = 0 ~ 255 */
+#define __tve_set_first_video_line(n)		\
+do {\
+		REG_TVE_FRCFG &= ~TVE_FRCFG_L1ST_MASK;\
+		REG_TVE_FRCFG |= (n) << TVE_FRCFG_L1ST_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_line_num_per_frm(n)		\
+do {\
+		REG_TVE_FRCFG &= ~TVE_FRCFG_NLINE_MASK;\
+		REG_TVE_CFG |= (n) << TVE_FRCFG_NLINE_BIT;\
+} while(0)
+#define __tve_get_video_line_num()\
+	(((REG_TVE_FRCFG & TVE_FRCFG_NLINE_MASK) >> TVE_FRCFG_NLINE_BIT) - 1 - 2 * ((REG_TVE_FRCFG & TVE_FRCFG_L1ST_MASK) >> TVE_FRCFG_L1ST_BIT))
+
+/* TV Encoder Signal Level Configure register ops */
+/* n = 0 ~ 1023 */
+#define __tve_set_white_level(n)		\
+do {\
+		REG_TVE_SLCFG1 &= ~TVE_SLCFG1_WHITEL_MASK;\
+		REG_TVE_SLCFG1 |= (n) << TVE_SLCFG1_WHITEL_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_black_level(n)		\
+do {\
+		REG_TVE_SLCFG1 &= ~TVE_SLCFG1_BLACKL_MASK;\
+		REG_TVE_SLCFG1 |= (n) << TVE_SLCFG1_BLACKL_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_blank_level(n)		\
+do {\
+		REG_TVE_SLCFG2 &= ~TVE_SLCFG2_BLANKL_MASK;\
+		REG_TVE_SLCFG2 |= (n) << TVE_SLCFG2_BLANKL_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_vbi_blank_level(n)		\
+do {\
+		REG_TVE_SLCFG2 &= ~TVE_SLCFG2_VBLANKL_MASK;\
+		REG_TVE_SLCFG2 |= (n) << TVE_SLCFG2_VBLANKL_BIT;\
+} while(0)
+/* n = 0 ~ 1023 */
+#define __tve_set_sync_level(n)		\
+do {\
+		REG_TVE_SLCFG3 &= ~TVE_SLCFG3_SYNCL_MASK;\
+		REG_TVE_SLCFG3 |= (n) << TVE_SLCFG3_SYNCL_BIT;\
+} while(0)
+
+/* TV Encoder Signal Level Configure register ops */
+/* n = 0 ~ 31 */
+#define __tve_set_front_porch(n)		\
+do {\
+		REG_TVE_LTCFG1 &= ~TVE_LTCFG1_FRONTP_MASK;\
+		REG_TVE_LTCFG1 |= (n) << TVE_LTCFG1_FRONTP_BIT;	\
+} while(0)
+/* n = 0 ~ 127 */
+#define __tve_set_hsync_width(n)		\
+do {\
+		REG_TVE_LTCFG1 &= ~TVE_LTCFG1_HSYNCW_MASK;\
+		REG_TVE_LTCFG1 |= (n) << TVE_LTCFG1_HSYNCW_BIT;	\
+} while(0)
+/* n = 0 ~ 127 */
+#define __tve_set_back_porch(n)		\
+do {\
+		REG_TVE_LTCFG1 &= ~TVE_LTCFG1_BACKP_MASK;\
+		REG_TVE_LTCFG1 |= (n) << TVE_LTCFG1_BACKP_BIT;	\
+} while(0)
+/* n = 0 ~ 2047 */
+#define __tve_set_active_linec(n)		\
+do {\
+		REG_TVE_LTCFG2 &= ~TVE_LTCFG2_ACTLIN_MASK;\
+		REG_TVE_LTCFG2 |= (n) << TVE_LTCFG2_ACTLIN_BIT;	\
+} while(0)
+/* n = 0 ~ 31 */
+#define __tve_set_breezy_way(n)		\
+do {\
+		REG_TVE_LTCFG2 &= ~TVE_LTCFG2_PREBW_MASK;\
+		REG_TVE_LTCFG2 |= (n) << TVE_LTCFG2_PREBW_BIT;	\
+} while(0)
+
+/* n = 0 ~ 127 */
+#define __tve_set_burst_width(n)		\
+do {\
+		REG_TVE_LTCFG2 &= ~TVE_LTCFG2_BURSTW_MASK;\
+		REG_TVE_LTCFG2 |= (n) << TVE_LTCFG2_BURSTW_BIT;	\
+} while(0)
+
+/* TV Encoder Chrominance filter and Modulation register ops */
+/* n = 0 ~ (2^32-1) */
+#define __tve_set_c_sub_carrier_freq(n)  REG_TVE_CFREQ = (n)
+/* n = 0 ~ 255 */
+#define __tve_set_c_sub_carrier_init_phase(n) \
+do {   \
+	REG_TVE_CPHASE &= ~TVE_CPHASE_INITPH_MASK;	\
+	REG_TVE_CPHASE |= (n) << TVE_CPHASE_INITPH_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_c_sub_carrier_act_phase(n) \
+do {   \
+	REG_TVE_CPHASE &= ~TVE_CPHASE_ACTPH_MASK;	\
+	REG_TVE_CPHASE |= (n) << TVE_CPHASE_ACTPH_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_c_phase_rst_period(n) \
+do {   \
+	REG_TVE_CPHASE &= ~TVE_CPHASE_CCRSTP_MASK;	\
+	REG_TVE_CPHASE |= (n) << TVE_CPHASE_CCRSTP_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_cb_burst_amp(n) \
+do {   \
+	REG_TVE_CBCRCFG &= ~TVE_CBCRCFG_CBBA_MASK;	\
+	REG_TVE_CBCRCFG |= (n) << TVE_CBCRCFG_CBBA_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_cr_burst_amp(n) \
+do {   \
+	REG_TVE_CBCRCFG &= ~TVE_CBCRCFG_CRBA_MASK;	\
+	REG_TVE_CBCRCFG |= (n) << TVE_CBCRCFG_CRBA_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_cb_gain_amp(n) \
+do {   \
+	REG_TVE_CBCRCFG &= ~TVE_CBCRCFG_CBGAIN_MASK;	\
+	REG_TVE_CBCRCFG |= (n) << TVE_CBCRCFG_CBGAIN_BIT;	\
+} while(0)
+/* n = 0 ~ 255 */
+#define __tve_set_cr_gain_amp(n) \
+do {   \
+	REG_TVE_CBCRCFG &= ~TVE_CBCRCFG_CRGAIN_MASK;	\
+	REG_TVE_CBCRCFG |= (n) << TVE_CBCRCFG_CRGAIN_BIT;	\
+} while(0)
+
+/* TV Encoder Wide Screen Signal Control register ops */
+/* n = 0 ~ 7 */
+#define __tve_set_notch_freq(n) \
+do {   \
+	REG_TVE_WSSCR &= ~TVE_WSSCR_NCHFREQ_MASK;	\
+	REG_TVE_WSSCR |= (n) << TVE_WSSCR_NCHFREQ_BIT;	\
+} while(0)
+/* n = 0 ~ 7 */
+#define __tve_set_notch_width()	(REG_TVE_WSSCR |= TVE_WSSCR_NCHW_BIT)
+#define __tve_clear_notch_width()	(REG_TVE_WSSCR &= ~TVE_WSSCR_NCHW_BIT)
+#define __tve_enable_notch()		(REG_TVE_WSSCR |= TVE_WSSCR_ENCH_BIT)
+#define __tve_disable_notch()		(REG_TVE_WSSCR &= ~TVE_WSSCR_ENCH_BIT)
+/* n = 0 ~ 7 */
+#define __tve_set_wss_edge(n) \
+do {   \
+	REG_TVE_WSSCR &= ~TVE_WSSCR_WSSEDGE_MASK;	\
+	REG_TVE_WSSCR |= (n) << TVE_WSSCR_WSSEDGE_BIT;	\
+} while(0)
+#define __tve_set_wss_clkbyp()		(REG_TVE_WSSCR |= TVE_WSSCR_WSSCKBP_BIT)
+#define __tve_set_wss_type()		(REG_TVE_WSSCR |= TVE_WSSCR_WSSTP_BIT)
+#define __tve_enable_wssf1()		(REG_TVE_WSSCR |= TVE_WSSCR_EWSS1_BIT)
+#define __tve_enable_wssf0()		(REG_TVE_WSSCR |= TVE_WSSCR_EWSS0_BIT)
+
+/* TV Encoder Wide Screen Signal Configure register 1, 2 and 3 ops */
+/* n = 0 ~ 1023 */
+#define __tve_set_wss_level(n) \
+do {   \
+	REG_TVE_WSSCFG1 &= ~TVE_WSSCFG1_WSSL_MASK;	\
+	REG_TVE_WSSCFG1 |= (n) << TVE_WSSCFG1_WSSL_BIT;	\
+} while(0)
+/* n = 0 ~ 4095 */
+#define __tve_set_wss_freq(n) \
+do {   \
+	REG_TVE_WSSCFG1 &= ~TVE_WSSCFG1_WSSFREQ_MASK;	\
+	REG_TVE_WSSCFG1 |= (n) << TVE_WSSCFG1_WSSFREQ_BIT;	\
+} while(0)
+/* n = 0, 1; l = 0 ~ 255 */
+#define __tve_set_wss_line(n,v)			\
+do {   \
+	REG_TVE_WSSCFG##n &= ~TVE_WSSCFG_WSSLINE_MASK;	\
+	REG_TVE_WSSCFG##n |= (v) << TVE_WSSCFG_WSSLINE_BIT;	\
+} while(0)
+/* n = 0, 1; d = 0 ~ (2^20-1) */
+#define __tve_set_wss_data(n, v)			\
+do {   \
+	REG_TVE_WSSCFG##n &= ~TVE_WSSCFG_WSSLINE_MASK;	\
+	REG_TVE_WSSCFG##n |= (v) << TVE_WSSCFG_WSSLINE_BIT;	\
+} while(0)
+
+/***************************************************************************
+ * RTC ops
+ ***************************************************************************/
+
+#define __rtc_write_ready()  ( (REG_RTC_RCR & RTC_RCR_WRDY) >> RTC_RCR_WRDY_BIT )
+#define __rtc_enabled()        ( REG_RTC_RCR |= RTC_RCR_RTCE )
+#define __rtc_disabled()         ( REG_RTC_RCR &= ~RTC_RCR_RTCE )
+#define __rtc_enable_alarm()         ( REG_RTC_RCR |= RTC_RCR_AE )
+#define __rtc_disable_alarm()         ( REG_RTC_RCR &= ~RTC_RCR_AE )
+#define __rtc_enable_alarm_irq()         ( REG_RTC_RCR |= RTC_RCR_AIE )
+#define __rtc_disable_alarm_irq()         ( REG_RTC_RCR &= ~RTC_RCR_AIE )
+#define __rtc_enable_1Hz_irq()         ( REG_RTC_RCR |= RTC_RCR_1HZIE )
+#define __rtc_disable_1Hz_irq()         ( REG_RTC_RCR &= ~RTC_RCR_1HZIE )
+
+#define __rtc_get_1Hz_flag()           ( (REG_RTC_RCR >> RTC_RCR_1HZ_BIT) & 0x1 )
+#define __rtc_clear_1Hz_flag()           ( REG_RTC_RCR &= ~RTC_RCR_1HZ )
+#define __rtc_get_alarm_flag()           ( (REG_RTC_RCR >> RTC_RCR_AF_BIT) & 0x1 )
+#define __rtc_clear_alarm_flag()           ( REG_RTC_RCR &= ~RTC_RCR_AF )
+
+#define __rtc_get_second()   ( REG_RTC_RSR )
+#define __rtc_set_second(v)   ( REG_RTC_RSR = v )
+
+#define __rtc_get_alarm_second()   ( REG_RTC_RSAR )
+#define __rtc_set_alarm_second(v)   ( REG_RTC_RSAR = v )
+
+#define __rtc_RGR_is_locked()       ( (REG_RTC_RGR >> RTC_RGR_LOCK) )
+#define __rtc_lock_RGR()       ( REG_RTC_RGR |= RTC_RGR_LOCK )
+#define __rtc_unlock_RGR()       ( REG_RTC_RGR &= ~RTC_RGR_LOCK )
+#define __rtc_get_adjc_val()       ( (REG_RTC_RGR & RTC_RGR_ADJC_MASK) >> RTC_RGR_ADJC_BIT )
+#define __rtc_set_adjc_val(v)      \
+       ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_ADJC_MASK) | (v << RTC_RGR_ADJC_BIT) ))
+#define __rtc_get_nc1Hz_val()       ( (REG_RTC_RGR & RTC_RGR_NC1HZ_MASK) >> RTC_RGR_NC1HZ_BIT )
+#define __rtc_set_nc1Hz_val(v)      \
+       ( REG_RTC_RGR = ( (REG_RTC_RGR & ~RTC_RGR_NC1HZ_MASK) | (v << RTC_RGR_NC1HZ_BIT) ))
+
+#define __rtc_power_down()            ( REG_RTC_HCR |= RTC_HCR_PD )
+
+#define __rtc_get_hwfcr_val()         ( REG_RTC_HWFCR & RTC_HWFCR_MASK )
+#define __rtc_set_hwfcr_val(v)         ( REG_RTC_HWFCR = (v) & RTC_HWFCR_MASK )
+#define __rtc_get_hrcr_val()         ( REG_RTC_HRCR & RTC_HRCR_MASK )
+#define __rtc_set_hrcr_val(v)         ( REG_RTC_HRCR = (v) & RTC_HRCR_MASK )
+
+#define __rtc_enable_alarm_wakeup()        ( REG_RTC_HWCR |= RTC_HWCR_EALM )
+#define __rtc_disable_alarm_wakeup()        ( REG_RTC_HWCR &= ~RTC_HWCR_EALM )
+
+#define __rtc_status_hib_reset_occur()        ( (REG_RTC_HWRSR >> RTC_HWRSR_HR) & 0x1 )
+#define __rtc_status_ppr_reset_occur()        ( (REG_RTC_HWRSR >> RTC_HWRSR_PPR) & 0x1 )
+#define __rtc_status_wakeup_pin_waken_up()    ( (REG_RTC_HWRSR >> RTC_HWRSR_PIN) & 0x1 )
+#define __rtc_status_alarm_waken_up()        ( (REG_RTC_HWRSR >> RTC_HWRSR_ALM) & 0x1 )
+#define __rtc_clear_hib_stat_all()               ( REG_RTC_HWRSR = 0 )
+
+#define __rtc_get_scratch_pattern() 		(REG_RTC_HSPR)
+#define __rtc_set_scratch_pattern(n) 		(REG_RTC_HSPR = n )
+
+/*************************************************************************
+ * BCH
+ *************************************************************************/
+#define __ecc_encoding_4bit()                                   \
+do {				   		        	\
+	REG_BCH_CRS = BCH_CR_ENCE | BCH_CR_BRST | BCH_CR_BCHE;  \
+	REG_BCH_CRC = BCH_CR_BSEL8;				\
+} while(0)
+#define __ecc_decoding_4bit()                           \
+do {                                                    \
+	REG_BCH_CRS = BCH_CR_BRST | BCH_CR_BCHE;	\
+	REG_BCH_CRC = BCH_CR_ENCE | BCH_CR_BSEL8;	\
+} while(0)
+#define __ecc_encoding_8bit()                                                   \
+do {				   		                        	\
+	REG_BCH_CRS = BCH_CR_ENCE | BCH_CR_BRST | BCH_CR_BSEL8 | BCH_CR_BCHE;   \
+} while(0)
+#define __ecc_decoding_8bit()                                        \
+do {                                                                 \
+	REG_BCH_CRS = BCH_CR_BRST | BCH_CR_BSEL8 | BCH_CR_BCHE;	     \
+	REG_BCH_CRC = BCH_CR_ENCE;	                             \
+} while(0)
+#define __ecc_dma_enable()        ( REG_BCH_CRS = BCH_CR_DMAE )
+#define __ecc_disable()           ( REG_BCH_CRC = BCH_CR_BCHE )
+#define __ecc_encode_sync()       while (!(REG_BCH_INTS & BCH_INTS_ENCF))
+#define __ecc_decode_sync()       while (!(REG_BCH_INTS & BCH_INTS_DECF))
+#define __ecc_cnt_dec(n)                                             \
+do {                                                                 \
+        REG_BCH_CNT &= ~(BCH_CNT_DEC_MASK << BCH_CNT_DEC_BIT);       \
+        REG_BCH_CNT = (n) << BCH_CNT_DEC_BIT;                        \
+} while(0)
+#define __ecc_cnt_enc(n)                                             \
+do {                                                                 \
+        REG_BCH_CNT &= ~(BCH_CNT_ENC_MASK << BCH_CNT_ENC_BIT);       \
+        REG_BCH_CNT = (n) << BCH_CNT_ENC_BIT;                        \
+} while(0)
+
+/***************************************************************************
+ * OWI (one-wire bus)  ops
+ ***************************************************************************/
+
+/* OW control register ops */
+#define __owi_enable_all_interrupts()      ( REG_OWI_CTL = (OWI_CTL_EBYTE | OWI_CTL_EBIT | OWI_CTL_ERST) )
+#define __owi_disable_all_interrupts()     ( REG_OWI_CTL = 0 )
+
+#define __owi_enable_byte_interrupt()      ( REG_OWI_CTL |= OWI_CTL_EBYTE )
+#define __owi_disable_byte_interrupt()     ( REG_OWI_CTL &= ~OWI_CTL_EBYTE )
+#define __owi_enable_bit_interrupt()       ( REG_OWI_CTL |= OWI_CTL_EBIT )
+#define __owi_disable_bit_interrupt()      ( REG_OWI_CTL &= ~OWI_CTL_EBIT )
+#define __owi_enable_rst_interrupt()       ( REG_OWI_CTL |= OWI_CTL_ERST ) 
+#define __owi_disable_rst_interrupt()      ( REG_OWI_CTL &=~OWI_CTL_ERST )
+
+/* OW configure register ops */
+#define __owi_select_regular_mode()        ( REG_OWI_CFG &= ~OWI_CFG_MODE )
+#define __owi_select_overdrive_mode()      ( REG_OWI_CFG |= OWI_CFG_MODE )
+
+#define __owi_set_rddata()  ( REG_OWI_CFG |= OWI_CFG_RDDATA )
+#define __owi_clr_rddata()  ( REG_OWI_CFG &= ~OWI_CFG_RDDATA )
+#define __owi_get_rddata()  ( REG_OWI_CFG & OWI_CFG_RDDATA )
+
+#define __owi_set_wrdata()  ( REG_OWI_CFG |= OWI_CFG_WRDATA )
+#define __owi_clr_wrdata()  ( REG_OWI_CFG &= ~OWI_CFG_WRDATA )
+#define __owi_get_wrdata()  ( REG_OWI_CFG & OWI_CFG_WRDATA )
+
+#define __owi_get_rdst()    ( REG_OWI_CFG & OWI_CFG_RDST )
+
+#define __owi_set_wr1rd()   ( REG_OWI_CFG |= OWI_CFG_WR1RD )
+#define __owi_clr_wr1rd()   ( REG_OWI_CFG &= ~OWI_CFG_WR1RD )
+#define __owi_get_wr1rd()   ( REG_OWI_CFG & OWI_CFG_WR1RD )
+
+#define __owi_set_wr0()     ( REG_OWI_CFG |= OWI_CFG_WR0 )
+#define __owi_clr_wr0()     ( REG_OWI_CFG &= ~OWI_CFG_WR0 )
+#define __owi_get_wr0()     ( REG_OWI_CFG & OWI_CFG_WR0 )
+
+#define __owi_set_rst()     ( REG_OWI_CFG |= OWI_CFG_RST )
+#define __owi_clr_rst()     ( REG_OWI_CFG &= ~OWI_CFG_RST )
+#define __owi_get_rst()     ( REG_OWI_CFG & OWI_CFG_RST )
+
+#define __owi_enable_ow_ops()  ( REG_OWI_CFG |= OWI_CFG_ENA )
+#define __owi_disable_ow_ops() ( REG_OWI_CFG &= ~OWI_CFG_ENA )
+#define __owi_get_enable()     ( REG_OWI_CFG & OWI_CFG_ENA )
+
+#define __owi_wait_ops_rdy()                \
+	do {				    \
+		while(__owi_get_enable());  \
+		udelay(1);		    \
+	} while(0);
+
+/* OW status register ops */
+#define __owi_clr_sts()           ( REG_OWI_STS = 0 )
+#define __owi_get_sts_pst()       ( REG_OWI_STS & OWI_STS_PST )
+#define __owi_get_sts_byte_rdy()  ( REG_OWI_STS & OWI_STS_BYTE_RDY )
+#define __owi_get_sts_bit_rdy()   ( REG_OWI_STS & OWI_STS_BIT_RDY )
+#define __owi_get_sts_pst_rdy()   ( REG_OWI_STS & OWI_STS_PST_RDY )
+
+/*************************************************************************
+ * TSSI MPEG 2-TS slave interface operation
+ *************************************************************************/
+#define __tssi_enable()                       ( REG_TSSI_ENA |= TSSI_ENA_ENA )
+#define __tssi_disable()                      ( REG_TSSI_ENA &= ~TSSI_ENA_ENA )
+#define __tssi_soft_reset()                   ( REG_TSSI_ENA |= TSSI_ENA_SFT_RST )
+#define __tssi_dma_enable()                   ( REG_TSSI_ENA |= TSSI_ENA_DMA_EN )
+#define __tssi_dma_disable()                  ( REG_TSSI_ENA &= ~TSSI_ENA_DMA_EN )
+#define __tssi_filter_enable()                ( REG_TSSI_ENA |= TSSI_ENA_PID_EN )
+#define __tssi_filter_disable()               ( REG_TSSI_ENA &= ~TSSI_ENA_PID_EN )
+
+/* n = 4, 8, 16 */
+#define __tssi_set_tigger_num(n)			\
+	do {						\
+		REG_TSSI_CFG &= ~TSSI_CFG_TRIG_MASK;	\
+		REG_TSSI_CFG |= TSSI_CFG_TRIG_##n;	\
+	} while (0)
+
+#define __tssi_set_wd_1()                     ( REG_TSSI_CFG |= TSSI_CFG_END_WD )
+#define __tssi_set_wd_0()                     ( REG_TSSI_CFG &= ~TSSI_CFG_END_WD )
+
+#define __tssi_set_bt_1()                     ( REG_TSSI_CFG |= TSSI_CFG_END_BD )
+#define __tssi_set_bt_0()                     ( REG_TSSI_CFG &= ~TSSI_CFG_END_BD )
+
+#define __tssi_set_data_pola_high()           ( REG_TSSI_CFG |= TSSI_CFG_TSDI_H )
+#define __tssi_set_data_pola_low()            ( REG_TSSI_CFG &= ~TSSI_CFG_TSDI_H )
+
+#define __tssi_set_data_use_data0()           ( REG_TSSI_CFG |= TSSI_CFG_USE_0 )
+#define __tssi_set_data_use_data7()           ( REG_TSSI_CFG &= ~TSSI_CFG_USE_0 )
+
+#define __tssi_select_clk_fast()              ( REG_TSSI_CFG &= ~TSSI_CFG_TSCLK_CH )
+#define __tssi_select_clk_slow()              ( REG_TSSI_CFG |= TSSI_CFG_TSCLK_CH )
+
+#define __tssi_select_serail_mode()           ( REG_TSSI_CFG &= ~TSSI_CFG_PARAL )
+#define __tssi_select_paral_mode()            ( REG_TSSI_CFG |= TSSI_CFG_PARAL )
+
+#define __tssi_select_clk_nega_edge()         ( REG_TSSI_CFG &= ~TSSI_CFG_TSCLK_P )
+#define __tssi_select_clk_posi_edge()         ( REG_TSSI_CFG |= TSSI_CFG_TSCLK_P )
+
+#define __tssi_select_frm_act_high()          ( REG_TSSI_CFG |= TSSI_CFG_TSFRM_H )
+#define __tssi_select_frm_act_low()           ( REG_TSSI_CFG &= ~TSSI_CFG_TSFRM_H )
+
+#define __tssi_select_str_act_high()          ( REG_TSSI_CFG |= TSSI_CFG_TSSTR_H )
+#define __tssi_select_str_act_low()           ( REG_TSSI_CFG &= ~TSSI_CFG_TSSTR_H )
+
+#define __tssi_select_fail_act_high()         ( REG_TSSI_CFG |= TSSI_CFG_TSFAIL_H )
+#define __tssi_select_fail_act_low()          ( REG_TSSI_CFG &= ~TSSI_CFG_TSFAIL_H )
+
+#define __tssi_enable_ovrn_irq()              ( REG_TSSI_CTRL &= ~TSSI_CTRL_OVRNM )
+#define __tssi_disable_ovrn_irq()             ( REG_TSSI_CTRL |= TSSI_CTRL_OVRNM )
+
+#define __tssi_enable_trig_irq()              ( REG_TSSI_CTRL &= ~TSSI_CTRL_TRIGM )
+#define __tssi_disable_trig_irq()             ( REG_TSSI_CTRL |= TSSI_CTRL_TRIGM ) 
+
+#define __tssi_state_is_overrun()             ( REG_TSSI_STAT & TSSI_STAT_OVRN )
+#define __tssi_state_trigger_meet()           ( REG_TSSI_STAT & TSSI_STAT_TRIG )
+#define __tssi_clear_state()                  ( REG_TSSI_STAT = 0 ) /* write 0??? */
+#define __tssi_state_clear_overrun()          ( REG_TSSI_STAT = TSSI_STAT_OVRN )
+
+#define __tssi_enable_filte_pid0()            ( REG_TSSI_PEN |= TSSI_PEN_PID0 )
+#define __tssi_disable_filte_pid0()           ( REG_TSSI_PEN &= ~TSSI_PEN_PID0 )
+
+/* m = 0, ..., 15 */
+#define __tssi_enable_pid_filter(m)				\
+	do {							\
+		int n = (m);					\
+		if ( n>=0 && n <(TSSI_PID_MAX*2) ) {		\
+			if ( n >= TSSI_PID_MAX ) n += 8;	\
+			REG_TSSI_PEN |= ( 1 << n );		\
+		}						\
+	} while (0)
+
+/* m = 0, ..., 15 */
+#define __tssi_disable_pid_filter(m)				       \
+	do {							       \
+		int n = (m);					       \
+		if ( n>=0 && n <(TSSI_PID_MAX*2) ) {		       \
+			if ( n >= TSSI_PID_MAX ) n += 8;	       \
+			REG_TSSI_PEN &= ~( 1 << n );		       \
+		}						       \
+	} while (0)
+
+/* n = 0, ..., 7 */
+#define __tssi_set_pid0(n, pid0)					\
+	do {								\
+		REG_TSSI_PID(n) &= ~TSSI_PID_PID0_MASK;			\
+		REG_TSSI_PID(n) |= ((pid0)<<TSSI_PID_PID0_BIT)&TSSI_PID_PID0_MASK; \
+	}while (0)
+/* n = 0, ..., 7 */
+#define __tssi_set_pid1(n, pid1)					\
+	do {								\
+		REG_TSSI_PID(n) &= ~TSSI_PID_PID1_MASK;			\
+		REG_TSSI_PID(n) |= ((pid1)<<TSSI_PID_PID1_BIT)&TSSI_PID_PID1_MASK; \
+	}while (0)
+
+/* n = 0, ..., 15 */
+#define __tssi_set_pid(n, pid)						\
+	do {								\
+		if ( n>=0 && n < TSSI_PID_MAX*2) {			\
+			if ( n < TSSI_PID_MAX )				\
+				__tssi_set_pid0(n, pid);		\
+			else						\
+				__tssi_set_pid1(n-TSSI_PID_MAX, pid);	\
+		}							\
+	}while (0)
+
+
+#if 0
+/*************************************************************************
+ * IPU (Image Processing Unit)
+ *************************************************************************/
+#define u32 volatile unsigned long
+
+#define write_reg(reg, val)	\
+do {				\
+	*(u32 *)(reg) = (val);	\
+} while(0)
+
+#define read_reg(reg, off)	(*(u32 *)((reg)+(off)))
+
+
+#define set_ipu_fmt(rgb_888_out_fmt, rgb_out_oft, out_fmt, yuv_pkg_out, in_oft, in_fmt ) \
+({ write_reg( (IPU_V_BASE + REG_D_FMT), ((in_fmt) & IN_FMT_MSK)<<IN_FMT_SFT \
+| ((in_oft) & IN_OFT_MSK)<< IN_OFT_SFT \
+| ((out_fmt) & OUT_FMT_MSK)<<OUT_FMT_SFT \
+| ((yuv_pkg_out) & YUV_PKG_OUT_MSK ) << YUV_PKG_OUT_SFT \
+| ((rgb_888_out_fmt) & RGB888_FMT_MSK ) << RGB888_FMT_SFT \
+| ((rgb_out_oft) & RGB_OUT_OFT_MSK ) << RGB_OUT_OFT_SFT); \
+})
+#define set_y_addr(y_addr) \
+({ write_reg( (IPU_V_BASE + REG_Y_ADDR), y_addr); \
+})
+#define set_u_addr(u_addr) \
+({ write_reg( (IPU_V_BASE + REG_U_ADDR), u_addr); \
+})
+
+#define set_v_addr(v_addr) \
+({ write_reg( (IPU_V_BASE + REG_V_ADDR), v_addr); \
+})
+
+#define set_y_phy_t_addr(y_phy_t_addr) \
+({ write_reg( (IPU_V_BASE + REG_Y_PHY_T_ADDR), y_phy_t_addr); \
+})
+
+#define set_u_phy_t_addr(u_phy_t_addr) \
+({ write_reg( (IPU_V_BASE + REG_U_PHY_T_ADDR), u_phy_t_addr); \
+})
+
+#define set_v_phy_t_addr(v_phy_t_addr) \
+({ write_reg( (IPU_V_BASE + REG_V_PHY_T_ADDR), v_phy_t_addr); \
+})
+
+#define set_out_phy_t_addr(out_phy_t_addr) \
+({ write_reg( (IPU_V_BASE + REG_OUT_PHY_T_ADDR), out_phy_t_addr); \
+})
+
+#define set_inframe_gsize(width, height, y_stride, u_stride, v_stride) \
+({ write_reg( (IPU_V_BASE + REG_IN_FM_GS), ((width) & IN_FM_W_MSK)<<IN_FM_W_SFT \
+| ((height) & IN_FM_H_MSK)<<IN_FM_H_SFT); \
+ write_reg( (IPU_V_BASE + REG_Y_STRIDE), ((y_stride) & Y_S_MSK)<<Y_S_SFT); \
+ write_reg( (IPU_V_BASE + REG_UV_STRIDE), ((u_stride) & U_S_MSK)<<U_S_SFT \
+| ((v_stride) & V_S_MSK)<<V_S_SFT); \
+})
+#define set_out_addr(out_addr) \
+({ write_reg( (IPU_V_BASE + REG_OUT_ADDR), out_addr); \
+})
+#define set_outframe_gsize(width, height, o_stride) \
+({ write_reg( (IPU_V_BASE + REG_OUT_GS), ((width) & OUT_FM_W_MSK)<<OUT_FM_W_SFT \
+| ((height) & OUT_FM_H_MSK)<<OUT_FM_H_SFT); \
+ write_reg( (IPU_V_BASE + REG_OUT_STRIDE), ((o_stride) & OUT_S_MSK)<<OUT_S_SFT); \
+})
+#define set_rsz_lut_end(h_end, v_end) \
+({ write_reg( (IPU_V_BASE + REG_RSZ_COEF_INDEX), ((h_end) & HE_IDX_MSK)<<HE_IDX_SFT \
+| ((v_end) & VE_IDX_MSK)<<VE_IDX_SFT); \
+})
+#define set_csc_c0(c0_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_CO_COEF), ((c0_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_csc_c1(c1_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_C1_COEF), ((c1_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_csc_c2(c2_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_C2_COEF), ((c2_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_csc_c3(c3_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_C3_COEF), ((c3_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_csc_c4(c4_coeff) \
+({ write_reg( (IPU_V_BASE + REG_CSC_C4_COEF), ((c4_coeff) & CX_COEF_MSK)<<CX_COEF_SFT); \
+})
+#define set_hrsz_lut_coef(coef, in_n, out_n) \
+({ write_reg( (IPU_V_BASE + HRSZ_LUT_BASE ), ((coef) & W_COEF_MSK)<<W_COEF_SFT \
+| ((in_n) & IN_N_MSK)<<IN_N_SFT | ((out_n) & OUT_N_MSK)<<OUT_N_SFT); \
+})
+#define set_vrsz_lut_coef(coef, in_n, out_n) \
+({ write_reg( (IPU_V_BASE + VRSZ_LUT_BASE), ((coef) & W_COEF_MSK)<<W_COEF_SFT \
+| ((in_n) & IN_N_MSK)<<IN_N_SFT | ((out_n) & OUT_N_MSK)<<OUT_N_SFT); \
+})
+
+#define set_primary_ctrl(vrsz_en, hrsz_en,csc_en, irq_en) \
+({ write_reg( (IPU_V_BASE + REG_CTRL), ((irq_en) & FM_IRQ_EN_MSK)<<FM_IRQ_EN_SFT \
+| ((vrsz_en) & VRSZ_EN_MSK)<<VRSZ_EN_SFT \
+| ((hrsz_en) & HRSZ_EN_MSK)<<HRSZ_EN_SFT \
+| ((csc_en) & CSC_EN_MSK)<<CSC_EN_SFT \
+| (read_reg(IPU_V_BASE, REG_CTRL)) \
+& ~(CSC_EN_MSK<<CSC_EN_SFT | FM_IRQ_EN_MSK<<FM_IRQ_EN_SFT | VRSZ_EN_MSK<<VRSZ_EN_SFT | HRSZ_EN_MSK<<HRSZ_EN_SFT ) ); \
+})
+
+#define set_source_ctrl(pkg_sel, spage_sel) \
+({ write_reg( (IPU_V_BASE + REG_CTRL), ((pkg_sel) & PKG_SEL_MSK  )<< PKG_SEL_SFT \
+| ((spage_sel) & SPAGE_MAP_MSK )<< SPAGE_MAP_SFT \
+| (read_reg(IPU_V_BASE, REG_CTRL)) \
+& ~(SPAGE_MAP_MSK << SPAGE_MAP_SFT | PKG_SEL_MSK << PKG_SEL_SFT ) ) ; \
+})
+
+#define set_out_ctrl(lcdc_sel, dpage_sel, disp_sel) \
+({ write_reg( (IPU_V_BASE + REG_CTRL), ((lcdc_sel) & LCDC_SEL_MSK  )<< LCDC_SEL_SFT \
+| ((dpage_sel) & DPAGE_SEL_MSK )<< DPAGE_SEL_SFT \
+| ((disp_sel) & DISP_SEL_MSK )<< DISP_SEL_SFT \
+| (read_reg(IPU_V_BASE, REG_CTRL)) \
+& ~(LCDC_SEL_MSK<< LCDC_SEL_SFT | DPAGE_SEL_MSK << DPAGE_SEL_SFT | DISP_SEL_MSK << DISP_SEL_SFT ) ); \
+})
+
+#define set_scale_ctrl(v_scal, h_scal) \
+({ write_reg( (IPU_V_BASE + REG_CTRL), ((v_scal) & V_SCALE_MSK)<<V_SCALE_SFT \
+| ((h_scal) & H_SCALE_MSK)<<H_SCALE_SFT \
+| (read_reg(IPU_V_BASE, REG_CTRL)) & ~(V_SCALE_MSK<<V_SCALE_SFT | H_SCALE_MSK<<H_SCALE_SFT ) ); \
+})
+
+
+#define set_csc_ofset_para(chrom_oft, luma_oft) \
+({ write_reg( (IPU_V_BASE + REG_CSC_OFSET_PARA ), ((chrom_oft) & CHROM_OF_MSK ) << CHROM_OF_SFT \
+| ((luma_oft) & LUMA_OF_MSK ) << LUMA_OF_SFT ) ; \
+})
+
+#define sw_reset_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) \
+| IPU_RST_MSK<<IPU_RST_SFT); \
+})
+#define enable_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) | 0x1); \
+})
+#define disable_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) & ~0x1); \
+})
+#define run_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) | 0x2); \
+})
+#define stop_ipu() \
+({ write_reg( (IPU_V_BASE + REG_CTRL), (read_reg(IPU_V_BASE, REG_CTRL)) & ~0x2); \
+})
+
+#define polling_end_flag() \
+({ (read_reg(IPU_V_BASE, REG_STATUS)) & 0x01; \
+})
+
+#define start_vlut_coef_write() \
+({ write_reg( (IPU_V_BASE + VRSZ_LUT_BASE), ( 0x1<<12 ) ); \
+})
+
+#define start_hlut_coef_write() \
+({ write_reg( (IPU_V_BASE + HRSZ_LUT_BASE), ( 0x01<<12 ) ); \
+})
+
+#define clear_end_flag() \
+({ write_reg( (IPU_V_BASE + REG_STATUS), 0); \
+})
+#endif /* #if 0 */
+
+
+#endif /* __JZ4750D_OPS_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750d/regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750d/regs.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,3398 @@
+/*
+ * linux/include/asm-mips/mach-jz4750d/regs.h
+ *
+ * JZ4750D register definition.
+ *
+ * Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __JZ4750D_REGS_H__
+#define __JZ4750D_REGS_H__
+
+#if defined(__ASSEMBLY__) || defined(__LANGUAGE_ASSEMBLY)
+#define REG8(addr)	(addr)
+#define REG16(addr)	(addr)
+#define REG32(addr)	(addr)
+#else
+#define REG8(addr)	*((volatile unsigned char *)(addr))
+#define REG16(addr)	*((volatile unsigned short *)(addr))
+#define REG32(addr)	*((volatile unsigned int *)(addr))
+#endif
+
+/*
+ * Define the module base addresses
+ */
+#define	CPM_BASE	0xB0000000
+#define	INTC_BASE	0xB0001000
+#define	TCU_BASE	0xB0002000
+#define	WDT_BASE	0xB0002000
+#define	RTC_BASE	0xB0003000
+#define	GPIO_BASE	0xB0010000
+#define	AIC_BASE	0xB0020000
+#define	ICDC_BASE	0xB0020000
+#define	MSC_BASE	0xB0021000
+#define	UART0_BASE	0xB0030000
+#define	UART1_BASE	0xB0031000
+#define	UART2_BASE	0xB0032000
+#define	UART3_BASE	0xB0033000
+#define	I2C_BASE	0xB0042000
+#define	SSI_BASE	0xB0043000
+#define	SADC_BASE	0xB0070000
+#define PCM_BASE        0xB0071000
+#define	EMC_BASE	0xB3010000
+#define	DMAC_BASE	0xB3020000
+#define	UHC_BASE	0xB3030000
+#define	UDC_BASE	0xB3040000
+#define	LCD_BASE	0xB3050000
+#define	SLCD_BASE	0xB3050000
+#define	TVE_BASE	0xB3050100
+#define	CIM_BASE	0xB3060000
+#define IPU_BASE	0xB3080000
+#define ME_BASE		0xB3090000
+#define MC_BASE		0xB30A0000
+#define BCH_BASE	0xB30D0000
+#define	ETH_BASE	0xB3100000
+#define	TCSM_BASE	0xF4000000
+#define OWI_BASE	0XB0072000
+#define OTP_BASE	0xB3012000
+#define TSSI_BASE	0xB0073000
+
+/*************************************************************************
+ * INTC (Interrupt Controller)
+ *************************************************************************/
+#define INTC_ISR	(INTC_BASE + 0x00)
+#define INTC_IMR	(INTC_BASE + 0x04)
+#define INTC_IMSR	(INTC_BASE + 0x08)
+#define INTC_IMCR	(INTC_BASE + 0x0c)
+#define INTC_IPR	(INTC_BASE + 0x10)
+#define INTC_ISSR	(INTC_BASE + 0x18)  /* Interrupt Controller Source Set Register */
+#define INTC_ISCR	(INTC_BASE + 0x1c)  /* Interrupt Controller Source Clear Register */
+
+#define REG_INTC_ISR	REG32(INTC_ISR)
+#define REG_INTC_IMR	REG32(INTC_IMR)
+#define REG_INTC_IMSR	REG32(INTC_IMSR)
+#define REG_INTC_IMCR	REG32(INTC_IMCR)
+#define REG_INTC_IPR	REG32(INTC_IPR)
+#define REG_INTC_ISSR   REG32(INTC_ISSR)
+#define REG_INTC_ISCR   REG32(INTC_ISCR)
+
+// 1st-level interrupts
+#define IRQ_ETH		0
+#define IRQ_SFT		4
+#define IRQ_I2C		5
+#define IRQ_RTC		6
+#define IRQ_UART2	7
+#define IRQ_UART1	8
+#define IRQ_UART0	9
+#define IRQ_AIC 	10
+#define IRQ_GPIO5	11
+#define IRQ_GPIO4	12
+#define IRQ_GPIO3	13
+#define IRQ_GPIO2	14
+#define IRQ_GPIO1	15
+#define IRQ_GPIO0	16
+#define IRQ_BCH		17
+#define IRQ_SADC	18
+#define IRQ_CIM		19
+#define IRQ_TSSI	20
+#define IRQ_TCU2	21
+#define IRQ_TCU1	22
+#define IRQ_TCU0	23
+#define IRQ_MSC1	24
+#define IRQ_MSC0	25
+#define IRQ_SSI   	26
+#define IRQ_UDC		27
+#define IRQ_DMAC1	28
+#define IRQ_DMAC0	29
+#define IRQ_IPU		30
+#define IRQ_LCD		31
+
+// 2nd-level interrupts
+#define IRQ_DMA_0	32  /* 32 to 43 for DMAC0's 0-5  and DMAC1's 0-5 */
+#define IRQ_GPIO_0	48  /* 48 to 240 for GPIO pin 0 to 192 */
+
+#define NUM_DMA         MAX_DMA_NUM	/* 12 */
+#define NUM_GPIO        MAX_GPIO_NUM	/* GPIO NUM: 192, Jz4750D real num GPIO 178 */
+
+
+/*************************************************************************
+ * RTC
+ *************************************************************************/
+#define RTC_RCR		(RTC_BASE + 0x00) /* RTC Control Register */
+#define RTC_RSR		(RTC_BASE + 0x04) /* RTC Second Register */
+#define RTC_RSAR	(RTC_BASE + 0x08) /* RTC Second Alarm Register */
+#define RTC_RGR		(RTC_BASE + 0x0c) /* RTC Regulator Register */
+
+#define RTC_HCR		(RTC_BASE + 0x20) /* Hibernate Control Register */
+#define RTC_HWFCR	(RTC_BASE + 0x24) /* Hibernate Wakeup Filter Counter Reg */
+#define RTC_HRCR	(RTC_BASE + 0x28) /* Hibernate Reset Counter Register */
+#define RTC_HWCR	(RTC_BASE + 0x2c) /* Hibernate Wakeup Control Register */
+#define RTC_HWRSR	(RTC_BASE + 0x30) /* Hibernate Wakeup Status Register */
+#define RTC_HSPR	(RTC_BASE + 0x34) /* Hibernate Scratch Pattern Register */
+
+#define REG_RTC_RCR	REG32(RTC_RCR)
+#define REG_RTC_RSR	REG32(RTC_RSR)
+#define REG_RTC_RSAR	REG32(RTC_RSAR)
+#define REG_RTC_RGR	REG32(RTC_RGR)
+#define REG_RTC_HCR	REG32(RTC_HCR)
+#define REG_RTC_HWFCR	REG32(RTC_HWFCR)
+#define REG_RTC_HRCR	REG32(RTC_HRCR)
+#define REG_RTC_HWCR	REG32(RTC_HWCR)
+#define REG_RTC_HWRSR	REG32(RTC_HWRSR)
+#define REG_RTC_HSPR	REG32(RTC_HSPR)
+
+/* RTC Control Register */
+#define RTC_RCR_WRDY_BIT 7
+#define RTC_RCR_WRDY	(1 << 7)  /* Write Ready Flag */
+#define RTC_RCR_1HZ_BIT	6
+#define RTC_RCR_1HZ	(1 << RTC_RCR_1HZ_BIT)  /* 1Hz Flag */
+#define RTC_RCR_1HZIE	(1 << 5)  /* 1Hz Interrupt Enable */
+#define RTC_RCR_AF_BIT	4
+#define RTC_RCR_AF	(1 << RTC_RCR_AF_BIT)  /* Alarm Flag */
+#define RTC_RCR_AIE	(1 << 3)  /* Alarm Interrupt Enable */
+#define RTC_RCR_AE	(1 << 2)  /* Alarm Enable */
+#define RTC_RCR_RTCE	(1 << 0)  /* RTC Enable */
+
+/* RTC Regulator Register */
+#define RTC_RGR_LOCK		(1 << 31) /* Lock Bit */
+#define RTC_RGR_ADJC_BIT	16
+#define RTC_RGR_ADJC_MASK	(0x3ff << RTC_RGR_ADJC_BIT)
+#define RTC_RGR_NC1HZ_BIT	0
+#define RTC_RGR_NC1HZ_MASK	(0xffff << RTC_RGR_NC1HZ_BIT)
+
+/* Hibernate Control Register */
+#define RTC_HCR_PD		(1 << 0)  /* Power Down */
+
+/* Hibernate Wakeup Filter Counter Register */
+#define RTC_HWFCR_BIT		5
+#define RTC_HWFCR_MASK		(0x7ff << RTC_HWFCR_BIT)
+
+/* Hibernate Reset Counter Register */
+#define RTC_HRCR_BIT		5
+#define RTC_HRCR_MASK		(0x7f << RTC_HRCR_BIT)
+
+/* Hibernate Wakeup Control Register */
+#define RTC_HWCR_EALM		(1 << 0)  /* RTC alarm wakeup enable */
+
+/* Hibernate Wakeup Status Register */
+#define RTC_HWRSR_HR		(1 << 5)  /* Hibernate reset */
+#define RTC_HWRSR_PPR		(1 << 4)  /* PPR reset */
+#define RTC_HWRSR_PIN		(1 << 1)  /* Wakeup pin status bit */
+#define RTC_HWRSR_ALM		(1 << 0)  /* RTC alarm status bit */
+
+
+/*************************************************************************
+ * CPM (Clock reset and Power control Management)
+ *************************************************************************/
+#define CPM_CPCCR	(CPM_BASE+0x00)
+#define CPM_CPPCR	(CPM_BASE+0x10)
+#define CPM_CPPSR	(CPM_BASE+0x14) /* PLL Switch and Status Register */
+#define CPM_I2SCDR	(CPM_BASE+0x60)
+#define CPM_LPCDR	(CPM_BASE+0x64)
+#define CPM_MSCCDR(n)	(CPM_BASE+0x10*(n)+0x68) /* MSC0(n=0) or MSC1(n=1) device clock divider Register */
+#define CPM_UHCCDR	(CPM_BASE+0x6C)
+#define CPM_SSICDR	(CPM_BASE+0x74)
+#define CPM_PCMCDR	(CPM_BASE+0x7C) /* PCM device clock divider Register */
+
+#define CPM_LCR		(CPM_BASE+0x04)
+#define CPM_CLKGR	(CPM_BASE+0x20)
+#define CPM_OPCR	(CPM_BASE+0x24) /* Oscillator and Power Control Register */
+
+#define CPM_RSR		(CPM_BASE+0x08)
+
+#define REG_CPM_CPCCR   	REG32(CPM_CPCCR)
+#define REG_CPM_CPPCR    	REG32(CPM_CPPCR)
+#define REG_CPM_CPPSR	        REG32(CPM_CPPSR)
+#define REG_CPM_I2SCDR  	REG32(CPM_I2SCDR)
+#define REG_CPM_LPCDR   	REG32(CPM_LPCDR)
+#define REG_CPM_MSCCDR(n)	REG32(CPM_MSCCDR(n))
+#define REG_CPM_UHCCDR   	REG32(CPM_UHCCDR)
+#define REG_CPM_SSICDR  	REG32(CPM_SSICDR)
+#define REG_CPM_PCMCDR          REG32(CPM_PCMCDR)
+
+#define REG_CPM_LCR	REG32(CPM_LCR)
+#define REG_CPM_CLKGR	REG32(CPM_CLKGR)
+#define REG_CPM_OPCR	REG32(CPM_OPCR)
+
+#define REG_CPM_RSR	REG32(CPM_RSR)
+
+/* Clock Control Register */
+#define CPM_CPCCR_I2CS		(1 << 31)
+#define CPM_CPCCR_ECS   	(1 << 30) /* Select the between EXCLK and EXCLK/2 output */
+#define CPM_CPCCR_UCS		(1 << 29)
+#define CPM_CPCCR_UDIV_BIT	23
+#define CPM_CPCCR_UDIV_MASK	(0x3f << CPM_CPCCR_UDIV_BIT)
+#define CPM_CPCCR_CE		(1 << 22)
+#define CPM_CPCCR_PCS		(1 << 21)
+#define CPM_CPCCR_LDIV_BIT	16
+#define CPM_CPCCR_LDIV_MASK	(0x1f << CPM_CPCCR_LDIV_BIT)
+#define CPM_CPCCR_MDIV_BIT	12
+#define CPM_CPCCR_MDIV_MASK	(0x0f << CPM_CPCCR_MDIV_BIT)
+#define CPM_CPCCR_PDIV_BIT	8
+#define CPM_CPCCR_PDIV_MASK	(0x0f << CPM_CPCCR_PDIV_BIT)
+#define CPM_CPCCR_HDIV_BIT	4
+#define CPM_CPCCR_HDIV_MASK	(0x0f << CPM_CPCCR_HDIV_BIT)
+#define CPM_CPCCR_CDIV_BIT	0
+#define CPM_CPCCR_CDIV_MASK	(0x0f << CPM_CPCCR_CDIV_BIT)
+
+/* PLL Switch and Status Register */
+#define CPM_CPPSR_PLLOFF        (1<<31)
+#define CPM_CPPSR_PLLBP         (1<<30)
+#define CPM_CPPSR_PLLON         (1<<29)
+#define CPM_CPPSR_PS            (1<<28) /* Indicate whether the PLL parameters' change has finished */
+#define CPM_CPPSR_FS            (1<<27) /* Indicate whether the main clock's change has finished */
+#define CPM_CPPSR_CS            (1<<26) /* Indicate whether the clock switch has finished */
+#define CPM_CPPSR_PM            (1<<1)  /* Clock switch mode */
+#define CPM_CPPSR_FM            (1<<0)  /* Clock frequency change mode */
+
+/* I2S Clock Divider Register */
+#define CPM_I2SCDR_I2SDIV_BIT	0
+#define CPM_I2SCDR_I2SDIV_MASK	(0x1ff << CPM_I2SCDR_I2SDIV_BIT)
+
+/* LCD Pixel Clock Divider Register */
+#define CPM_LPCDR_LSCS	        (1<<31) /* TV encoder Source Pixel Clock Selection */
+#define CPM_LPCDR_LPCS	        (1<<30) /* LCD Panel pix clock Selection */
+#define CPM_LPCDR_LTCS	        (1<<29) /* LCD TV Encoder or Panel pix clock Selection */
+#define CPM_LPCDR_PIXDIV_BIT	0
+#define CPM_LPCDR_PIXDIV_MASK	(0x7ff << CPM_LPCDR_PIXDIV_BIT)
+
+/* MSC Clock Divider Register */
+#define CPM_MSCCDR_MSCDIV_BIT	0
+#define CPM_MSCCDR_MSCDIV_MASK	(0x1f << CPM_MSCCDR_MSCDIV_BIT)
+
+/* UHC Clock Divider Register */
+#define CPM_UHCCDR_UHCDIV_BIT	0
+#define CPM_UHCCDR_UHCDIV_MASK	(0xf << CPM_UHCCDR_UHCDIV_BIT)
+
+/* SSI Clock Divider Register */
+#define CPM_SSICDR_SSIDIV_BIT	0
+#define CPM_SSICDR_SSIDIV_MASK	(0xf << CPM_SSICDR_SSIDIV_BIT)
+
+/* PCM device clock divider Register */
+#define CPM_PCMCDR_PCMS         31 /* PCM source clock Selection */
+#define CPM_PCMCDR_PCMCD_BIT    0
+#define CPM_PCMCDR_PCMCD_MASK   (0x1ff << CPM_PCMCDR_PCMCD_BIT)
+
+/* PLL Control Register */
+#define CPM_CPPCR_PLLM_BIT	23
+#define CPM_CPPCR_PLLM_MASK	(0x1ff << CPM_CPPCR_PLLM_BIT)
+#define CPM_CPPCR_PLLN_BIT	18
+#define CPM_CPPCR_PLLN_MASK	(0x1f << CPM_CPPCR_PLLN_BIT)
+#define CPM_CPPCR_PLLOD_BIT	16
+#define CPM_CPPCR_PLLOD_MASK	(0x03 << CPM_CPPCR_PLLOD_BIT)
+#define CPM_CPPCR_PLLS		(1 << 10) /* obsolete, replaced by CPM_CPPSR_PLLON */
+#define CPM_CPPCR_PLLBP		(1 << 9)
+#define CPM_CPPCR_PLLEN		(1 << 8)
+#define CPM_CPPCR_PLLST_BIT	0
+#define CPM_CPPCR_PLLST_MASK	(0xff << CPM_CPPCR_PLLST_BIT)
+
+/* Low Power Control Register */
+#define CPM_LCR_DOZE_DUTY_BIT 	3
+#define CPM_LCR_DOZE_DUTY_MASK 	(0x1f << CPM_LCR_DOZE_DUTY_BIT)
+#define CPM_LCR_DOZE_ON		(1 << 2)
+#define CPM_LCR_LPM_BIT		0
+#define CPM_LCR_LPM_MASK	(0x3 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_IDLE	(0x0 << CPM_LCR_LPM_BIT)
+  #define CPM_LCR_LPM_SLEEP	(0x1 << CPM_LCR_LPM_BIT)
+
+/* Clock Gate Register */
+#define CPM_CLKGR_CIMRAM	(1 << 28)
+#define CPM_CLKGR_IDCT  	(1 << 27)
+#define CPM_CLKGR_DB    	(1 << 26)
+#define CPM_CLKGR_ME    	(1 << 25)
+#define CPM_CLKGR_MC    	(1 << 24)
+#define CPM_CLKGR_TVE    	(1 << 23)
+#define CPM_CLKGR_TSSI    	(1 << 22)
+#define CPM_CLKGR_OWI    	(1 << 21)
+#define CPM_CLKGR_PCM    	(1 << 20)
+#define CPM_CLKGR_MSC1    	(1 << 19)
+#define CPM_CLKGR_SSI0    	(1 << 18)
+#define CPM_CLKGR_UART3    	(1 << 17)
+#define CPM_CLKGR_UART2    	(1 << 16)
+#define CPM_CLKGR_UART1		(1 << 15)
+#define CPM_CLKGR_UHC		(1 << 14)
+#define CPM_CLKGR_IPU		(1 << 13)
+#define CPM_CLKGR_DMAC		(1 << 12)
+#define CPM_CLKGR_UDC		(1 << 11)
+#define CPM_CLKGR_LCD		(1 << 10)
+#define CPM_CLKGR_CIM		(1 << 9)
+#define CPM_CLKGR_SADC		(1 << 8)
+#define CPM_CLKGR_MSC0		(1 << 7)
+#define CPM_CLKGR_AIC1		(1 << 6)
+#define CPM_CLKGR_AIC2		(1 << 5)
+#define CPM_CLKGR_SSI1		(1 << 4)
+#define CPM_CLKGR_I2C		(1 << 3)
+#define CPM_CLKGR_RTC		(1 << 2)
+#define CPM_CLKGR_TCU		(1 << 1)
+#define CPM_CLKGR_UART0		(1 << 0)
+
+/* Oscillator and Power Control Register */
+#define CPM_OPCR_O1ST_BIT	8
+#define CPM_OPCR_O1ST_MASK	(0xff << CPM_SCR_O1ST_BIT)
+#define CPM_OPCR_UHCPHY_DISABLE	(1 << 7)
+#define CPM_OPCR_UDCPHY_ENABLE	(1 << 6)
+#define CPM_OPCR_OSC_ENABLE	(1 << 4)
+#define CPM_OPCR_ERCS           (1 << 2) /* EXCLK/512 clock and RTCLK clock selection */
+#define CPM_OPCR_MOSE           (1 << 1) /* Main Oscillator Enable */
+#define CPM_OPCR_MCS            (1 << 0) /* Main clock source select register */
+
+/* Reset Status Register */
+#define CPM_RSR_HR		(1 << 2)
+#define CPM_RSR_WR		(1 << 1)
+#define CPM_RSR_PR		(1 << 0)
+
+
+/*************************************************************************
+ * TCU (Timer Counter Unit)
+ *************************************************************************/
+#define TCU_TSTR	(TCU_BASE + 0xF0) /* Timer Status Register,Only Used In Tcu2 Mode */
+#define TCU_TSTSR	(TCU_BASE + 0xF4) /* Timer Status Set Register */
+#define TCU_TSTCR	(TCU_BASE + 0xF8) /* Timer Status Clear Register */
+#define TCU_TSR		(TCU_BASE + 0x1C) /* Timer Stop Register */
+#define TCU_TSSR	(TCU_BASE + 0x2C) /* Timer Stop Set Register */
+#define TCU_TSCR	(TCU_BASE + 0x3C) /* Timer Stop Clear Register */
+#define TCU_TER		(TCU_BASE + 0x10) /* Timer Counter Enable Register */
+#define TCU_TESR	(TCU_BASE + 0x14) /* Timer Counter Enable Set Register */
+#define TCU_TECR	(TCU_BASE + 0x18) /* Timer Counter Enable Clear Register */
+#define TCU_TFR		(TCU_BASE + 0x20) /* Timer Flag Register */
+#define TCU_TFSR	(TCU_BASE + 0x24) /* Timer Flag Set Register */
+#define TCU_TFCR	(TCU_BASE + 0x28) /* Timer Flag Clear Register */
+#define TCU_TMR		(TCU_BASE + 0x30) /* Timer Mask Register */
+#define TCU_TMSR	(TCU_BASE + 0x34) /* Timer Mask Set Register */
+#define TCU_TMCR	(TCU_BASE + 0x38) /* Timer Mask Clear Register */
+
+#define TCU_TDFR0	(TCU_BASE + 0x40) /* Timer Data Full Register */
+#define TCU_TDHR0	(TCU_BASE + 0x44) /* Timer Data Half Register */
+#define TCU_TCNT0	(TCU_BASE + 0x48) /* Timer Counter Register */
+#define TCU_TCSR0	(TCU_BASE + 0x4C) /* Timer Control Register */
+#define TCU_TDFR1	(TCU_BASE + 0x50)
+#define TCU_TDHR1	(TCU_BASE + 0x54)
+#define TCU_TCNT1	(TCU_BASE + 0x58)
+#define TCU_TCSR1	(TCU_BASE + 0x5C)
+#define TCU_TDFR2	(TCU_BASE + 0x60)
+#define TCU_TDHR2	(TCU_BASE + 0x64)
+#define TCU_TCNT2	(TCU_BASE + 0x68)
+#define TCU_TCSR2	(TCU_BASE + 0x6C)
+#define TCU_TDFR3	(TCU_BASE + 0x70)
+#define TCU_TDHR3	(TCU_BASE + 0x74)
+#define TCU_TCNT3	(TCU_BASE + 0x78)
+#define TCU_TCSR3	(TCU_BASE + 0x7C)
+#define TCU_TDFR4	(TCU_BASE + 0x80)
+#define TCU_TDHR4	(TCU_BASE + 0x84)
+#define TCU_TCNT4	(TCU_BASE + 0x88)
+#define TCU_TCSR4	(TCU_BASE + 0x8C)
+#define TCU_TDFR5	(TCU_BASE + 0x90)
+#define TCU_TDHR5	(TCU_BASE + 0x94)
+#define TCU_TCNT5	(TCU_BASE + 0x98)
+#define TCU_TCSR5	(TCU_BASE + 0x9C)
+
+#define REG_TCU_TSTR	REG32(TCU_TSTR)
+#define REG_TCU_TSTSR	REG32(TCU_TSTSR)
+#define REG_TCU_TSTCR	REG32(TCU_TSTCR)
+#define REG_TCU_TSR	REG32(TCU_TSR)
+#define REG_TCU_TSSR	REG32(TCU_TSSR)
+#define REG_TCU_TSCR	REG32(TCU_TSCR)
+#define REG_TCU_TER	REG16(TCU_TER)
+#define REG_TCU_TESR	REG32(TCU_TESR)
+#define REG_TCU_TECR	REG32(TCU_TECR)
+#define REG_TCU_TFR	REG32(TCU_TFR)
+#define REG_TCU_TFSR	REG32(TCU_TFSR)
+#define REG_TCU_TFCR	REG32(TCU_TFCR)
+#define REG_TCU_TMR	REG32(TCU_TMR)
+#define REG_TCU_TMSR	REG32(TCU_TMSR)
+#define REG_TCU_TMCR	REG32(TCU_TMCR)
+#define REG_TCU_TDFR0	REG16(TCU_TDFR0)
+#define REG_TCU_TDHR0	REG16(TCU_TDHR0)
+#define REG_TCU_TCNT0	REG16(TCU_TCNT0)
+#define REG_TCU_TCSR0	REG16(TCU_TCSR0)
+#define REG_TCU_TDFR1	REG16(TCU_TDFR1)
+#define REG_TCU_TDHR1	REG16(TCU_TDHR1)
+#define REG_TCU_TCNT1	REG16(TCU_TCNT1)
+#define REG_TCU_TCSR1	REG16(TCU_TCSR1)
+#define REG_TCU_TDFR2	REG16(TCU_TDFR2)
+#define REG_TCU_TDHR2	REG16(TCU_TDHR2)
+#define REG_TCU_TCNT2	REG16(TCU_TCNT2)
+#define REG_TCU_TCSR2	REG16(TCU_TCSR2)
+#define REG_TCU_TDFR3	REG16(TCU_TDFR3)
+#define REG_TCU_TDHR3	REG16(TCU_TDHR3)
+#define REG_TCU_TCNT3	REG16(TCU_TCNT3)
+#define REG_TCU_TCSR3	REG16(TCU_TCSR3)
+#define REG_TCU_TDFR4	REG16(TCU_TDFR4)
+#define REG_TCU_TDHR4	REG16(TCU_TDHR4)
+#define REG_TCU_TCNT4	REG16(TCU_TCNT4)
+#define REG_TCU_TCSR4	REG16(TCU_TCSR4)
+
+// n = 0,1,2,3,4,5
+#define TCU_TDFR(n)	(TCU_BASE + (0x40 + (n)*0x10)) /* Timer Data Full Reg */
+#define TCU_TDHR(n)	(TCU_BASE + (0x44 + (n)*0x10)) /* Timer Data Half Reg */
+#define TCU_TCNT(n)	(TCU_BASE + (0x48 + (n)*0x10)) /* Timer Counter Reg */
+#define TCU_TCSR(n)	(TCU_BASE + (0x4C + (n)*0x10)) /* Timer Control Reg */
+#define TCU_OSTDR	(TCU_BASE + 0xe0) /* Operating System Timer Data Reg */
+#define TCU_OSTCNT	(TCU_BASE + 0xe8) /* Operating System Timer Counter Reg */
+#define TCU_OSTCSR	(TCU_BASE + 0xeC) /* Operating System Timer Control Reg */
+
+#define REG_TCU_TDFR(n)	REG16(TCU_TDFR((n)))
+#define REG_TCU_TDHR(n)	REG16(TCU_TDHR((n)))
+#define REG_TCU_TCNT(n)	REG16(TCU_TCNT((n)))
+#define REG_TCU_TCSR(n)	REG16(TCU_TCSR((n)))
+#define REG_TCU_OSTDR   REG32(TCU_OSTDR)
+#define REG_TCU_OSTCNT  REG32(TCU_OSTCNT)
+#define REG_TCU_OSTCSR  REG32(TCU_OSTCSR)
+
+// Register definitions
+#define TCU_TSTR_REAL2		(1 << 18) /* only used in TCU2 mode */
+#define TCU_TSTR_REAL1		(1 << 17) /* only used in TCU2 mode */
+#define TCU_TSTR_BUSY2		(1 << 2)  /* only used in TCU2 mode */
+#define TCU_TSTR_BUSY1		(1 << 1)  /* only used in TCU2 mode */
+
+#define TCU_TSTSR_REAL2		(1 << 18)
+#define TCU_TSTSR_REAL1		(1 << 17)
+#define TCU_TSTSR_BUSY2		(1 << 2)
+#define TCU_TSTSR_BUSY1		(1 << 1)
+
+#define TCU_TSTCR_REAL2		(1 << 18)
+#define TCU_TSTCR_REAL1		(1 << 17)
+#define TCU_TSTCR_BUSY2		(1 << 2)
+#define TCU_TSTCR_BUSY1		(1 << 1)
+
+#define TCU_TSR_WDTS		(1 << 16) /*the clock supplies to wdt is stopped */
+#define TCU_TSR_OSTS		(1 << 15) /*the clock supplies to osts is stopped */
+#define TCU_TSR_STOP5		(1 << 5)  /*the clock supplies to timer5 is stopped */
+#define TCU_TSR_STOP4		(1 << 4)  /*the clock supplies to timer4 is stopped */
+#define TCU_TSR_STOP3		(1 << 3)  /*the clock supplies to timer3 is stopped */
+#define TCU_TSR_STOP2		(1 << 2)  /*the clock supplies to timer2 is stopped */
+#define TCU_TSR_STOP1		(1 << 1)  /*the clock supplies to timer1 is stopped */
+#define TCU_TSR_STOP0		(1 << 0)  /*the clock supplies to timer0 is stopped */
+
+#define TCU_TSSR_WDTSS		(1 << 16)
+#define TCU_TSSR_OSTSS		(1 << 15)
+#define TCU_TSSR_STPS5		(1 << 5)
+#define TCU_TSSR_STPS4		(1 << 4)
+#define TCU_TSSR_STPS3		(1 << 3)
+#define TCU_TSSR_STPS2		(1 << 2)
+#define TCU_TSSR_STPS1		(1 << 1)
+#define TCU_TSSR_STPS0		(1 << 0)
+
+#define TCU_TSCR_WDTSC		(1 << 16)
+#define TCU_TSCR_OSTSC		(1 << 15)
+#define TCU_TSCR_STPC5		(1 << 5)
+#define TCU_TSCR_STPC4		(1 << 4)
+#define TCU_TSCR_STPC3		(1 << 3)
+#define TCU_TSCR_STPC2		(1 << 2)
+#define TCU_TSCR_STPC1		(1 << 1)
+#define TCU_TSCR_STPC0		(1 << 0)
+
+#define TCU_TER_OSTEN		(1 << 15) /* enable the counter in ost */
+#define TCU_TER_TCEN5		(1 << 5)  /* enable the counter in timer5 */
+#define TCU_TER_TCEN4		(1 << 4)
+#define TCU_TER_TCEN3		(1 << 3)
+#define TCU_TER_TCEN2		(1 << 2)
+#define TCU_TER_TCEN1		(1 << 1)
+#define TCU_TER_TCEN0		(1 << 0)
+
+#define TCU_TESR_OSTST		(1 << 15)
+#define TCU_TESR_TCST5		(1 << 5)
+#define TCU_TESR_TCST4		(1 << 4)
+#define TCU_TESR_TCST3		(1 << 3)
+#define TCU_TESR_TCST2		(1 << 2)
+#define TCU_TESR_TCST1		(1 << 1)
+#define TCU_TESR_TCST0		(1 << 0)
+
+#define TCU_TECR_OSTCL		(1 << 15)
+#define TCU_TECR_TCCL5		(1 << 5)
+#define TCU_TECR_TCCL4		(1 << 4)
+#define TCU_TECR_TCCL3		(1 << 3)
+#define TCU_TECR_TCCL2		(1 << 2)
+#define TCU_TECR_TCCL1		(1 << 1)
+#define TCU_TECR_TCCL0		(1 << 0)
+
+#define TCU_TFR_HFLAG5		(1 << 21) /* half comparison match flag */
+#define TCU_TFR_HFLAG4		(1 << 20)
+#define TCU_TFR_HFLAG3		(1 << 19)
+#define TCU_TFR_HFLAG2		(1 << 18)
+#define TCU_TFR_HFLAG1		(1 << 17)
+#define TCU_TFR_HFLAG0		(1 << 16)
+#define TCU_TFR_OSTFLAG		(1 << 15) /* ost comparison match flag */
+#define TCU_TFR_FFLAG5		(1 << 5)  /* full comparison match flag */
+#define TCU_TFR_FFLAG4		(1 << 4)
+#define TCU_TFR_FFLAG3		(1 << 3)
+#define TCU_TFR_FFLAG2		(1 << 2)
+#define TCU_TFR_FFLAG1		(1 << 1)
+#define TCU_TFR_FFLAG0		(1 << 0)
+
+#define TCU_TFSR_HFST5		(1 << 21)
+#define TCU_TFSR_HFST4		(1 << 20)
+#define TCU_TFSR_HFST3		(1 << 19)
+#define TCU_TFSR_HFST2		(1 << 18)
+#define TCU_TFSR_HFST1		(1 << 17)
+#define TCU_TFSR_HFST0		(1 << 16)
+#define TCU_TFSR_OSTFST		(1 << 15)
+#define TCU_TFSR_FFST5		(1 << 5)
+#define TCU_TFSR_FFST4		(1 << 4)
+#define TCU_TFSR_FFST3		(1 << 3)
+#define TCU_TFSR_FFST2		(1 << 2)
+#define TCU_TFSR_FFST1		(1 << 1)
+#define TCU_TFSR_FFST0		(1 << 0)
+
+#define TCU_TFCR_HFCL5		(1 << 21)
+#define TCU_TFCR_HFCL4		(1 << 20)
+#define TCU_TFCR_HFCL3		(1 << 19)
+#define TCU_TFCR_HFCL2		(1 << 18)
+#define TCU_TFCR_HFCL1		(1 << 17)
+#define TCU_TFCR_HFCL0		(1 << 16)
+#define TCU_TFCR_OSTFCL		(1 << 15)
+#define TCU_TFCR_FFCL5		(1 << 5)
+#define TCU_TFCR_FFCL4		(1 << 4)
+#define TCU_TFCR_FFCL3		(1 << 3)
+#define TCU_TFCR_FFCL2		(1 << 2)
+#define TCU_TFCR_FFCL1		(1 << 1)
+#define TCU_TFCR_FFCL0		(1 << 0)
+
+#define TCU_TMR_HMASK5		(1 << 21) /* half comparison match interrupt mask */
+#define TCU_TMR_HMASK4		(1 << 20)
+#define TCU_TMR_HMASK3		(1 << 19)
+#define TCU_TMR_HMASK2		(1 << 18)
+#define TCU_TMR_HMASK1		(1 << 17)
+#define TCU_TMR_HMASK0		(1 << 16)
+#define TCU_TMR_OSTMASK		(1 << 15) /* ost comparison match interrupt mask */
+#define TCU_TMR_FMASK5		(1 << 5)  /* full comparison match interrupt mask */
+#define TCU_TMR_FMASK4		(1 << 4)
+#define TCU_TMR_FMASK3		(1 << 3)
+#define TCU_TMR_FMASK2		(1 << 2)
+#define TCU_TMR_FMASK1		(1 << 1)
+#define TCU_TMR_FMASK0		(1 << 0)
+
+#define TCU_TMSR_HMST5		(1 << 21)
+#define TCU_TMSR_HMST4		(1 << 20)
+#define TCU_TMSR_HMST3		(1 << 19)
+#define TCU_TMSR_HMST2		(1 << 18)
+#define TCU_TMSR_HMST1		(1 << 17)
+#define TCU_TMSR_HMST0		(1 << 16)
+#define TCU_TMSR_OSTMST		(1 << 15)
+#define TCU_TMSR_FMST5		(1 << 5)
+#define TCU_TMSR_FMST4		(1 << 4)
+#define TCU_TMSR_FMST3		(1 << 3)
+#define TCU_TMSR_FMST2		(1 << 2)
+#define TCU_TMSR_FMST1		(1 << 1)
+#define TCU_TMSR_FMST0		(1 << 0)
+
+#define TCU_TMCR_HMCL5		(1 << 21)
+#define TCU_TMCR_HMCL4		(1 << 20)
+#define TCU_TMCR_HMCL3		(1 << 19)
+#define TCU_TMCR_HMCL2		(1 << 18)
+#define TCU_TMCR_HMCL1		(1 << 17)
+#define TCU_TMCR_HMCL0		(1 << 16)
+#define TCU_TMCR_OSTMCL		(1 << 15)
+#define TCU_TMCR_FMCL5		(1 << 5)
+#define TCU_TMCR_FMCL4		(1 << 4)
+#define TCU_TMCR_FMCL3		(1 << 3)
+#define TCU_TMCR_FMCL2		(1 << 2)
+#define TCU_TMCR_FMCL1		(1 << 1)
+#define TCU_TMCR_FMCL0		(1 << 0)
+
+#define TCU_TCSR_CNT_CLRZ	(1 << 10) /* clear counter to 0, only used in TCU2 mode */
+#define TCU_TCSR_PWM_SD		(1 << 9)  /* shut down the pwm output only used in TCU1 mode */
+#define TCU_TCSR_PWM_INITL_HIGH	(1 << 8)  /* selects an initial output level for pwm output */
+#define TCU_TCSR_PWM_EN		(1 << 7)  /* pwm pin output enable */
+#define TCU_TCSR_PRESCALE_BIT	3         /* select the tcnt count clock frequency*/
+#define TCU_TCSR_PRESCALE_MASK	(0x7 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1	(0x0 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE4	(0x1 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE16	(0x2 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE64	(0x3 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE256	(0x4 << TCU_TCSR_PRESCALE_BIT)
+  #define TCU_TCSR_PRESCALE1024	(0x5 << TCU_TCSR_PRESCALE_BIT)
+#define TCU_TCSR_EXT_EN		(1 << 2)  /* select extal as the timer clock input */
+#define TCU_TCSR_RTC_EN		(1 << 1)  /* select rtcclk as the timer clock input */
+#define TCU_TCSR_PCK_EN		(1 << 0)  /* select pclk as the timer clock input */
+
+#define TCU_TSTR_REAL2		(1 << 18) /* the value read from counter 2 is a real value */
+#define TCU_TSTR_REAL1		(1 << 17)
+#define TCU_TSTR_BUSY2		(1 << 2)  /* the counter 2 is busy now */
+#define TCU_TSTR_BUSY1		(1 << 1)
+
+#define TCU_TSTSR_REALS2	(1 << 18)
+#define TCU_TSTSR_REALS1	(1 << 17)
+#define TCU_TSTSR_BUSYS2	(1 << 2)
+#define TCU_TSTSR_BUSYS1	(1 << 1)
+
+#define TCU_TSTCR_REALC2	(1 << 18)
+#define TCU_TSTCR_REALC1	(1 << 17)
+#define TCU_TSTCR_BUSYC2	(1 << 2)
+#define TCU_TSTCR_BUSYC1	(1 << 1)
+
+#define TCU_OSTCR_CNT_MD		(1 << 15) /* when the value counter is equal to compare value,the counter is go on increasing till overflow,and then icrease from 0 */
+#define TCU_OSTCR_PWM_SD		(1 << 9) /* shut down the pwm output, only used in TCU1 mode */
+#define TCU_OSTCSR_PRESCALE_BIT		3
+#define TCU_OSTCSR_PRESCALE_MASK	(0x7 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE1		(0x0 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE4		(0x1 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE16		(0x2 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE64		(0x3 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE256	(0x4 << TCU_OSTCSR_PRESCALE_BIT)
+  #define TCU_OSTCSR_PRESCALE1024	(0x5 << TCU_OSTCSR_PRESCALE_BIT)
+#define TCU_OSTCSR_EXT_EN		(1 << 2) /* select extal as the timer clock input */
+#define TCU_OSTCSR_RTC_EN		(1 << 1) /* select rtcclk as the timer clock input */
+#define TCU_OSTCSR_PCK_EN		(1 << 0) /* select pclk as the timer clock input */
+
+/*************************************************************************
+ * WDT (WatchDog Timer)
+ *************************************************************************/
+#define WDT_TDR		(WDT_BASE + 0x00)
+#define WDT_TCER	(WDT_BASE + 0x04)
+#define WDT_TCNT	(WDT_BASE + 0x08)
+#define WDT_TCSR	(WDT_BASE + 0x0C)
+
+#define REG_WDT_TDR	REG16(WDT_TDR)
+#define REG_WDT_TCER	REG8(WDT_TCER)
+#define REG_WDT_TCNT	REG16(WDT_TCNT)
+#define REG_WDT_TCSR	REG16(WDT_TCSR)
+
+// Register definition
+#define WDT_TCSR_PRESCALE_BIT	3
+#define WDT_TCSR_PRESCALE_MASK	(0x7 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1	(0x0 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE4	(0x1 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE16	(0x2 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE64	(0x3 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE256	(0x4 << WDT_TCSR_PRESCALE_BIT)
+  #define WDT_TCSR_PRESCALE1024	(0x5 << WDT_TCSR_PRESCALE_BIT)
+#define WDT_TCSR_EXT_EN		(1 << 2)
+#define WDT_TCSR_RTC_EN		(1 << 1)
+#define WDT_TCSR_PCK_EN		(1 << 0)
+
+#define WDT_TCER_TCEN		(1 << 0)
+
+
+/*************************************************************************
+ * DMAC (DMA Controller)
+ *************************************************************************/
+
+#define MAX_DMA_NUM	8  /* max 8 channels */
+#define HALF_DMA_NUM	4   /* the number of one dma controller's channels */
+
+/* m is the DMA controller index (0, 1), n is the DMA channel index (0 - 11) */
+
+#define DMAC_DSAR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x00 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA source address */
+#define DMAC_DTAR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x04 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA target address */
+#define DMAC_DTCR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x08 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA transfer count */
+#define DMAC_DRSR(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x0c + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA request source */
+#define DMAC_DCCSR(n) (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x10 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA control/status */
+#define DMAC_DCMD(n)  (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x14 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA command */
+#define DMAC_DDA(n)   (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0x18 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x20)) /* DMA descriptor address */
+#define DMAC_DSD(n)   (DMAC_BASE + ((n)/HALF_DMA_NUM*0x100 + 0xc0 + ((n)-(n)/HALF_DMA_NUM*HALF_DMA_NUM) * 0x04)) /* DMA Stride Address */
+
+#define DMAC_DMACR(m)	(DMAC_BASE + 0x0300 + 0x100 * (m))              /* DMA control register */
+#define DMAC_DMAIPR(m)	(DMAC_BASE + 0x0304 + 0x100 * (m))              /* DMA interrupt pending */
+#define DMAC_DMADBR(m)	(DMAC_BASE + 0x0308 + 0x100 * (m))              /* DMA doorbell */
+#define DMAC_DMADBSR(m)	(DMAC_BASE + 0x030C + 0x100 * (m))              /* DMA doorbell set */
+#define DMAC_DMACKE(m)  (DMAC_BASE + 0x0310 + 0x100 * (m))
+
+#define REG_DMAC_DSAR(n)	REG32(DMAC_DSAR((n)))
+#define REG_DMAC_DTAR(n)	REG32(DMAC_DTAR((n)))
+#define REG_DMAC_DTCR(n)	REG32(DMAC_DTCR((n)))
+#define REG_DMAC_DRSR(n)	REG32(DMAC_DRSR((n)))
+#define REG_DMAC_DCCSR(n)	REG32(DMAC_DCCSR((n)))
+#define REG_DMAC_DCMD(n)	REG32(DMAC_DCMD((n)))
+#define REG_DMAC_DDA(n)		REG32(DMAC_DDA((n)))
+#define REG_DMAC_DSD(n)         REG32(DMAC_DSD(n))
+#define REG_DMAC_DMACR(m)	REG32(DMAC_DMACR(m))
+#define REG_DMAC_DMAIPR(m)	REG32(DMAC_DMAIPR(m))
+#define REG_DMAC_DMADBR(m)	REG32(DMAC_DMADBR(m))
+#define REG_DMAC_DMADBSR(m)	REG32(DMAC_DMADBSR(m))
+#define REG_DMAC_DMACKE(m)      REG32(DMAC_DMACKE(m))
+
+// DMA request source register
+#define DMAC_DRSR_RS_BIT	0
+#define DMAC_DRSR_RS_MASK	(0x3f << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_EXT	(0 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_NAND	(1 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_BCH_ENC	(2 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_BCH_DEC	(3 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AUTO	(8 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_TSSIIN	(9 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3OUT	(14 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART3IN	(15 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2OUT	(16 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART2IN	(17 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1OUT	(18 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART1IN	(19 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0OUT	(20 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_UART0IN	(21 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI0OUT	(22 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI0IN	(23 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICOUT	(24 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_AICIN	(25 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC0OUT	(26 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC0IN	(27 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_TCU	(28 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SADC	(29 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC1OUT	(30 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_MSC1IN	(31 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI1OUT	(32 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_SSI1IN	(33 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PMOUT	(34 << DMAC_DRSR_RS_BIT)
+  #define DMAC_DRSR_RS_PMIN	(35 << DMAC_DRSR_RS_BIT)
+
+// DMA channel control/status register
+#define DMAC_DCCSR_NDES		(1 << 31) /* descriptor (0) or not (1) ? */
+#define DMAC_DCCSR_DES8    	(1 << 30) /* Descriptor 8 Word */
+#define DMAC_DCCSR_DES4    	(0 << 30) /* Descriptor 4 Word */
+#define DMAC_DCCSR_CDOA_BIT	16        /* copy of DMA offset address */
+#define DMAC_DCCSR_CDOA_MASK	(0xff << DMAC_DCCSR_CDOA_BIT)
+#define DMAC_DCCSR_BERR		(1 << 7)  /* BCH error within this transfer, Only for channel 0 */
+#define DMAC_DCCSR_INV		(1 << 6)  /* descriptor invalid */
+#define DMAC_DCCSR_AR		(1 << 4)  /* address error */
+#define DMAC_DCCSR_TT		(1 << 3)  /* transfer terminated */
+#define DMAC_DCCSR_HLT		(1 << 2)  /* DMA halted */
+#define DMAC_DCCSR_CT		(1 << 1)  /* count terminated */
+#define DMAC_DCCSR_EN		(1 << 0)  /* channel enable bit */
+
+// DMA channel command register 
+#define DMAC_DCMD_EACKS_LOW  	(1 << 31) /* External DACK Output Level Select, active low */
+#define DMAC_DCMD_EACKS_HIGH  	(0 << 31) /* External DACK Output Level Select, active high */
+#define DMAC_DCMD_EACKM_WRITE 	(1 << 30) /* External DACK Output Mode Select, output in write cycle */
+#define DMAC_DCMD_EACKM_READ 	(0 << 30) /* External DACK Output Mode Select, output in read cycle */
+#define DMAC_DCMD_ERDM_BIT      28        /* External DREQ Detection Mode Select */
+#define DMAC_DCMD_ERDM_MASK     (0x03 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_LOW    (0 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_FALL   (1 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_HIGH   (2 << DMAC_DCMD_ERDM_BIT)
+  #define DMAC_DCMD_ERDM_RISE   (3 << DMAC_DCMD_ERDM_BIT)
+#define DMAC_DCMD_BLAST		(1 << 25) /* BCH last */
+#define DMAC_DCMD_SAI		(1 << 23) /* source address increment */
+#define DMAC_DCMD_DAI		(1 << 22) /* dest address increment */
+#define DMAC_DCMD_RDIL_BIT	16        /* request detection interval length */
+#define DMAC_DCMD_RDIL_MASK	(0x0f << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_IGN	(0 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_2	(1 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_4	(2 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_8	(3 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_12	(4 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_16	(5 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_20	(6 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_24	(7 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_28	(8 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_32	(9 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_48	(10 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_60	(11 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_64	(12 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_124	(13 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_128	(14 << DMAC_DCMD_RDIL_BIT)
+  #define DMAC_DCMD_RDIL_200	(15 << DMAC_DCMD_RDIL_BIT)
+#define DMAC_DCMD_SWDH_BIT	14  /* source port width */
+#define DMAC_DCMD_SWDH_MASK	(0x03 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_32	(0 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_8	(1 << DMAC_DCMD_SWDH_BIT)
+  #define DMAC_DCMD_SWDH_16	(2 << DMAC_DCMD_SWDH_BIT)
+#define DMAC_DCMD_DWDH_BIT	12  /* dest port width */
+#define DMAC_DCMD_DWDH_MASK	(0x03 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_32	(0 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_8	(1 << DMAC_DCMD_DWDH_BIT)
+  #define DMAC_DCMD_DWDH_16	(2 << DMAC_DCMD_DWDH_BIT)
+#define DMAC_DCMD_DS_BIT	8  /* transfer data size of a data unit */
+#define DMAC_DCMD_DS_MASK	(0x07 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BIT	(0 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_8BIT	(1 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BIT	(2 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_16BYTE	(3 << DMAC_DCMD_DS_BIT)
+  #define DMAC_DCMD_DS_32BYTE	(4 << DMAC_DCMD_DS_BIT)
+#define DMAC_DCMD_STDE   	(1 << 5)  /* Stride Disable/Enable */
+#define DMAC_DCMD_DES_V		(1 << 4)  /* descriptor valid flag */
+#define DMAC_DCMD_DES_VM	(1 << 3)  /* descriptor valid mask: 1:support V-bit */
+#define DMAC_DCMD_DES_VIE	(1 << 2)  /* DMA valid error interrupt enable */
+#define DMAC_DCMD_TIE		(1 << 1)  /* DMA transfer interrupt enable */
+#define DMAC_DCMD_LINK		(1 << 0)  /* descriptor link enable */
+
+// DMA descriptor address register
+#define DMAC_DDA_BASE_BIT	12  /* descriptor base address */
+#define DMAC_DDA_BASE_MASK	(0x0fffff << DMAC_DDA_BASE_BIT)
+#define DMAC_DDA_OFFSET_BIT	4   /* descriptor offset address */
+#define DMAC_DDA_OFFSET_MASK	(0x0ff << DMAC_DDA_OFFSET_BIT)
+
+// DMA stride address register
+#define DMAC_DSD_TSD_BIT        16  /* target stride address */
+#define DMAC_DSD_TSD_MASK      	(0xffff << DMAC_DSD_TSD_BIT)
+#define DMAC_DSD_SSD_BIT        0  /* source stride address */
+#define DMAC_DSD_SSD_MASK      	(0xffff << DMAC_DSD_SSD_BIT)
+
+// DMA control register
+#define DMAC_DMACR_FMSC		(1 << 31)  /* MSC Fast DMA mode */
+#define DMAC_DMACR_FSSI		(1 << 30)  /* SSI Fast DMA mode */
+#define DMAC_DMACR_FTSSI	(1 << 29)  /* TSSI Fast DMA mode */
+#define DMAC_DMACR_FUART	(1 << 28)  /* UART Fast DMA mode */
+#define DMAC_DMACR_FAIC		(1 << 27)  /* AIC Fast DMA mode */
+#define DMAC_DMACR_PR_BIT	8  /* channel priority mode */
+#define DMAC_DMACR_PR_MASK	(0x03 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_012345	(0 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_120345	(1 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_230145	(2 << DMAC_DMACR_PR_BIT)
+  #define DMAC_DMACR_PR_340125	(3 << DMAC_DMACR_PR_BIT)
+#define DMAC_DMACR_HLT		(1 << 3)  /* DMA halt flag */
+#define DMAC_DMACR_AR		(1 << 2)  /* address error flag */
+#define DMAC_DMACR_DMAE		(1 << 0)  /* DMA enable bit */
+
+// DMA doorbell register
+#define DMAC_DMADBR_DB5		(1 << 5)  /* doorbell for channel 5 */
+#define DMAC_DMADBR_DB4		(1 << 4)  /* doorbell for channel 4 */
+#define DMAC_DMADBR_DB3		(1 << 3)  /* doorbell for channel 3 */
+#define DMAC_DMADBR_DB2		(1 << 2)  /* doorbell for channel 2 */
+#define DMAC_DMADBR_DB1		(1 << 1)  /* doorbell for channel 1 */
+#define DMAC_DMADBR_DB0		(1 << 0)  /* doorbell for channel 0 */
+
+// DMA doorbell set register
+#define DMAC_DMADBSR_DBS5	(1 << 5)  /* enable doorbell for channel 5 */
+#define DMAC_DMADBSR_DBS4	(1 << 4)  /* enable doorbell for channel 4 */
+#define DMAC_DMADBSR_DBS3	(1 << 3)  /* enable doorbell for channel 3 */
+#define DMAC_DMADBSR_DBS2	(1 << 2)  /* enable doorbell for channel 2 */
+#define DMAC_DMADBSR_DBS1	(1 << 1)  /* enable doorbell for channel 1 */
+#define DMAC_DMADBSR_DBS0	(1 << 0)  /* enable doorbell for channel 0 */
+
+// DMA interrupt pending register
+#define DMAC_DMAIPR_CIRQ5	(1 << 5)  /* irq pending status for channel 5 */
+#define DMAC_DMAIPR_CIRQ4	(1 << 4)  /* irq pending status for channel 4 */
+#define DMAC_DMAIPR_CIRQ3	(1 << 3)  /* irq pending status for channel 3 */
+#define DMAC_DMAIPR_CIRQ2	(1 << 2)  /* irq pending status for channel 2 */
+#define DMAC_DMAIPR_CIRQ1	(1 << 1)  /* irq pending status for channel 1 */
+#define DMAC_DMAIPR_CIRQ0	(1 << 0)  /* irq pending status for channel 0 */
+
+
+/*************************************************************************
+ * GPIO (General-Purpose I/O Ports)
+ *************************************************************************/
+#define MAX_GPIO_NUM	192
+#define GPIO_WAKEUP     (32 * 4 + 30)
+
+//n = 0,1,2,3,4,5 (PORTA, PORTB, PORTC, PORTD, PORTE, PORTF)
+#define GPIO_PXPIN(n)	(GPIO_BASE + (0x00 + (n)*0x100)) /* PIN Level Register */
+#define GPIO_PXDAT(n)	(GPIO_BASE + (0x10 + (n)*0x100)) /* Port Data Register */
+#define GPIO_PXDATS(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Data Set Register */
+#define GPIO_PXDATC(n)	(GPIO_BASE + (0x18 + (n)*0x100)) /* Port Data Clear Register */
+#define GPIO_PXIM(n)	(GPIO_BASE + (0x20 + (n)*0x100)) /* Interrupt Mask Register */
+#define GPIO_PXIMS(n)	(GPIO_BASE + (0x24 + (n)*0x100)) /* Interrupt Mask Set Reg */
+#define GPIO_PXIMC(n)	(GPIO_BASE + (0x28 + (n)*0x100)) /* Interrupt Mask Clear Reg */
+#define GPIO_PXPE(n)	(GPIO_BASE + (0x30 + (n)*0x100)) /* Pull Enable Register */
+#define GPIO_PXPES(n)	(GPIO_BASE + (0x34 + (n)*0x100)) /* Pull Enable Set Reg. */
+#define GPIO_PXPEC(n)	(GPIO_BASE + (0x38 + (n)*0x100)) /* Pull Enable Clear Reg. */
+#define GPIO_PXFUN(n)	(GPIO_BASE + (0x40 + (n)*0x100)) /* Function Register */
+#define GPIO_PXFUNS(n)	(GPIO_BASE + (0x44 + (n)*0x100)) /* Function Set Register */
+#define GPIO_PXFUNC(n)	(GPIO_BASE + (0x48 + (n)*0x100)) /* Function Clear Register */
+#define GPIO_PXSEL(n)	(GPIO_BASE + (0x50 + (n)*0x100)) /* Select Register */
+#define GPIO_PXSELS(n)	(GPIO_BASE + (0x54 + (n)*0x100)) /* Select Set Register */
+#define GPIO_PXSELC(n)	(GPIO_BASE + (0x58 + (n)*0x100)) /* Select Clear Register */
+#define GPIO_PXDIR(n)	(GPIO_BASE + (0x60 + (n)*0x100)) /* Direction Register */
+#define GPIO_PXDIRS(n)	(GPIO_BASE + (0x64 + (n)*0x100)) /* Direction Set Register */
+#define GPIO_PXDIRC(n)	(GPIO_BASE + (0x68 + (n)*0x100)) /* Direction Clear Register */
+#define GPIO_PXTRG(n)	(GPIO_BASE + (0x70 + (n)*0x100)) /* Trigger Register */
+#define GPIO_PXTRGS(n)	(GPIO_BASE + (0x74 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXTRGC(n)	(GPIO_BASE + (0x78 + (n)*0x100)) /* Trigger Set Register */
+#define GPIO_PXFLG(n)	(GPIO_BASE + (0x80 + (n)*0x100)) /* Port Flag Register */
+#define GPIO_PXFLGC(n)	(GPIO_BASE + (0x14 + (n)*0x100)) /* Port Flag Clear Register */
+
+#define REG_GPIO_PXPIN(n)	REG32(GPIO_PXPIN((n)))  /* PIN level */
+#define REG_GPIO_PXDAT(n)	REG32(GPIO_PXDAT((n)))  /* 1: interrupt pending */
+#define REG_GPIO_PXDATS(n)	REG32(GPIO_PXDATS((n)))
+#define REG_GPIO_PXDATC(n)	REG32(GPIO_PXDATC((n)))
+#define REG_GPIO_PXIM(n)	REG32(GPIO_PXIM((n)))   /* 1: mask pin interrupt */
+#define REG_GPIO_PXIMS(n)	REG32(GPIO_PXIMS((n)))
+#define REG_GPIO_PXIMC(n)	REG32(GPIO_PXIMC((n)))
+#define REG_GPIO_PXPE(n)	REG32(GPIO_PXPE((n)))   /* 1: disable pull up/down */
+#define REG_GPIO_PXPES(n)	REG32(GPIO_PXPES((n)))
+#define REG_GPIO_PXPEC(n)	REG32(GPIO_PXPEC((n)))
+#define REG_GPIO_PXFUN(n)	REG32(GPIO_PXFUN((n)))  /* 0:GPIO or intr, 1:FUNC */
+#define REG_GPIO_PXFUNS(n)	REG32(GPIO_PXFUNS((n)))
+#define REG_GPIO_PXFUNC(n)	REG32(GPIO_PXFUNC((n)))
+#define REG_GPIO_PXSEL(n)	REG32(GPIO_PXSEL((n))) /* 0:GPIO/Fun0,1:intr/fun1*/
+#define REG_GPIO_PXSELS(n)	REG32(GPIO_PXSELS((n)))
+#define REG_GPIO_PXSELC(n)	REG32(GPIO_PXSELC((n)))
+#define REG_GPIO_PXDIR(n)	REG32(GPIO_PXDIR((n))) /* 0:input/low-level-trig/falling-edge-trig, 1:output/high-level-trig/rising-edge-trig */
+#define REG_GPIO_PXDIRS(n)	REG32(GPIO_PXDIRS((n)))
+#define REG_GPIO_PXDIRC(n)	REG32(GPIO_PXDIRC((n)))
+#define REG_GPIO_PXTRG(n)	REG32(GPIO_PXTRG((n))) /* 0:level-trigger, 1:edge-trigger */
+#define REG_GPIO_PXTRGS(n)	REG32(GPIO_PXTRGS((n)))
+#define REG_GPIO_PXTRGC(n)	REG32(GPIO_PXTRGC((n)))
+#define REG_GPIO_PXFLG(n)	REG32(GPIO_PXFLG((n))) /* interrupt flag */
+#define REG_GPIO_PXFLGC(n)	REG32(GPIO_PXFLGC((n))) /* interrupt flag */
+
+
+/*************************************************************************
+ * UART
+ *************************************************************************/
+
+#define IRDA_BASE	UART0_BASE
+#define UART_BASE	UART0_BASE
+#define UART_OFF	0x1000
+
+/* Register Offset */
+#define OFF_RDR		(0x00)	/* R  8b H'xx */
+#define OFF_TDR		(0x00)	/* W  8b H'xx */
+#define OFF_DLLR	(0x00)	/* RW 8b H'00 */
+#define OFF_DLHR	(0x04)	/* RW 8b H'00 */
+#define OFF_IER		(0x04)	/* RW 8b H'00 */
+#define OFF_ISR		(0x08)	/* R  8b H'01 */
+#define OFF_FCR		(0x08)	/* W  8b H'00 */
+#define OFF_LCR		(0x0C)	/* RW 8b H'00 */
+#define OFF_MCR		(0x10)	/* RW 8b H'00 */
+#define OFF_LSR		(0x14)	/* R  8b H'00 */
+#define OFF_MSR		(0x18)	/* R  8b H'00 */
+#define OFF_SPR		(0x1C)	/* RW 8b H'00 */
+#define OFF_SIRCR	(0x20)	/* RW 8b H'00, UART0 */
+#define OFF_UMR		(0x24)	/* RW 8b H'00, UART M Register */
+#define OFF_UACR	(0x28)	/* RW 8b H'00, UART Add Cycle Register */
+
+/* Register Address */
+#define UART0_RDR	(UART0_BASE + OFF_RDR)
+#define UART0_TDR	(UART0_BASE + OFF_TDR)
+#define UART0_DLLR	(UART0_BASE + OFF_DLLR)
+#define UART0_DLHR	(UART0_BASE + OFF_DLHR)
+#define UART0_IER	(UART0_BASE + OFF_IER)
+#define UART0_ISR	(UART0_BASE + OFF_ISR)
+#define UART0_FCR	(UART0_BASE + OFF_FCR)
+#define UART0_LCR	(UART0_BASE + OFF_LCR)
+#define UART0_MCR	(UART0_BASE + OFF_MCR)
+#define UART0_LSR	(UART0_BASE + OFF_LSR)
+#define UART0_MSR	(UART0_BASE + OFF_MSR)
+#define UART0_SPR	(UART0_BASE + OFF_SPR)
+#define UART0_SIRCR	(UART0_BASE + OFF_SIRCR)
+#define UART0_UMR	(UART0_BASE + OFF_UMR)
+#define UART0_UACR	(UART0_BASE + OFF_UACR)
+
+#define UART1_RDR	(UART1_BASE + OFF_RDR)
+#define UART1_TDR	(UART1_BASE + OFF_TDR)
+#define UART1_DLLR	(UART1_BASE + OFF_DLLR)
+#define UART1_DLHR	(UART1_BASE + OFF_DLHR)
+#define UART1_IER	(UART1_BASE + OFF_IER)
+#define UART1_ISR	(UART1_BASE + OFF_ISR)
+#define UART1_FCR	(UART1_BASE + OFF_FCR)
+#define UART1_LCR	(UART1_BASE + OFF_LCR)
+#define UART1_MCR	(UART1_BASE + OFF_MCR)
+#define UART1_LSR	(UART1_BASE + OFF_LSR)
+#define UART1_MSR	(UART1_BASE + OFF_MSR)
+#define UART1_SPR	(UART1_BASE + OFF_SPR)
+#define UART1_SIRCR	(UART1_BASE + OFF_SIRCR)
+
+#define UART2_RDR	(UART2_BASE + OFF_RDR)
+#define UART2_TDR	(UART2_BASE + OFF_TDR)
+#define UART2_DLLR	(UART2_BASE + OFF_DLLR)
+#define UART2_DLHR	(UART2_BASE + OFF_DLHR)
+#define UART2_IER	(UART2_BASE + OFF_IER)
+#define UART2_ISR	(UART2_BASE + OFF_ISR)
+#define UART2_FCR	(UART2_BASE + OFF_FCR)
+#define UART2_LCR	(UART2_BASE + OFF_LCR)
+#define UART2_MCR	(UART2_BASE + OFF_MCR)
+#define UART2_LSR	(UART2_BASE + OFF_LSR)
+#define UART2_MSR	(UART2_BASE + OFF_MSR)
+#define UART2_SPR	(UART2_BASE + OFF_SPR)
+#define UART2_SIRCR	(UART2_BASE + OFF_SIRCR)
+
+#define UART3_RDR	(UART3_BASE + OFF_RDR)
+#define UART3_TDR	(UART3_BASE + OFF_TDR)
+#define UART3_DLLR	(UART3_BASE + OFF_DLLR)
+#define UART3_DLHR	(UART3_BASE + OFF_DLHR)
+#define UART3_IER	(UART3_BASE + OFF_IER)
+#define UART3_ISR	(UART3_BASE + OFF_ISR)
+#define UART3_FCR	(UART3_BASE + OFF_FCR)
+#define UART3_LCR	(UART3_BASE + OFF_LCR)
+#define UART3_MCR	(UART3_BASE + OFF_MCR)
+#define UART3_LSR	(UART3_BASE + OFF_LSR)
+#define UART3_MSR	(UART3_BASE + OFF_MSR)
+#define UART3_SPR	(UART3_BASE + OFF_SPR)
+#define UART3_SIRCR	(UART3_BASE + OFF_SIRCR)
+
+
+/*
+ * Define macros for UARTIER
+ * UART Interrupt Enable Register
+ */
+#define UARTIER_RIE	(1 << 0)	/* 0: receive fifo full interrupt disable */
+#define UARTIER_TIE	(1 << 1)	/* 0: transmit fifo empty interrupt disable */
+#define UARTIER_RLIE	(1 << 2)	/* 0: receive line status interrupt disable */
+#define UARTIER_MIE	(1 << 3)	/* 0: modem status interrupt disable */
+#define UARTIER_RTIE	(1 << 4)	/* 0: receive timeout interrupt disable */
+
+/*
+ * Define macros for UARTISR
+ * UART Interrupt Status Register
+ */
+#define UARTISR_IP	(1 << 0)	/* 0: interrupt is pending  1: no interrupt */
+#define UARTISR_IID	(7 << 1)	/* Source of Interrupt */
+#define UARTISR_IID_MSI		(0 << 1)  /* Modem status interrupt */
+#define UARTISR_IID_THRI	(1 << 1)  /* Transmitter holding register empty */
+#define UARTISR_IID_RDI		(2 << 1)  /* Receiver data interrupt */
+#define UARTISR_IID_RLSI	(3 << 1)  /* Receiver line status interrupt */
+#define UARTISR_IID_RTO		(6 << 1)  /* Receive timeout */
+#define UARTISR_FFMS		(3 << 6)  /* FIFO mode select, set when UARTFCR.FE is set to 1 */
+#define UARTISR_FFMS_NO_FIFO	(0 << 6)
+#define UARTISR_FFMS_FIFO_MODE	(3 << 6)
+
+/*
+ * Define macros for UARTFCR
+ * UART FIFO Control Register
+ */
+#define UARTFCR_FE	(1 << 0)	/* 0: non-FIFO mode  1: FIFO mode */
+#define UARTFCR_RFLS	(1 << 1)	/* write 1 to flush receive FIFO */
+#define UARTFCR_TFLS	(1 << 2)	/* write 1 to flush transmit FIFO */
+#define UARTFCR_DMS	(1 << 3)	/* 0: disable DMA mode */
+#define UARTFCR_UUE	(1 << 4)	/* 0: disable UART */
+#define UARTFCR_RTRG	(3 << 6)	/* Receive FIFO Data Trigger */
+#define UARTFCR_RTRG_1	(0 << 6)
+#define UARTFCR_RTRG_4	(1 << 6)
+#define UARTFCR_RTRG_8	(2 << 6)
+#define UARTFCR_RTRG_15	(3 << 6)
+
+/*
+ * Define macros for UARTLCR
+ * UART Line Control Register
+ */
+#define UARTLCR_WLEN	(3 << 0)	/* word length */
+#define UARTLCR_WLEN_5	(0 << 0)
+#define UARTLCR_WLEN_6	(1 << 0)
+#define UARTLCR_WLEN_7	(2 << 0)
+#define UARTLCR_WLEN_8	(3 << 0)
+#define UARTLCR_STOP	(1 << 2)	/* 0: 1 stop bit when word length is 5,6,7,8
+					   1: 1.5 stop bits when 5; 2 stop bits when 6,7,8 */
+#define UARTLCR_STOP1	(0 << 2)
+#define UARTLCR_STOP2	(1 << 2)
+#define UARTLCR_PE	(1 << 3)	/* 0: parity disable */
+#define UARTLCR_PROE	(1 << 4)	/* 0: even parity  1: odd parity */
+#define UARTLCR_SPAR	(1 << 5)	/* 0: sticky parity disable */
+#define UARTLCR_SBRK	(1 << 6)	/* write 0 normal, write 1 send break */
+#define UARTLCR_DLAB	(1 << 7)	/* 0: access UARTRDR/TDR/IER  1: access UARTDLLR/DLHR */
+
+/*
+ * Define macros for UARTLSR
+ * UART Line Status Register
+ */
+#define UARTLSR_DR	(1 << 0)	/* 0: receive FIFO is empty  1: receive data is ready */
+#define UARTLSR_ORER	(1 << 1)	/* 0: no overrun error */
+#define UARTLSR_PER	(1 << 2)	/* 0: no parity error */
+#define UARTLSR_FER	(1 << 3)	/* 0; no framing error */
+#define UARTLSR_BRK	(1 << 4)	/* 0: no break detected  1: receive a break signal */
+#define UARTLSR_TDRQ	(1 << 5)	/* 1: transmit FIFO half "empty" */
+#define UARTLSR_TEMT	(1 << 6)	/* 1: transmit FIFO and shift registers empty */
+#define UARTLSR_RFER	(1 << 7)	/* 0: no receive error  1: receive error in FIFO mode */
+
+/*
+ * Define macros for UARTMCR
+ * UART Modem Control Register
+ */
+#define UARTMCR_RTS	(1 << 1)	/* 0: RTS_ output high, 1: RTS_ output low */
+#define UARTMCR_LOOP	(1 << 4)	/* 0: normal  1: loopback mode */
+#define UARTMCR_MCE	(1 << 7)	/* 0: modem function is disable */
+
+/*
+ * Define macros for UARTMSR
+ * UART Modem Status Register
+ */
+#define UARTMSR_CCTS	(1 << 0)        /* 1: a change on CTS_ pin */
+#define UARTMSR_CTS	(1 << 4)	/* 0: CTS_ pin is high */
+
+/*
+ * Define macros for SIRCR
+ * Slow IrDA Control Register
+ */
+#define SIRCR_TSIRE	(1 << 0)  /* 0: transmitter is in UART mode  1: SIR mode */
+#define SIRCR_RSIRE	(1 << 1)  /* 0: receiver is in UART mode  1: SIR mode */
+#define SIRCR_TPWS	(1 << 2)  /* 0: transmit 0 pulse width is 3/16 of bit length
+					   1: 0 pulse width is 1.6us for 115.2Kbps */
+#define SIRCR_TDPL	(1 << 3)  /* 0: encoder generates a positive pulse for 0 */
+#define SIRCR_RDPL	(1 << 4)  /* 0: decoder interprets positive pulse as 0 */
+
+
+/*************************************************************************
+ * AIC (AC97/I2S Controller)
+ *************************************************************************/
+#define	AIC_FR			(AIC_BASE + 0x000)
+#define	AIC_CR			(AIC_BASE + 0x004)
+#define	AIC_ACCR1		(AIC_BASE + 0x008)
+#define	AIC_ACCR2		(AIC_BASE + 0x00C)
+#define	AIC_I2SCR		(AIC_BASE + 0x010)
+#define	AIC_SR			(AIC_BASE + 0x014)
+#define	AIC_ACSR		(AIC_BASE + 0x018)
+#define	AIC_I2SSR		(AIC_BASE + 0x01C)
+#define	AIC_ACCAR		(AIC_BASE + 0x020)
+#define	AIC_ACCDR		(AIC_BASE + 0x024)
+#define	AIC_ACSAR		(AIC_BASE + 0x028)
+#define	AIC_ACSDR		(AIC_BASE + 0x02C)
+#define	AIC_I2SDIV		(AIC_BASE + 0x030)
+#define	AIC_DR			(AIC_BASE + 0x034)
+
+#define	REG_AIC_FR		REG32(AIC_FR)
+#define	REG_AIC_CR		REG32(AIC_CR)
+#define	REG_AIC_ACCR1		REG32(AIC_ACCR1)
+#define	REG_AIC_ACCR2		REG32(AIC_ACCR2)
+#define	REG_AIC_I2SCR		REG32(AIC_I2SCR)
+#define	REG_AIC_SR		REG32(AIC_SR)
+#define	REG_AIC_ACSR		REG32(AIC_ACSR)
+#define	REG_AIC_I2SSR		REG32(AIC_I2SSR)
+#define	REG_AIC_ACCAR		REG32(AIC_ACCAR)
+#define	REG_AIC_ACCDR		REG32(AIC_ACCDR)
+#define	REG_AIC_ACSAR		REG32(AIC_ACSAR)
+#define	REG_AIC_ACSDR		REG32(AIC_ACSDR)
+#define	REG_AIC_I2SDIV		REG32(AIC_I2SDIV)
+#define	REG_AIC_DR		REG32(AIC_DR)
+
+/* AIC Controller Configuration Register (AIC_FR) */
+
+#define	AIC_FR_RFTH_BIT		12        /* Receive FIFO Threshold */
+#define	AIC_FR_RFTH_MASK	(0xf << AIC_FR_RFTH_BIT)
+#define	AIC_FR_TFTH_BIT		8         /* Transmit FIFO Threshold */
+#define	AIC_FR_TFTH_MASK	(0xf << AIC_FR_TFTH_BIT)
+#define	AIC_FR_LSMP		(1 << 6)  /* Play Zero sample or last sample */
+#define	AIC_FR_ICDC		(1 << 5)  /* External(0) or Internal CODEC(1) */
+#define	AIC_FR_AUSEL		(1 << 4)  /* AC97(0) or I2S/MSB-justified(1) */
+#define	AIC_FR_RST		(1 << 3)  /* AIC registers reset */
+#define	AIC_FR_BCKD		(1 << 2)  /* I2S BIT_CLK direction, 0:input,1:output */
+#define	AIC_FR_SYNCD		(1 << 1)  /* I2S SYNC direction, 0:input,1:output */
+#define	AIC_FR_ENB		(1 << 0)  /* AIC enable bit */
+
+/* AIC Controller Common Control Register (AIC_CR) */
+
+#define	AIC_CR_OSS_BIT		19  /* Output Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_OSS_MASK		(0x7 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_8BIT	(0x0 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_16BIT	(0x1 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_18BIT	(0x2 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_20BIT	(0x3 << AIC_CR_OSS_BIT)
+  #define AIC_CR_OSS_24BIT	(0x4 << AIC_CR_OSS_BIT)
+#define	AIC_CR_ISS_BIT		16  /* Input Sample Size from memory (AIC V2 only) */
+#define	AIC_CR_ISS_MASK		(0x7 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_8BIT	(0x0 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_16BIT	(0x1 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_18BIT	(0x2 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_20BIT	(0x3 << AIC_CR_ISS_BIT)
+  #define AIC_CR_ISS_24BIT	(0x4 << AIC_CR_ISS_BIT)
+#define	AIC_CR_RDMS		(1 << 15)  /* Receive DMA enable */
+#define	AIC_CR_TDMS		(1 << 14)  /* Transmit DMA enable */
+#define	AIC_CR_M2S		(1 << 11)  /* Mono to Stereo enable */
+#define	AIC_CR_ENDSW		(1 << 10)  /* Endian switch enable */
+#define	AIC_CR_AVSTSU		(1 << 9)   /* Signed <-> Unsigned toggle enable */
+#define	AIC_CR_FLUSH		(1 << 8)   /* Flush FIFO */
+#define	AIC_CR_EROR		(1 << 6)   /* Enable ROR interrupt */
+#define	AIC_CR_ETUR		(1 << 5)   /* Enable TUR interrupt */
+#define	AIC_CR_ERFS		(1 << 4)   /* Enable RFS interrupt */
+#define	AIC_CR_ETFS		(1 << 3)   /* Enable TFS interrupt */
+#define	AIC_CR_ENLBF		(1 << 2)   /* Enable Loopback Function */
+#define	AIC_CR_ERPL		(1 << 1)   /* Enable Playback Function */
+#define	AIC_CR_EREC		(1 << 0)   /* Enable Record Function */
+
+/* AIC Controller AC-link Control Register 1 (AIC_ACCR1) */
+
+#define	AIC_ACCR1_RS_BIT	16          /* Receive Valid Slots */
+#define	AIC_ACCR1_RS_MASK	(0x3ff << AIC_ACCR1_RS_BIT)
+  #define AIC_ACCR1_RS_SLOT12	  (1 << 25) /* Slot 12 valid bit */
+  #define AIC_ACCR1_RS_SLOT11	  (1 << 24) /* Slot 11 valid bit */
+  #define AIC_ACCR1_RS_SLOT10	  (1 << 23) /* Slot 10 valid bit */
+  #define AIC_ACCR1_RS_SLOT9	  (1 << 22) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_RS_SLOT8	  (1 << 21) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_RS_SLOT7	  (1 << 20) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_RS_SLOT6	  (1 << 19) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_RS_SLOT5	  (1 << 18) /* Slot 5 valid bit */
+  #define AIC_ACCR1_RS_SLOT4	  (1 << 17) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_RS_SLOT3	  (1 << 16) /* Slot 3 valid bit, PCM Left */
+#define	AIC_ACCR1_XS_BIT	0          /* Transmit Valid Slots */
+#define	AIC_ACCR1_XS_MASK	(0x3ff << AIC_ACCR1_XS_BIT)
+  #define AIC_ACCR1_XS_SLOT12	  (1 << 9) /* Slot 12 valid bit */
+  #define AIC_ACCR1_XS_SLOT11	  (1 << 8) /* Slot 11 valid bit */
+  #define AIC_ACCR1_XS_SLOT10	  (1 << 7) /* Slot 10 valid bit */
+  #define AIC_ACCR1_XS_SLOT9	  (1 << 6) /* Slot 9 valid bit, LFE */
+  #define AIC_ACCR1_XS_SLOT8	  (1 << 5) /* Slot 8 valid bit, Surround Right */
+  #define AIC_ACCR1_XS_SLOT7	  (1 << 4) /* Slot 7 valid bit, Surround Left */
+  #define AIC_ACCR1_XS_SLOT6	  (1 << 3) /* Slot 6 valid bit, PCM Center */
+  #define AIC_ACCR1_XS_SLOT5	  (1 << 2) /* Slot 5 valid bit */
+  #define AIC_ACCR1_XS_SLOT4	  (1 << 1) /* Slot 4 valid bit, PCM Right */
+  #define AIC_ACCR1_XS_SLOT3	  (1 << 0) /* Slot 3 valid bit, PCM Left */
+
+/* AIC Controller AC-link Control Register 2 (AIC_ACCR2) */
+
+#define	AIC_ACCR2_ERSTO		(1 << 18) /* Enable RSTO interrupt */
+#define	AIC_ACCR2_ESADR		(1 << 17) /* Enable SADR interrupt */
+#define	AIC_ACCR2_ECADT		(1 << 16) /* Enable CADT interrupt */
+#define	AIC_ACCR2_OASS_BIT	8  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_OASS_MASK	(0x3 << AIC_ACCR2_OASS_BIT)
+  #define AIC_ACCR2_OASS_20BIT	  (0 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_OASS_18BIT	  (1 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_OASS_16BIT	  (2 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_OASS_8BIT	  (3 << AIC_ACCR2_OASS_BIT) /* Output Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_IASS_BIT	6  /* Output Sample Size for AC-link */
+#define	AIC_ACCR2_IASS_MASK	(0x3 << AIC_ACCR2_IASS_BIT)
+  #define AIC_ACCR2_IASS_20BIT	  (0 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 20-bit */
+  #define AIC_ACCR2_IASS_18BIT	  (1 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 18-bit */
+  #define AIC_ACCR2_IASS_16BIT	  (2 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 16-bit */
+  #define AIC_ACCR2_IASS_8BIT	  (3 << AIC_ACCR2_IASS_BIT) /* Input Audio Sample Size is 8-bit */
+#define	AIC_ACCR2_SO		(1 << 3)  /* SDATA_OUT output value */
+#define	AIC_ACCR2_SR		(1 << 2)  /* RESET# pin level */
+#define	AIC_ACCR2_SS		(1 << 1)  /* SYNC pin level */
+#define	AIC_ACCR2_SA		(1 << 0)  /* SYNC and SDATA_OUT alternation */
+
+/* AIC Controller I2S/MSB-justified Control Register (AIC_I2SCR) */
+
+#define	AIC_I2SCR_STPBK		(1 << 12) /* Stop BIT_CLK for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_BIT	1  /* Input/Output Sample Size for I2S/MSB-justified */
+#define	AIC_I2SCR_WL_MASK	(0x7 << AIC_I2SCR_WL_BIT)
+  #define AIC_I2SCR_WL_24BIT	  (0 << AIC_I2SCR_WL_BIT) /* Word Length is 24 bit */
+  #define AIC_I2SCR_WL_20BIT	  (1 << AIC_I2SCR_WL_BIT) /* Word Length is 20 bit */
+  #define AIC_I2SCR_WL_18BIT	  (2 << AIC_I2SCR_WL_BIT) /* Word Length is 18 bit */
+  #define AIC_I2SCR_WL_16BIT	  (3 << AIC_I2SCR_WL_BIT) /* Word Length is 16 bit */
+  #define AIC_I2SCR_WL_8BIT	  (4 << AIC_I2SCR_WL_BIT) /* Word Length is 8 bit */
+#define	AIC_I2SCR_AMSL		(1 << 0) /* 0:I2S, 1:MSB-justified */
+
+/* AIC Controller FIFO Status Register (AIC_SR) */
+
+#define	AIC_SR_RFL_BIT		24  /* Receive FIFO Level */
+#define	AIC_SR_RFL_MASK		(0x3f << AIC_SR_RFL_BIT)
+#define	AIC_SR_TFL_BIT		8   /* Transmit FIFO level */
+#define	AIC_SR_TFL_MASK		(0x3f << AIC_SR_TFL_BIT)
+#define	AIC_SR_ROR		(1 << 6) /* Receive FIFO Overrun */
+#define	AIC_SR_TUR		(1 << 5) /* Transmit FIFO Underrun */
+#define	AIC_SR_RFS		(1 << 4) /* Receive FIFO Service Request */
+#define	AIC_SR_TFS		(1 << 3) /* Transmit FIFO Service Request */
+
+/* AIC Controller AC-link Status Register (AIC_ACSR) */
+
+#define	AIC_ACSR_SLTERR		(1 << 21) /* Slot Error Flag */
+#define	AIC_ACSR_CRDY		(1 << 20) /* External CODEC Ready Flag */
+#define	AIC_ACSR_CLPM		(1 << 19) /* External CODEC low power mode flag */
+#define	AIC_ACSR_RSTO		(1 << 18) /* External CODEC regs read status timeout */
+#define	AIC_ACSR_SADR		(1 << 17) /* External CODEC regs status addr and data received */
+#define	AIC_ACSR_CADT		(1 << 16) /* Command Address and Data Transmitted */
+
+/* AIC Controller I2S/MSB-justified Status Register (AIC_I2SSR) */
+
+#define	AIC_I2SSR_BSY		(1 << 2)  /* AIC Busy in I2S/MSB-justified format */
+
+/* AIC Controller AC97 codec Command Address Register (AIC_ACCAR) */
+
+#define	AIC_ACCAR_CAR_BIT	0
+#define	AIC_ACCAR_CAR_MASK	(0xfffff << AIC_ACCAR_CAR_BIT)
+
+/* AIC Controller AC97 codec Command Data Register (AIC_ACCDR) */
+
+#define	AIC_ACCDR_CDR_BIT	0
+#define	AIC_ACCDR_CDR_MASK	(0xfffff << AIC_ACCDR_CDR_BIT)
+
+/* AIC Controller AC97 codec Status Address Register (AIC_ACSAR) */
+
+#define	AIC_ACSAR_SAR_BIT	0
+#define	AIC_ACSAR_SAR_MASK	(0xfffff << AIC_ACSAR_SAR_BIT)
+
+/* AIC Controller AC97 codec Status Data Register (AIC_ACSDR) */
+
+#define	AIC_ACSDR_SDR_BIT	0
+#define	AIC_ACSDR_SDR_MASK	(0xfffff << AIC_ACSDR_SDR_BIT)
+
+/* AIC Controller I2S/MSB-justified Clock Divider Register (AIC_I2SDIV) */
+
+#define	AIC_I2SDIV_DIV_BIT	0
+#define	AIC_I2SDIV_DIV_MASK	(0x7f << AIC_I2SDIV_DIV_BIT)
+  #define AIC_I2SDIV_BITCLK_3072KHZ	(0x0C << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 3.072MHz */
+  #define AIC_I2SDIV_BITCLK_2836KHZ	(0x0D << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 2.836MHz */
+  #define AIC_I2SDIV_BITCLK_1418KHZ	(0x1A << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.418MHz */
+  #define AIC_I2SDIV_BITCLK_1024KHZ	(0x24 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 1.024MHz */
+  #define AIC_I2SDIV_BITCLK_7089KHZ	(0x34 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 708.92KHz */
+  #define AIC_I2SDIV_BITCLK_512KHZ	(0x48 << AIC_I2SDIV_DIV_BIT) /* BIT_CLK of 512.00KHz */
+
+
+/*************************************************************************
+ * ICDC (Internal CODEC)
+ *************************************************************************/
+
+#define	ICDC_CKCFG	  (ICDC_BASE + 0x00a0)  /* Clock Configure Register */
+#define	ICDC_RGADW	  (ICDC_BASE + 0x00a4)  /* internal register access control */
+#define	ICDC_RGDATA	  (ICDC_BASE + 0x00a8)  /* internal register data output */
+
+#define	REG_ICDC_CKCFG		REG32(ICDC_CKCFG)
+#define	REG_ICDC_RGADW		REG32(ICDC_RGADW)
+#define	REG_ICDC_RGDATA		REG32(ICDC_RGDATA)
+
+/* ICDC Clock Configure Register */
+#define	ICDC_CKCFG_CKRDY	(1 << 1) 
+#define	ICDC_CKCFG_SELAD	(1 << 0)
+
+/* ICDC internal register access control Register */
+#define ICDC_RGADW_RGWR         (1 << 16)
+#define ICDC_RGADW_RGADDR_BIT   8
+#define	ICDC_RGADW_RGADDR_MASK	(0x7f << ICDC_RGADW_RGADDR_BIT)
+#define ICDC_RGADW_RGDIN_BIT    0
+#define	ICDC_RGADW_RGDIN_MASK	(0xff << ICDC_RGADW_RGDIN_BIT)
+
+/* ICDC internal register data output Register */
+#define ICDC_RGDATA_IRQ         (1 << 8)
+#define ICDC_RGDATA_RGDOUT_BIT  0
+#define ICDC_RGDATA_RGDOUT_MASK (0xff << ICDC_RGDATA_RGDOUT_BIT)
+
+/*************************************************************************
+ * PCM Controller
+ *************************************************************************/
+
+#define PCM_CTL                 (PCM_BASE + 0x000)
+#define PCM_CFG                 (PCM_BASE + 0x004)
+#define PCM_DP                  (PCM_BASE + 0x008)
+#define PCM_INTC                (PCM_BASE + 0x00c)
+#define PCM_INTS                (PCM_BASE + 0x010)
+#define PCM_DIV                 (PCM_BASE + 0x014)
+
+#define REG_PCM_CTL             REG32(PCM_CTL)
+#define REG_PCM_CFG             REG32(PCM_CFG)
+#define REG_PCM_DP              REG32(PCM_DP)
+#define REG_PCM_INTC            REG32(PCM_INTC)
+#define REG_PCM_INTS            REG32(PCM_INTS)
+#define REG_PCM_DIV             REG32(PCM_DIV)
+
+/* PCM Controller control Register (PCM_CTL) */
+
+#define PCM_CTL_ERDMA		(1 << 9)  /* Enable Receive DMA */
+#define PCM_CTL_ETDMA           (1 << 8)  /* Enable Transmit DMA */
+#define PCM_CTL_LSMP		(1 << 7)  /* Play Zero sample or last sample */
+#define PCM_CTL_ERPL            (1 << 6)  /* Enable Playing Back Function */
+#define PCM_CTL_EREC            (1 << 5)  /* Enable Recording Function */
+#define PCM_CTL_FLUSH           (1 << 4)  /* FIFO flush */
+#define PCM_CTL_RST             (1 << 3)  /* Reset PCM */
+#define PCM_CTL_CLKEN           (1 << 1)  /* Enable the clock division logic */
+#define PCM_CTL_PCMEN           (1 << 0)  /* Enable PCM module */
+
+/* PCM Controller configure Register (PCM_CFG) */
+
+#define PCM_CFG_SLOT_BIT        13
+#define PCM_CFG_SLOT_MASK       (0x3 << PCM_CFG_SLOT_BIT)
+  #define PCM_CFG_SLOT_0	  (0 << PCM_CFG_SLOT_BIT) /* Slot is 0 */
+  #define PCM_CFG_SLOT_1	  (1 << PCM_CFG_SLOT_BIT) /* Slot is 1 */
+  #define PCM_CFG_SLOT_2	  (2 << PCM_CFG_SLOT_BIT) /* Slot is 2 */
+  #define PCM_CFG_SLOT_3	  (3 << PCM_CFG_SLOT_BIT) /* Slot is 3 */
+#define PCM_CFG_ISS_BIT         12
+#define PCM_CFG_ISS_MASK        (0x1 << PCM_CFG_ISS_BIT)
+  #define PCM_CFG_ISS_8           (0 << PCM_CFG_ISS_BIT)
+  #define PCM_CFG_ISS_16          (1 << PCM_CFG_ISS_BIT)
+#define PCM_CFG_OSS_BIT         11
+#define PCM_CFG_OSS_MASK        (0x1 << PCM_CFG_OSS_BIT)
+  #define PCM_CFG_OSS_8           (0 << PCM_CFG_OSS_BIT)
+  #define PCM_CFG_OSS_16          (1 << PCM_CFG_OSS_BIT)
+#define PCM_CFG_IMSBPOS         (1 << 10)
+#define PCM_CFG_OMSBPOS         (1 << 9)
+#define	PCM_CFG_RFTH_BIT	5        /* Receive FIFO Threshold */
+#define	PCM_CFG_RFTH_MASK	(0xf << PCM_CFG_RFTH_BIT)
+#define	PCM_CFG_TFTH_BIT	1         /* Transmit FIFO Threshold */
+#define	PCM_CFG_TFTH_MASK	(0xf << PCM_CFG_TFTH_BIT)
+#define PCM_CFG_MODE            (0x0 << 0)
+
+/* PCM Controller interrupt control Register (PCM_INTC) */
+
+#define PCM_INTC_ETFS           (1 << 3)
+#define PCM_INTC_ETUR           (1 << 2)
+#define PCM_INTC_ERFS           (1 << 1)
+#define PCM_INTC_EROR           (1 << 0)
+
+/* PCM Controller interrupt status Register (PCM_INTS) */
+
+#define PCM_INTS_RSTS		(1 << 14) /* Reset or flush has not complete */
+#define PCM_INTS_TFL_BIT        9
+#define PCM_INTS_TFL_MASK       (0x1f << PCM_INTS_TFL_BIT)
+#define PCM_INTS_TFS		(1 << 8) /* Tranmit FIFO Service Request */
+#define PCM_INTS_TUR		(1 << 7) /* Transmit FIFO Under Run */
+#define PCM_INTS_RFL_BIT        2
+#define PCM_INTS_RFL_MASK       (0x1f << PCM_INTS_RFL_BIT)
+#define PCM_INTS_RFS		(1 << 1) /* Receive FIFO Service Request */
+#define PCM_INTS_ROR		(1 << 0) /* Receive FIFO Over Run */
+
+/* PCM Controller clock division Register (PCM_DIV) */
+#define PCM_DIV_SYNL_BIT        11
+#define PCM_DIV_SYNL_MASK       (0x3f << PCM_DIV_SYNL_BIT)
+#define PCM_DIV_SYNDIV_BIT      6
+#define PCM_DIV_SYNDIV_MASK     (0x1f << PCM_DIV_SYNDIV_BIT)
+#define PCM_DIV_CLKDIV_BIT      0
+#define PCM_DIV_CLKDIV_MASK     (0x3f << PCM_DIV_CLKDIV_BIT)
+
+
+/*************************************************************************
+ * I2C
+ *************************************************************************/
+#define	I2C_DR			(I2C_BASE + 0x000)
+#define	I2C_CR			(I2C_BASE + 0x004)
+#define	I2C_SR			(I2C_BASE + 0x008)
+#define	I2C_GR			(I2C_BASE + 0x00C)
+
+#define	REG_I2C_DR		REG8(I2C_DR)
+#define	REG_I2C_CR		REG8(I2C_CR)
+#define REG_I2C_SR		REG8(I2C_SR)
+#define REG_I2C_GR		REG16(I2C_GR)
+
+/* I2C Control Register (I2C_CR) */
+
+#define I2C_CR_IEN		(1 << 4)
+#define I2C_CR_STA		(1 << 3)
+#define I2C_CR_STO		(1 << 2)
+#define I2C_CR_AC		(1 << 1)
+#define I2C_CR_I2CE		(1 << 0)
+
+/* I2C Status Register (I2C_SR) */
+
+#define I2C_SR_STX		(1 << 4)
+#define I2C_SR_BUSY		(1 << 3)
+#define I2C_SR_TEND		(1 << 2)
+#define I2C_SR_DRF		(1 << 1)
+#define I2C_SR_ACKF		(1 << 0)
+
+
+/*************************************************************************
+ * SSI (Synchronous Serial Interface)
+ *************************************************************************/
+/* n = 0, 1 (SSI0, SSI1) */
+#define	SSI_DR(n)		(SSI_BASE + 0x000 + (n)*0x2000)
+#define	SSI_CR0(n)		(SSI_BASE + 0x004 + (n)*0x2000)
+#define	SSI_CR1(n)		(SSI_BASE + 0x008 + (n)*0x2000)
+#define	SSI_SR(n)		(SSI_BASE + 0x00C + (n)*0x2000)
+#define	SSI_ITR(n)		(SSI_BASE + 0x010 + (n)*0x2000)
+#define	SSI_ICR(n)		(SSI_BASE + 0x014 + (n)*0x2000)
+#define	SSI_GR(n)		(SSI_BASE + 0x018 + (n)*0x2000)
+
+#define	REG_SSI_DR(n)		REG32(SSI_DR(n))
+#define	REG_SSI_CR0(n)		REG16(SSI_CR0(n))
+#define	REG_SSI_CR1(n)		REG32(SSI_CR1(n))
+#define	REG_SSI_SR(n)		REG32(SSI_SR(n))
+#define	REG_SSI_ITR(n)		REG16(SSI_ITR(n))
+#define	REG_SSI_ICR(n)		REG8(SSI_ICR(n))
+#define	REG_SSI_GR(n)		REG16(SSI_GR(n))
+
+/* SSI Data Register (SSI_DR) */
+
+#define	SSI_DR_GPC_BIT		0
+#define	SSI_DR_GPC_MASK		(0x1ff << SSI_DR_GPC_BIT)
+
+#define SSI_MAX_FIFO_ENTRIES 	128 /* 128 txfifo and 128 rxfifo */
+
+/* SSI Control Register 0 (SSI_CR0) */
+
+#define SSI_CR0_SSIE		(1 << 15)
+#define SSI_CR0_TIE		(1 << 14)
+#define SSI_CR0_RIE		(1 << 13)
+#define SSI_CR0_TEIE		(1 << 12)
+#define SSI_CR0_REIE		(1 << 11)
+#define SSI_CR0_LOOP		(1 << 10)
+#define SSI_CR0_RFINE		(1 << 9)
+#define SSI_CR0_RFINC		(1 << 8)
+#define SSI_CR0_EACLRUN		(1 << 7) /* hardware auto clear underrun when TxFifo no empty */
+#define SSI_CR0_FSEL		(1 << 6)
+#define SSI_CR0_TFLUSH		(1 << 2)
+#define SSI_CR0_RFLUSH		(1 << 1)
+#define SSI_CR0_DISREV		(1 << 0)
+
+/* SSI Control Register 1 (SSI_CR1) */
+
+#define SSI_CR1_FRMHL_BIT	30
+#define SSI_CR1_FRMHL_MASK	(0x3 << SSI_CR1_FRMHL_BIT)
+  #define SSI_CR1_FRMHL_CELOW_CE2LOW	(0 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2LOW	(1 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is low valid */
+  #define SSI_CR1_FRMHL_CELOW_CE2HIGH	(2 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is low valid  and SSI_CE2_ is high valid */
+  #define SSI_CR1_FRMHL_CEHIGH_CE2HIGH	(3 << SSI_CR1_FRMHL_BIT) /* SSI_CE_ is high valid and SSI_CE2_ is high valid */
+#define SSI_CR1_TFVCK_BIT	28
+#define SSI_CR1_TFVCK_MASK	(0x3 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_0	  (0 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_1	  (1 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_2	  (2 << SSI_CR1_TFVCK_BIT)
+  #define SSI_CR1_TFVCK_3	  (3 << SSI_CR1_TFVCK_BIT)
+#define SSI_CR1_TCKFI_BIT	26
+#define SSI_CR1_TCKFI_MASK	(0x3 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_0	  (0 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_1	  (1 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_2	  (2 << SSI_CR1_TCKFI_BIT)
+  #define SSI_CR1_TCKFI_3	  (3 << SSI_CR1_TCKFI_BIT)
+#define SSI_CR1_LFST		(1 << 25)
+#define SSI_CR1_ITFRM		(1 << 24)
+#define SSI_CR1_UNFIN		(1 << 23)
+#define SSI_CR1_MULTS		(1 << 22)
+#define SSI_CR1_FMAT_BIT	20
+#define SSI_CR1_FMAT_MASK	(0x3 << SSI_CR1_FMAT_BIT)
+  #define SSI_CR1_FMAT_SPI	  (0 << SSI_CR1_FMAT_BIT) /* Motorolas SPI format */
+  #define SSI_CR1_FMAT_SSP	  (1 << SSI_CR1_FMAT_BIT) /* TI's SSP format */
+  #define SSI_CR1_FMAT_MW1	  (2 << SSI_CR1_FMAT_BIT) /* National Microwire 1 format */
+  #define SSI_CR1_FMAT_MW2	  (3 << SSI_CR1_FMAT_BIT) /* National Microwire 2 format */
+#define SSI_CR1_TTRG_BIT	16 /* SSI1 TX trigger */
+#define SSI_CR1_TTRG_MASK	(0xf << SSI_CR1_TTRG_BIT) 
+#define SSI_CR1_MCOM_BIT	12
+#define SSI_CR1_MCOM_MASK	(0xf << SSI_CR1_MCOM_BIT)
+  #define SSI_CR1_MCOM_1BIT	  (0x0 << SSI_CR1_MCOM_BIT) /* 1-bit command selected */
+  #define SSI_CR1_MCOM_2BIT	  (0x1 << SSI_CR1_MCOM_BIT) /* 2-bit command selected */
+  #define SSI_CR1_MCOM_3BIT	  (0x2 << SSI_CR1_MCOM_BIT) /* 3-bit command selected */
+  #define SSI_CR1_MCOM_4BIT	  (0x3 << SSI_CR1_MCOM_BIT) /* 4-bit command selected */
+  #define SSI_CR1_MCOM_5BIT	  (0x4 << SSI_CR1_MCOM_BIT) /* 5-bit command selected */
+  #define SSI_CR1_MCOM_6BIT	  (0x5 << SSI_CR1_MCOM_BIT) /* 6-bit command selected */
+  #define SSI_CR1_MCOM_7BIT	  (0x6 << SSI_CR1_MCOM_BIT) /* 7-bit command selected */
+  #define SSI_CR1_MCOM_8BIT	  (0x7 << SSI_CR1_MCOM_BIT) /* 8-bit command selected */
+  #define SSI_CR1_MCOM_9BIT	  (0x8 << SSI_CR1_MCOM_BIT) /* 9-bit command selected */
+  #define SSI_CR1_MCOM_10BIT	  (0x9 << SSI_CR1_MCOM_BIT) /* 10-bit command selected */
+  #define SSI_CR1_MCOM_11BIT	  (0xA << SSI_CR1_MCOM_BIT) /* 11-bit command selected */
+  #define SSI_CR1_MCOM_12BIT	  (0xB << SSI_CR1_MCOM_BIT) /* 12-bit command selected */
+  #define SSI_CR1_MCOM_13BIT	  (0xC << SSI_CR1_MCOM_BIT) /* 13-bit command selected */
+  #define SSI_CR1_MCOM_14BIT	  (0xD << SSI_CR1_MCOM_BIT) /* 14-bit command selected */
+  #define SSI_CR1_MCOM_15BIT	  (0xE << SSI_CR1_MCOM_BIT) /* 15-bit command selected */
+  #define SSI_CR1_MCOM_16BIT	  (0xF << SSI_CR1_MCOM_BIT) /* 16-bit command selected */
+#define SSI_CR1_RTRG_BIT	8 /* SSI RX trigger */
+#define SSI_CR1_RTRG_MASK	(0xf << SSI_CR1_RTRG_BIT)
+#define SSI_CR1_FLEN_BIT	4
+#define SSI_CR1_FLEN_MASK	(0xf << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_2BIT	  (0x0 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_3BIT	  (0x1 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_4BIT	  (0x2 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_5BIT	  (0x3 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_6BIT	  (0x4 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_7BIT	  (0x5 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_8BIT	  (0x6 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_9BIT	  (0x7 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_10BIT	  (0x8 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_11BIT	  (0x9 << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_12BIT	  (0xA << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_13BIT	  (0xB << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_14BIT	  (0xC << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_15BIT	  (0xD << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_16BIT	  (0xE << SSI_CR1_FLEN_BIT)
+  #define SSI_CR1_FLEN_17BIT	  (0xF << SSI_CR1_FLEN_BIT)
+#define SSI_CR1_PHA		(1 << 1)
+#define SSI_CR1_POL		(1 << 0)
+
+/* SSI Status Register (SSI_SR) */
+
+#define SSI_SR_TFIFONUM_BIT	16
+#define SSI_SR_TFIFONUM_MASK	(0xff << SSI_SR_TFIFONUM_BIT)
+#define SSI_SR_RFIFONUM_BIT	8
+#define SSI_SR_RFIFONUM_MASK	(0xff << SSI_SR_RFIFONUM_BIT)
+#define SSI_SR_END		(1 << 7)
+#define SSI_SR_BUSY		(1 << 6)
+#define SSI_SR_TFF		(1 << 5)
+#define SSI_SR_RFE		(1 << 4)
+#define SSI_SR_TFHE		(1 << 3)
+#define SSI_SR_RFHF		(1 << 2)
+#define SSI_SR_UNDR		(1 << 1)
+#define SSI_SR_OVER		(1 << 0)
+
+/* SSI Interval Time Control Register (SSI_ITR) */
+
+#define	SSI_ITR_CNTCLK		(1 << 15)
+#define SSI_ITR_IVLTM_BIT	0
+#define SSI_ITR_IVLTM_MASK	(0x7fff << SSI_ITR_IVLTM_BIT)
+
+
+/*************************************************************************
+ * MSC
+ ************************************************************************/
+/* n = 0, 1 (MSC0, MSC1) */
+#define	MSC_STRPCL(n)		(MSC_BASE + (n)*0x1000 + 0x000)
+#define	MSC_STAT(n)		(MSC_BASE + (n)*0x1000 + 0x004)
+#define	MSC_CLKRT(n)		(MSC_BASE + (n)*0x1000 + 0x008)
+#define	MSC_CMDAT(n)		(MSC_BASE + (n)*0x1000 + 0x00C)
+#define	MSC_RESTO(n)		(MSC_BASE + (n)*0x1000 + 0x010)
+#define	MSC_RDTO(n)		(MSC_BASE + (n)*0x1000 + 0x014)
+#define	MSC_BLKLEN(n)		(MSC_BASE + (n)*0x1000 + 0x018)
+#define	MSC_NOB(n)		(MSC_BASE + (n)*0x1000 + 0x01C)
+#define	MSC_SNOB(n)		(MSC_BASE + (n)*0x1000 + 0x020)
+#define	MSC_IMASK(n)		(MSC_BASE + (n)*0x1000 + 0x024)
+#define	MSC_IREG(n)		(MSC_BASE + (n)*0x1000 + 0x028)
+#define	MSC_CMD(n)		(MSC_BASE + (n)*0x1000 + 0x02C)
+#define	MSC_ARG(n)		(MSC_BASE + (n)*0x1000 + 0x030)
+#define	MSC_RES(n)		(MSC_BASE + (n)*0x1000 + 0x034)
+#define	MSC_RXFIFO(n)		(MSC_BASE + (n)*0x1000 + 0x038)
+#define	MSC_TXFIFO(n)		(MSC_BASE + (n)*0x1000 + 0x03C)
+#define	MSC_LPM(n)		(MSC_BASE + (n)*0x1000 + 0x040)
+
+#define	REG_MSC_STRPCL(n)	REG16(MSC_STRPCL(n))
+#define	REG_MSC_STAT(n)		REG32(MSC_STAT(n))
+#define	REG_MSC_CLKRT(n)	REG16(MSC_CLKRT(n))
+#define	REG_MSC_CMDAT(n)	REG32(MSC_CMDAT(n))
+#define	REG_MSC_RESTO(n)	REG16(MSC_RESTO(n))
+#define	REG_MSC_RDTO(n)		REG16(MSC_RDTO(n))
+#define	REG_MSC_BLKLEN(n)	REG16(MSC_BLKLEN(n))
+#define	REG_MSC_NOB(n)		REG16(MSC_NOB(n))
+#define	REG_MSC_SNOB(n)		REG16(MSC_SNOB(n))
+#define	REG_MSC_IMASK(n)	REG32(MSC_IMASK(n))
+#define	REG_MSC_IREG(n)		REG16(MSC_IREG(n))
+#define	REG_MSC_CMD(n)		REG8(MSC_CMD(n))
+#define	REG_MSC_ARG(n)		REG32(MSC_ARG(n))
+#define	REG_MSC_RES(n)		REG16(MSC_RES(n))
+#define	REG_MSC_RXFIFO(n)	REG32(MSC_RXFIFO(n))
+#define	REG_MSC_TXFIFO(n)	REG32(MSC_TXFIFO(n))
+#define	REG_MSC_LPM(n)		REG32(MSC_LPM(n))
+
+/* MSC Clock and Control Register (MSC_STRPCL) */
+#define MSC_STRPCL_SEND_CCSD		(1 << 15) /*send command completion signal disable to ceata */
+#define MSC_STRPCL_SEND_AS_CCSD		(1 << 14) /*send internally generated stop after sending ccsd */
+#define MSC_STRPCL_EXIT_MULTIPLE	(1 << 7)
+#define MSC_STRPCL_EXIT_TRANSFER	(1 << 6)
+#define MSC_STRPCL_START_READWAIT	(1 << 5)
+#define MSC_STRPCL_STOP_READWAIT	(1 << 4)
+#define MSC_STRPCL_RESET		(1 << 3)
+#define MSC_STRPCL_START_OP		(1 << 2)
+#define MSC_STRPCL_CLOCK_CONTROL_BIT	0
+#define MSC_STRPCL_CLOCK_CONTROL_MASK	(0x3 << MSC_STRPCL_CLOCK_CONTROL_BIT)
+  #define MSC_STRPCL_CLOCK_CONTROL_STOP	  (0x1 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Stop MMC/SD clock */
+  #define MSC_STRPCL_CLOCK_CONTROL_START  (0x2 << MSC_STRPCL_CLOCK_CONTROL_BIT) /* Start MMC/SD clock */
+
+/* MSC Status Register (MSC_STAT) */
+#define MSC_STAT_AUTO_CMD_DONE		(1 << 31) /*12 is internally generated by controller has finished */
+#define MSC_STAT_IS_RESETTING		(1 << 15)
+#define MSC_STAT_SDIO_INT_ACTIVE	(1 << 14)
+#define MSC_STAT_PRG_DONE		(1 << 13)
+#define MSC_STAT_DATA_TRAN_DONE		(1 << 12)
+#define MSC_STAT_END_CMD_RES		(1 << 11)
+#define MSC_STAT_DATA_FIFO_AFULL	(1 << 10)
+#define MSC_STAT_IS_READWAIT		(1 << 9)
+#define MSC_STAT_CLK_EN			(1 << 8)
+#define MSC_STAT_DATA_FIFO_FULL		(1 << 7)
+#define MSC_STAT_DATA_FIFO_EMPTY	(1 << 6)
+#define MSC_STAT_CRC_RES_ERR		(1 << 5)
+#define MSC_STAT_CRC_READ_ERROR		(1 << 4)
+#define MSC_STAT_CRC_WRITE_ERROR_BIT	2
+#define MSC_STAT_CRC_WRITE_ERROR_MASK	(0x3 << MSC_STAT_CRC_WRITE_ERROR_BIT)
+  #define MSC_STAT_CRC_WRITE_ERROR_NO		(0 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No error on transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR		(1 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* Card observed erroneous transmission of data */
+  #define MSC_STAT_CRC_WRITE_ERROR_NOSTS	(2 << MSC_STAT_CRC_WRITE_ERROR_BIT) /* No CRC status is sent back */
+#define MSC_STAT_TIME_OUT_RES		(1 << 1)
+#define MSC_STAT_TIME_OUT_READ		(1 << 0)
+
+/* MSC Bus Clock Control Register (MSC_CLKRT) */
+#define	MSC_CLKRT_CLK_RATE_BIT		0
+#define	MSC_CLKRT_CLK_RATE_MASK		(0x7 << MSC_CLKRT_CLK_RATE_BIT)
+  #define MSC_CLKRT_CLK_RATE_DIV_1	(0x0 << MSC_CLKRT_CLK_RATE_BIT) /* CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_2	(0x1 << MSC_CLKRT_CLK_RATE_BIT) /* 1/2 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_4	(0x2 << MSC_CLKRT_CLK_RATE_BIT) /* 1/4 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_8	(0x3 << MSC_CLKRT_CLK_RATE_BIT) /* 1/8 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_16	(0x4 << MSC_CLKRT_CLK_RATE_BIT) /* 1/16 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_32	(0x5 << MSC_CLKRT_CLK_RATE_BIT) /* 1/32 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_64	(0x6 << MSC_CLKRT_CLK_RATE_BIT) /* 1/64 of CLK_SRC */
+  #define MSC_CLKRT_CLK_RATE_DIV_128	(0x7 << MSC_CLKRT_CLK_RATE_BIT) /* 1/128 of CLK_SRC */
+
+/* MSC Command Sequence Control Register (MSC_CMDAT) */
+#define	MSC_CMDAT_CCS_EXPECTED		(1 << 31) /* interrupts are enabled in ce-ata */
+#define	MSC_CMDAT_READ_CEATA		(1 << 30)
+#define	MSC_CMDAT_SDIO_PRDT		(1 << 17) /* exact 2 cycle */
+#define	MSC_CMDAT_SEND_AS_STOP		(1 << 16)
+#define	MSC_CMDAT_RTRG_BIT		14
+  #define MSC_CMDAT_RTRG_EQUALT_8	(0x0 << MSC_CMDAT_RTRG_BIT)
+  #define MSC_CMDAT_RTRG_EQUALT_16	(0x1 << MSC_CMDAT_RTRG_BIT) /* reset value */
+  #define MSC_CMDAT_RTRG_EQUALT_24	(0x2 << MSC_CMDAT_RTRG_BIT)
+
+#define	MSC_CMDAT_TTRG_BIT		12
+  #define MSC_CMDAT_TTRG_LESS_8		(0x0 << MSC_CMDAT_TTRG_BIT)
+  #define MSC_CMDAT_TTRG_LESS_16	(0x1 << MSC_CMDAT_TTRG_BIT) /*reset value  */
+  #define MSC_CMDAT_TTRG_LESS_24	(0x2 << MSC_CMDAT_TTRG_BIT)
+#define	MSC_CMDAT_STOP_ABORT		(1 << 11)
+#define	MSC_CMDAT_BUS_WIDTH_BIT		9
+#define	MSC_CMDAT_BUS_WIDTH_MASK	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT)
+  #define MSC_CMDAT_BUS_WIDTH_1BIT	(0x0 << MSC_CMDAT_BUS_WIDTH_BIT) /* 1-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_4BIT	(0x2 << MSC_CMDAT_BUS_WIDTH_BIT) /* 4-bit data bus */
+  #define MSC_CMDAT_BUS_WIDTH_8BIT	(0x3 << MSC_CMDAT_BUS_WIDTH_BIT) /* 8-bit data bus */
+#define	MSC_CMDAT_DMA_EN		(1 << 8)
+#define	MSC_CMDAT_INIT			(1 << 7)
+#define	MSC_CMDAT_BUSY			(1 << 6)
+#define	MSC_CMDAT_STREAM_BLOCK		(1 << 5)
+#define	MSC_CMDAT_WRITE			(1 << 4)
+#define	MSC_CMDAT_READ			(0 << 4)
+#define	MSC_CMDAT_DATA_EN		(1 << 3)
+#define	MSC_CMDAT_RESPONSE_BIT	0
+#define	MSC_CMDAT_RESPONSE_MASK	(0x7 << MSC_CMDAT_RESPONSE_BIT)
+  #define MSC_CMDAT_RESPONSE_NONE (0x0 << MSC_CMDAT_RESPONSE_BIT) /* No response */
+  #define MSC_CMDAT_RESPONSE_R1	  (0x1 << MSC_CMDAT_RESPONSE_BIT) /* Format R1 and R1b */
+  #define MSC_CMDAT_RESPONSE_R2	  (0x2 << MSC_CMDAT_RESPONSE_BIT) /* Format R2 */
+  #define MSC_CMDAT_RESPONSE_R3	  (0x3 << MSC_CMDAT_RESPONSE_BIT) /* Format R3 */
+  #define MSC_CMDAT_RESPONSE_R4	  (0x4 << MSC_CMDAT_RESPONSE_BIT) /* Format R4 */
+  #define MSC_CMDAT_RESPONSE_R5	  (0x5 << MSC_CMDAT_RESPONSE_BIT) /* Format R5 */
+  #define MSC_CMDAT_RESPONSE_R6	  (0x6 << MSC_CMDAT_RESPONSE_BIT) /* Format R6 */
+
+#define	CMDAT_DMA_EN	(1 << 8)
+#define	CMDAT_INIT	(1 << 7)
+#define	CMDAT_BUSY	(1 << 6)
+#define	CMDAT_STREAM	(1 << 5)
+#define	CMDAT_WRITE	(1 << 4)
+#define	CMDAT_DATA_EN	(1 << 3)
+
+/* MSC Interrupts Mask Register (MSC_IMASK) */
+#define	MSC_IMASK_AUTO_CMD_DONE		(1 << 8)
+#define	MSC_IMASK_SDIO			(1 << 7)
+#define	MSC_IMASK_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IMASK_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IMASK_END_CMD_RES		(1 << 2)
+#define	MSC_IMASK_PRG_DONE		(1 << 1)
+#define	MSC_IMASK_DATA_TRAN_DONE	(1 << 0)
+
+/* MSC Interrupts Status Register (MSC_IREG) */
+#define	MSC_IREG_AUTO_CMD_DONE		(1 << 8)
+#define	MSC_IREG_SDIO			(1 << 7)
+#define	MSC_IREG_TXFIFO_WR_REQ		(1 << 6)
+#define	MSC_IREG_RXFIFO_RD_REQ		(1 << 5)
+#define	MSC_IREG_END_CMD_RES		(1 << 2)
+#define	MSC_IREG_PRG_DONE		(1 << 1)
+#define	MSC_IREG_DATA_TRAN_DONE		(1 << 0)
+
+/* MSC Low Power Mode Register (MSC_LPM) */
+#define	MSC_SET_LPM			(1 << 0)
+
+/*************************************************************************
+ * EMC (External Memory Controller)
+ *************************************************************************/
+#define EMC_BCR    	(EMC_BASE + 0x00)  /* Bus Control Register */
+#define EMC_SMCR0	(EMC_BASE + 0x10)  /* Static Memory Control Register 0 */
+#define EMC_SMCR1	(EMC_BASE + 0x14)  /* Static Memory Control Register 1 */
+#define EMC_SMCR2	(EMC_BASE + 0x18)  /* Static Memory Control Register 2 */
+#define EMC_SMCR3	(EMC_BASE + 0x1c)  /* Static Memory Control Register 3 */
+#define EMC_SMCR4	(EMC_BASE + 0x20)  /* Static Memory Control Register 4 */
+#define EMC_SACR0	(EMC_BASE + 0x30)  /* Static Memory Bank 0 Addr Config Reg */
+#define EMC_SACR1	(EMC_BASE + 0x34)  /* Static Memory Bank 1 Addr Config Reg */
+#define EMC_SACR2	(EMC_BASE + 0x38)  /* Static Memory Bank 2 Addr Config Reg */
+#define EMC_SACR3	(EMC_BASE + 0x3c)  /* Static Memory Bank 3 Addr Config Reg */
+#define EMC_SACR4	(EMC_BASE + 0x40)  /* Static Memory Bank 4 Addr Config Reg */
+
+#define EMC_NFCSR	(EMC_BASE + 0x050) /* NAND Flash Control/Status Register */
+
+#define EMC_DMCR	(EMC_BASE + 0x80)  /* DRAM Control Register */
+#define EMC_RTCSR	(EMC_BASE + 0x84)  /* Refresh Time Control/Status Register */
+#define EMC_RTCNT	(EMC_BASE + 0x88)  /* Refresh Timer Counter */
+#define EMC_RTCOR	(EMC_BASE + 0x8c)  /* Refresh Time Constant Register */
+#define EMC_DMAR0	(EMC_BASE + 0x90)  /* SDRAM Bank 0 Addr Config Register */
+#define EMC_DMAR1	(EMC_BASE + 0x94)  /* SDRAM Bank 1 Addr Config Register */
+#define EMC_SDMR0	(EMC_BASE + 0xa000) /* Mode Register of SDRAM bank 0 */
+
+#define REG_EMC_BCR 	REG32(EMC_BCR)
+#define REG_EMC_SMCR0	REG32(EMC_SMCR0)
+#define REG_EMC_SMCR1	REG32(EMC_SMCR1)
+#define REG_EMC_SMCR2	REG32(EMC_SMCR2)
+#define REG_EMC_SMCR3	REG32(EMC_SMCR3)
+#define REG_EMC_SMCR4	REG32(EMC_SMCR4)
+#define REG_EMC_SACR0	REG32(EMC_SACR0)
+#define REG_EMC_SACR1	REG32(EMC_SACR1)
+#define REG_EMC_SACR2	REG32(EMC_SACR2)
+#define REG_EMC_SACR3	REG32(EMC_SACR3)
+#define REG_EMC_SACR4	REG32(EMC_SACR4)
+
+#define REG_EMC_NFCSR	REG32(EMC_NFCSR)
+
+#define REG_EMC_DMCR	REG32(EMC_DMCR)
+#define REG_EMC_RTCSR	REG16(EMC_RTCSR)
+#define REG_EMC_RTCNT	REG16(EMC_RTCNT)
+#define REG_EMC_RTCOR	REG16(EMC_RTCOR)
+#define REG_EMC_DMAR0	REG32(EMC_DMAR0)
+#define REG_EMC_DMAR1	REG32(EMC_DMAR1)
+
+/* Bus Control Register */
+#define EMC_BCR_BT_SEL_BIT      30
+#define EMC_BCR_BT_SEL_MASK     (0x3 << EMC_BCR_BT_SEL_BIT)
+#define EMC_BCR_PK_SEL          (1 << 24)
+#define EMC_BCR_BSR_MASK          (1 << 2)  /* Nand and SDRAM Bus Share Select: 0, share; 1, unshare */
+  #define EMC_BCR_BSR_SHARE       (0 << 2)
+  #define EMC_BCR_BSR_UNSHARE     (1 << 2)
+#define EMC_BCR_BRE             (1 << 1)
+#define EMC_BCR_ENDIAN          (1 << 0)
+
+/* Static Memory Control Register */
+#define EMC_SMCR_STRV_BIT	24
+#define EMC_SMCR_STRV_MASK	(0x0f << EMC_SMCR_STRV_BIT)
+#define EMC_SMCR_TAW_BIT	20
+#define EMC_SMCR_TAW_MASK	(0x0f << EMC_SMCR_TAW_BIT)
+#define EMC_SMCR_TBP_BIT	16
+#define EMC_SMCR_TBP_MASK	(0x0f << EMC_SMCR_TBP_BIT)
+#define EMC_SMCR_TAH_BIT	12
+#define EMC_SMCR_TAH_MASK	(0x07 << EMC_SMCR_TAH_BIT)
+#define EMC_SMCR_TAS_BIT	8
+#define EMC_SMCR_TAS_MASK	(0x07 << EMC_SMCR_TAS_BIT)
+#define EMC_SMCR_BW_BIT		6
+#define EMC_SMCR_BW_MASK	(0x03 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_8BIT	(0 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_16BIT	(1 << EMC_SMCR_BW_BIT)
+  #define EMC_SMCR_BW_32BIT	(2 << EMC_SMCR_BW_BIT)
+#define EMC_SMCR_BCM		(1 << 3)
+#define EMC_SMCR_BL_BIT		1
+#define EMC_SMCR_BL_MASK	(0x03 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_4		(0 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_8		(1 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_16	(2 << EMC_SMCR_BL_BIT)
+  #define EMC_SMCR_BL_32	(3 << EMC_SMCR_BL_BIT)
+#define EMC_SMCR_SMT		(1 << 0)
+
+/* Static Memory Bank Addr Config Reg */
+#define EMC_SACR_BASE_BIT	8
+#define EMC_SACR_BASE_MASK	(0xff << EMC_SACR_BASE_BIT)
+#define EMC_SACR_MASK_BIT	0
+#define EMC_SACR_MASK_MASK	(0xff << EMC_SACR_MASK_BIT)
+
+/* NAND Flash Control/Status Register */
+#define EMC_NFCSR_NFCE4		(1 << 7) /* NAND Flash Enable */
+#define EMC_NFCSR_NFE4		(1 << 6) /* NAND Flash FCE# Assertion Enable */
+#define EMC_NFCSR_NFCE3		(1 << 5)
+#define EMC_NFCSR_NFE3		(1 << 4)
+#define EMC_NFCSR_NFCE2		(1 << 3)
+#define EMC_NFCSR_NFE2		(1 << 2)
+#define EMC_NFCSR_NFCE1		(1 << 1)
+#define EMC_NFCSR_NFE1		(1 << 0)
+
+/* DRAM Control Register */
+#define EMC_DMCR_BW_BIT		31
+#define EMC_DMCR_BW		(1 << EMC_DMCR_BW_BIT)
+#define EMC_DMCR_CA_BIT		26
+#define EMC_DMCR_CA_MASK	(0x07 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_8		(0 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_9		(1 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_10	(2 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_11	(3 << EMC_DMCR_CA_BIT)
+  #define EMC_DMCR_CA_12	(4 << EMC_DMCR_CA_BIT)
+#define EMC_DMCR_RMODE		(1 << 25)
+#define EMC_DMCR_RFSH		(1 << 24)
+#define EMC_DMCR_MRSET		(1 << 23)
+#define EMC_DMCR_RA_BIT		20
+#define EMC_DMCR_RA_MASK	(0x03 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_11	(0 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_12	(1 << EMC_DMCR_RA_BIT)
+  #define EMC_DMCR_RA_13	(2 << EMC_DMCR_RA_BIT)
+#define EMC_DMCR_BA_BIT		19
+#define EMC_DMCR_BA		(1 << EMC_DMCR_BA_BIT)
+#define EMC_DMCR_PDM		(1 << 18)
+#define EMC_DMCR_EPIN		(1 << 17)
+#define EMC_DMCR_MBSEL		(1 << 16)
+#define EMC_DMCR_TRAS_BIT	13
+#define EMC_DMCR_TRAS_MASK	(0x07 << EMC_DMCR_TRAS_BIT)
+#define EMC_DMCR_RCD_BIT	11
+#define EMC_DMCR_RCD_MASK	(0x03 << EMC_DMCR_RCD_BIT)
+#define EMC_DMCR_TPC_BIT	8
+#define EMC_DMCR_TPC_MASK	(0x07 << EMC_DMCR_TPC_BIT)
+#define EMC_DMCR_TRWL_BIT	5
+#define EMC_DMCR_TRWL_MASK	(0x03 << EMC_DMCR_TRWL_BIT)
+#define EMC_DMCR_TRC_BIT	2
+#define EMC_DMCR_TRC_MASK	(0x07 << EMC_DMCR_TRC_BIT)
+#define EMC_DMCR_TCL_BIT	0
+#define EMC_DMCR_TCL_MASK	(0x03 << EMC_DMCR_TCL_BIT)
+
+/* Refresh Time Control/Status Register */
+#define EMC_RTCSR_SFR		(1 << 8)    /* self refresh flag */
+#define EMC_RTCSR_CMF		(1 << 7)
+#define EMC_RTCSR_CKS_BIT	0
+#define EMC_RTCSR_CKS_MASK	(0x07 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_DISABLE	(0 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4	(1 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_16	(2 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_64	(3 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_256	(4 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_1024	(5 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_2048	(6 << EMC_RTCSR_CKS_BIT)
+  #define EMC_RTCSR_CKS_4096	(7 << EMC_RTCSR_CKS_BIT)
+
+/* SDRAM Bank Address Configuration Register */
+#define EMC_DMAR_BASE_BIT	8
+#define EMC_DMAR_BASE_MASK	(0xff << EMC_DMAR_BASE_BIT)
+#define EMC_DMAR_MASK_BIT	0
+#define EMC_DMAR_MASK_MASK	(0xff << EMC_DMAR_MASK_BIT)
+
+/* Mode Register of SDRAM bank 0 */
+#define EMC_SDMR_BM		(1 << 9) /* Write Burst Mode */
+#define EMC_SDMR_OM_BIT		7        /* Operating Mode */
+#define EMC_SDMR_OM_MASK	(3 << EMC_SDMR_OM_BIT)
+  #define EMC_SDMR_OM_NORMAL	(0 << EMC_SDMR_OM_BIT)
+#define EMC_SDMR_CAS_BIT	4        /* CAS Latency */
+#define EMC_SDMR_CAS_MASK	(7 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_1	(1 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_2	(2 << EMC_SDMR_CAS_BIT)
+  #define EMC_SDMR_CAS_3	(3 << EMC_SDMR_CAS_BIT)
+#define EMC_SDMR_BT_BIT		3        /* Burst Type */
+#define EMC_SDMR_BT_MASK	(1 << EMC_SDMR_BT_BIT)
+  #define EMC_SDMR_BT_SEQ	(0 << EMC_SDMR_BT_BIT) /* Sequential */
+  #define EMC_SDMR_BT_INT	(1 << EMC_SDMR_BT_BIT) /* Interleave */
+#define EMC_SDMR_BL_BIT		0        /* Burst Length */
+#define EMC_SDMR_BL_MASK	(7 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_1		(0 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_2		(1 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_4		(2 << EMC_SDMR_BL_BIT)
+  #define EMC_SDMR_BL_8		(3 << EMC_SDMR_BL_BIT)
+
+#define EMC_SDMR_CAS2_16BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS2_32BIT \
+  (EMC_SDMR_CAS_2 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+#define EMC_SDMR_CAS3_16BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_2)
+#define EMC_SDMR_CAS3_32BIT \
+  (EMC_SDMR_CAS_3 | EMC_SDMR_BT_SEQ | EMC_SDMR_BL_4)
+
+
+/*************************************************************************
+ * CIM
+ *************************************************************************/
+#define	CIM_CFG			(CIM_BASE + 0x0000)
+#define	CIM_CTRL		(CIM_BASE + 0x0004)
+#define	CIM_STATE		(CIM_BASE + 0x0008)
+#define	CIM_IID			(CIM_BASE + 0x000C)
+#define	CIM_RXFIFO		(CIM_BASE + 0x0010)
+#define	CIM_DA			(CIM_BASE + 0x0020)
+#define	CIM_FA			(CIM_BASE + 0x0024)
+#define	CIM_FID			(CIM_BASE + 0x0028)
+#define	CIM_CMD			(CIM_BASE + 0x002C)
+#define	CIM_SIZE		(CIM_BASE + 0x0030)
+#define	CIM_OFFSET		(CIM_BASE + 0x0034)
+#define	CIM_RAM_ADDR		(CIM_BASE + 0x1000)
+
+#define	REG_CIM_CFG		REG32(CIM_CFG)
+#define	REG_CIM_CTRL		REG32(CIM_CTRL)
+#define	REG_CIM_STATE		REG32(CIM_STATE)
+#define	REG_CIM_IID		REG32(CIM_IID)
+#define	REG_CIM_RXFIFO		REG32(CIM_RXFIFO)
+#define	REG_CIM_DA		REG32(CIM_DA)
+#define	REG_CIM_FA		REG32(CIM_FA)
+#define	REG_CIM_FID		REG32(CIM_FID)
+#define	REG_CIM_CMD		REG32(CIM_CMD)
+#define	REG_CIM_SIZE		REG32(CIM_SIZE)
+#define	REG_CIM_OFFSET		REG32(CIM_OFFSET)
+
+#define	CIM_CFG_ORDER_BIT	18
+#define	CIM_CFG_ORDER_MASK	(0x3 << CIM_CFG_ORDER_BIT)
+  #define CIM_CFG_ORDER_0	  (0x0 << CIM_CFG_ORDER_BIT) 	/* Y0CbY1Cr; YCbCr */
+  #define CIM_CFG_ORDER_1	  (0x1 << CIM_CFG_ORDER_BIT)	/* Y0CrY1Cb; YCrCb */
+  #define CIM_CFG_ORDER_2	  (0x2 << CIM_CFG_ORDER_BIT)	/* CbY0CrY1; CbCrY */
+  #define CIM_CFG_ORDER_3	  (0x3 << CIM_CFG_ORDER_BIT)	/* CrY0CbY1; CrCbY */
+#define	CIM_CFG_DF_BIT		16
+#define	CIM_CFG_DF_MASK		  (0x3 << CIM_CFG_DF_BIT)
+  #define CIM_CFG_DF_YUV444	  (0x1 << CIM_CFG_DF_BIT) 	/* YCbCr444 */
+  #define CIM_CFG_DF_YUV422	  (0x2 << CIM_CFG_DF_BIT)	/* YCbCr422 */
+  #define CIM_CFG_DF_ITU656	  (0x3 << CIM_CFG_DF_BIT)	/* ITU656 YCbCr422 */
+#define	CIM_CFG_INV_DAT		(1 << 15)
+#define	CIM_CFG_VSP		(1 << 14) /* VSYNC Polarity:0-rising edge active,1-falling edge active */
+#define	CIM_CFG_HSP		(1 << 13) /* HSYNC Polarity:0-rising edge active,1-falling edge active */
+#define	CIM_CFG_PCP		(1 << 12) /* PCLK working edge: 0-rising, 1-falling */
+#define	CIM_CFG_DMA_BURST_TYPE_BIT	10
+#define	CIM_CFG_DMA_BURST_TYPE_MASK	(0x3 << CIM_CFG_DMA_BURST_TYPE_BIT)
+  #define	CIM_CFG_DMA_BURST_INCR4		(0 << CIM_CFG_DMA_BURST_TYPE_BIT)
+  #define	CIM_CFG_DMA_BURT_INCR8		(1 << CIM_CFG_DMA_BURST_TYPE_BIT)	/* Suggested */
+  #define	CIM_CFG_DMA_BURT_INCR16	(2 << CIM_CFG_DMA_BURST_TYPE_BIT)	/* Suggested High speed AHB*/
+#define	CIM_CFG_DUMMY_ZERO	(1 << 9)
+#define	CIM_CFG_EXT_VSYNC	(1 << 8)	/* Only for ITU656 Progressive mode */
+#define	CIM_CFG_PACK_BIT	4
+#define	CIM_CFG_PACK_MASK	(0x7 << CIM_CFG_PACK_BIT)
+  #define CIM_CFG_PACK_0	  (0 << CIM_CFG_PACK_BIT) /* 11 22 33 44 0xY0CbY1Cr */
+  #define CIM_CFG_PACK_1	  (1 << CIM_CFG_PACK_BIT) /* 22 33 44 11 0xCbY1CrY0 */
+  #define CIM_CFG_PACK_2	  (2 << CIM_CFG_PACK_BIT) /* 33 44 11 22 0xY1CrY0Cb */
+  #define CIM_CFG_PACK_3	  (3 << CIM_CFG_PACK_BIT) /* 44 11 22 33 0xCrY0CbY1 */
+  #define CIM_CFG_PACK_4	  (4 << CIM_CFG_PACK_BIT) /* 44 33 22 11 0xCrY1CbY0 */
+  #define CIM_CFG_PACK_5	  (5 << CIM_CFG_PACK_BIT) /* 33 22 11 44 0xY1CbY0Cr */
+  #define CIM_CFG_PACK_6	  (6 << CIM_CFG_PACK_BIT) /* 22 11 44 33 0xCbY0CrY1 */
+  #define CIM_CFG_PACK_7	  (7 << CIM_CFG_PACK_BIT) /* 11 44 33 22 0xY0CrY1Cb */
+#define	CIM_CFG_BYPASS_BIT	2
+#define	CIM_CFG_BYPASS_MASK	(1 << CIM_CFG_BYPASS_BIT)
+  #define CIM_CFG_BYPASS	  (1 << CIM_CFG_BYPASS_BIT)
+#define	CIM_CFG_DSM_BIT		0
+#define	CIM_CFG_DSM_MASK	(0x3 << CIM_CFG_DSM_BIT)
+  #define CIM_CFG_DSM_CPM	  (0 << CIM_CFG_DSM_BIT) /* CCIR656 Progressive Mode */
+  #define CIM_CFG_DSM_CIM	  (1 << CIM_CFG_DSM_BIT) /* CCIR656 Interlace Mode */
+  #define CIM_CFG_DSM_GCM	  (2 << CIM_CFG_DSM_BIT) /* Gated Clock Mode */
+
+/* CIM Control Register  (CIM_CTRL) */
+#define	CIM_CTRL_EEOF_LINE_BIT	20
+#define	CIM_CTRL_EEOF_LINE_MASK	(0xfff << CIM_CTRL_MCLKDIV_BIT)
+#define	CIM_CTRL_FRC_BIT	16
+#define	CIM_CTRL_FRC_MASK	(0xf << CIM_CTRL_FRC_BIT)
+  #define CIM_CTRL_FRC_1	  (0x0 << CIM_CTRL_FRC_BIT) /* Sample every frame */
+  #define CIM_CTRL_FRC_2	  (0x1 << CIM_CTRL_FRC_BIT) /* Sample 1/2 frame */
+  #define CIM_CTRL_FRC_3	  (0x2 << CIM_CTRL_FRC_BIT) /* Sample 1/3 frame */
+  #define CIM_CTRL_FRC_4	  (0x3 << CIM_CTRL_FRC_BIT) /* Sample 1/4 frame */
+  #define CIM_CTRL_FRC_5	  (0x4 << CIM_CTRL_FRC_BIT) /* Sample 1/5 frame */
+  #define CIM_CTRL_FRC_6	  (0x5 << CIM_CTRL_FRC_BIT) /* Sample 1/6 frame */
+  #define CIM_CTRL_FRC_7	  (0x6 << CIM_CTRL_FRC_BIT) /* Sample 1/7 frame */
+  #define CIM_CTRL_FRC_8	  (0x7 << CIM_CTRL_FRC_BIT) /* Sample 1/8 frame */
+  #define CIM_CTRL_FRC_9	  (0x8 << CIM_CTRL_FRC_BIT) /* Sample 1/9 frame */
+  #define CIM_CTRL_FRC_10	  (0x9 << CIM_CTRL_FRC_BIT) /* Sample 1/10 frame */
+  #define CIM_CTRL_FRC_11	  (0xA << CIM_CTRL_FRC_BIT) /* Sample 1/11 frame */
+  #define CIM_CTRL_FRC_12	  (0xB << CIM_CTRL_FRC_BIT) /* Sample 1/12 frame */
+  #define CIM_CTRL_FRC_13	  (0xC << CIM_CTRL_FRC_BIT) /* Sample 1/13 frame */
+  #define CIM_CTRL_FRC_14	  (0xD << CIM_CTRL_FRC_BIT) /* Sample 1/14 frame */
+  #define CIM_CTRL_FRC_15	  (0xE << CIM_CTRL_FRC_BIT) /* Sample 1/15 frame */
+  #define CIM_CTRL_FRC_16	  (0xF << CIM_CTRL_FRC_BIT) /* Sample 1/16 frame */
+
+#define	CIM_CTRL_DMA_EEOFM	(1 << 15)	/* Enable EEOF interrupt */
+#define	CIM_CTRL_WIN_EN		(1 << 14)
+#define	CIM_CTRL_VDDM		(1 << 13) /* VDD interrupt enable */
+#define	CIM_CTRL_DMA_SOFM	(1 << 12)
+#define	CIM_CTRL_DMA_EOFM	(1 << 11)
+#define	CIM_CTRL_DMA_STOPM	(1 << 10)
+#define	CIM_CTRL_RXF_TRIGM	(1 << 9)
+#define	CIM_CTRL_RXF_OFM	(1 << 8)
+#define	CIM_CTRL_DMA_SYNC	(1 << 7)	/*when change DA, do frame sync */
+#define	CIM_CTRL_RXF_TRIG_BIT	3
+#define	CIM_CTRL_RXF_TRIG_MASK	(0xf << CIM_CTRL_RXF_TRIG_BIT) /* trigger value = (n+1)*burst_type */
+#define	CIM_CTRL_DMA_EN		(1 << 2) /* Enable DMA */
+#define	CIM_CTRL_RXF_RST	(1 << 1) /* RxFIFO reset */
+#define	CIM_CTRL_ENA		(1 << 0) /* Enable CIM */
+
+/* CIM State Register  (CIM_STATE) */
+#define	CIM_STATE_DMA_EEOF	(1 << 7) /* DMA Line EEOf irq */
+#define	CIM_STATE_DMA_SOF	(1 << 6) /* DMA start irq */
+#define	CIM_STATE_DMA_EOF	(1 << 5) /* DMA end irq */
+#define	CIM_STATE_DMA_STOP	(1 << 4) /* DMA stop irq */
+#define	CIM_STATE_RXF_OF	(1 << 3) /* RXFIFO over flow irq */
+#define	CIM_STATE_RXF_TRIG	(1 << 2) /* RXFIFO triger meet irq */
+#define	CIM_STATE_RXF_EMPTY	(1 << 1) /* RXFIFO empty irq */
+#define	CIM_STATE_VDD		(1 << 0) /* CIM disabled irq */
+
+/* CIM DMA Command Register (CIM_CMD) */
+
+#define	CIM_CMD_SOFINT		(1 << 31) /* enable DMA start irq */
+#define	CIM_CMD_EOFINT		(1 << 30) /* enable DMA end irq */
+#define	CIM_CMD_EEOFINT		(1 << 29) /* enable DMA EEOF irq */
+#define	CIM_CMD_STOP		(1 << 28) /* enable DMA stop irq */
+#define	CIM_CMD_OFRCV		(1 << 27) /* enable recovery when TXFiFo overflow */
+#define	CIM_CMD_LEN_BIT		0
+#define	CIM_CMD_LEN_MASK	(0xffffff << CIM_CMD_LEN_BIT)
+
+/* CIM Window-Image Size Register  (CIM_SIZE) */
+#define	CIM_SIZE_LPF_BIT	16 /* Lines per freame for csc output image */
+#define	CIM_SIZE_LPF_MASK	(0x1fff << CIM_SIZE_LPF_BIT)
+#define	CIM_SIZE_PPL_BIT	0 /* Pixels per line for csc output image, should be an even number */
+#define	CIM_SIZE_PPL_MASK	(0x1fff << CIM_SIZE_PPL_BIT)
+
+/* CIM Image Offset Register  (CIM_OFFSET) */
+#define	CIM_OFFSET_V_BIT	16 /* Vertical offset */
+#define	CIM_OFFSET_V_MASK	(0xfff << CIM_OFFSET_V_BIT)
+#define	CIM_OFFSET_H_BIT	0 /* Horizontal offset, should be an enen number */
+#define	CIM_OFFSET_H_MASK	(0xfff << CIM_OFFSET_H_BIT) /*OFFSET_H should be even number*/
+
+/*************************************************************************
+ * SADC (Smart A/D Controller)
+ *************************************************************************/
+
+#define SADC_ENA	(SADC_BASE + 0x00)  /* ADC Enable Register */
+#define SADC_CFG	(SADC_BASE + 0x04)  /* ADC Configure Register */
+#define SADC_CTRL	(SADC_BASE + 0x08)  /* ADC Control Register */
+#define SADC_STATE	(SADC_BASE + 0x0C)  /* ADC Status Register*/
+#define SADC_SAMETIME	(SADC_BASE + 0x10)  /* ADC Same Point Time Register */
+#define SADC_WAITTIME	(SADC_BASE + 0x14)  /* ADC Wait Time Register */
+#define SADC_TSDAT	(SADC_BASE + 0x18)  /* ADC Touch Screen Data Register */
+#define SADC_BATDAT	(SADC_BASE + 0x1C)  /* ADC PBAT Data Register */
+#define SADC_SADDAT	(SADC_BASE + 0x20)  /* ADC SADCIN Data Register */
+#define SADC_ADCLK	(SADC_BASE + 0x28)  /* ADC Clock Divide Register */
+
+#define REG_SADC_ENA		REG8(SADC_ENA)
+#define REG_SADC_CFG		REG32(SADC_CFG)
+#define REG_SADC_CTRL		REG8(SADC_CTRL)
+#define REG_SADC_STATE		REG8(SADC_STATE)
+#define REG_SADC_SAMETIME	REG16(SADC_SAMETIME)
+#define REG_SADC_WAITTIME	REG16(SADC_WAITTIME)
+#define REG_SADC_TSDAT		REG32(SADC_TSDAT)
+#define REG_SADC_BATDAT		REG16(SADC_BATDAT)
+#define REG_SADC_SADDAT		REG16(SADC_SADDAT)
+#define REG_SADC_ADCLK		REG32(SADC_ADCLK)
+
+/* ADC Enable Register */
+#define SADC_ENA_ADEN		(1 << 7)  /* Touch Screen Enable */
+#define SADC_ENA_ENTR_SLP	(1 << 6)  /* Touch Screen Enable */
+#define SADC_ENA_EXIT_SLP	(1 << 5)  /* Touch Screen Enable */
+#define SADC_ENA_TSEN		(1 << 2)  /* Touch Screen Enable */
+#define SADC_ENA_PBATEN		(1 << 1)  /* PBAT Enable */
+#define SADC_ENA_SADCINEN	(1 << 0)  /* SADCIN Enable */
+
+/* ADC Configure Register */
+#define SADC_CFG_EXIN           (1 << 30)
+#define SADC_CFG_CLKOUT_NUM_BIT	16
+#define SADC_CFG_CLKOUT_NUM_MASK (0x7 << SADC_CFG_CLKOUT_NUM_BIT)
+#define SADC_CFG_TS_DMA		(1 << 15)  /* Touch Screen DMA Enable */
+#define SADC_CFG_XYZ_BIT	13  /* XYZ selection */
+#define SADC_CFG_XYZ_MASK	(0x3 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XY		(0 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ		(1 << SADC_CFG_XYZ_BIT)
+  #define SADC_CFG_XYZ1Z2	(2 << SADC_CFG_XYZ_BIT)
+#define SADC_CFG_SNUM_BIT	10  /* Sample Number */
+#define SADC_CFG_SNUM_MASK	(0x7 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_1	(0x0 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_2	(0x1 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_3	(0x2 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_4	(0x3 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_5	(0x4 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_6	(0x5 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_8	(0x6 << SADC_CFG_SNUM_BIT)
+  #define SADC_CFG_SNUM_9	(0x7 << SADC_CFG_SNUM_BIT)
+#define SADC_CFG_CLKDIV_BIT	5  /* AD Converter frequency clock divider */
+#define SADC_CFG_CLKDIV_MASK	(0x1f << SADC_CFG_CLKDIV_BIT)
+#define SADC_CFG_PBAT_HIGH	(0 << 4)  /* PBAT >= 2.5V */
+#define SADC_CFG_PBAT_LOW	(1 << 4)  /* PBAT < 2.5V */
+#define SADC_CFG_CMD_BIT	0  /* ADC Command */
+#define SADC_CFG_CMD_MASK	(0xf << SADC_CFG_CMD_BIT)
+  #define SADC_CFG_CMD_X_SE	(0x0 << SADC_CFG_CMD_BIT) /* X Single-End */
+  #define SADC_CFG_CMD_Y_SE	(0x1 << SADC_CFG_CMD_BIT) /* Y Single-End */
+  #define SADC_CFG_CMD_X_DIFF	(0x2 << SADC_CFG_CMD_BIT) /* X Differential */
+  #define SADC_CFG_CMD_Y_DIFF	(0x3 << SADC_CFG_CMD_BIT) /* Y Differential */
+  #define SADC_CFG_CMD_Z1_DIFF	(0x4 << SADC_CFG_CMD_BIT) /* Z1 Differential */
+  #define SADC_CFG_CMD_Z2_DIFF	(0x5 << SADC_CFG_CMD_BIT) /* Z2 Differential */
+  #define SADC_CFG_CMD_Z3_DIFF	(0x6 << SADC_CFG_CMD_BIT) /* Z3 Differential */
+  #define SADC_CFG_CMD_Z4_DIFF	(0x7 << SADC_CFG_CMD_BIT) /* Z4 Differential */
+  #define SADC_CFG_CMD_TP_SE	(0x8 << SADC_CFG_CMD_BIT) /* Touch Pressure */
+  #define SADC_CFG_CMD_PBATH_SE	(0x9 << SADC_CFG_CMD_BIT) /* PBAT >= 2.5V */
+  #define SADC_CFG_CMD_PBATL_SE	(0xa << SADC_CFG_CMD_BIT) /* PBAT < 2.5V */
+  #define SADC_CFG_CMD_SADCIN_SE (0xb << SADC_CFG_CMD_BIT) /* Measure SADCIN */
+  #define SADC_CFG_CMD_INT_PEN	(0xc << SADC_CFG_CMD_BIT) /* INT_PEN Enable */
+
+/* ADC Control Register */
+#define SADC_CTRL_SLPENDM	(1 << 5)  /* sleep Interrupt Mask */
+#define SADC_CTRL_PENDM		(1 << 4)  /* Pen Down Interrupt Mask */
+#define SADC_CTRL_PENUM		(1 << 3)  /* Pen Up Interrupt Mask */
+#define SADC_CTRL_TSRDYM	(1 << 2)  /* Touch Screen Data Ready Interrupt Mask */
+#define SADC_CTRL_PBATRDYM	(1 << 1)  /* PBAT Data Ready Interrupt Mask */
+#define SADC_CTRL_SRDYM		(1 << 0)  /* SADCIN Data Ready Interrupt Mask */
+
+/* ADC Status Register */
+#define SADC_STATE_SLEEPND	(1 << 5)  /* Pen Down Interrupt Flag */
+#define SADC_STATE_PEND		(1 << 4)  /* Pen Down Interrupt Flag */
+#define SADC_STATE_PENU		(1 << 3)  /* Pen Up Interrupt Flag */
+#define SADC_STATE_TSRDY	(1 << 2)  /* Touch Screen Data Ready Interrupt Flag */
+#define SADC_STATE_PBATRDY	(1 << 1)  /* PBAT Data Ready Interrupt Flag */
+#define SADC_STATE_SRDY		(1 << 0)  /* SADCIN Data Ready Interrupt Flag */
+
+/* ADC Touch Screen Data Register */
+#define SADC_TSDAT_DATA0_BIT	0
+#define SADC_TSDAT_DATA0_MASK	(0xfff << SADC_TSDAT_DATA0_BIT)
+#define SADC_TSDAT_TYPE0	(1 << 15)
+#define SADC_TSDAT_DATA1_BIT	16
+#define SADC_TSDAT_DATA1_MASK	(0xfff << SADC_TSDAT_DATA1_BIT)
+#define SADC_TSDAT_TYPE1	(1 << 31)
+
+/* ADC Clock Divide Register */
+#define SADC_ADCLK_CLKDIV_10_BIT	16
+#define SADC_ADCLK_CLKDIV_10_MASK	(0x7f << SADC_ADCLK_CLKDIV_10_BIT)
+#define SADC_ADCLK_CLKDIV_BIT		0
+#define SADC_ADCLK_CLKDIV_MASK		(0x3f << SADC_ADCLK_CLKDIV_BIT)
+
+/*************************************************************************
+ * SLCD (Smart LCD Controller)
+ *************************************************************************/
+
+#define SLCD_CFG	(SLCD_BASE + 0xA0)  /* SLCD Configure Register */
+#define SLCD_CTRL	(SLCD_BASE + 0xA4)  /* SLCD Control Register */
+#define SLCD_STATE	(SLCD_BASE + 0xA8)  /* SLCD Status Register */
+#define SLCD_DATA	(SLCD_BASE + 0xAC)  /* SLCD Data Register */
+
+#define REG_SLCD_CFG	REG32(SLCD_CFG)
+#define REG_SLCD_CTRL	REG8(SLCD_CTRL)
+#define REG_SLCD_STATE	REG8(SLCD_STATE)
+#define REG_SLCD_DATA	REG32(SLCD_DATA)
+
+/* SLCD Configure Register */
+#define SLCD_CFG_DWIDTH_BIT	10
+#define SLCD_CFG_DWIDTH_MASK	(0x7 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_18BIT	(0 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_16BIT	(1 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8BIT_x3	(2 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8BIT_x2	(3 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_8BIT_x1	(4 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_24BIT	(5 << SLCD_CFG_DWIDTH_BIT)
+  #define SLCD_CFG_DWIDTH_9BIT_x2	(7 << SLCD_CFG_DWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_BIT	(8)
+#define SLCD_CFG_CWIDTH_MASK	(0x7 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_16BIT	(0 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_8BIT	(1 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_18BIT	(2 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CWIDTH_24BIT	(3 << SLCD_CFG_CWIDTH_BIT)
+#define SLCD_CFG_CS_ACTIVE_LOW	(0 << 4)
+#define SLCD_CFG_CS_ACTIVE_HIGH	(1 << 4)
+#define SLCD_CFG_RS_CMD_LOW	(0 << 3)
+#define SLCD_CFG_RS_CMD_HIGH	(1 << 3)
+#define SLCD_CFG_CLK_ACTIVE_FALLING	(0 << 1)
+#define SLCD_CFG_CLK_ACTIVE_RISING	(1 << 1)
+#define SLCD_CFG_TYPE_PARALLEL	(0 << 0)
+#define SLCD_CFG_TYPE_SERIAL	(1 << 0)
+
+/* SLCD Control Register */
+#define SLCD_CTRL_DMA_EN	(1 << 0)
+
+/* SLCD Status Register */
+#define SLCD_STATE_BUSY		(1 << 0)
+
+/* SLCD Data Register */
+#define SLCD_DATA_RS_DATA	(0 << 31)
+#define SLCD_DATA_RS_COMMAND	(1 << 31)
+
+/*************************************************************************
+ * LCD (LCD Controller)
+ *************************************************************************/
+#define LCD_CFG		(LCD_BASE + 0x00) /* LCD Configure Register */
+#define LCD_CTRL	(LCD_BASE + 0x30) /* LCD Control Register */
+#define LCD_STATE	(LCD_BASE + 0x34) /* LCD Status Register */
+
+#define LCD_OSDC	(LCD_BASE + 0x100) /* LCD OSD Configure Register */
+#define LCD_OSDCTRL	(LCD_BASE + 0x104) /* LCD OSD Control Register */
+#define LCD_OSDS	(LCD_BASE + 0x108) /* LCD OSD Status Register */
+#define LCD_BGC		(LCD_BASE + 0x10C) /* LCD Background Color Register */
+#define LCD_KEY0	(LCD_BASE + 0x110) /* LCD Foreground Color Key Register 0 */
+#define LCD_KEY1	(LCD_BASE + 0x114) /* LCD Foreground Color Key Register 1 */
+#define LCD_ALPHA	(LCD_BASE + 0x118) /* LCD ALPHA Register */
+#define LCD_IPUR	(LCD_BASE + 0x11C) /* LCD IPU Restart Register */
+
+#define LCD_VAT		(LCD_BASE + 0x0c) /* Virtual Area Setting Register */
+#define LCD_DAH		(LCD_BASE + 0x10) /* Display Area Horizontal Start/End Point */
+#define LCD_DAV		(LCD_BASE + 0x14) /* Display Area Vertical Start/End Point */
+
+#define LCD_XYP0	(LCD_BASE + 0x120) /* Foreground 0 XY Position Register */
+#define LCD_XYP1	(LCD_BASE + 0x124) /* Foreground 1 XY Position Register */
+#define LCD_SIZE0	(LCD_BASE + 0x128) /* Foreground 0 Size Register */
+#define LCD_SIZE1	(LCD_BASE + 0x12C) /* Foreground 1 Size Register */
+#define LCD_RGBC	(LCD_BASE + 0x90) /* RGB Controll Register */
+
+#define LCD_VSYNC	(LCD_BASE + 0x04) /* Vertical Synchronize Register */
+#define LCD_HSYNC	(LCD_BASE + 0x08) /* Horizontal Synchronize Register */
+#define LCD_PS		(LCD_BASE + 0x18) /* PS Signal Setting */
+#define LCD_CLS		(LCD_BASE + 0x1c) /* CLS Signal Setting */
+#define LCD_SPL		(LCD_BASE + 0x20) /* SPL Signal Setting */
+#define LCD_REV		(LCD_BASE + 0x24) /* REV Signal Setting */
+#define LCD_IID		(LCD_BASE + 0x38) /* Interrupt ID Register */
+#define LCD_DA0		(LCD_BASE + 0x40) /* Descriptor Address Register 0 */
+#define LCD_SA0		(LCD_BASE + 0x44) /* Source Address Register 0 */
+#define LCD_FID0	(LCD_BASE + 0x48) /* Frame ID Register 0 */
+#define LCD_CMD0	(LCD_BASE + 0x4c) /* DMA Command Register 0 */
+#define LCD_DA1		(LCD_BASE + 0x50) /* Descriptor Address Register 1 */
+#define LCD_SA1		(LCD_BASE + 0x54) /* Source Address Register 1 */
+#define LCD_FID1	(LCD_BASE + 0x58) /* Frame ID Register 1 */
+#define LCD_CMD1	(LCD_BASE + 0x5c) /* DMA Command Register 1 */
+
+#define LCD_OFFS0	(LCD_BASE + 0x60) /* DMA Offsize Register 0 */
+#define LCD_PW0		(LCD_BASE + 0x64) /* DMA Page Width Register 0 */
+#define LCD_CNUM0	(LCD_BASE + 0x68) /* DMA Command Counter Register 0 */
+#define LCD_DESSIZE0	(LCD_BASE + 0x6C) /* Foreground Size in Descriptor 0 Register*/
+#define LCD_OFFS1	(LCD_BASE + 0x70) /* DMA Offsize Register 1 */
+#define LCD_PW1		(LCD_BASE + 0x74) /* DMA Page Width Register 1 */
+#define LCD_CNUM1	(LCD_BASE + 0x78) /* DMA Command Counter Register 1 */
+#define LCD_DESSIZE1	(LCD_BASE + 0x7C) /* Foreground Size in Descriptor 1 Register*/
+
+#define REG_LCD_CFG	REG32(LCD_CFG)
+#define REG_LCD_CTRL	REG32(LCD_CTRL)
+#define REG_LCD_STATE	REG32(LCD_STATE)
+
+#define REG_LCD_OSDC	REG16(LCD_OSDC)
+#define REG_LCD_OSDCTRL	REG16(LCD_OSDCTRL)
+#define REG_LCD_OSDS	REG16(LCD_OSDS)
+#define REG_LCD_BGC	REG32(LCD_BGC)
+#define REG_LCD_KEY0	REG32(LCD_KEY0)
+#define REG_LCD_KEY1	REG32(LCD_KEY1)
+#define REG_LCD_ALPHA	REG8(LCD_ALPHA)
+#define REG_LCD_IPUR	REG32(LCD_IPUR)
+
+#define REG_LCD_VAT	REG32(LCD_VAT)
+#define REG_LCD_DAH	REG32(LCD_DAH)
+#define REG_LCD_DAV	REG32(LCD_DAV)
+
+#define REG_LCD_XYP0	REG32(LCD_XYP0)
+#define REG_LCD_XYP1	REG32(LCD_XYP1)
+#define REG_LCD_SIZE0	REG32(LCD_SIZE0)
+#define REG_LCD_SIZE1	REG32(LCD_SIZE1)
+#define REG_LCD_RGBC	REG16(LCD_RGBC)
+
+#define REG_LCD_VSYNC	REG32(LCD_VSYNC)
+#define REG_LCD_HSYNC	REG32(LCD_HSYNC)
+#define REG_LCD_PS	REG32(LCD_PS)
+#define REG_LCD_CLS	REG32(LCD_CLS)
+#define REG_LCD_SPL	REG32(LCD_SPL)
+#define REG_LCD_REV	REG32(LCD_REV)
+#define REG_LCD_IID	REG32(LCD_IID)
+#define REG_LCD_DA0	REG32(LCD_DA0)
+#define REG_LCD_SA0	REG32(LCD_SA0)
+#define REG_LCD_FID0	REG32(LCD_FID0)
+#define REG_LCD_CMD0	REG32(LCD_CMD0)
+#define REG_LCD_DA1	REG32(LCD_DA1)
+#define REG_LCD_SA1	REG32(LCD_SA1)
+#define REG_LCD_FID1	REG32(LCD_FID1)
+#define REG_LCD_CMD1	REG32(LCD_CMD1)
+
+#define REG_LCD_OFFS0	REG32(LCD_OFFS0)
+#define REG_LCD_PW0	REG32(LCD_PW0)
+#define REG_LCD_CNUM0	REG32(LCD_CNUM0)
+#define REG_LCD_DESSIZE0	REG32(LCD_DESSIZE0)
+#define REG_LCD_OFFS1	REG32(LCD_OFFS1)
+#define REG_LCD_PW1	REG32(LCD_PW1)
+#define REG_LCD_CNUM1	REG32(LCD_CNUM1)
+#define REG_LCD_DESSIZE1	REG32(LCD_DESSIZE1)
+
+/* LCD Configure Register */
+#define LCD_CFG_LCDPIN_BIT	31  /* LCD pins selection */
+#define LCD_CFG_LCDPIN_MASK	(0x1 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_LCD	(0x0 << LCD_CFG_LCDPIN_BIT)
+  #define LCD_CFG_LCDPIN_SLCD	(0x1 << LCD_CFG_LCDPIN_BIT)
+#define LCD_CFG_TVEPEH		(1 << 30) /* TVE PAL enable extra halfline signal */
+#define LCD_CFG_FUHOLD		(1 << 29) /* hold pixel clock when outFIFO underrun */
+#define LCD_CFG_NEWDES		(1 << 28) /* use new descripter. old: 4words, new:8words */
+#define LCD_CFG_PALBP		(1 << 27) /* bypass data format and alpha blending */
+#define LCD_CFG_TVEN		(1 << 26) /* indicate the terminal is lcd or tv */
+#define LCD_CFG_RECOVER		(1 << 25) /* Auto recover when output fifo underrun */
+#define LCD_CFG_DITHER		(1 << 24) /* Dither function */
+#define LCD_CFG_PSM		(1 << 23) /* PS signal mode */
+#define LCD_CFG_CLSM		(1 << 22) /* CLS signal mode */
+#define LCD_CFG_SPLM		(1 << 21) /* SPL signal mode */
+#define LCD_CFG_REVM		(1 << 20) /* REV signal mode */
+#define LCD_CFG_HSYNM		(1 << 19) /* HSYNC signal mode */
+#define LCD_CFG_PCLKM		(1 << 18) /* PCLK signal mode */
+#define LCD_CFG_INVDAT		(1 << 17) /* Inverse output data */
+#define LCD_CFG_SYNDIR_IN	(1 << 16) /* VSYNC&HSYNC direction */
+#define LCD_CFG_PSP		(1 << 15) /* PS pin reset state */
+#define LCD_CFG_CLSP		(1 << 14) /* CLS pin reset state */
+#define LCD_CFG_SPLP		(1 << 13) /* SPL pin reset state */
+#define LCD_CFG_REVP		(1 << 12) /* REV pin reset state */
+#define LCD_CFG_HSP		(1 << 11) /* HSYNC polarity:0-active high,1-active low */
+#define LCD_CFG_PCP		(1 << 10) /* PCLK polarity:0-rising,1-falling */
+#define LCD_CFG_DEP		(1 << 9)  /* DE polarity:0-active high,1-active low */
+#define LCD_CFG_VSP		(1 << 8)  /* VSYNC polarity:0-rising,1-falling */
+#define LCD_CFG_MODE_TFT_18BIT 	(1 << 7)  /* 18bit TFT */
+#define LCD_CFG_MODE_TFT_16BIT 	(0 << 7)  /* 16bit TFT */
+#define LCD_CFG_MODE_TFT_24BIT 	(1 << 6)  /* 24bit TFT */
+#define LCD_CFG_PDW_BIT		4  /* STN pins utilization */
+#define LCD_CFG_PDW_MASK	(0x3 << LCD_DEV_PDW_BIT)
+#define LCD_CFG_PDW_1		(0 << LCD_CFG_PDW_BIT) /* LCD_D[0] */
+  #define LCD_CFG_PDW_2		(1 << LCD_CFG_PDW_BIT) /* LCD_D[0:1] */
+  #define LCD_CFG_PDW_4		(2 << LCD_CFG_PDW_BIT) /* LCD_D[0:3]/LCD_D[8:11] */
+  #define LCD_CFG_PDW_8		(3 << LCD_CFG_PDW_BIT) /* LCD_D[0:7]/LCD_D[8:15] */
+#define LCD_CFG_MODE_BIT	0  /* Display Device Mode Select */
+#define LCD_CFG_MODE_MASK	(0x0f << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_GENERIC_TFT	(0 << LCD_CFG_MODE_BIT) /* 16,18 bit TFT */
+  #define LCD_CFG_MODE_SPECIAL_TFT_1	(1 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_2	(2 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SPECIAL_TFT_3	(3 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_NONINTER_CCIR656	(4 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_INTER_CCIR656	(6 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_CSTN	(8 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SINGLE_MSTN	(9 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_CSTN	(10 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_DUAL_MSTN	(11 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SERIAL_TFT	(12 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_LCM  		(13 << LCD_CFG_MODE_BIT)
+  #define LCD_CFG_MODE_SLCD  		LCD_CFG_MODE_LCM
+
+/* LCD Control Register */
+#define LCD_CTRL_BST_BIT	28  /* Burst Length Selection */
+#define LCD_CTRL_BST_MASK	(0x03 << LCD_CTRL_BST_BIT)
+  #define LCD_CTRL_BST_4	(0 << LCD_CTRL_BST_BIT) /* 4-word */
+  #define LCD_CTRL_BST_8	(1 << LCD_CTRL_BST_BIT) /* 8-word */
+  #define LCD_CTRL_BST_16	(2 << LCD_CTRL_BST_BIT) /* 16-word */
+  #define LCD_CTRL_BST_32	(3 << LCD_CTRL_BST_BIT) /* 32-word */
+#define LCD_CTRL_RGB565		(0 << 27) /* RGB565 mode(foreground 0 in OSD mode) */
+#define LCD_CTRL_RGB555		(1 << 27) /* RGB555 mode(foreground 0 in OSD mode) */
+#define LCD_CTRL_OFUP		(1 << 26) /* Output FIFO underrun protection enable */
+#define LCD_CTRL_FRC_BIT	24  /* STN FRC Algorithm Selection */
+#define LCD_CTRL_FRC_MASK	(0x03 << LCD_CTRL_FRC_BIT)
+  #define LCD_CTRL_FRC_16	(0 << LCD_CTRL_FRC_BIT) /* 16 grayscale */
+  #define LCD_CTRL_FRC_4	(1 << LCD_CTRL_FRC_BIT) /* 4 grayscale */
+  #define LCD_CTRL_FRC_2	(2 << LCD_CTRL_FRC_BIT) /* 2 grayscale */
+#define LCD_CTRL_PDD_BIT	16  /* Load Palette Delay Counter */
+#define LCD_CTRL_PDD_MASK	(0xff << LCD_CTRL_PDD_BIT)
+#define LCD_CTRL_EOFM		(1 << 13) /* EOF interrupt mask */
+#define LCD_CTRL_SOFM		(1 << 12) /* SOF interrupt mask */
+#define LCD_CTRL_OFUM		(1 << 11) /* Output FIFO underrun interrupt mask */
+#define LCD_CTRL_IFUM0		(1 << 10) /* Input FIFO 0 underrun interrupt mask */
+#define LCD_CTRL_IFUM1		(1 << 9)  /* Input FIFO 1 underrun interrupt mask */
+#define LCD_CTRL_LDDM		(1 << 8)  /* LCD disable done interrupt mask */
+#define LCD_CTRL_QDM		(1 << 7)  /* LCD quick disable done interrupt mask */
+#define LCD_CTRL_BEDN		(1 << 6)  /* Endian selection */
+#define LCD_CTRL_PEDN		(1 << 5)  /* Endian in byte:0-msb first, 1-lsb first */
+#define LCD_CTRL_DIS		(1 << 4)  /* Disable indicate bit */
+#define LCD_CTRL_ENA		(1 << 3)  /* LCD enable bit */
+#define LCD_CTRL_BPP_BIT	0  /* Bits Per Pixel */
+#define LCD_CTRL_BPP_MASK	(0x07 << LCD_CTRL_BPP_BIT)
+  #define LCD_CTRL_BPP_1	(0 << LCD_CTRL_BPP_BIT) /* 1 bpp */
+  #define LCD_CTRL_BPP_2	(1 << LCD_CTRL_BPP_BIT) /* 2 bpp */
+  #define LCD_CTRL_BPP_4	(2 << LCD_CTRL_BPP_BIT) /* 4 bpp */
+  #define LCD_CTRL_BPP_8	(3 << LCD_CTRL_BPP_BIT) /* 8 bpp */
+  #define LCD_CTRL_BPP_16	(4 << LCD_CTRL_BPP_BIT) /* 15/16 bpp */
+  #define LCD_CTRL_BPP_18_24	(5 << LCD_CTRL_BPP_BIT) /* 18/24/32 bpp */
+  #define LCD_CTRL_BPP_CMPS_24	(6 << LCD_CTRL_BPP_BIT) /* 24 compress bpp */
+
+/* LCD Status Register */
+#define LCD_STATE_QD		(1 << 7) /* Quick Disable Done */
+#define LCD_STATE_EOF		(1 << 5) /* EOF Flag */
+#define LCD_STATE_SOF		(1 << 4) /* SOF Flag */
+#define LCD_STATE_OFU		(1 << 3) /* Output FIFO Underrun */
+#define LCD_STATE_IFU0		(1 << 2) /* Input FIFO 0 Underrun */
+#define LCD_STATE_IFU1		(1 << 1) /* Input FIFO 1 Underrun */
+#define LCD_STATE_LDD		(1 << 0) /* LCD Disabled */
+
+/* OSD Configure Register */
+#define LCD_OSDC_SOFM1		(1 << 15) /* Start of frame interrupt mask for foreground 1 */
+#define LCD_OSDC_EOFM1		(1 << 14) /* End of frame interrupt mask for foreground 1 */
+#define LCD_OSDC_REM1		(1 << 13) /* Real end of frame mask for foreground 1 */
+#define LCD_OSDC_SOFM0		(1 << 11) /* Start of frame interrupt mask for foreground 0 */
+#define LCD_OSDC_EOFM0		(1 << 10) /* End of frame interrupt mask for foreground 0 */
+#define LCD_OSDC_REM0		(1 << 9) /* Real end of frame mask for foreground 0 */
+#define LCD_OSDC_REMB		(1 << 7) /* Real end of frame mask for background */
+#define LCD_OSDC_F1EN		(1 << 4) /* enable foreground 1 */
+#define LCD_OSDC_F0EN		(1 << 3) /* enable foreground 0 */
+#define LCD_OSDC_ALPHAEN		(1 << 2) /* enable alpha blending */
+#define LCD_OSDC_ALPHAMD		(1 << 1) /* alpha blending mode */
+#define LCD_OSDC_OSDEN		(1 << 0) /* OSD mode enable */
+
+/* OSD Controll Register */
+#define LCD_OSDCTRL_IPU		(1 << 15) /* input data from IPU */
+#define LCD_OSDCTRL_RGB565	(0 << 4) /* foreground 1, 16bpp, 0-RGB565, 1-RGB555 */
+#define LCD_OSDCTRL_RGB555	(1 << 4) /* foreground 1, 16bpp, 0-RGB565, 1-RGB555 */
+#define LCD_OSDCTRL_CHANGES	(1 << 3) /* Change size flag */
+#define LCD_OSDCTRL_OSDBPP_BIT	0 	 /* Bits Per Pixel of OSD Channel 1 */
+#define LCD_OSDCTRL_OSDBPP_MASK	(0x7<<LCD_OSDCTRL_OSDBPP_BIT) 	 /* Bits Per Pixel of OSD Channel 1's MASK */
+  #define LCD_OSDCTRL_OSDBPP_16	(4 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 15,16 bit*/
+  #define LCD_OSDCTRL_OSDBPP_15_16	(4 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 15,16 bit*/
+  #define LCD_OSDCTRL_OSDBPP_18_24	(5 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 18,24 bit*/
+  #define LCD_OSDCTRL_OSDBPP_CMPS_24	(6 << LCD_OSDCTRL_OSDBPP_BIT) /* RGB 18,24 bit*/
+
+/* OSD State Register */
+#define LCD_OSDS_SOF1		(1 << 15) /* Start of frame flag for foreground 1 */
+#define LCD_OSDS_EOF1		(1 << 14) /* End of frame flag for foreground 1 */
+#define LCD_OSDS_SOF0		(1 << 11) /* Start of frame flag for foreground 0 */
+#define LCD_OSDS_EOF0		(1 << 10) /* End of frame flag for foreground 0 */
+#define LCD_OSDS_READY		(1 << 0)  /* Read for accept the change */
+
+/* Background Color Register */
+#define LCD_BGC_RED_OFFSET	(1 << 16)  /* Red color offset */
+#define LCD_BGC_RED_MASK	(0xFF<<LCD_BGC_RED_OFFSET)
+#define LCD_BGC_GREEN_OFFSET	(1 << 8)   /* Green color offset */
+#define LCD_BGC_GREEN_MASK	(0xFF<<LCD_BGC_GREEN_OFFSET)
+#define LCD_BGC_BLUE_OFFSET	(1 << 0)   /* Blue color offset */
+#define LCD_BGC_BLUE_MASK	(0xFF<<LCD_BGC_BLUE_OFFSET)
+
+/* Foreground Color Key Register 0,1(foreground 0, foreground 1) */
+#define LCD_KEY_KEYEN		(1 << 31)   /* enable color key */
+#define LCD_KEY_KEYMD		(1 << 30)   /* color key mode */
+#define LCD_KEY_RED_OFFSET	16  /* Red color offset */
+#define LCD_KEY_RED_MASK	(0xFF<<LCD_KEY_RED_OFFSET)
+#define LCD_KEY_GREEN_OFFSET	8   /* Green color offset */
+#define LCD_KEY_GREEN_MASK	(0xFF<<LCD_KEY_GREEN_OFFSET)
+#define LCD_KEY_BLUE_OFFSET	0   /* Blue color offset */
+#define LCD_KEY_BLUE_MASK	(0xFF<<LCD_KEY_BLUE_OFFSET)
+#define LCD_KEY_MASK		(LCD_KEY_RED_MASK|LCD_KEY_GREEN_MASK|LCD_KEY_BLUE_MASK)
+
+/* IPU Restart Register */
+#define LCD_IPUR_IPUREN		(1 << 31)   /* IPU restart function enable*/
+#define LCD_IPUR_IPURMASK	(0xFFFFFF)   /* IPU restart value mask*/
+
+/* RGB Control Register */
+#define LCD_RGBC_RGBDM		(1 << 15)   /* enable RGB Dummy data */
+#define LCD_RGBC_DMM		(1 << 14)   /* RGB Dummy mode */
+#define LCD_RGBC_YCC		(1 << 8)    /* RGB to YCC */
+#define LCD_RGBC_ODDRGB_BIT	4	/* odd line serial RGB data arrangement */
+#define LCD_RGBC_ODDRGB_MASK	(0x7<<LCD_RGBC_ODDRGB_BIT)
+  #define LCD_RGBC_ODD_RGB	0
+  #define LCD_RGBC_ODD_RBG	1
+  #define LCD_RGBC_ODD_GRB	2
+  #define LCD_RGBC_ODD_GBR	3
+  #define LCD_RGBC_ODD_BRG	4
+  #define LCD_RGBC_ODD_BGR	5
+#define LCD_RGBC_EVENRGB_BIT	0	/* even line serial RGB data arrangement */
+#define LCD_RGBC_EVENRGB_MASK	(0x7<<LCD_RGBC_EVENRGB_BIT)
+  #define LCD_RGBC_EVEN_RGB	0
+  #define LCD_RGBC_EVEN_RBG	1
+  #define LCD_RGBC_EVEN_GRB	2
+  #define LCD_RGBC_EVEN_GBR	3
+  #define LCD_RGBC_EVEN_BRG	4
+  #define LCD_RGBC_EVEN_BGR	5
+
+/* Vertical Synchronize Register */
+#define LCD_VSYNC_VPS_BIT	16  /* VSYNC pulse start in line clock, fixed to 0 */
+#define LCD_VSYNC_VPS_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+#define LCD_VSYNC_VPE_BIT	0   /* VSYNC pulse end in line clock */
+#define LCD_VSYNC_VPE_MASK	(0xffff << LCD_VSYNC_VPS_BIT)
+
+/* Horizontal Synchronize Register */
+#define LCD_HSYNC_HPS_BIT	16  /* HSYNC pulse start position in dot clock */
+#define LCD_HSYNC_HPS_MASK	(0xffff << LCD_HSYNC_HPS_BIT)
+#define LCD_HSYNC_HPE_BIT	0   /* HSYNC pulse end position in dot clock */
+#define LCD_HSYNC_HPE_MASK	(0xffff << LCD_HSYNC_HPE_BIT)
+
+/* Virtual Area Setting Register */
+#define LCD_VAT_HT_BIT		16  /* Horizontal Total size in dot clock */
+#define LCD_VAT_HT_MASK		(0xffff << LCD_VAT_HT_BIT)
+#define LCD_VAT_VT_BIT		0   /* Vertical Total size in dot clock */
+#define LCD_VAT_VT_MASK		(0xffff << LCD_VAT_VT_BIT)
+
+/* Display Area Horizontal Start/End Point Register */
+#define LCD_DAH_HDS_BIT		16  /* Horizontal display area start in dot clock */
+#define LCD_DAH_HDS_MASK	(0xffff << LCD_DAH_HDS_BIT)
+#define LCD_DAH_HDE_BIT		0   /* Horizontal display area end in dot clock */
+#define LCD_DAH_HDE_MASK	(0xffff << LCD_DAH_HDE_BIT)
+
+/* Display Area Vertical Start/End Point Register */
+#define LCD_DAV_VDS_BIT		16  /* Vertical display area start in line clock */
+#define LCD_DAV_VDS_MASK	(0xffff << LCD_DAV_VDS_BIT)
+#define LCD_DAV_VDE_BIT		0   /* Vertical display area end in line clock */
+#define LCD_DAV_VDE_MASK	(0xffff << LCD_DAV_VDE_BIT)
+
+/* Foreground XY Position Register */
+#define LCD_XYP_YPOS_BIT	16  /* Y position bit of foreground 0 or 1 */
+#define LCD_XYP_YPOS_MASK	(0xffff << LCD_XYP_YPOS_BIT)
+#define LCD_XYP_XPOS_BIT	0   /* X position bit of foreground 0 or 1 */
+#define LCD_XYP_XPOS_MASK	(0xffff << LCD_XYP_XPOS_BIT)
+
+/* PS Signal Setting */
+#define LCD_PS_PSS_BIT		16  /* PS signal start position in dot clock */
+#define LCD_PS_PSS_MASK		(0xffff << LCD_PS_PSS_BIT)
+#define LCD_PS_PSE_BIT		0   /* PS signal end position in dot clock */
+#define LCD_PS_PSE_MASK		(0xffff << LCD_PS_PSE_BIT)
+
+/* CLS Signal Setting */
+#define LCD_CLS_CLSS_BIT	16  /* CLS signal start position in dot clock */
+#define LCD_CLS_CLSS_MASK	(0xffff << LCD_CLS_CLSS_BIT)
+#define LCD_CLS_CLSE_BIT	0   /* CLS signal end position in dot clock */
+#define LCD_CLS_CLSE_MASK	(0xffff << LCD_CLS_CLSE_BIT)
+
+/* SPL Signal Setting */
+#define LCD_SPL_SPLS_BIT	16  /* SPL signal start position in dot clock */
+#define LCD_SPL_SPLS_MASK	(0xffff << LCD_SPL_SPLS_BIT)
+#define LCD_SPL_SPLE_BIT	0   /* SPL signal end position in dot clock */
+#define LCD_SPL_SPLE_MASK	(0xffff << LCD_SPL_SPLE_BIT)
+
+/* REV Signal Setting */
+#define LCD_REV_REVS_BIT	16  /* REV signal start position in dot clock */
+#define LCD_REV_REVS_MASK	(0xffff << LCD_REV_REVS_BIT)
+
+/* DMA Command Register */
+#define LCD_CMD_SOFINT		(1 << 31)
+#define LCD_CMD_EOFINT		(1 << 30)
+#define LCD_CMD_CMD		(1 << 29) /* indicate command in slcd mode */
+#define LCD_CMD_PAL		(1 << 28)
+#define LCD_CMD_LEN_BIT		0
+#define LCD_CMD_LEN_MASK	(0xffffff << LCD_CMD_LEN_BIT)
+
+/* DMA Offsize Register 0,1 */
+
+/* DMA Page Width Register 0,1 */
+
+/* DMA Command Counter Register 0,1 */
+
+/* Foreground 0,1 Size Register */
+#define LCD_DESSIZE_HEIGHT_BIT	16  /* height of foreground 1 */
+#define LCD_DESSIZE_HEIGHT_MASK	(0xffff << LCD_DESSIZE_HEIGHT_BIT)
+#define LCD_DESSIZE_WIDTH_BIT	0  /* width of foreground 1 */
+#define LCD_DESSIZE_WIDTH_MASK	(0xffff << LCD_DESSIZE_WIDTH_BIT)
+
+/*************************************************************************
+ * TVE (TV Encoder Controller)
+ *************************************************************************/
+#define TVE_CTRL	(TVE_BASE + 0x40) /* TV Encoder Control register */
+#define TVE_FRCFG	(TVE_BASE + 0x44) /* Frame configure register */
+#define TVE_SLCFG1	(TVE_BASE + 0x50) /* TV signal level configure register 1 */
+#define TVE_SLCFG2	(TVE_BASE + 0x54) /* TV signal level configure register 2*/
+#define TVE_SLCFG3	(TVE_BASE + 0x58) /* TV signal level configure register 3*/
+#define TVE_LTCFG1	(TVE_BASE + 0x60) /* Line timing configure register 1 */
+#define TVE_LTCFG2	(TVE_BASE + 0x64) /* Line timing configure register 2 */
+#define TVE_CFREQ	(TVE_BASE + 0x70) /* Chrominance sub-carrier frequency configure register */
+#define TVE_CPHASE	(TVE_BASE + 0x74) /* Chrominance sub-carrier phase configure register */
+#define TVE_CBCRCFG	(TVE_BASE + 0x78) /* Chrominance filter configure register */
+#define TVE_WSSCR	(TVE_BASE + 0x80) /* Wide screen signal control register */
+#define TVE_WSSCFG1	(TVE_BASE + 0x84) /* Wide screen signal configure register 1 */
+#define TVE_WSSCFG2	(TVE_BASE + 0x88) /* Wide screen signal configure register 2 */
+#define TVE_WSSCFG3	(TVE_BASE + 0x8c) /* Wide screen signal configure register 3 */
+
+#define REG_TVE_CTRL     REG32(TVE_CTRL)
+#define REG_TVE_FRCFG    REG32(TVE_FRCFG)
+#define REG_TVE_SLCFG1   REG32(TVE_SLCFG1)
+#define REG_TVE_SLCFG2   REG32(TVE_SLCFG2)
+#define REG_TVE_SLCFG3   REG32(TVE_SLCFG3)
+#define REG_TVE_LTCFG1   REG32(TVE_LTCFG1)
+#define REG_TVE_LTCFG2   REG32(TVE_LTCFG2)
+#define REG_TVE_CFREQ    REG32(TVE_CFREQ)
+#define REG_TVE_CPHASE   REG32(TVE_CPHASE)
+#define REG_TVE_CBCRCFG	 REG32(TVE_CBCRCFG)
+#define REG_TVE_WSSCR    REG32(TVE_WSSCR)
+#define REG_TVE_WSSCFG1  REG32(TVE_WSSCFG1)
+#define REG_TVE_WSSCFG2	 REG32(TVE_WSSCFG2)
+#define REG_TVE_WSSCFG3  REG32(TVE_WSSCFG3)
+
+/* TV Encoder Control register */
+#define TVE_CTRL_ECVBS          (1 << 24)    /* cvbs_enable */
+#define TVE_CTRL_DAPD3	        (1 << 23)    /* DAC 3 power down, not exist in jz4750D */
+#define TVE_CTRL_DAPD2	        (1 << 22)    /* DAC 2 power down */	
+#define TVE_CTRL_DAPD1	        (1 << 21)    /* DAC 1 power down */	
+#define TVE_CTRL_DAPD           (1 << 20)    /* power down all DACs */
+#define TVE_CTRL_YCDLY_BIT      16
+#define TVE_CTRL_YCDLY_MASK     (0x7 << TVE_CTRL_YCDLY_BIT)
+#define TVE_CTRL_CGAIN_BIT      14
+#define TVE_CTRL_CGAIN_MASK     (0x3 << TVE_CTRL_CGAIN_BIT)
+  #define TVE_CTRL_CGAIN_FULL		(0 << TVE_CTRL_CGAIN_BIT) /* gain = 1 */
+  #define TVE_CTRL_CGAIN_QUTR		(1 << TVE_CTRL_CGAIN_BIT) /* gain = 1/4 */
+  #define TVE_CTRL_CGAIN_HALF		(2 << TVE_CTRL_CGAIN_BIT) /* gain = 1/2 */
+  #define TVE_CTRL_CGAIN_THREE_QURT	(3 << TVE_CTRL_CGAIN_BIT) /* gain = 3/4 */
+#define TVE_CTRL_CBW_BIT        12
+#define TVE_CTRL_CBW_MASK       (0x3 << TVE_CTRL_CBW_BIT)
+  #define TVE_CTRL_CBW_NARROW	(0 << TVE_CTRL_CBW_BIT) /* Narrow band */
+  #define TVE_CTRL_CBW_WIDE	(1 << TVE_CTRL_CBW_BIT) /* Wide band */
+  #define TVE_CTRL_CBW_EXTRA	(2 << TVE_CTRL_CBW_BIT) /* Extra wide band */
+  #define TVE_CTRL_CBW_ULTRA	(3 << TVE_CTRL_CBW_BIT) /* Ultra wide band */
+#define TVE_CTRL_SYNCT          (1 << 9)
+#define TVE_CTRL_PAL            (1 << 8)
+#define TVE_CTRL_FINV           (1 << 7) /* invert_top:1-invert top and bottom fields. */
+#define TVE_CTRL_ZBLACK         (1 << 6) /* bypass_yclamp:1-Black of luminance (Y) input is 0.*/
+#define TVE_CTRL_CR1ST          (1 << 5) /* uv_order:0-Cb before Cr,1-Cr before Cb */
+#define TVE_CTRL_CLBAR          (1 << 4) /* Color bar mode:0-Output input video to TV,1-Output color bar to TV */
+#define TVE_CTRL_SWRST          (1 << 0) /* Software reset:1-TVE is reset */
+
+/* Signal level configure register 1 */
+#define TVE_SLCFG1_BLACKL_BIT   0
+#define TVE_SLCFG1_BLACKL_MASK  (0x3ff << TVE_SLCFG1_BLACKL_BIT)
+#define TVE_SLCFG1_WHITEL_BIT   16
+#define TVE_SLCFG1_WHITEL_MASK  (0x3ff << TVE_SLCFG1_WHITEL_BIT)
+
+/* Signal level configure register 2 */
+#define TVE_SLCFG2_BLANKL_BIT    0
+#define TVE_SLCFG2_BLANKL_MASK   (0x3ff << TVE_SLCFG2_BLANKL_BIT)
+#define TVE_SLCFG2_VBLANKL_BIT   16
+#define TVE_SLCFG2_VBLANKL_MASK  (0x3ff << TVE_SLCFG2_VBLANKL_BIT)
+
+/* Signal level configure register 3 */
+#define TVE_SLCFG3_SYNCL_BIT   0
+#define TVE_SLCFG3_SYNCL_MASK  (0xff << TVE_SLCFG3_SYNCL_BIT)
+
+/* Line timing configure register 1 */
+#define TVE_LTCFG1_BACKP_BIT   0
+#define TVE_LTCFG1_BACKP_MASK  (0x7f << TVE_LTCFG1_BACKP_BIT)
+#define TVE_LTCFG1_HSYNCW_BIT   8
+#define TVE_LTCFG1_HSYNCW_MASK  (0x7f << TVE_LTCFG1_HSYNCW_BIT)
+#define TVE_LTCFG1_FRONTP_BIT   16
+#define TVE_LTCFG1_FRONTP_MASK  (0x1f << TVE_LTCFG1_FRONTP_BIT)
+
+/* Line timing configure register 2 */
+#define TVE_LTCFG2_BURSTW_BIT    0
+#define TVE_LTCFG2_BURSTW_MASK   (0x3f << TVE_LTCFG2_BURSTW_BIT)
+#define TVE_LTCFG2_PREBW_BIT     8
+#define TVE_LTCFG2_PREBW_MASK    (0x1f << TVE_LTCFG2_PREBW_BIT)
+#define TVE_LTCFG2_ACTLIN_BIT    16
+#define TVE_LTCFG2_ACTLIN_MASK	(0x7ff << TVE_LTCFG2_ACTLIN_BIT)
+
+/* Chrominance sub-carrier phase configure register */
+#define TVE_CPHASE_CCRSTP_BIT    0
+#define TVE_CPHASE_CCRSTP_MASK   (0x3 << TVE_CPHASE_CCRSTP_BIT)
+  #define TVE_CPHASE_CCRSTP_8	(0 << TVE_CPHASE_CCRSTP_BIT) /* Every 8 field */
+  #define TVE_CPHASE_CCRSTP_4	(1 << TVE_CPHASE_CCRSTP_BIT) /* Every 4 field */
+  #define TVE_CPHASE_CCRSTP_2	(2 << TVE_CPHASE_CCRSTP_BIT) /* Every 2 lines */
+  #define TVE_CPHASE_CCRSTP_0	(3 << TVE_CPHASE_CCRSTP_BIT) /* Never */
+#define TVE_CPHASE_ACTPH_BIT     16
+#define TVE_CPHASE_ACTPH_MASK    (0xff << TVE_CPHASE_ACTPH_BIT)
+#define TVE_CPHASE_INITPH_BIT    24
+#define TVE_CPHASE_INITPH_MASK   (0xff << TVE_CPHASE_INITPH_BIT)
+
+/* Chrominance filter configure register */
+#define TVE_CBCRCFG_CRGAIN_BIT       0
+#define TVE_CBCRCFG_CRGAIN_MASK      (0xff << TVE_CBCRCFG_CRGAIN_BIT)
+#define TVE_CBCRCFG_CBGAIN_BIT       8
+#define TVE_CBCRCFG_CBGAIN_MASK      (0xff << TVE_CBCRCFG_CBGAIN_BIT)
+#define TVE_CBCRCFG_CRBA_BIT         16
+#define TVE_CBCRCFG_CRBA_MASK        (0xff << TVE_CBCRCFG_CRBA_BIT)
+#define TVE_CBCRCFG_CBBA_BIT         24
+#define TVE_CBCRCFG_CBBA_MASK        (0xff << TVE_CBCRCFG_CBBA_BIT)
+
+/* Frame configure register */
+#define TVE_FRCFG_NLINE_BIT          0
+#define TVE_FRCFG_NLINE_MASK         (0x3ff << TVE_FRCFG_NLINE_BIT)
+#define TVE_FRCFG_L1ST_BIT           16
+#define TVE_FRCFG_L1ST_MASK          (0xff << TVE_FRCFG_L1ST_BIT)
+
+/* Wide screen signal control register */
+#define TVE_WSSCR_EWSS0_BIT	0
+#define TVE_WSSCR_EWSS1_BIT	1
+#define TVE_WSSCR_WSSTP_BIT	2
+#define TVE_WSSCR_WSSCKBP_BIT	3
+#define TVE_WSSCR_WSSEDGE_BIT	4
+#define TVE_WSSCR_WSSEDGE_MASK	(0x7 << TVE_WSSCR_WSSEDGE_BIT)
+#define TVE_WSSCR_ENCH_BIT	8
+#define TVE_WSSCR_NCHW_BIT	9
+#define TVE_WSSCR_NCHFREQ_BIT	12
+#define TVE_WSSCR_NCHFREQ_MASK	(0x7 << TVE_WSSCR_NCHFREQ_BIT)
+
+/*************************************************************************
+ * USB Device
+ *************************************************************************/
+#define USB_BASE  UDC_BASE
+
+#define USB_REG_FADDR		(USB_BASE + 0x00) /* Function Address 8-bit */
+#define USB_REG_POWER		(USB_BASE + 0x01) /* Power Managemetn 8-bit */
+#define USB_REG_INTRIN		(USB_BASE + 0x02) /* Interrupt IN 16-bit */
+#define USB_REG_INTROUT		(USB_BASE + 0x04) /* Interrupt OUT 16-bit */
+#define USB_REG_INTRINE		(USB_BASE + 0x06) /* Intr IN enable 16-bit */
+#define USB_REG_INTROUTE	(USB_BASE + 0x08) /* Intr OUT enable 16-bit */
+#define USB_REG_INTRUSB		(USB_BASE + 0x0a) /* Interrupt USB 8-bit */
+#define USB_REG_INTRUSBE	(USB_BASE + 0x0b) /* Interrupt USB Enable 8-bit */
+#define USB_REG_FRAME		(USB_BASE + 0x0c) /* Frame number 16-bit */
+#define USB_REG_INDEX		(USB_BASE + 0x0e) /* Index register 8-bit */
+#define USB_REG_TESTMODE	(USB_BASE + 0x0f) /* USB test mode 8-bit */
+
+#define USB_REG_CSR0		(USB_BASE + 0x12) /* EP0 CSR 8-bit */
+#define USB_REG_INMAXP		(USB_BASE + 0x10) /* EP1-2 IN Max Pkt Size 16-bit */
+#define USB_REG_INCSR		(USB_BASE + 0x12) /* EP1-2 IN CSR LSB 8/16bit */
+#define USB_REG_INCSRH		(USB_BASE + 0x13) /* EP1-2 IN CSR MSB 8-bit */
+#define USB_REG_OUTMAXP		(USB_BASE + 0x14) /* EP1 OUT Max Pkt Size 16-bit */
+#define USB_REG_OUTCSR		(USB_BASE + 0x16) /* EP1 OUT CSR LSB 8/16bit */
+#define USB_REG_OUTCSRH		(USB_BASE + 0x17) /* EP1 OUT CSR MSB 8-bit */
+#define USB_REG_OUTCOUNT	(USB_BASE + 0x18) /* bytes in EP0/1 OUT FIFO 16-bit */
+
+#define USB_FIFO_EP0		(USB_BASE + 0x20)
+#define USB_FIFO_EP1		(USB_BASE + 0x24)
+#define USB_FIFO_EP2		(USB_BASE + 0x28)
+
+#define USB_REG_EPINFO		(USB_BASE + 0x78) /* Endpoint information */
+#define USB_REG_RAMINFO		(USB_BASE + 0x79) /* RAM information */
+
+#define USB_REG_INTR		(USB_BASE + 0x200) /* DMA pending interrupts */
+#define USB_REG_CNTL1		(USB_BASE + 0x204) /* DMA channel 1 control */
+#define USB_REG_ADDR1		(USB_BASE + 0x208) /* DMA channel 1 AHB memory addr */
+#define USB_REG_COUNT1		(USB_BASE + 0x20c) /* DMA channel 1 byte count */
+#define USB_REG_CNTL2		(USB_BASE + 0x214) /* DMA channel 2 control */
+#define USB_REG_ADDR2		(USB_BASE + 0x218) /* DMA channel 2 AHB memory addr */
+#define USB_REG_COUNT2		(USB_BASE + 0x21c) /* DMA channel 2 byte count */
+
+
+/* Power register bit masks */
+#define USB_POWER_SUSPENDM	0x01
+#define USB_POWER_RESUME	0x04
+#define USB_POWER_HSMODE	0x10
+#define USB_POWER_HSENAB	0x20
+#define USB_POWER_SOFTCONN	0x40
+
+/* Interrupt register bit masks */
+#define USB_INTR_SUSPEND	0x01
+#define USB_INTR_RESUME		0x02
+#define USB_INTR_RESET		0x04
+
+#define USB_INTR_EP0		0x0001
+#define USB_INTR_INEP1		0x0002
+#define USB_INTR_INEP2		0x0004
+#define USB_INTR_OUTEP1		0x0002
+
+/* CSR0 bit masks */
+#define USB_CSR0_OUTPKTRDY	0x01
+#define USB_CSR0_INPKTRDY	0x02
+#define USB_CSR0_SENTSTALL	0x04
+#define USB_CSR0_DATAEND	0x08
+#define USB_CSR0_SETUPEND	0x10
+#define USB_CSR0_SENDSTALL	0x20
+#define USB_CSR0_SVDOUTPKTRDY	0x40
+#define USB_CSR0_SVDSETUPEND	0x80
+
+/* Endpoint CSR register bits */
+#define USB_INCSRH_AUTOSET	0x80
+#define USB_INCSRH_ISO		0x40
+#define USB_INCSRH_MODE		0x20
+#define USB_INCSRH_DMAREQENAB	0x10
+#define USB_INCSRH_DMAREQMODE	0x04
+#define USB_INCSR_CDT		0x40
+#define USB_INCSR_SENTSTALL	0x20
+#define USB_INCSR_SENDSTALL	0x10
+#define USB_INCSR_FF		0x08
+#define USB_INCSR_UNDERRUN	0x04
+#define USB_INCSR_FFNOTEMPT	0x02
+#define USB_INCSR_INPKTRDY	0x01
+#define USB_OUTCSRH_AUTOCLR	0x80
+#define USB_OUTCSRH_ISO		0x40
+#define USB_OUTCSRH_DMAREQENAB	0x20
+#define USB_OUTCSRH_DNYT	0x10
+#define USB_OUTCSRH_DMAREQMODE	0x08
+#define USB_OUTCSR_CDT		0x80
+#define USB_OUTCSR_SENTSTALL	0x40
+#define USB_OUTCSR_SENDSTALL	0x20
+#define USB_OUTCSR_FF		0x10
+#define USB_OUTCSR_DATAERR	0x08
+#define USB_OUTCSR_OVERRUN	0x04
+#define USB_OUTCSR_FFFULL	0x02
+#define USB_OUTCSR_OUTPKTRDY	0x01
+
+/* Testmode register bits */
+#define USB_TEST_SE0NAK		0x01
+#define USB_TEST_J		0x02
+#define USB_TEST_K		0x04
+#define USB_TEST_PACKET		0x08
+
+/* DMA control bits */
+#define USB_CNTL_ENA		0x01
+#define USB_CNTL_DIR_IN		0x02
+#define USB_CNTL_MODE_1		0x04
+#define USB_CNTL_INTR_EN	0x08
+#define USB_CNTL_EP(n)		((n) << 4)
+#define USB_CNTL_BURST_0	(0 << 9)
+#define USB_CNTL_BURST_4	(1 << 9)
+#define USB_CNTL_BURST_8	(2 << 9)
+#define USB_CNTL_BURST_16	(3 << 9)
+
+/*************************************************************************
+ * BCH
+ *************************************************************************/
+#define	BCH_CR         	(BCH_BASE + 0x00) /* BCH Control register */
+#define	BCH_CRS       	(BCH_BASE + 0x04) /* BCH Control Set register */
+#define	BCH_CRC       	(BCH_BASE + 0x08) /* BCH Control Clear register */
+#define	BCH_CNT    	(BCH_BASE + 0x0C) /* BCH ENC/DEC Count register */
+#define	BCH_DR     	(BCH_BASE + 0x10) /* BCH data register */
+#define	BCH_PAR0    	(BCH_BASE + 0x14) /* BCH Parity 0 register */
+#define	BCH_PAR1    	(BCH_BASE + 0x18) /* BCH Parity 1 register */
+#define	BCH_PAR2    	(BCH_BASE + 0x1C) /* BCH Parity 2 register */
+#define	BCH_PAR3    	(BCH_BASE + 0x20) /* BCH Parity 3 register */
+#define	BCH_INTS    	(BCH_BASE + 0x24) /* BCH Interrupt Status register */
+#define	BCH_ERR0        (BCH_BASE + 0x28) /* BCH Error Report 0 register */
+#define	BCH_ERR1        (BCH_BASE + 0x2C) /* BCH Error Report 1 register */
+#define	BCH_ERR2        (BCH_BASE + 0x30) /* BCH Error Report 2 register */
+#define	BCH_ERR3        (BCH_BASE + 0x34) /* BCH Error Report 3 register */
+#define	BCH_INTE        (BCH_BASE + 0x38) /* BCH Interrupt Enable register */
+#define	BCH_INTES       (BCH_BASE + 0x3C) /* BCH Interrupt Set register */
+#define	BCH_INTEC       (BCH_BASE + 0x40) /* BCH Interrupt Clear register */
+
+#define	REG_BCH_CR      REG32(BCH_CR)
+#define	REG_BCH_CRS     REG32(BCH_CRS)
+#define	REG_BCH_CRC     REG32(BCH_CRC)
+#define	REG_BCH_CNT     REG32(BCH_CNT)
+#define	REG_BCH_DR      REG8(BCH_DR)
+#define	REG_BCH_PAR0    REG32(BCH_PAR0)
+#define	REG_BCH_PAR1    REG32(BCH_PAR1)
+#define	REG_BCH_PAR2    REG32(BCH_PAR2)
+#define	REG_BCH_PAR3    REG32(BCH_PAR3)
+#define	REG_BCH_INTS    REG32(BCH_INTS)
+#define	REG_BCH_ERR0    REG32(BCH_ERR0)
+#define	REG_BCH_ERR1    REG32(BCH_ERR1)
+#define	REG_BCH_ERR2    REG32(BCH_ERR2)
+#define	REG_BCH_ERR3    REG32(BCH_ERR3)
+#define	REG_BCH_INTE    REG32(BCH_INTE)
+#define	REG_BCH_INTEC   REG32(BCH_INTEC)
+#define	REG_BCH_INTES   REG32(BCH_INTES)
+
+/* BCH Control Register*/
+#define	BCH_CR_DMAE              (1 << 4)  /* BCH DMA Enable */
+#define	BCH_CR_ENCE              (1 << 3)  /* BCH Encoding Select */
+#define	BCH_CR_DECE              (0 << 3)  /* BCH Decoding Select */
+#define	BCH_CR_BSEL8             (1 << 2)  /* 8 Bit BCH Select */
+#define	BCH_CR_BSEL4             (0 << 2)  /* 4 Bit BCH Select */
+#define	BCH_CR_BRST              (1 << 1)  /* BCH Reset */
+#define	BCH_CR_BCHE              (1 << 0)  /* BCH Enable */
+
+/* BCH Interrupt Status Register */
+#define	BCH_INTS_ERRC_BIT        28
+#define	BCH_INTS_ERRC_MASK       (0xf << BCH_INTS_ERRC_BIT)
+#define	BCH_INTS_ALL0            (1 << 5)
+#define	BCH_INTS_ALLf            (1 << 4)
+#define	BCH_INTS_DECF            (1 << 3)
+#define	BCH_INTS_ENCF            (1 << 2)
+#define	BCH_INTS_UNCOR           (1 << 1)
+#define	BCH_INTS_ERR             (1 << 0)
+
+/* BCH ENC/DEC Count Register */
+#define BCH_CNT_DEC_BIT          16
+#define BCH_CNT_DEC_MASK         (0x3ff << BCH_CNT_DEC_BIT)
+#define BCH_CNT_ENC_BIT          0
+#define BCH_CNT_ENC_MASK         (0x3ff << BCH_CNT_ENC_BIT)
+
+/* BCH Error Report Register */
+#define BCH_ERR_INDEX_ODD_BIT    16
+#define BCH_ERR_INDEX_ODD_MASK   (0x1fff << BCH_ERR_INDEX_ODD_BIT)
+#define BCH_ERR_INDEX_EVEN_BIT   0
+#define BCH_ERR_INDEX_EVEN_MASK  (0x1fff << BCH_ERR_INDEX_EVEN_BIT)
+
+/*************************************************************************
+ * OWI (One-wire Bus Controller )
+ *************************************************************************/
+#define OWI_CFG (OWI_BASE + 0x00) /* OWI Configure Register */
+#define OWI_CTL (OWI_BASE + 0x04) /* OWI Control Register */
+#define OWI_STS (OWI_BASE + 0x08) /* OWI Status Register */
+#define OWI_DAT (OWI_BASE + 0x0c) /* OWI Data Register */
+#define OWI_DIV (OWI_BASE + 0x10) /* OWI Clock Divide Register */
+
+#define REG_OWI_CFG  REG8(OWI_CFG)
+#define REG_OWI_CTL  REG8(OWI_CTL)
+#define REG_OWI_STS  REG8(OWI_STS)
+#define REG_OWI_DAT  REG8(OWI_DAT)
+#define REG_OWI_DIV  REG8(OWI_DIV)
+
+/* OWI Configure Register */
+#define OWI_CFG_MODE      (1 << 7) /*  0: Regular speed mode  1: Overdrive  speed mode */
+#define OWI_CFG_RDDATA    (1 << 6) /* 1: receive data from one-wire bus and stored in OWDAT*/
+#define OWI_CFG_WRDATA    (1 << 5) /* 1: transmit the data in OWDAT */
+#define OWI_CFG_RDST      (1 << 4) /* 1: was sampled during a read */
+#define OWI_CFG_WR1RD     (1 << 3) /* 1: generate write 1 sequence on line */
+#define OWI_CFG_WR0       (1 << 2) /* 1: generate write 0 sequence on line */
+#define OWI_CFG_RST       (1 << 1) /* 1: generate reset pulse and sample slaves presence pulse*/
+#define OWI_CFG_ENA       (1 << 0) /* 1: enable the OWI operation */
+
+/* OWI Control Register */
+#define OWI_CTL_EBYTE     (1 << 2) /* enable byte write/read interrupt */
+#define OWI_CTL_EBIT      (1 << 1) /* enable bit write/read interrupt */
+#define OWI_CTL_ERST      (1 << 0) /* enable reset sequence finished interrupt */
+
+/* OWI Status Register */
+#define OWI_STS_PST       (1 << 7) /* 1: one-wire bus has device on it */
+#define OWI_STS_BYTE_RDY  (1 << 2) /* 1: have received or transmitted a data */
+#define OWI_STS_BIT_RDY   (1 << 1) /* 1: have received or transmitted a bit */
+#define OWI_STS_PST_RDY   (1 << 0) /* 1: have finished a reset pulse */
+
+/* OWI Clock Divide Register */
+#define OWI_DIV_CLKDIV_BIT  5
+
+
+/*************************************************************************
+ * MC (Motion Compensation)
+ *************************************************************************/
+#define MC_CTRL		(MC_BASE + 0x00) /* MC Control Register */
+#define MC_STAT		(MC_BASE + 0x04) /* MC Status Register */
+#define MC_REF_ADDR	(MC_BASE + 0x08) /* MC Reference Block Address Register */
+#define MC_REF2_ADDR	(MC_BASE + 0x0C) /* MC 2nd Reference Block Address Register */
+#define MC_CURR_ADDR	(MC_BASE + 0x10) /* MC Current Block Address Register */
+#define MC_REF_STRD	(MC_BASE + 0x14) /* MC Reference Frame Stride Register */
+#define MC_CURR_STRD	(MC_BASE + 0x18) /* MC Current Frame Stride Register */
+#define MC_ITP_INFO	(MC_BASE + 0x1C) /* MC Block Interpolation Information Register */
+#define MC_TAP_COEF1	(MC_BASE + 0x20) /* MC TAP Filter Coefficient 1 Register */
+#define MC_TAP_COEF2	(MC_BASE + 0x24) /* MC TAP Filter Coefficient 2 Register */
+
+#define REG_MC_CTRL		REG32(MC_CTRL)
+#define REG_MC_STAT		REG32(MC_STAT)
+#define REG_MC_REF_ADDR		REG32(MC_REF_ADDR)
+#define REG_MC_REF2_ADDR	REG32(MC_REF2_ADDR)
+#define REG_MC_CURR_ADDR	REG32(MC_CURR_ADDR)
+#define REG_MC_REF_STRD		REG32(MC_REF_STRD)
+#define REG_MC_CURR_STRD	REG32(MC_CURR_STRD)
+#define REG_MC_ITP_INFO		REG32(MC_ITP_INFO)
+#define REG_MC_TAP_COEF1	REG32(MC_TAP_COEF1)
+#define REG_MC_TAP_COEF2	REG32(MC_TAP_COEF2)
+
+/* MC Control Register */
+#define MC_CTRL_CACHECLR	(1 << 2) /* MC Cache clear */
+#define MC_CTRL_RESET		(1 << 1) /* MC Reset */
+#define MC_CTRL_ENABLE		(1 << 0) /* MC enable */
+
+/* MC Status Register */
+#define MC_STAT_OUT_END		(1 << 0) /* Output DMA termination flag */
+
+/* MC Reference Frame Stride Register, unit: byte */
+#define MC_REF_STRD_BIT		16
+#define MC_REF_STRD_MASK	(0xfff << MC_REF_STRD_BIT)
+#define MC_REF_STRD2_BIT	0
+#define MC_REF_STRD2_MASK	(0xfff << MC_REF_STRD2_BIT)
+
+/* MC Current Frame Stride Register, unit: byte */
+#define MC_CURR_STRD_BIT	0
+#define MC_CURR_STRD_MASK	(0xfff << MC_CURR_STRD_BIT)
+
+/* MC Block Interpolation Information Register */
+#define MC_ITP_INFO_RND1_BIT	24  /* Rounding data during interpolation */
+#define MC_ITP_INFO_RND1_MASK	(0xff << MC_ITP_INFO_RND1_BIT)
+#define MC_ITP_INFO_RND0_BIT	16  /* Rounding data during interpolation */
+#define MC_ITP_INFO_RND0_MASK	(0xff << MC_ITP_INFO_RND0_BIT)
+#define MC_ITP_INFO_AVG		(1 << 12)  /* 0: output interpolated data directly; 1: doing average operation with 2nd source data after interpolating and output */
+#define MC_ITP_INFO_FMT_BIT	8  /* Indicate current interpolation's type */
+#define MC_ITP_INFO_RMT_MASK	(0xf << MC_ITP_INFO_RMT_BIT)
+  #define MC_ITP_INFO_FMT_MPEG_HPEL  (0x0 << MC_ITP_INFO_RMT_BIT) /* MPEG Half-pixel interpolation */
+  #define MC_ITP_INFO_FMT_MPEG_QPEL  (0x1 << MC_ITP_INFO_RMT_BIT) /* MPEG 8-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_H264_QPEL  (0x2 << MC_ITP_INFO_RMT_BIT) /* H264 6-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_H264_EPEL  (0x3 << MC_ITP_INFO_RMT_BIT) /* H264 2-tap Eight-pixel interpolation */
+  #define MC_ITP_INFO_FMT_H264_WPDT  (0x4 << MC_ITP_INFO_RMT_BIT) /* H264 Weighted-prediction */
+  #define MC_ITP_INFO_FMT_WMV2_QPEL  (0x5 << MC_ITP_INFO_RMT_BIT) /* WMV2 4-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_VC1_QPEL   (0x6 << MC_ITP_INFO_RMT_BIT) /* VC1 4-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_RV8_TPEL   (0x7 << MC_ITP_INFO_RMT_BIT) /* RV8 4-tap Third-pixel interpolation */
+  #define MC_ITP_INFO_FMT_RV8_CHROM  (0x8 << MC_ITP_INFO_RMT_BIT) /* RV8 2-tap Third-pixel interpolation */
+  #define MC_ITP_INFO_FMT_RV9_QPEL   (0x9 << MC_ITP_INFO_RMT_BIT) /* RV9 6-tap Quarter-pixel interpolation */
+  #define MC_ITP_INFO_FMT_RV9_CHROM  (0xa << MC_ITP_INFO_RMT_BIT) /* RV9 2-tap Quarter-pixel interpolation */
+#define MC_ITP_INFO_BLK_W_BIT	6  /* Indicate reference block's width, unit: pixel */
+#define MC_ITP_INFO_BLK_W_MASK	(0x3 << MC_ITP_INFO_BLK_W_BIT)
+  #define MC_ITP_INFO_BLK_W_2	(0x0 << MC_ITP_INFO_BLK_W_BIT)
+  #define MC_ITP_INFO_BLK_W_4	(0x1 << MC_ITP_INFO_BLK_W_BIT)
+  #define MC_ITP_INFO_BLK_W_8	(0x2 << MC_ITP_INFO_BLK_W_BIT)
+  #define MC_ITP_INFO_BLK_W_16	(0x3 << MC_ITP_INFO_BLK_W_BIT)
+#define MC_ITP_INFO_BLK_H_BIT	4  /* Indicate reference block's height, unit: pixel */
+#define MC_ITP_INFO_BLK_H_MASK	(0x3 << MC_ITP_INFO_BLK_H_BIT)
+  #define MC_ITP_INFO_BLK_H_2	(0x0 << MC_ITP_INFO_BLK_H_BIT)
+  #define MC_ITP_INFO_BLK_H_4	(0x1 << MC_ITP_INFO_BLK_H_BIT)
+  #define MC_ITP_INFO_BLK_H_8	(0x2 << MC_ITP_INFO_BLK_H_BIT)
+  #define MC_ITP_INFO_BLK_H_16	(0x3 << MC_ITP_INFO_BLK_H_BIT)
+#define MC_ITP_INFO_ITP_CASE_BIT	0  /* Indicate interpolation final destination pixel position */
+#define MC_ITP_INFO_ITP_CASE_MASK	(0xf << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H0V0	(0x0 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H1V0	(0x1 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H2V0	(0x2 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H3V0	(0x3 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H0V1	(0x4 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H1V1	(0x5 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H2V1	(0x6 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H3V1	(0x7 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H0V2	(0x8 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H1V2	(0x9 << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H2V2	(0xa << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H3V2	(0xb << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H0V3	(0xc << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H1V3	(0xd << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H2V3	(0xe << MC_ITP_INFO_ITP_CASE_BIT)
+  #define MC_ITP_INFO_ITP_CASE_H3V3	(0xf << MC_ITP_INFO_ITP_CASE_BIT)
+
+/* MC TAP Filter Coefficient 1 Register */
+#define MC_TAP_COEF1_TAP_COEF4_BIT	24
+#define MC_TAP_COEF1_TAP_COEF4_MASK	(0xff << MC_TAP_COEF1_TAP_COEF4_BIT)
+#define MC_TAP_COEF1_TAP_COEF3_BIT	16
+#define MC_TAP_COEF1_TAP_COEF3_MASK	(0xff << MC_TAP_COEF1_TAP_COEF3_BIT)
+#define MC_TAP_COEF1_TAP_COEF2_BIT	8
+#define MC_TAP_COEF1_TAP_COEF2_MASK	(0xff << MC_TAP_COEF1_TAP_COEF2_BIT)
+#define MC_TAP_COEF1_TAP_COEF1_BIT	0
+#define MC_TAP_COEF1_TAP_COEF1_MASK	(0xff << MC_TAP_COEF1_TAP_COEF1_BIT)
+
+/* MC TAP Filter Coefficient 2 Register */
+#define MC_TAP_COEF2_TAP_COEF8_BIT	24
+#define MC_TAP_COEF2_TAP_COEF8_MASK	(0xff << MC_TAP_COEF2_TAP_COEF8_BIT)
+#define MC_TAP_COEF2_TAP_COEF7_BIT	16
+#define MC_TAP_COEF2_TAP_COEF7_MASK	(0xff << MC_TAP_COEF2_TAP_COEF7_BIT)
+#define MC_TAP_COEF2_TAP_COEF6_BIT	8
+#define MC_TAP_COEF2_TAP_COEF6_MASK	(0xff << MC_TAP_COEF2_TAP_COEF6_BIT)
+#define MC_TAP_COEF2_TAP_COEF5_BIT	0
+#define MC_TAP_COEF2_TAP_COEF5_MASK	(0xff << MC_TAP_COEF2_TAP_COEF5_BIT)
+
+
+/*************************************************************************
+ * ME (Motion Estimation)
+ *************************************************************************/
+#define ME_CTRL		(ME_BASE + 0x00) /* ME Control Register */
+#define ME_REF_ADDR	(ME_BASE + 0x04) /* ME Reference Block Address Register */
+#define ME_CURR_ADDR	(ME_BASE + 0x08) /* ME Current Block Address Register */
+#define ME_DIFF_ADDR	(ME_BASE + 0x0C) /* ME Difference Address Register */
+#define ME_REF_STRD	(ME_BASE + 0x10) /* ME Reference Frame Stride Register */
+#define ME_CURR_STRD	(ME_BASE + 0x14) /* ME Current Frame Stride Register */
+#define ME_DIFF_STRD	(ME_BASE + 0x18) /* ME Difference Frame Stride Register */
+#define ME_SETTINGS	(ME_BASE + 0x1C) /* ME Settings Register */
+#define ME_MVD		(ME_BASE + 0x20) /* ME Motion Vector Difference Register */
+#define ME_FLAG		(ME_BASE + 0x24) /* ME Flag Register */
+
+#define REG_ME_CTRL		REG32(ME_CTRL)
+#define REG_ME_REF_ADDR		REG32(ME_REF_ADDR)
+#define REG_ME_CURR_ADDR	REG32(ME_CURR_ADDR)
+#define REG_ME_DIFF_ADDR	REG32(ME_DIFF_ADDR)
+#define REG_ME_REF_STRD		REG32(ME_REF_STRD)
+#define REG_ME_CURR_STRD	REG32(ME_CURR_STRD)
+#define REG_ME_DIFF_STRD	REG32(ME_DIFF_STRD)
+#define REG_ME_SETTINGS		REG32(ME_SETTINGS)
+#define REG_ME_MVD		REG32(ME_MVD)
+#define REG_ME_FLAG		REG32(ME_FLAG)
+
+
+/* ME Control Register */
+#define ME_CTRL_FLUSH		(1 << 2) /* ME cache clear */
+#define ME_CTRL_RESET		(1 << 1) /* ME reset */
+#define ME_CTRL_ENABLE		(1 << 0) /* ME enable */
+
+/* ME Settings Register */
+#define ME_SETTINGS_SAD_GATE_BIT	16 /* The max SAD value which can be accepted */
+#define ME_SETTINGS_SAD_GATE_MASK	(0xffff << ME_SETTINGS_SAD_GATE_BIT)
+#define ME_SETTINGS_STEP_NUM_BIT	0  /* The max step number the search process can not exceed */
+#define ME_SETTINGS_STEP_NUM_MASK	(0x3f << ME_SETTINGS_STEP_NUM_BIT)
+
+/* ME Motion Vector Difference Register */
+#define ME_MVD_MVDY_BIT		16 /* The MVD value of coordinate-Y */
+#define ME_MVD_MVDY_MASK	(0xffff << ME_MVD_MVDY_BIT)
+#define ME_MVD_MVDX_BIT		0  /* The MVD value of coordinate-X */
+#define ME_MVD_MVDX_MASK	(0xffff << ME_MVD_MVDX_BIT)
+
+/* ME Flag Register */
+#define ME_FLAG_INTRA		(1 << 1) /* Indicate the current MB will be predicted in intra mode */
+#define ME_FLAG_COMPLETED	(1 << 0) /* The ME of the current part of the MB is completed */
+
+
+/*************************************************************************
+ * OTP (One Time Programmable Module)
+ *************************************************************************/
+#define OTP_ID0		(OTP_BASE + 0x00) /* ID0 Register */
+#define OTP_ID1		(OTP_BASE + 0x04) /* ID1 Register */
+#define OTP_ID2		(OTP_BASE + 0x08) /* ID2 Register */
+#define OTP_ID3		(OTP_BASE + 0x0C) /* ID3 Register */
+#define OTP_BR0		(OTP_BASE + 0x10) /* BOOTROM0 Register */
+#define OTP_BR1		(OTP_BASE + 0x14) /* BOOTROM1 Register */
+#define OTP_HW0		(OTP_BASE + 0x18) /* Chip Hardware 0 Register */
+#define OTP_HW1		(OTP_BASE + 0x1C) /* Chip Hardware 1 Register */
+
+#define REG_OTP_ID0	REG32(OTP_ID0)
+#define REG_OTP_ID1	REG32(OTP_ID1)
+#define REG_OTP_ID2	REG32(OTP_ID2)
+#define REG_OTP_ID3	REG32(OTP_ID3)
+#define REG_OTP_BR0	REG32(OTP_BR0)
+#define REG_OTP_BR1	REG32(OTP_BR1)
+#define REG_OTP_HW0	REG32(OTP_HW0)
+#define REG_OTP_HW1	REG32(OTP_HW1)
+
+/* ID0 Register */
+#define OTP_ID0_WID_BIT		24 /* Wafer ID */
+#define OTP_ID0_WID_MASK	(0xff << OTP_ID0_WID_BIT)
+#define OTP_ID0_MID_BIT		16 /* MASK ID */
+#define OTP_ID0_MID_MASK	(0xff << OTP_ID0_MID_BIT)
+#define OTP_ID0_FID_BIT		8 /* Foundary ID */
+#define OTP_ID0_FID_MASK	(0xff << OTP_ID0_FID_BIT)
+#define OTP_ID0_PID_BIT		0 /* Product ID */
+#define OTP_ID0_PID_MASK	(0xff << OTP_ID0_PID_BIT)
+
+/* ID1 Register */
+#define OTP_ID1_LID_BIT		8 /* Lot ID */
+#define OTP_ID1_LID_MASK	(0xffffff << OTP_ID1_LID_BIT)
+#define OTP_ID1_TID_BIT		0 /* Test House ID */
+#define OTP_ID1_TID_MASK	(0xff << OTP_ID1_TID_BIT)
+
+/* ID2 Register */
+#define OTP_ID2_XADR_BIT	24 /* Die X-dir Address */
+#define OTP_ID2_XADR_MASK	(0xff << OTP_ID2_XADR_BIT)
+#define OTP_ID2_YADR_BIT	16 /* Die Y-dir Address */
+#define OTP_ID2_YADR_MASK	(0xff << OTP_ID2_YADR_BIT)
+#define OTP_ID2_TDATE_BIT	0  /* Testing Date */
+#define OTP_ID2_TDATE_MASK	(0xffff << OTP_ID2_TDATE_BIT)
+
+/* ID3 Register */
+#define OTP_ID3_CID_BIT		16 /* Customer ID */
+#define OTP_ID3_CID_MASK	(0xffff << OTP_ID3_CID_BIT)
+#define OTP_ID3_CP_BIT		0 /* Chip Parameters */
+#define OTP_ID3_CP_MASK		(0xffff << OTP_ID3_CP_BIT)
+
+/* BOOTROM1 Register */
+#define OTP_BR1_UDCBOOT_BIT	0
+#define OTP_BR1_UDCBOOT_MASK	(0xff << OTP_BR1_UDCBOOT_BIT)
+  #define OTP_BR1_UDCBOOT_AUTO	(0xf0 << OTP_BR1_UDCBOOT_BIT)
+  #define OTP_BR1_UDCBOOT_24M	(0x0f << OTP_BR1_UDCBOOT_BIT) /* 24MHz OSC */
+  #define OTP_BR1_UDCBOOT_13M	(0x0c << OTP_BR1_UDCBOOT_BIT) /* 13MHz OSC */
+  #define OTP_BR1_UDCBOOT_26M	(0x03 << OTP_BR1_UDCBOOT_BIT) /* 26MHz OSC */
+  #define OTP_BR1_UDCBOOT_27M	(0x00 << OTP_BR1_UDCBOOT_BIT) /* 27MHz OSC */
+
+/* Chip Hardware 1 Register */
+#define OTP_HW1_MC_EN		(0x3 << 30) /* MC is enabled */
+#define OTP_HW1_ME_EN		(0x3 << 28)
+#define OTP_HW1_DE_EN		(0x3 << 26)
+#define OTP_HW1_IDCT_EN		(0x3 << 24)
+#define OTP_HW1_UART3_EN	(0x3 << 22)
+#define OTP_HW1_UART2_EN	(0x3 << 20)
+#define OTP_HW1_UART1_EN	(0x3 << 18)
+#define OTP_HW1_UART0_EN	(0x3 << 16)
+#define OTP_HW1_SSI1_EN		(0x3 << 14)
+#define OTP_HW1_SSI0_EN		(0x3 << 12)
+#define OTP_HW1_MSC1_EN		(0x3 << 10)
+#define OTP_HW1_MSC0_EN		(0x3 << 8)
+#define OTP_HW1_UHC_EN		(0x3 << 6)
+#define OTP_HW1_TVE_EN		(0x3 << 4)
+#define OTP_HW1_TSSI_EN		(0x3 << 2)
+#define OTP_HW1_CIM_EN		(0x3 << 0)
+
+
+/*************************************************************************
+ * TSSI MPEG 2-TS slave interface
+ *************************************************************************/
+#define TSSI_ENA       ( TSSI_BASE + 0x00 )   /* TSSI enable register */
+#define TSSI_CFG       ( TSSI_BASE + 0x04 )   /* TSSI configure register */
+#define TSSI_CTRL      ( TSSI_BASE + 0x08 )   /* TSSI control register */
+#define TSSI_STAT      ( TSSI_BASE + 0x0c )   /* TSSI state register */
+#define TSSI_FIFO      ( TSSI_BASE + 0x10 )   /* TSSI FIFO register */
+#define TSSI_PEN       ( TSSI_BASE + 0x14 )   /* TSSI PID enable register */
+#define TSSI_PID(n)    ( TSSI_BASE + 0x20 + 4*(n) )   /* TSSI PID filter register */
+#define TSSI_PID0      ( TSSI_BASE + 0x20 )
+#define TSSI_PID1      ( TSSI_BASE + 0x24 )
+#define TSSI_PID2      ( TSSI_BASE + 0x28 )
+#define TSSI_PID3      ( TSSI_BASE + 0x2c )
+#define TSSI_PID4      ( TSSI_BASE + 0x30 )
+#define TSSI_PID5      ( TSSI_BASE + 0x34 )
+#define TSSI_PID6      ( TSSI_BASE + 0x38 )
+#define TSSI_PID7      ( TSSI_BASE + 0x3c )
+#define TSSI_PID_MAX   8	/* max PID: 7 */
+ 
+#define REG_TSSI_ENA       REG8( TSSI_ENA )
+#define REG_TSSI_CFG       REG16( TSSI_CFG )
+#define REG_TSSI_CTRL      REG8( TSSI_CTRL )
+#define REG_TSSI_STAT      REG8( TSSI_STAT )
+#define REG_TSSI_FIFO      REG32( TSSI_FIFO )
+#define REG_TSSI_PEN       REG32( TSSI_PEN )
+#define REG_TSSI_PID(n)    REG32( TSSI_PID(n) )
+#define REG_TSSI_PID0      REG32( TSSI_PID0 )
+#define REG_TSSI_PID1      REG32( TSSI_PID1 )
+#define REG_TSSI_PID2      REG32( TSSI_PID2 )
+#define REG_TSSI_PID3      REG32( TSSI_PID3 )
+#define REG_TSSI_PID4      REG32( TSSI_PID4 )
+#define REG_TSSI_PID5      REG32( TSSI_PID5 )
+#define REG_TSSI_PID6      REG32( TSSI_PID6 )
+#define REG_TSSI_PID7      REG32( TSSI_PID7 )
+
+/* TSSI enable register */
+#define TSSI_ENA_SFT_RST 	( 1 << 7 )      /* soft reset bit */
+#define TSSI_ENA_PID_EN 	( 1 << 2 )      /* soft filtering function enable bit */
+#define TSSI_ENA_DMA_EN 	( 1 << 1 )      /* DMA enable bit */
+#define TSSI_ENA_ENA 		( 1 << 0 )      /* TSSI enable bit */
+
+/* TSSI configure register */
+#define TSSI_CFG_TRIG_BIT 	14 /* fifo trig number */
+#define TSSI_CFG_TRIG_MASK 	( 0x3 << TSSI_CFG_TRIG_BIT)
+#define TSSI_CFG_TRIG_4 	( 0 << TSSI_CFG_TRIG_BIT)
+#define TSSI_CFG_TRIG_8 	( 1 << TSSI_CFG_TRIG_BIT)
+#define TSSI_CFG_TRIG_16 	( 2 << TSSI_CFG_TRIG_BIT)
+#define TSSI_CFG_END_WD 	( 1 << 9 )      /* order of data in word */
+#define TSSI_CFG_END_BT 	( 1 << 8 )      /* order of data in byte */
+#define TSSI_CFG_TSDI_H 	( 1 << 7 )      /* data pin polarity */
+#define TSSI_CFG_USE_0 		( 1 << 6 )      /* serial mode data pin select */
+#define TSSI_CFG_USE_TSDI0 	( 0 << 6 )      /* TSDI0 as serial mode data pin */
+#define TSSI_CFG_USE_TSDI7 	( 1 << 6 )      /* TSDI7 as serial mode data pin */
+#define TSSI_CFG_TSCLK_CH 	( 1 << 5 )      /* clk channel select */
+#define TSSI_CFG_PARAL 		( 1 << 4 )      /* mode select */
+#define TSSI_CFG_PARAL_MODE 	( 1 << 4 )      /* parallel select */
+#define TSSI_CFG_SERIAL_MODE 	( 0 << 4 )      /* serial select */
+#define TSSI_CFG_TSCLK_P 	( 1 << 3 )      /* clk edge select */
+#define TSSI_CFG_TSFRM_H 	( 1 << 2 )      /* TSFRM polarity select */
+#define TSSI_CFG_TSSTR_H 	( 1 << 1 )      /* TSSTR polarity select */
+#define TSSI_CFG_TSFAIL_H 	( 1 << 0 )      /* TSFAIL polarity select */
+
+/* TSSI control register */
+#define TSSI_CTRL_OVRNM 	( 1 << 1 )      /* FIFO overrun interrupt mask bit */
+#define TSSI_CTRL_TRIGM 	( 1 << 0 )      /* FIFO trigger interrupt mask bit */
+
+/* TSSI state register */
+#define TSSI_STAT_OVRN 		( 1 << 1 )      /* FIFO overrun interrupt flag bit */
+#define TSSI_STAT_TRIG 		( 1 << 0 )      /* FIFO trigger interrupt flag bit */
+
+/* TSSI PID enable register */
+#define TSSI_PEN_EN00 	( 1 << 0 )      /* enable PID n */
+#define TSSI_PEN_EN10 	( 1 << 1 )      
+#define TSSI_PEN_EN20 	( 1 << 2 )      
+#define TSSI_PEN_EN30 	( 1 << 3 )      
+#define TSSI_PEN_EN40 	( 1 << 4 )      
+#define TSSI_PEN_EN50 	( 1 << 5 )      
+#define TSSI_PEN_EN60 	( 1 << 6 )      
+#define TSSI_PEN_EN70 	( 1 << 7 )      
+#define TSSI_PEN_EN01 	( 1 << 16 )      
+#define TSSI_PEN_EN11 	( 1 << 17 )      
+#define TSSI_PEN_EN21 	( 1 << 18 )     
+#define TSSI_PEN_EN31 	( 1 << 19 )      
+#define TSSI_PEN_EN41 	( 1 << 20 )     
+#define TSSI_PEN_EN51 	( 1 << 21 )      
+#define TSSI_PEN_EN61 	( 1 << 22 )     
+#define TSSI_PEN_EN71 	( 1 << 23 )      
+#define TSSI_PEN_PID0 	( 1 << 31 ) /* PID filter enable PID0 */
+
+/* TSSI PID Filter Registers */
+#define TSSI_PID_PID1_BIT 	16
+#define TSSI_PID_PID1_MASK 	(0x1FFF<<TSSI_PID_PID1_BIT)
+#define TSSI_PID_PID0_BIT 	0
+#define TSSI_PID_PID0_MASK 	(0x1FFF<<TSSI_PID_PID0_BIT)
+
+
+/*************************************************************************
+ * IPU (Image Processing Unit)
+ *************************************************************************/
+#define IPU_V_BASE		0xB3080000
+#define IPU_P_BASE		0x13080000
+
+/* Register offset */
+#define REG_CTRL		0x0  /* IPU Control Register */
+#define REG_STATUS		0x4  /* IPU Status Register */
+#define REG_D_FMT		0x8  /* Data Format Register */
+#define REG_Y_ADDR		0xc  /* Input Y or YUV422 Packaged Data Address Register */
+#define REG_U_ADDR		0x10 /* Input U Data Address Register */
+#define REG_V_ADDR		0x14 /* Input V Data Address Register */
+#define REG_IN_FM_GS		0x18 /* Input Geometric Size Register */
+#define REG_Y_STRIDE		0x1c /* Input Y Data Line Stride Register */
+#define REG_UV_STRIDE		0x20 /* Input UV Data Line Stride Register */
+#define REG_OUT_ADDR		0x24 /* Output Frame Start Address Register */
+#define REG_OUT_GS		0x28 /* Output Geometric Size Register */
+#define REG_OUT_STRIDE		0x2c /* Output Data Line Stride Register */
+#define REG_RSZ_COEF_INDEX	0x30 /* Resize Coefficients Table Index Register */
+#define REG_CSC_CO_COEF		0x34 /* CSC C0 Coefficient Register */
+#define REG_CSC_C1_COEF		0x38 /* CSC C1 Coefficient Register */
+#define REG_CSC_C2_COEF 	0x3c /* CSC C2 Coefficient Register */
+#define REG_CSC_C3_COEF 	0x40 /* CSC C3 Coefficient Register */
+#define REG_CSC_C4_COEF 	0x44 /* CSC C4 Coefficient Register */
+#define HRSZ_LUT_BASE 		0x48 /* Horizontal Resize Coefficients Look Up Table Register group */
+#define VRSZ_LUT_BASE 		0x4c /* Virtical Resize Coefficients Look Up Table Register group */
+#define REG_CSC_OFSET_PARA	0x50 /* CSC Offset Parameter Register */
+#define REG_Y_PHY_T_ADDR	0x54 /* Input Y Physical Table Address Register */
+#define REG_U_PHY_T_ADDR	0x58 /* Input U Physical Table Address Register */
+#define REG_V_PHY_T_ADDR	0x5c /* Input V Physical Table Address Register */
+#define REG_OUT_PHY_T_ADDR	0x60 /* Output Physical Table Address Register */
+
+/* REG_CTRL: IPU Control Register */
+#define IPU_CE_SFT	0x0
+#define IPU_CE_MSK	0x1
+#define IPU_RUN_SFT	0x1
+#define IPU_RUN_MSK	0x1
+#define HRSZ_EN_SFT	0x2
+#define HRSZ_EN_MSK	0x1
+#define VRSZ_EN_SFT	0x3
+#define VRSZ_EN_MSK	0x1
+#define CSC_EN_SFT	0x4
+#define CSC_EN_MSK	0x1
+#define FM_IRQ_EN_SFT	0x5
+#define FM_IRQ_EN_MSK	0x1
+#define IPU_RST_SFT	0x6
+#define IPU_RST_MSK	0x1
+#define H_SCALE_SFT	0x8
+#define H_SCALE_MSK	0x1
+#define V_SCALE_SFT	0x9
+#define V_SCALE_MSK	0x1
+#define PKG_SEL_SFT	0xA
+#define PKG_SEL_MSK	0x1
+#define LCDC_SEL_SFT	0xB
+#define LCDC_SEL_MSK	0x1
+#define SPAGE_MAP_SFT	0xC
+#define SPAGE_MAP_MSK	0x1
+#define DPAGE_SEL_SFT	0xD
+#define DPAGE_SEL_MSK	0x1
+#define DISP_SEL_SFT	0xE
+#define DISP_SEL_MSK	0x1
+#define FIELD_CONF_EN_SFT 15
+#define FIELD_CONF_EN_MSK 1
+#define FIELD_SEL_SFT	16
+#define FIELD_SEL_MSK	1
+#define DFIX_SEL_SFT	17
+#define DFIX_SEL_MSK	1
+
+/* REG_STATUS: IPU Status Register */
+#define OUT_END_SFT	0x0
+#define OUT_END_MSK	0x1
+#define FMT_ERR_SFT	0x1
+#define FMT_ERR_MSK	0x1
+#define SIZE_ERR_SFT	0x2
+#define SIZE_ERR_MSK	0x1
+
+/* D_FMT: Data Format Register */
+#define IN_FMT_SFT	0x0
+#define IN_FMT_MSK 	0x3
+#define IN_OFT_SFT 	0x2
+#define IN_OFT_MSK 	0x3
+#define YUV_PKG_OUT_SFT	0x10
+#define YUV_PKG_OUT_MSK	0x7
+#define OUT_FMT_SFT 	0x13
+#define OUT_FMT_MSK 	0x3
+#define RGB_OUT_OFT_SFT	0x15
+#define RGB_OUT_OFT_MSK	0x7
+#define RGB888_FMT_SFT	0x18
+#define RGB888_FMT_MSK	0x1
+
+/* IN_FM_GS: Input Geometric Size Register */
+#define IN_FM_H_SFT	0x0
+#define IN_FM_H_MSK	0xFFF
+#define IN_FM_W_SFT	0x10
+#define IN_FM_W_MSK	0xFFF
+
+/* Y_STRIDE: Input Y Data Line Stride Register */
+#define Y_S_SFT		0x0
+#define Y_S_MSK		0x3FFF
+
+/* UV_STRIDE: Input UV Data Line Stride Register */
+#define V_S_SFT		0x0
+#define V_S_MSK		0x1FFF
+#define U_S_SFT 	0x10
+#define U_S_MSK		0x1FFF
+
+/* OUT_GS: Output Geometric Size Register */
+#define OUT_FM_H_SFT	0x0
+#define OUT_FM_H_MSK	0x1FFF
+#define OUT_FM_W_SFT	0x10
+#define OUT_FM_W_MSK	0x7FFF
+
+/* OUT_STRIDE: Output Data Line Stride Register */
+#define OUT_S_SFT	0x0
+#define OUT_S_MSK	0xFFFF
+
+/* RSZ_COEF_INDEX: Resize Coefficients Table Index Register */
+#define VE_IDX_SFT	0x0
+#define VE_IDX_MSK	0x1F
+#define HE_IDX_SFT	0x10
+#define HE_IDX_MSK	0x1F
+
+/* CSC_CX_COEF: CSC CX Coefficient Register */
+#define CX_COEF_SFT	0x0
+#define CX_COEF_MSK	0xFFF
+
+/* HRSZ_LUT_BASE, VRSZ_LUT_BASE: Resize Coefficients Look Up Table Register group */
+#define LUT_LEN		20
+
+#define OUT_N_SFT	0x0
+#define OUT_N_MSK	0x1
+#define IN_N_SFT	0x1
+#define IN_N_MSK	0x1
+#define W_COEF_SFT	0x2
+#define W_COEF_MSK	0x3FF
+
+/* CSC_OFSET_PARA: CSC Offset Parameter Register */
+#define CHROM_OF_SFT	0x10
+#define CHROM_OF_MSK	0xFF
+#define LUMA_OF_SFT	0x00
+#define LUMA_OF_MSK	0xFF
+
+
+#endif /* __JZ4750D_REGS_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750d/serial.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750d/serial.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,30 @@
+/*
+ *  linux/include/asm-mips/mach-jz4750d/serial.h
+ *
+ *  Ingenic's JZ4750D common include.
+ *
+ *  Copyright (C) 2008 Ingenic Semiconductor Inc.
+ *
+ *  Author: <cwjia@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_BOARD_SERIAL_H__
+#define __ASM_BOARD_SERIAL_H__
+
+#ifndef CONFIG_SERIAL_MANY_PORTS
+#undef RS_TABLE_SIZE
+#define RS_TABLE_SIZE  1
+#endif
+
+#define JZ_BASE_BAUD	(12000000/16)
+
+#define JZ_SERIAL_PORT_DEFNS \
+	{ .baud_base = JZ_BASE_BAUD, .irq = IRQ_UART0, \
+	  .flags = STD_COM_FLAGS, .iomem_base = (u8 *)UART0_BASE, \
+	  .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM },
+
+#endif /* __ASM_BORAD_SERIAL_H__ */
--- linux-2.6.24.7.old/include/asm-mips/mach-jz4750d/war.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/mach-jz4750d/war.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_JZ4740_WAR_H
+#define __ASM_MIPS_MACH_JZ4740_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_JZ4740_WAR_H */
--- linux-2.6.24.7.old/include/asm-mips/ptrace.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/asm-mips/ptrace.h	2009-04-12 18:13:57.000000000 +0200
@@ -79,7 +79,7 @@
 /*
  * Does the process account for user or for system time?
  */
-#define user_mode(regs) (((regs)->cp0_status & KU_MASK) == KU_USER)
+#define user_mode(regs) ((((regs)->cp0_status & KU_MASK) == KU_USER) || (((regs)->cp0_status & 0x08000000) == 0x08000000))
 
 #define instruction_pointer(regs) ((regs)->cp0_epc)
 #define profile_pc(regs) instruction_pointer(regs)
--- linux-2.6.24.7.old/include/asm-mips/r4kcache.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/asm-mips/r4kcache.h	2009-04-12 18:13:57.000000000 +0200
@@ -17,6 +17,58 @@
 #include <asm/cpu-features.h>
 #include <asm/mipsmtregs.h>
 
+#ifdef CONFIG_JZRISC
+
+#define K0_TO_K1()				\
+do {						\
+	unsigned long __k0_addr;		\
+						\
+	__asm__ __volatile__(			\
+	"la %0, 1f\n\t"				\
+	"or	%0, %0, %1\n\t"			\
+	"jr	%0\n\t"				\
+	"nop\n\t"				\
+	"1: nop\n"				\
+	: "=&r"(__k0_addr)			\
+	: "r" (0x20000000) );			\
+} while(0)
+
+#define K1_TO_K0()				\
+do {						\
+	unsigned long __k0_addr;		\
+	__asm__ __volatile__(			\
+	"nop;nop;nop;nop;nop;nop;nop\n\t"	\
+	"la %0, 1f\n\t"				\
+	"jr	%0\n\t"				\
+	"nop\n\t"				\
+	"1:	nop\n"				\
+	: "=&r" (__k0_addr));			\
+} while (0)
+
+#define INVALIDATE_BTB()			\
+do {						\
+	unsigned long tmp;			\
+	__asm__ __volatile__(			\
+	".set mips32\n\t"			\
+	"mfc0 %0, $16, 7\n\t"			\
+	"nop\n\t"				\
+	"ori %0, 2\n\t"				\
+	"mtc0 %0, $16, 7\n\t"			\
+	"nop\n\t"				\
+	: "=&r" (tmp));				\
+} while (0)
+
+#define SYNC_WB() __asm__ __volatile__ ("sync")
+
+#else /* CONFIG_JZRISC */
+
+#define K0_TO_K1() do { } while (0)
+#define K1_TO_K0() do { } while (0)
+#define INVALIDATE_BTB() do { } while (0)
+#define SYNC_WB() do { } while (0)
+
+#endif /* CONFIG_JZRISC */
+
 /*
  * This macro return a properly sign-extended address suitable as base address
  * for indexed cache operations.  Two issues here:
@@ -144,6 +196,7 @@
 {
 	__iflush_prologue
 	cache_op(Index_Invalidate_I, addr);
+	INVALIDATE_BTB();
 	__iflush_epilogue
 }
 
@@ -151,6 +204,7 @@
 {
 	__dflush_prologue
 	cache_op(Index_Writeback_Inv_D, addr);
+	SYNC_WB();
 	__dflush_epilogue
 }
 
@@ -163,6 +217,7 @@
 {
 	__iflush_prologue
 	cache_op(Hit_Invalidate_I, addr);
+	INVALIDATE_BTB();
 	__iflush_epilogue
 }
 
@@ -170,6 +225,7 @@
 {
 	__dflush_prologue
 	cache_op(Hit_Writeback_Inv_D, addr);
+	SYNC_WB();
 	__dflush_epilogue
 }
 
@@ -177,6 +233,7 @@
 {
 	__dflush_prologue
 	cache_op(Hit_Invalidate_D, addr);
+	SYNC_WB();
 	__dflush_epilogue
 }
 
@@ -209,6 +266,7 @@
 static inline void protected_flush_icache_line(unsigned long addr)
 {
 	protected_cache_op(Hit_Invalidate_I, addr);
+	INVALIDATE_BTB();
 }
 
 /*
@@ -220,6 +278,7 @@
 static inline void protected_writeback_dcache_line(unsigned long addr)
 {
 	protected_cache_op(Hit_Writeback_Inv_D, addr);
+	SYNC_WB();
 }
 
 static inline void protected_writeback_scache_line(unsigned long addr)
@@ -396,13 +455,123 @@
 __BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 16)
 __BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 16)
 __BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 16)
+#ifndef CONFIG_JZRISC
 __BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 32)
 __BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 32)
+#endif
 __BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 32)
 __BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 64)
 __BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 64)
 __BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 128)
 
+#ifdef CONFIG_JZRISC
+
+static inline void blast_dcache32(void)
+{
+	unsigned long start = INDEX_BASE;
+	unsigned long end = start + current_cpu_data.dcache.waysize;
+	unsigned long ws_inc = 1UL << current_cpu_data.dcache.waybit;
+	unsigned long ws_end = current_cpu_data.dcache.ways <<
+	                       current_cpu_data.dcache.waybit;
+	unsigned long ws, addr;
+
+	for (ws = 0; ws < ws_end; ws += ws_inc)
+		for (addr = start; addr < end; addr += 0x400)
+			cache32_unroll32(addr|ws,Index_Writeback_Inv_D);
+
+	SYNC_WB();
+}
+
+static inline void blast_dcache32_page(unsigned long page)
+{
+	unsigned long start = page;
+	unsigned long end = page + PAGE_SIZE;
+
+	do {
+		cache32_unroll32(start,Hit_Writeback_Inv_D);
+		start += 0x400;
+	} while (start < end);
+
+	SYNC_WB();
+}
+
+static inline void blast_dcache32_page_indexed(unsigned long page)
+{
+	unsigned long indexmask = current_cpu_data.dcache.waysize - 1;
+	unsigned long start = INDEX_BASE + (page & indexmask);
+	unsigned long end = start + PAGE_SIZE;
+	unsigned long ws_inc = 1UL << current_cpu_data.dcache.waybit;
+	unsigned long ws_end = current_cpu_data.dcache.ways <<
+	                       current_cpu_data.dcache.waybit;
+	unsigned long ws, addr;
+
+	for (ws = 0; ws < ws_end; ws += ws_inc)
+		for (addr = start; addr < end; addr += 0x400)
+			cache32_unroll32(addr|ws,Index_Writeback_Inv_D);
+
+	SYNC_WB();
+}
+
+static inline void blast_icache32(void)
+{
+	unsigned long start = INDEX_BASE;
+	unsigned long end = start + current_cpu_data.icache.waysize;
+	unsigned long ws_inc = 1UL << current_cpu_data.icache.waybit;
+	unsigned long ws_end = current_cpu_data.icache.ways <<
+	                       current_cpu_data.icache.waybit;
+	unsigned long ws, addr;
+
+	K0_TO_K1();
+
+	for (ws = 0; ws < ws_end; ws += ws_inc)
+		for (addr = start; addr < end; addr += 0x400)
+			cache32_unroll32(addr|ws,Index_Invalidate_I);
+
+	INVALIDATE_BTB();
+
+	K1_TO_K0();
+}
+
+static inline void blast_icache32_page(unsigned long page)
+{
+	unsigned long start = page;
+	unsigned long end = page + PAGE_SIZE;
+
+	K0_TO_K1();
+
+	do {
+		cache32_unroll32(start,Hit_Invalidate_I);
+		start += 0x400;
+	} while (start < end);
+
+	INVALIDATE_BTB();
+
+	K1_TO_K0();
+}
+
+static inline void blast_icache32_page_indexed(unsigned long page)
+{
+	unsigned long indexmask = current_cpu_data.icache.waysize - 1;
+	unsigned long start = INDEX_BASE + (page & indexmask);
+	unsigned long end = start + PAGE_SIZE;
+	unsigned long ws_inc = 1UL << current_cpu_data.icache.waybit;
+	unsigned long ws_end = current_cpu_data.icache.ways <<
+	                       current_cpu_data.icache.waybit;
+	unsigned long ws, addr;
+
+	K0_TO_K1();
+
+	for (ws = 0; ws < ws_end; ws += ws_inc)
+		for (addr = start; addr < end; addr += 0x400)
+			cache32_unroll32(addr|ws,Index_Invalidate_I);
+
+	INVALIDATE_BTB();
+
+	K1_TO_K0();
+}
+
+#endif /* CONFIG_JZRISC */
+
 /* build blast_xxx_range, protected_blast_xxx_range */
 #define __BUILD_BLAST_CACHE_RANGE(pfx, desc, hitop, prot) \
 static inline void prot##blast_##pfx##cache##_range(unsigned long start, \
@@ -424,13 +593,73 @@
 	__##pfx##flush_epilogue						\
 }
 
+#ifndef CONFIG_JZRISC
 __BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, protected_)
+#endif
 __BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, protected_)
+#ifndef CONFIG_JZRISC
 __BUILD_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I, protected_)
 __BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, )
+#endif
 __BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, )
 /* blast_inv_dcache_range */
 __BUILD_BLAST_CACHE_RANGE(inv_d, dcache, Hit_Invalidate_D, )
 __BUILD_BLAST_CACHE_RANGE(inv_s, scache, Hit_Invalidate_SD, )
 
+#ifdef CONFIG_JZRISC
+
+static inline void protected_blast_dcache_range(unsigned long start,
+						unsigned long end)
+{
+	unsigned long lsize = cpu_dcache_line_size();
+	unsigned long addr = start & ~(lsize - 1);
+	unsigned long aend = (end - 1) & ~(lsize - 1);
+
+	while (1) {
+		protected_cache_op(Hit_Writeback_Inv_D, addr);
+		if (addr == aend)
+			break;
+		addr += lsize;
+	}
+	SYNC_WB();
+}
+
+static inline void protected_blast_icache_range(unsigned long start,
+						unsigned long end)
+{
+	unsigned long lsize = cpu_icache_line_size();
+	unsigned long addr = start & ~(lsize - 1);
+	unsigned long aend = (end - 1) & ~(lsize - 1);
+
+	K0_TO_K1();
+
+	while (1) {
+		protected_cache_op(Hit_Invalidate_I, addr);
+		if (addr == aend)
+			break;
+		addr += lsize;
+	}
+	INVALIDATE_BTB();
+
+	K1_TO_K0();
+}
+
+static inline void blast_dcache_range(unsigned long start,
+				      unsigned long end)
+{
+	unsigned long lsize = cpu_dcache_line_size();
+	unsigned long addr = start & ~(lsize - 1);
+	unsigned long aend = (end - 1) & ~(lsize - 1);
+
+	while (1) {
+		cache_op(Hit_Writeback_Inv_D, addr);
+		if (addr == aend)
+			break;
+		addr += lsize;
+	}
+	SYNC_WB();
+}
+
+#endif /* CONFIG_JZRISC */
+
 #endif /* _ASM_R4KCACHE_H */
--- linux-2.6.24.7.old/include/asm-mips/sizes.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/asm-mips/sizes.h	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size definitions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_16				0x00000010
+#define SZ_256				0x00000100
+#define SZ_512				0x00000200
+
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
--- linux-2.6.24.7.old/include/linux/fs.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/linux/fs.h	2009-04-12 18:13:57.000000000 +0200
@@ -1670,6 +1670,8 @@
 extern int invalidate_inode_pages2(struct address_space *mapping);
 extern int invalidate_inode_pages2_range(struct address_space *mapping,
 					 pgoff_t start, pgoff_t end);
+extern void generic_sync_sb_inodes(struct super_block *sb,
+				struct writeback_control *wbc);
 extern int write_inode_now(struct inode *, int);
 extern int filemap_fdatawrite(struct address_space *);
 extern int filemap_flush(struct address_space *);
--- linux-2.6.24.7.old/include/linux/i2c-dev.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/linux/i2c-dev.h	2009-04-12 18:13:57.000000000 +0200
@@ -49,7 +49,8 @@
 
 #define I2C_PEC		0x0708	/* != 0 to use PEC with SMBus */
 #define I2C_SMBUS	0x0720	/* SMBus transfer */
-
+#define I2C_SET_SUB_ADDRESS	0x0730	/* SMBus transfer */
+#define I2C_SET_CLOCK	0x0731	/* SMBus transfer */
 
 /* This is the structure as used in the I2C_SMBUS ioctl call */
 struct i2c_smbus_ioctl_data {
@@ -71,4 +72,5 @@
 #define I2C_MAJOR	89		/* Device major number		*/
 #endif
 
+extern void i2c_jz_setclk(unsigned int i2cclk);
 #endif /* _LINUX_I2C_DEV_H */
--- linux-2.6.24.7.old/include/linux/mmc/host.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/linux/mmc/host.h	2009-04-12 18:13:57.000000000 +0200
@@ -41,6 +41,7 @@
 
 #define MMC_BUS_WIDTH_1		0
 #define MMC_BUS_WIDTH_4		2
+#define MMC_BUS_WIDTH_8		4
 
 	unsigned char	timing;			/* timing specification used */
 
--- linux-2.6.24.7.old/include/linux/mtd/mtd.h	2009-04-12 18:05:07.000000000 +0200
+++ linux-2.6.24.7/include/linux/mtd/mtd.h	2009-04-12 18:13:57.000000000 +0200
@@ -32,9 +32,9 @@
    specific to any particular block. */
 struct erase_info {
 	struct mtd_info *mtd;
-	u_int32_t addr;
-	u_int32_t len;
-	u_int32_t fail_addr;
+	u_int64_t addr;
+	u_int64_t len;
+	u_int64_t fail_addr;
 	u_long time;
 	u_long retries;
 	u_int dev;
@@ -46,7 +46,7 @@
 };
 
 struct mtd_erase_region_info {
-	u_int32_t offset;			/* At which this region starts, from the beginning of the MTD */
+	u_int64_t offset;			/* At which this region starts, from the beginning of the MTD */
 	u_int32_t erasesize;		/* For this region */
 	u_int32_t numblocks;		/* Number of blocks of erasesize in this region */
 	unsigned long *lockmap;		/* If keeping bitmap of locks */
@@ -89,10 +89,10 @@
  */
 struct mtd_oob_ops {
 	mtd_oob_mode_t	mode;
-	size_t		len;
-	size_t		retlen;
-	size_t		ooblen;
-	size_t		oobretlen;
+	size_mtd_t		len;
+	size_mtd_t		retlen;
+	size_mtd_t		ooblen;
+	size_mtd_t		oobretlen;
 	uint32_t	ooboffs;
 	uint8_t		*datbuf;
 	uint8_t		*oobbuf;
@@ -102,7 +102,7 @@
 struct mtd_info {
 	u_char type;
 	u_int32_t flags;
-	u_int32_t size;	 // Total size of the MTD
+	u_int64_t size;	 // Total size of the MTD
 
 	/* "Major" erase size for the device. Nave users may take this
 	 * to be the only erase size available, or may use the more detailed
@@ -144,18 +144,18 @@
 	int (*erase) (struct mtd_info *mtd, struct erase_info *instr);
 
 	/* This stuff for eXecute-In-Place */
-	int (*point) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char **mtdbuf);
+	int (*point) (struct mtd_info *mtd, loff_mtd_t from, size_mtd_t len, size_mtd_t *retlen, u_char **mtdbuf);
 
 	/* We probably shouldn't allow XIP if the unpoint isn't a NULL */
-	void (*unpoint) (struct mtd_info *mtd, u_char * addr, loff_t from, size_t len);
+	void (*unpoint) (struct mtd_info *mtd, u_char * addr, loff_mtd_t from, size_mtd_t len);
 
 
-	int (*read) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
-	int (*write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
+	int (*read) (struct mtd_info *mtd, loff_mtd_t from, size_mtd_t len, size_mtd_t *retlen, u_char *buf);
+	int (*write) (struct mtd_info *mtd, loff_mtd_t to, size_mtd_t len, size_mtd_t *retlen, const u_char *buf);
 
-	int (*read_oob) (struct mtd_info *mtd, loff_t from,
+	int (*read_oob) (struct mtd_info *mtd, loff_mtd_t from,
 			 struct mtd_oob_ops *ops);
-	int (*write_oob) (struct mtd_info *mtd, loff_t to,
+	int (*write_oob) (struct mtd_info *mtd, loff_mtd_t to,
 			 struct mtd_oob_ops *ops);
 
 	/*
@@ -163,33 +163,33 @@
 	 * flash devices. The user data is one time programmable but the
 	 * factory data is read only.
 	 */
-	int (*get_fact_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);
-	int (*read_fact_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
-	int (*get_user_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);
-	int (*read_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
-	int (*write_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
-	int (*lock_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len);
+	int (*get_fact_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_mtd_t len);
+	int (*read_fact_prot_reg) (struct mtd_info *mtd, loff_mtd_t from, size_mtd_t len, size_mtd_t *retlen, u_char *buf);
+	int (*get_user_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_mtd_t len);
+	int (*read_user_prot_reg) (struct mtd_info *mtd, loff_mtd_t from, size_mtd_t len, size_mtd_t *retlen, u_char *buf);
+	int (*write_user_prot_reg) (struct mtd_info *mtd, loff_mtd_t from, size_mtd_t len, size_mtd_t *retlen, u_char *buf);
+	int (*lock_user_prot_reg) (struct mtd_info *mtd, loff_mtd_t from, size_mtd_t len);
 
 	/* kvec-based read/write methods.
 	   NB: The 'count' parameter is the number of _vectors_, each of
 	   which contains an (ofs, len) tuple.
 	*/
-	int (*writev) (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, loff_t to, size_t *retlen);
+	int (*writev) (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, loff_mtd_t to, size_mtd_t *retlen);
 
 	/* Sync */
 	void (*sync) (struct mtd_info *mtd);
 
 	/* Chip-supported device locking */
-	int (*lock) (struct mtd_info *mtd, loff_t ofs, size_t len);
-	int (*unlock) (struct mtd_info *mtd, loff_t ofs, size_t len);
+	int (*lock) (struct mtd_info *mtd, loff_mtd_t ofs, size_mtd_t len);
+	int (*unlock) (struct mtd_info *mtd, loff_mtd_t ofs, size_mtd_t len);
 
 	/* Power Management functions */
 	int (*suspend) (struct mtd_info *mtd);
 	void (*resume) (struct mtd_info *mtd);
 
 	/* Bad block management functions */
-	int (*block_isbad) (struct mtd_info *mtd, loff_t ofs);
-	int (*block_markbad) (struct mtd_info *mtd, loff_t ofs);
+	int (*block_isbad) (struct mtd_info *mtd, loff_mtd_t ofs);
+	int (*block_markbad) (struct mtd_info *mtd, loff_mtd_t ofs);
 
 	struct notifier_block reboot_notifier;  /* default mode before reboot */
 
@@ -237,10 +237,10 @@
 extern int unregister_mtd_user (struct mtd_notifier *old);
 
 int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
-		       unsigned long count, loff_t to, size_t *retlen);
+		       unsigned long count, loff_mtd_t to, size_mtd_t *retlen);
 
 int default_mtd_readv(struct mtd_info *mtd, struct kvec *vecs,
-		      unsigned long count, loff_t from, size_t *retlen);
+		      unsigned long count, loff_mtd_t from, size_mtd_t *retlen);
 
 #ifdef CONFIG_MTD_PARTITIONS
 void mtd_erase_callback(struct erase_info *instr);
--- linux-2.6.24.7.old/include/linux/mtd/mtd.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/linux/mtd/mtd.h.orig	2009-04-12 18:01:55.000000000 +0200
@@ -0,0 +1,274 @@
+/*
+ * $Id: mtd.h,v 1.61 2005/11/07 11:14:54 gleixner Exp $
+ *
+ * Copyright (C) 1999-2003 David Woodhouse <dwmw2@infradead.org> et al.
+ *
+ * Released under GPL
+ */
+
+#ifndef __MTD_MTD_H__
+#define __MTD_MTD_H__
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/uio.h>
+#include <linux/notifier.h>
+
+#include <linux/mtd/compatmac.h>
+#include <mtd/mtd-abi.h>
+
+#define MTD_CHAR_MAJOR 90
+#define MTD_BLOCK_MAJOR 31
+#define MAX_MTD_DEVICES 32
+
+#define MTD_ERASE_PENDING      	0x01
+#define MTD_ERASING		0x02
+#define MTD_ERASE_SUSPEND	0x04
+#define MTD_ERASE_DONE          0x08
+#define MTD_ERASE_FAILED        0x10
+
+/* If the erase fails, fail_addr might indicate exactly which block failed.  If
+   fail_addr = 0xffffffff, the failure was not at the device level or was not
+   specific to any particular block. */
+struct erase_info {
+	struct mtd_info *mtd;
+	u_int32_t addr;
+	u_int32_t len;
+	u_int32_t fail_addr;
+	u_long time;
+	u_long retries;
+	u_int dev;
+	u_int cell;
+	void (*callback) (struct erase_info *self);
+	u_long priv;
+	u_char state;
+	struct erase_info *next;
+};
+
+struct mtd_erase_region_info {
+	u_int32_t offset;			/* At which this region starts, from the beginning of the MTD */
+	u_int32_t erasesize;		/* For this region */
+	u_int32_t numblocks;		/* Number of blocks of erasesize in this region */
+	unsigned long *lockmap;		/* If keeping bitmap of locks */
+};
+
+/*
+ * oob operation modes
+ *
+ * MTD_OOB_PLACE:	oob data are placed at the given offset
+ * MTD_OOB_AUTO:	oob data are automatically placed at the free areas
+ *			which are defined by the ecclayout
+ * MTD_OOB_RAW:		mode to read raw data+oob in one chunk. The oob data
+ *			is inserted into the data. Thats a raw image of the
+ *			flash contents.
+ */
+typedef enum {
+	MTD_OOB_PLACE,
+	MTD_OOB_AUTO,
+	MTD_OOB_RAW,
+} mtd_oob_mode_t;
+
+/**
+ * struct mtd_oob_ops - oob operation operands
+ * @mode:	operation mode
+ *
+ * @len:	number of data bytes to write/read
+ *
+ * @retlen:	number of data bytes written/read
+ *
+ * @ooblen:	number of oob bytes to write/read
+ * @oobretlen:	number of oob bytes written/read
+ * @ooboffs:	offset of oob data in the oob area (only relevant when
+ *		mode = MTD_OOB_PLACE)
+ * @datbuf:	data buffer - if NULL only oob data are read/written
+ * @oobbuf:	oob data buffer
+ *
+ * Note, it is allowed to read more then one OOB area at one go, but not write.
+ * The interface assumes that the OOB write requests program only one page's
+ * OOB area.
+ */
+struct mtd_oob_ops {
+	mtd_oob_mode_t	mode;
+	size_t		len;
+	size_t		retlen;
+	size_t		ooblen;
+	size_t		oobretlen;
+	uint32_t	ooboffs;
+	uint8_t		*datbuf;
+	uint8_t		*oobbuf;
+};
+
+struct mtd_info;
+struct mtd_info {
+	u_char type;
+	u_int32_t flags;
+	u_int32_t size;	 // Total size of the MTD
+
+	/* "Major" erase size for the device. Nave users may take this
+	 * to be the only erase size available, or may use the more detailed
+	 * information below if they desire
+	 */
+	u_int32_t erasesize;
+	/* Minimal writable flash unit size. In case of NOR flash it is 1 (even
+	 * though individual bits can be cleared), in case of NAND flash it is
+	 * one NAND page (or half, or one-fourths of it), in case of ECC-ed NOR
+	 * it is of ECC block size, etc. It is illegal to have writesize = 0.
+	 * Any driver registering a struct mtd_info must ensure a writesize of
+	 * 1 or larger.
+	 */
+	u_int32_t writesize;
+
+	u_int32_t oobsize;   // Amount of OOB data per block (e.g. 16)
+	u_int32_t oobavail;  // Available OOB bytes per block
+
+	// Kernel-only stuff starts here.
+	char *name;
+	int index;
+
+	/* ecc layout structure pointer - read only ! */
+	struct nand_ecclayout *ecclayout;
+
+	/* Data for variable erase regions. If numeraseregions is zero,
+	 * it means that the whole device has erasesize as given above.
+	 */
+	int numeraseregions;
+	struct mtd_erase_region_info *eraseregions;
+
+	/*
+	 * Erase is an asynchronous operation.  Device drivers are supposed
+	 * to call instr->callback() whenever the operation completes, even
+	 * if it completes with a failure.
+	 * Callers are supposed to pass a callback function and wait for it
+	 * to be called before writing to the block.
+	 */
+	int (*erase) (struct mtd_info *mtd, struct erase_info *instr);
+
+	/* This stuff for eXecute-In-Place */
+	int (*point) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char **mtdbuf);
+
+	/* We probably shouldn't allow XIP if the unpoint isn't a NULL */
+	void (*unpoint) (struct mtd_info *mtd, u_char * addr, loff_t from, size_t len);
+
+
+	int (*read) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
+	int (*write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
+
+	int (*read_oob) (struct mtd_info *mtd, loff_t from,
+			 struct mtd_oob_ops *ops);
+	int (*write_oob) (struct mtd_info *mtd, loff_t to,
+			 struct mtd_oob_ops *ops);
+
+	/*
+	 * Methods to access the protection register area, present in some
+	 * flash devices. The user data is one time programmable but the
+	 * factory data is read only.
+	 */
+	int (*get_fact_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);
+	int (*read_fact_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
+	int (*get_user_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);
+	int (*read_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
+	int (*write_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
+	int (*lock_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len);
+
+	/* kvec-based read/write methods.
+	   NB: The 'count' parameter is the number of _vectors_, each of
+	   which contains an (ofs, len) tuple.
+	*/
+	int (*writev) (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, loff_t to, size_t *retlen);
+
+	/* Sync */
+	void (*sync) (struct mtd_info *mtd);
+
+	/* Chip-supported device locking */
+	int (*lock) (struct mtd_info *mtd, loff_t ofs, size_t len);
+	int (*unlock) (struct mtd_info *mtd, loff_t ofs, size_t len);
+
+	/* Power Management functions */
+	int (*suspend) (struct mtd_info *mtd);
+	void (*resume) (struct mtd_info *mtd);
+
+	/* Bad block management functions */
+	int (*block_isbad) (struct mtd_info *mtd, loff_t ofs);
+	int (*block_markbad) (struct mtd_info *mtd, loff_t ofs);
+
+	struct notifier_block reboot_notifier;  /* default mode before reboot */
+
+	/* ECC status information */
+	struct mtd_ecc_stats ecc_stats;
+	/* Subpage shift (NAND) */
+	int subpage_sft;
+
+	void *priv;
+
+	struct module *owner;
+	int usecount;
+
+	int (*refresh_device)(struct mtd_info *mtd);
+	struct mtd_info *split;
+
+	/* If the driver is something smart, like UBI, it may need to maintain
+	 * its own reference counting. The below functions are only for driver.
+	 * The driver may register its callbacks. These callbacks are not
+	 * supposed to be called by MTD users */
+	int (*get_device) (struct mtd_info *mtd);
+	void (*put_device) (struct mtd_info *mtd);
+};
+
+
+	/* Kernel-side ioctl definitions */
+
+extern int add_mtd_device(struct mtd_info *mtd);
+extern int del_mtd_device (struct mtd_info *mtd);
+
+extern struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num);
+extern struct mtd_info *get_mtd_device_nm(const char *name);
+
+extern void put_mtd_device(struct mtd_info *mtd);
+
+
+struct mtd_notifier {
+	void (*add)(struct mtd_info *mtd);
+	void (*remove)(struct mtd_info *mtd);
+	struct list_head list;
+};
+
+
+extern void register_mtd_user (struct mtd_notifier *new);
+extern int unregister_mtd_user (struct mtd_notifier *old);
+
+int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
+		       unsigned long count, loff_t to, size_t *retlen);
+
+int default_mtd_readv(struct mtd_info *mtd, struct kvec *vecs,
+		      unsigned long count, loff_t from, size_t *retlen);
+
+#ifdef CONFIG_MTD_PARTITIONS
+void mtd_erase_callback(struct erase_info *instr);
+#else
+static inline void mtd_erase_callback(struct erase_info *instr)
+{
+	if (instr->callback)
+		instr->callback(instr);
+}
+#endif
+
+/*
+ * Debugging macro and defines
+ */
+#define MTD_DEBUG_LEVEL0	(0)	/* Quiet   */
+#define MTD_DEBUG_LEVEL1	(1)	/* Audible */
+#define MTD_DEBUG_LEVEL2	(2)	/* Loud    */
+#define MTD_DEBUG_LEVEL3	(3)	/* Noisy   */
+
+#ifdef CONFIG_MTD_DEBUG
+#define DEBUG(n, args...)				\
+	do {						\
+		if (n <= CONFIG_MTD_DEBUG_VERBOSE)	\
+			printk(KERN_INFO args);		\
+	} while(0)
+#else /* CONFIG_MTD_DEBUG */
+#define DEBUG(n, args...) do { } while(0)
+
+#endif /* CONFIG_MTD_DEBUG */
+
+#endif /* __MTD_MTD_H__ */
--- linux-2.6.24.7.old/include/linux/mtd/nand.h	2009-04-12 18:05:07.000000000 +0200
+++ linux-2.6.24.7/include/linux/mtd/nand.h	2009-04-12 18:13:57.000000000 +0200
@@ -39,14 +39,14 @@
 extern void nand_wait_ready(struct mtd_info *mtd);
 
 /* The maximum number of NAND chips in an array */
-#define NAND_MAX_CHIPS		8
+#define NAND_MAX_CHIPS		4
 
 /* This constant declares the max. oobsize / page, which
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
-#define NAND_MAX_OOBSIZE	64
-#define NAND_MAX_PAGESIZE	2048
+#define NAND_MAX_OOBSIZE	256
+#define NAND_MAX_PAGESIZE	8192
 
 /*
  * Constants for hardware specific CLE/ALE/NCE function
@@ -55,6 +55,10 @@
  * bits in one go.
  */
 /* Select the chip by setting nCE to low */
+#define NAND_NCE1		0x08
+#define NAND_NCE2		0x10
+#define NAND_NCE3		0x20
+#define NAND_NCE4		0x40
 #define NAND_NCE		0x01
 /* Select the command latch by setting CLE to high */
 #define NAND_CLE		0x02
@@ -372,8 +376,8 @@
 	void		(*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
 	int		(*verify_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
 	void		(*select_chip)(struct mtd_info *mtd, int chip);
-	int		(*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
-	int		(*block_markbad)(struct mtd_info *mtd, loff_t ofs);
+	int		(*block_bad)(struct mtd_info *mtd, loff_mtd_t ofs, int getchip);
+	int		(*block_markbad)(struct mtd_info *mtd, loff_mtd_t ofs);
 	void		(*cmd_ctrl)(struct mtd_info *mtd, int dat,
 				    unsigned int ctrl);
 	int		(*dev_ready)(struct mtd_info *mtd);
@@ -393,12 +397,14 @@
 	int		bbt_erase_shift;
 	int		chip_shift;
 	int		numchips;
-	unsigned long	chipsize;
+	u64         	chipsize;
 	int		pagemask;
 	int		pagebuf;
 	int		subpagesize;
 	uint8_t		cellinfo;
 	int		badblockpos;
+	int     	realplanenum; /* number of planes the NAND has */
+	int     	planenum;     /* number of planes operating synchronously */
 
 	nand_state_t	state;
 
@@ -450,7 +456,7 @@
 	char *name;
 	int id;
 	unsigned long pagesize;
-	unsigned long chipsize;
+	u64 chipsize;
 	unsigned long erasesize;
 	unsigned long options;
 };
@@ -538,13 +544,13 @@
 #define NAND_BBT_SCAN_MAXBLOCKS	4
 
 extern int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd);
-extern int nand_update_bbt(struct mtd_info *mtd, loff_t offs);
+extern int nand_update_bbt(struct mtd_info *mtd, loff_mtd_t offs);
 extern int nand_default_bbt(struct mtd_info *mtd);
-extern int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
+extern int nand_isbad_bbt(struct mtd_info *mtd, loff_mtd_t offs, int allowbbt);
 extern int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
 			   int allowbbt);
-extern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
-			size_t * retlen, uint8_t * buf);
+extern int nand_do_read(struct mtd_info *mtd, loff_mtd_t from, size_mtd_t len,
+			size_mtd_t * retlen, uint8_t * buf);
 
 /*
 * Constants for oob configuration
--- linux-2.6.24.7.old/include/linux/mtd/partitions.h	2009-04-12 18:05:07.000000000 +0200
+++ linux-2.6.24.7/include/linux/mtd/partitions.h	2009-04-12 18:13:57.000000000 +0200
@@ -39,8 +39,9 @@
 struct mtd_partition;
 struct mtd_partition {
 	char *name;			/* identifier string */
-	u_int32_t size;			/* partition size */
-	u_int32_t offset;		/* offset within the master MTD space */
+	u_int64_t size;			/* partition size */
+	u_int64_t offset;		/* offset within the master MTD space */
+	char use_planes;                /* flag to specify whether multiple planes of NAND is used in the partition */
 	u_int32_t mask_flags;		/* master MTD flags to mask out for this partition */
 	struct nand_ecclayout *ecclayout;	/* out of band layout for this partition (NAND only)*/
 	struct mtd_info **mtdp;		/* pointer to store the MTD object */
--- linux-2.6.24.7.old/include/linux/mtd/partitions.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/linux/mtd/partitions.h.orig	2009-04-12 18:01:55.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+ * MTD partitioning layer definitions
+ *
+ * (C) 2000 Nicolas Pitre <nico@cam.org>
+ *
+ * This code is GPL
+ *
+ * $Id: partitions.h,v 1.17 2005/11/07 11:14:55 gleixner Exp $
+ */
+
+#ifndef MTD_PARTITIONS_H
+#define MTD_PARTITIONS_H
+
+#include <linux/types.h>
+
+
+/*
+ * Partition definition structure:
+ *
+ * An array of struct partition is passed along with a MTD object to
+ * add_mtd_partitions() to create them.
+ *
+ * For each partition, these fields are available:
+ * name: string that will be used to label the partition's MTD device.
+ * size: the partition size; if defined as MTDPART_SIZ_FULL, the partition
+ * 	will extend to the end of the master MTD device.
+ * offset: absolute starting position within the master MTD device; if
+ * 	defined as MTDPART_OFS_APPEND, the partition will start where the
+ * 	previous one ended; if MTDPART_OFS_NXTBLK, at the next erase block.
+ * mask_flags: contains flags that have to be masked (removed) from the
+ * 	master MTD flag set for the corresponding MTD partition.
+ * 	For example, to force a read-only partition, simply adding
+ * 	MTD_WRITEABLE to the mask_flags will do the trick.
+ *
+ * Note: writeable partitions require their size and offset be
+ * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
+ */
+
+struct mtd_partition;
+struct mtd_partition {
+	char *name;			/* identifier string */
+	u_int32_t size;			/* partition size */
+	u_int32_t offset;		/* offset within the master MTD space */
+	u_int32_t mask_flags;		/* master MTD flags to mask out for this partition */
+	struct nand_ecclayout *ecclayout;	/* out of band layout for this partition (NAND only)*/
+	struct mtd_info **mtdp;		/* pointer to store the MTD object */
+	int (*refresh_partition)(struct mtd_info *);
+};
+
+#define MTDPART_OFS_NXTBLK	(-2)
+#define MTDPART_OFS_APPEND	(-1)
+#define MTDPART_SIZ_FULL	(0)
+
+
+int add_mtd_partitions(struct mtd_info *, const struct mtd_partition *, int);
+int del_mtd_partitions(struct mtd_info *);
+int refresh_mtd_partitions(struct mtd_info *);
+
+/*
+ * Functions dealing with the various ways of partitioning the space
+ */
+
+struct mtd_part_parser {
+	struct list_head list;
+	struct module *owner;
+	const char *name;
+	int (*parse_fn)(struct mtd_info *, struct mtd_partition **, unsigned long);
+};
+
+extern int register_mtd_parser(struct mtd_part_parser *parser);
+extern int deregister_mtd_parser(struct mtd_part_parser *parser);
+extern int parse_mtd_partitions(struct mtd_info *master, const char **types,
+				struct mtd_partition **pparts, unsigned long origin);
+
+#define put_partition_parser(p) do { module_put((p)->owner); } while(0)
+
+#endif
+
--- linux-2.6.24.7.old/include/linux/mtd/ubi.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/linux/mtd/ubi.h	2009-04-12 18:13:57.000000000 +0200
@@ -26,23 +26,6 @@
 #include <mtd/ubi-user.h>
 
 /*
- * UBI data type hint constants.
- *
- * UBI_LONGTERM: long-term data
- * UBI_SHORTTERM: short-term data
- * UBI_UNKNOWN: data persistence is unknown
- *
- * These constants are used when data is written to UBI volumes in order to
- * help the UBI wear-leveling unit to find more appropriate physical
- * eraseblocks.
- */
-enum {
-	UBI_LONGTERM = 1,
-	UBI_SHORTTERM,
-	UBI_UNKNOWN
-};
-
-/*
  * enum ubi_open_mode - UBI volume open mode constants.
  *
  * UBI_READONLY: read-only mode
@@ -167,6 +150,7 @@
 		   int len, int dtype);
 int ubi_leb_erase(struct ubi_volume_desc *desc, int lnum);
 int ubi_leb_unmap(struct ubi_volume_desc *desc, int lnum);
+int ubi_leb_map(struct ubi_volume_desc *desc, int lnum, int dtype);
 int ubi_is_mapped(struct ubi_volume_desc *desc, int lnum);
 
 /*
--- linux-2.6.24.7.old/include/linux/vt.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/linux/vt.h	2009-04-12 18:13:57.000000000 +0200
@@ -18,10 +18,16 @@
  * resizing).
  */
 #define MIN_NR_CONSOLES 1       /* must be at least 1 */
-#define MAX_NR_CONSOLES	63	/* serial lines start at 64 */
-#define MAX_NR_USER_CONSOLES 63	/* must be root to allocate above this */
-		/* Note: the ioctl VT_GETSTATE does not work for
-		   consoles 16 and higher (since it returns a short) */
+
+#if defined(CONFIG_JZSOC)
+#define MAX_NR_CONSOLES	2
+#define MAX_NR_USER_CONSOLES 2
+#else
+#define MAX_NR_CONSOLES 63	/* serial lines start at 64 */
+#define MAX_NR_USER_CONSOLES 63 /* must be root to allocate above this */
+                  /* Note: the ioctl VT_GETSTATE does not work for 
+		     consoles 16 and higher (since it returns a short) */
+#endif
 
 /* 0x56 is 'V', to avoid collision with termios and kd */
 
--- linux-2.6.24.7.old/include/linux/writeback.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/linux/writeback.h	2009-04-12 18:13:57.000000000 +0200
@@ -70,6 +70,7 @@
 void writeback_inodes(struct writeback_control *wbc);
 int inode_wait(void *);
 void sync_inodes_sb(struct super_block *, int wait);
+void writeback_inodes_sb(struct super_block *sb, struct writeback_control *wbc);
 void sync_inodes(int wait);
 
 /* writeback.h requires fs.h; it, too, is not included from here. */
--- linux-2.6.24.7.old/include/mtd/mtd-abi.h	2009-04-12 18:05:07.000000000 +0200
+++ linux-2.6.24.7/include/mtd/mtd-abi.h	2009-04-12 18:23:10.000000000 +0200
@@ -7,9 +7,18 @@
 #ifndef __MTD_ABI_H__
 #define __MTD_ABI_H__
 
+
+#ifndef __KERNEL__ /* Urgh. The whole point of splitting this out into
+                   separate files was to avoid #ifdef __KERNEL__ */
+#define __user
+#endif
+
+typedef unsigned long long size_mtd_t;
+typedef unsigned long long loff_mtd_t;
+
 struct erase_info_user {
-	uint32_t start;
-	uint32_t length;
+	uint64_t start;
+	uint64_t length;
 };
 
 struct mtd_oob_buf {
@@ -18,6 +27,14 @@
 	unsigned char __user *ptr;
 };
 
+struct mtd_page_buf {
+	uint32_t start;      //page start address
+	uint32_t ooblength;
+	uint32_t datlength;
+	unsigned char __user *oobptr;
+	unsigned char __user *datptr;
+};
+
 #define MTD_ABSENT		0
 #define MTD_RAM			1
 #define MTD_ROM			2
@@ -52,7 +69,7 @@
 struct mtd_info_user {
 	uint8_t type;
 	uint32_t flags;
-	uint32_t size;	 // Total size of the MTD
+	uint64_t size;	 // Total size of the MTD
 	uint32_t erasesize;
 	uint32_t writesize;
 	uint32_t oobsize;   // Amount of OOB data per block (e.g. 16)
@@ -63,7 +80,7 @@
 };
 
 struct region_info_user {
-	uint32_t offset;		/* At which this region starts,
+	uint64_t offset;		/* At which this region starts,
 					 * from the beginning of the MTD */
 	uint32_t erasesize;		/* For this region */
 	uint32_t numblocks;		/* Number of blocks in this region */
@@ -86,8 +103,8 @@
 #define MEMGETREGIONINFO	_IOWR('M', 8, struct region_info_user)
 #define MEMSETOOBSEL		_IOW('M', 9, struct nand_oobinfo)
 #define MEMGETOOBSEL		_IOR('M', 10, struct nand_oobinfo)
-#define MEMGETBADBLOCK		_IOW('M', 11, loff_t)
-#define MEMSETBADBLOCK		_IOW('M', 12, loff_t)
+#define MEMGETBADBLOCK         _IOW('M', 11, loff_mtd_t)
+#define MEMSETBADBLOCK         _IOW('M', 12, loff_mtd_t)
 #define OTPSELECT		_IOR('M', 13, int)
 #define OTPGETREGIONCOUNT	_IOW('M', 14, int)
 #define OTPGETREGIONINFO	_IOW('M', 15, struct otp_info)
@@ -95,6 +112,7 @@
 #define ECCGETLAYOUT		_IOR('M', 17, struct nand_ecclayout)
 #define ECCGETSTATS		_IOR('M', 18, struct mtd_ecc_stats)
 #define MTDFILEMODE		_IO('M', 19)
+#define MEMWRITEPAGE           _IOWR('M', 20, struct mtd_page_buf)
 #define MTDREFRESH		_IO('M', 23)
 
 /*
@@ -105,7 +123,7 @@
 	uint32_t useecc;
 	uint32_t eccbytes;
 	uint32_t oobfree[8][2];
-	uint32_t eccpos[32];
+	uint32_t eccpos[104];
 };
 
 struct nand_oobfree {
@@ -120,7 +138,7 @@
  */
 struct nand_ecclayout {
 	uint32_t eccbytes;
-	uint32_t eccpos[64];
+	uint32_t eccpos[128];
 	uint32_t oobavail;
 	struct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];
 };
--- linux-2.6.24.7.old/include/mtd/ubi-user.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/mtd/ubi-user.h	2009-04-12 18:13:57.000000000 +0200
@@ -21,7 +21,26 @@
 #ifndef __UBI_USER_H__
 #define __UBI_USER_H__
 
+#ifndef __KERNEL__ /* Urgh. The whole point of splitting this out into
+		    separate files was to avoid #ifdef __KERNEL__ */
+#define __user
+#endif
 /*
+ * UBI device creation (the same as MTD device attachment)
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * MTD devices may be attached using %UBI_IOCATT ioctl command of the UBI
+ * control device. The caller has to properly fill and pass
+ * &struct ubi_attach_req object - UBI will attach the MTD device specified in
+ * the request and return the newly created UBI device number as the ioctl
+ * return value.
+ *
+ * UBI device deletion (the same as MTD device detachment)
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * An UBI device maybe deleted with %UBI_IOCDET ioctl command of the UBI
+ * control device.
+ *
  * UBI volume creation
  * ~~~~~~~~~~~~~~~~~~~
  *
@@ -48,7 +67,7 @@
  *
  * Volume update should be done via the %UBI_IOCVOLUP IOCTL command of the
  * corresponding UBI volume character device. A pointer to a 64-bit update
- * size should be passed to the IOCTL. After then, UBI expects user to write
+ * size should be passed to the IOCTL. After this, UBI expects user to write
  * this number of bytes to the volume character device. The update is finished
  * when the claimed number of bytes is passed. So, the volume update sequence
  * is something like:
@@ -57,14 +76,24 @@
  * ioctl(fd, UBI_IOCVOLUP, &image_size);
  * write(fd, buf, image_size);
  * close(fd);
+ *
+ * Atomic eraseblock change
+ * ~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * Atomic eraseblock change operation is done via the %UBI_IOCEBCH IOCTL
+ * command of the corresponding UBI volume character device. A pointer to
+ * &struct ubi_leb_change_req has to be passed to the IOCTL. Then the user is
+ * expected to write the requested amount of bytes. This is similar to the
+ * "volume update" IOCTL.
  */
 
 /*
- * When a new volume is created, users may either specify the volume number they
- * want to create or to let UBI automatically assign a volume number using this
- * constant.
+ * When a new UBI volume or UBI device is created, users may either specify the
+ * volume/device number they want to create or to let UBI automatically assign
+ * the number using these constants.
  */
 #define UBI_VOL_NUM_AUTO (-1)
+#define UBI_DEV_NUM_AUTO (-1)
 
 /* Maximum volume name length */
 #define UBI_MAX_VOLUME_NAME 127
@@ -80,6 +109,15 @@
 /* Re-size an UBI volume */
 #define UBI_IOCRSVOL _IOW(UBI_IOC_MAGIC, 2, struct ubi_rsvol_req)
 
+/* IOCTL commands of the UBI control character device */
+
+#define UBI_CTRL_IOC_MAGIC 'o'
+
+/* Attach an MTD device */
+#define UBI_IOCATT _IOW(UBI_CTRL_IOC_MAGIC, 64, struct ubi_attach_req)
+/* Detach an MTD device */
+#define UBI_IOCDET _IOW(UBI_CTRL_IOC_MAGIC, 65, int32_t)
+
 /* IOCTL commands of UBI volume character devices */
 
 #define UBI_VOL_IOC_MAGIC 'O'
@@ -88,6 +126,30 @@
 #define UBI_IOCVOLUP _IOW(UBI_VOL_IOC_MAGIC, 0, int64_t)
 /* An eraseblock erasure command, used for debugging, disabled by default */
 #define UBI_IOCEBER _IOW(UBI_VOL_IOC_MAGIC, 1, int32_t)
+/* An atomic eraseblock change command */
+#define UBI_IOCEBCH _IOW(UBI_VOL_IOC_MAGIC, 2, int32_t)
+/* Start UBI leb read */
+#define UBI_IOCLEBREAD _IOWR(UBI_VOL_IOC_MAGIC, 3, struct ubi_leb)
+
+/* Maximum MTD device name length supported by UBI */
+#define MAX_UBI_MTD_NAME_LEN 127
+
+/*
+ * UBI data type hint constants.
+ *
+ * UBI_LONGTERM: long-term data
+ * UBI_SHORTTERM: short-term data
+ * UBI_UNKNOWN: data persistence is unknown
+ *
+ * These constants are used when data is written to UBI volumes in order to
+ * help the UBI wear-leveling unit to find more appropriate physical
+ * eraseblocks.
+ */
+enum {
+	UBI_LONGTERM  = 1,
+	UBI_SHORTTERM = 2,
+	UBI_UNKNOWN   = 3,
+};
 
 /*
  * UBI volume type constants.
@@ -97,22 +159,58 @@
  */
 enum {
 	UBI_DYNAMIC_VOLUME = 3,
-	UBI_STATIC_VOLUME = 4
+	UBI_STATIC_VOLUME  = 4,
+};
+
+/**
+ * struct ubi_attach_req - attach MTD device request.
+ * @ubi_num: UBI device number to create
+ * @mtd_num: MTD device number to attach
+ * @vid_hdr_offset: VID header offset (use defaults if %0)
+ * @padding: reserved for future, not used, has to be zeroed
+ *
+ * This data structure is used to specify MTD device UBI has to attach and the
+ * parameters it has to use. The number which should be assigned to the new UBI
+ * device is passed in @ubi_num. UBI may automatically assign the number if
+ * @UBI_DEV_NUM_AUTO is passed. In this case, the device number is returned in
+ * @ubi_num.
+ *
+ * Most applications should pass %0 in @vid_hdr_offset to make UBI use default
+ * offset of the VID header within physical eraseblocks. The default offset is
+ * the next min. I/O unit after the EC header. For example, it will be offset
+ * 512 in case of a 512 bytes page NAND flash with no sub-page support. Or
+ * it will be 512 in case of a 2KiB page NAND flash with 4 512-byte sub-pages.
+ *
+ * But in rare cases, if this optimizes things, the VID header may be placed to
+ * a different offset. For example, the boot-loader might do things faster if the
+ * VID header sits at the end of the first 2KiB NAND page with 4 sub-pages. As
+ * the boot-loader would not normally need to read EC headers (unless it needs
+ * UBI in RW mode), it might be faster to calculate ECC. This is weird example,
+ * but it real-life example. So, in this example, @vid_hdr_offer would be
+ * 2KiB-64 bytes = 1984. Note, that this position is not even 512-bytes
+ * aligned, which is OK, as UBI is clever enough to realize this is 4th sub-page
+ * of the first page and add needed padding.
+ */
+struct ubi_attach_req {
+	int32_t ubi_num;
+	int32_t mtd_num;
+	int32_t vid_hdr_offset;
+	uint8_t padding[12];
 };
 
 /**
  * struct ubi_mkvol_req - volume description data structure used in
- * volume creation requests.
+ *                        volume creation requests.
  * @vol_id: volume number
  * @alignment: volume alignment
  * @bytes: volume size in bytes
  * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
- * @padding1: reserved for future, not used
+ * @padding1: reserved for future, not used, has to be zeroed
  * @name_len: volume name length
- * @padding2: reserved for future, not used
+ * @padding2: reserved for future, not used, has to be zeroed
  * @name: volume name
  *
- * This structure is used by userspace programs when creating new volumes. The
+ * This structure is used by user-space programs when creating new volumes. The
  * @used_bytes field is only necessary when creating static volumes.
  *
  * The @alignment field specifies the required alignment of the volume logical
@@ -139,7 +237,7 @@
 	int8_t padding1;
 	int16_t name_len;
 	int8_t padding2[4];
-	char name[UBI_MAX_VOLUME_NAME+1];
+	char name[UBI_MAX_VOLUME_NAME + 1];
 } __attribute__ ((packed));
 
 /**
@@ -158,4 +256,29 @@
 	int32_t vol_id;
 } __attribute__ ((packed));
 
+/**
+ * struct ubi_leb_change_req - a data structure used in atomic logical
+ *                             eraseblock change requests.
+ * @lnum: logical eraseblock number to change
+ * @bytes: how many bytes will be written to the logical eraseblock
+ * @dtype: data type (%UBI_LONGTERM, %UBI_SHORTTERM, %UBI_UNKNOWN)
+ * @padding: reserved for future, not used, has to be zeroed
+ */
+struct ubi_leb_change_req {
+	int32_t lnum;
+	int32_t bytes;
+	uint8_t dtype;
+	uint8_t padding[7];
+} __attribute__ ((packed));
+
+/**
+ * struct ubi_leb - a data structure describe LEB.
+ * @lnum: logical eraseblock number to dump
+ * @lebbuf: LEB data buffer
+ */
+struct ubi_leb{
+	unsigned int lnum;
+	char __user *buf;
+};
+
 #endif /* __UBI_USER_H__ */
--- linux-2.6.24.7.old/include/sound/pcm.h	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/include/sound/pcm.h	2009-04-12 18:13:57.000000000 +0200
@@ -107,23 +107,23 @@
 #define SNDRV_PCM_RATE_5512		(1<<0)		/* 5512Hz */
 #define SNDRV_PCM_RATE_8000		(1<<1)		/* 8000Hz */
 #define SNDRV_PCM_RATE_11025		(1<<2)		/* 11025Hz */
-#define SNDRV_PCM_RATE_16000		(1<<3)		/* 16000Hz */
-#define SNDRV_PCM_RATE_22050		(1<<4)		/* 22050Hz */
-#define SNDRV_PCM_RATE_32000		(1<<5)		/* 32000Hz */
-#define SNDRV_PCM_RATE_44100		(1<<6)		/* 44100Hz */
-#define SNDRV_PCM_RATE_48000		(1<<7)		/* 48000Hz */
-#define SNDRV_PCM_RATE_64000		(1<<8)		/* 64000Hz */
-#define SNDRV_PCM_RATE_88200		(1<<9)		/* 88200Hz */
-#define SNDRV_PCM_RATE_96000		(1<<10)		/* 96000Hz */
-#define SNDRV_PCM_RATE_176400		(1<<11)		/* 176400Hz */
-#define SNDRV_PCM_RATE_192000		(1<<12)		/* 192000Hz */
+#define SNDRV_PCM_RATE_12000		(1<<3)		/* 12000Hz */
+#define SNDRV_PCM_RATE_16000		(1<<4)		/* 16000Hz */
+#define SNDRV_PCM_RATE_22050		(1<<5)		/* 22050Hz */
+#define SNDRV_PCM_RATE_24000		(1<<6)		/* 24000Hz */
+#define SNDRV_PCM_RATE_32000		(1<<7)		/* 32000Hz */
+#define SNDRV_PCM_RATE_44100		(1<<8)		/* 44100Hz */
+#define SNDRV_PCM_RATE_48000		(1<<9)		/* 48000Hz */
+#define SNDRV_PCM_RATE_64000		(1<<10)		/* 64000Hz */
+#define SNDRV_PCM_RATE_88200		(1<<11)		/* 88200Hz */
+#define SNDRV_PCM_RATE_96000		(1<<12)		/* 96000Hz */
+#define SNDRV_PCM_RATE_176400		(1<<13)		/* 176400Hz */
+#define SNDRV_PCM_RATE_192000		(1<<14)		/* 192000Hz */
 
 #define SNDRV_PCM_RATE_CONTINUOUS	(1<<30)		/* continuous range */
 #define SNDRV_PCM_RATE_KNOT		(1<<31)		/* supports more non-continuos rates */
 
-#define SNDRV_PCM_RATE_8000_44100	(SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_11025|\
-					 SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_22050|\
-					 SNDRV_PCM_RATE_32000|SNDRV_PCM_RATE_44100)
+#define SNDRV_PCM_RATE_8000_44100	(SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_11025|SNDRV_PCM_RATE_12000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_22050|SNDRV_PCM_RATE_24000|SNDRV_PCM_RATE_32000|SNDRV_PCM_RATE_44100)
 #define SNDRV_PCM_RATE_8000_48000	(SNDRV_PCM_RATE_8000_44100|SNDRV_PCM_RATE_48000)
 #define SNDRV_PCM_RATE_8000_96000	(SNDRV_PCM_RATE_8000_48000|SNDRV_PCM_RATE_64000|\
 					 SNDRV_PCM_RATE_88200|SNDRV_PCM_RATE_96000)
--- linux-2.6.24.7.old/include/sound/pcm.h.org	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/include/sound/pcm.h.org	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,1011 @@
+#ifndef __SOUND_PCM_H
+#define __SOUND_PCM_H
+
+/*
+ *  Digital Audio (PCM) abstract layer
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
+ *                   Abramo Bagnara <abramo@alsa-project.org>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/asound.h>
+#include <sound/memalloc.h>
+#include <linux/poll.h>
+#include <linux/mm.h>
+#include <linux/bitops.h>
+
+#define snd_pcm_substream_chip(substream) ((substream)->private_data)
+#define snd_pcm_chip(pcm) ((pcm)->private_data)
+
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#include "pcm_oss.h"
+#endif
+
+/*
+ *  Hardware (lowlevel) section
+ */
+
+struct snd_pcm_hardware {
+	unsigned int info;		/* SNDRV_PCM_INFO_* */
+	u64 formats;			/* SNDRV_PCM_FMTBIT_* */
+	unsigned int rates;		/* SNDRV_PCM_RATE_* */
+	unsigned int rate_min;		/* min rate */
+	unsigned int rate_max;		/* max rate */
+	unsigned int channels_min;	/* min channels */
+	unsigned int channels_max;	/* max channels */
+	size_t buffer_bytes_max;	/* max buffer size */
+	size_t period_bytes_min;	/* min period size */
+	size_t period_bytes_max;	/* max period size */
+	unsigned int periods_min;	/* min # of periods */
+	unsigned int periods_max;	/* max # of periods */
+	size_t fifo_size;		/* fifo size in bytes */
+};
+
+struct snd_pcm_substream;
+
+struct snd_pcm_ops {
+	int (*open)(struct snd_pcm_substream *substream);
+	int (*close)(struct snd_pcm_substream *substream);
+	int (*ioctl)(struct snd_pcm_substream * substream,
+		     unsigned int cmd, void *arg);
+	int (*hw_params)(struct snd_pcm_substream *substream,
+			 struct snd_pcm_hw_params *params);
+	int (*hw_free)(struct snd_pcm_substream *substream);
+	int (*prepare)(struct snd_pcm_substream *substream);
+	int (*trigger)(struct snd_pcm_substream *substream, int cmd);
+	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream);
+	int (*copy)(struct snd_pcm_substream *substream, int channel,
+		    snd_pcm_uframes_t pos,
+		    void __user *buf, snd_pcm_uframes_t count);
+	int (*silence)(struct snd_pcm_substream *substream, int channel, 
+		       snd_pcm_uframes_t pos, snd_pcm_uframes_t count);
+	struct page *(*page)(struct snd_pcm_substream *substream,
+			     unsigned long offset);
+	int (*mmap)(struct snd_pcm_substream *substream, struct vm_area_struct *vma);
+	int (*ack)(struct snd_pcm_substream *substream);
+};
+
+/*
+ *
+ */
+
+#define SNDRV_PCM_DEVICES		8
+
+#define SNDRV_PCM_IOCTL1_FALSE		((void *)0)
+#define SNDRV_PCM_IOCTL1_TRUE		((void *)1)
+
+#define SNDRV_PCM_IOCTL1_RESET		0
+#define SNDRV_PCM_IOCTL1_INFO		1
+#define SNDRV_PCM_IOCTL1_CHANNEL_INFO	2
+#define SNDRV_PCM_IOCTL1_GSTATE		3
+
+#define SNDRV_PCM_TRIGGER_STOP		0
+#define SNDRV_PCM_TRIGGER_START		1
+#define SNDRV_PCM_TRIGGER_PAUSE_PUSH	3
+#define SNDRV_PCM_TRIGGER_PAUSE_RELEASE	4
+#define SNDRV_PCM_TRIGGER_SUSPEND	5
+#define SNDRV_PCM_TRIGGER_RESUME	6
+
+#define SNDRV_PCM_POS_XRUN		((snd_pcm_uframes_t)-1)
+
+/* If you change this don't forget to change rates[] table in pcm_native.c */
+#define SNDRV_PCM_RATE_5512		(1<<0)		/* 5512Hz */
+#define SNDRV_PCM_RATE_8000		(1<<1)		/* 8000Hz */
+#define SNDRV_PCM_RATE_11025		(1<<2)		/* 11025Hz */
+#define SNDRV_PCM_RATE_16000		(1<<3)		/* 16000Hz */
+#define SNDRV_PCM_RATE_22050		(1<<4)		/* 22050Hz */
+#define SNDRV_PCM_RATE_32000		(1<<5)		/* 32000Hz */
+#define SNDRV_PCM_RATE_44100		(1<<6)		/* 44100Hz */
+#define SNDRV_PCM_RATE_48000		(1<<7)		/* 48000Hz */
+#define SNDRV_PCM_RATE_64000		(1<<8)		/* 64000Hz */
+#define SNDRV_PCM_RATE_88200		(1<<9)		/* 88200Hz */
+#define SNDRV_PCM_RATE_96000		(1<<10)		/* 96000Hz */
+#define SNDRV_PCM_RATE_176400		(1<<11)		/* 176400Hz */
+#define SNDRV_PCM_RATE_192000		(1<<12)		/* 192000Hz */
+
+#define SNDRV_PCM_RATE_CONTINUOUS	(1<<30)		/* continuous range */
+#define SNDRV_PCM_RATE_KNOT		(1<<31)		/* supports more non-continuos rates */
+
+#define SNDRV_PCM_RATE_8000_44100	(SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_11025|\
+					 SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_22050|\
+					 SNDRV_PCM_RATE_32000|SNDRV_PCM_RATE_44100)
+#define SNDRV_PCM_RATE_8000_48000	(SNDRV_PCM_RATE_8000_44100|SNDRV_PCM_RATE_48000)
+#define SNDRV_PCM_RATE_8000_96000	(SNDRV_PCM_RATE_8000_48000|SNDRV_PCM_RATE_64000|\
+					 SNDRV_PCM_RATE_88200|SNDRV_PCM_RATE_96000)
+#define SNDRV_PCM_RATE_8000_192000	(SNDRV_PCM_RATE_8000_96000|SNDRV_PCM_RATE_176400|\
+					 SNDRV_PCM_RATE_192000)
+#define SNDRV_PCM_FMTBIT_S8		(1ULL << SNDRV_PCM_FORMAT_S8)
+#define SNDRV_PCM_FMTBIT_U8		(1ULL << SNDRV_PCM_FORMAT_U8)
+#define SNDRV_PCM_FMTBIT_S16_LE		(1ULL << SNDRV_PCM_FORMAT_S16_LE)
+#define SNDRV_PCM_FMTBIT_S16_BE		(1ULL << SNDRV_PCM_FORMAT_S16_BE)
+#define SNDRV_PCM_FMTBIT_U16_LE		(1ULL << SNDRV_PCM_FORMAT_U16_LE)
+#define SNDRV_PCM_FMTBIT_U16_BE		(1ULL << SNDRV_PCM_FORMAT_U16_BE)
+#define SNDRV_PCM_FMTBIT_S24_LE		(1ULL << SNDRV_PCM_FORMAT_S24_LE)
+#define SNDRV_PCM_FMTBIT_S24_BE		(1ULL << SNDRV_PCM_FORMAT_S24_BE)
+#define SNDRV_PCM_FMTBIT_U24_LE		(1ULL << SNDRV_PCM_FORMAT_U24_LE)
+#define SNDRV_PCM_FMTBIT_U24_BE		(1ULL << SNDRV_PCM_FORMAT_U24_BE)
+#define SNDRV_PCM_FMTBIT_S32_LE		(1ULL << SNDRV_PCM_FORMAT_S32_LE)
+#define SNDRV_PCM_FMTBIT_S32_BE		(1ULL << SNDRV_PCM_FORMAT_S32_BE)
+#define SNDRV_PCM_FMTBIT_U32_LE		(1ULL << SNDRV_PCM_FORMAT_U32_LE)
+#define SNDRV_PCM_FMTBIT_U32_BE		(1ULL << SNDRV_PCM_FORMAT_U32_BE)
+#define SNDRV_PCM_FMTBIT_FLOAT_LE	(1ULL << SNDRV_PCM_FORMAT_FLOAT_LE)
+#define SNDRV_PCM_FMTBIT_FLOAT_BE	(1ULL << SNDRV_PCM_FORMAT_FLOAT_BE)
+#define SNDRV_PCM_FMTBIT_FLOAT64_LE	(1ULL << SNDRV_PCM_FORMAT_FLOAT64_LE)
+#define SNDRV_PCM_FMTBIT_FLOAT64_BE	(1ULL << SNDRV_PCM_FORMAT_FLOAT64_BE)
+#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE (1ULL << SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE)
+#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE (1ULL << SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE)
+#define SNDRV_PCM_FMTBIT_MU_LAW		(1ULL << SNDRV_PCM_FORMAT_MU_LAW)
+#define SNDRV_PCM_FMTBIT_A_LAW		(1ULL << SNDRV_PCM_FORMAT_A_LAW)
+#define SNDRV_PCM_FMTBIT_IMA_ADPCM	(1ULL << SNDRV_PCM_FORMAT_IMA_ADPCM)
+#define SNDRV_PCM_FMTBIT_MPEG		(1ULL << SNDRV_PCM_FORMAT_MPEG)
+#define SNDRV_PCM_FMTBIT_GSM		(1ULL << SNDRV_PCM_FORMAT_GSM)
+#define SNDRV_PCM_FMTBIT_SPECIAL	(1ULL << SNDRV_PCM_FORMAT_SPECIAL)
+#define SNDRV_PCM_FMTBIT_S24_3LE	(1ULL << SNDRV_PCM_FORMAT_S24_3LE)
+#define SNDRV_PCM_FMTBIT_U24_3LE	(1ULL << SNDRV_PCM_FORMAT_U24_3LE)
+#define SNDRV_PCM_FMTBIT_S24_3BE	(1ULL << SNDRV_PCM_FORMAT_S24_3BE)
+#define SNDRV_PCM_FMTBIT_U24_3BE	(1ULL << SNDRV_PCM_FORMAT_U24_3BE)
+#define SNDRV_PCM_FMTBIT_S20_3LE	(1ULL << SNDRV_PCM_FORMAT_S20_3LE)
+#define SNDRV_PCM_FMTBIT_U20_3LE	(1ULL << SNDRV_PCM_FORMAT_U20_3LE)
+#define SNDRV_PCM_FMTBIT_S20_3BE	(1ULL << SNDRV_PCM_FORMAT_S20_3BE)
+#define SNDRV_PCM_FMTBIT_U20_3BE	(1ULL << SNDRV_PCM_FORMAT_U20_3BE)
+#define SNDRV_PCM_FMTBIT_S18_3LE	(1ULL << SNDRV_PCM_FORMAT_S18_3LE)
+#define SNDRV_PCM_FMTBIT_U18_3LE	(1ULL << SNDRV_PCM_FORMAT_U18_3LE)
+#define SNDRV_PCM_FMTBIT_S18_3BE	(1ULL << SNDRV_PCM_FORMAT_S18_3BE)
+#define SNDRV_PCM_FMTBIT_U18_3BE	(1ULL << SNDRV_PCM_FORMAT_U18_3BE)
+
+#ifdef SNDRV_LITTLE_ENDIAN
+#define SNDRV_PCM_FMTBIT_S16		SNDRV_PCM_FMTBIT_S16_LE
+#define SNDRV_PCM_FMTBIT_U16		SNDRV_PCM_FMTBIT_U16_LE
+#define SNDRV_PCM_FMTBIT_S24		SNDRV_PCM_FMTBIT_S24_LE
+#define SNDRV_PCM_FMTBIT_U24		SNDRV_PCM_FMTBIT_U24_LE
+#define SNDRV_PCM_FMTBIT_S32		SNDRV_PCM_FMTBIT_S32_LE
+#define SNDRV_PCM_FMTBIT_U32		SNDRV_PCM_FMTBIT_U32_LE
+#define SNDRV_PCM_FMTBIT_FLOAT		SNDRV_PCM_FMTBIT_FLOAT_LE
+#define SNDRV_PCM_FMTBIT_FLOAT64	SNDRV_PCM_FMTBIT_FLOAT64_LE
+#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE
+#endif
+#ifdef SNDRV_BIG_ENDIAN
+#define SNDRV_PCM_FMTBIT_S16		SNDRV_PCM_FMTBIT_S16_BE
+#define SNDRV_PCM_FMTBIT_U16		SNDRV_PCM_FMTBIT_U16_BE
+#define SNDRV_PCM_FMTBIT_S24		SNDRV_PCM_FMTBIT_S24_BE
+#define SNDRV_PCM_FMTBIT_U24		SNDRV_PCM_FMTBIT_U24_BE
+#define SNDRV_PCM_FMTBIT_S32		SNDRV_PCM_FMTBIT_S32_BE
+#define SNDRV_PCM_FMTBIT_U32		SNDRV_PCM_FMTBIT_U32_BE
+#define SNDRV_PCM_FMTBIT_FLOAT		SNDRV_PCM_FMTBIT_FLOAT_BE
+#define SNDRV_PCM_FMTBIT_FLOAT64	SNDRV_PCM_FMTBIT_FLOAT64_BE
+#define SNDRV_PCM_FMTBIT_IEC958_SUBFRAME SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE
+#endif
+
+struct snd_pcm_file {
+	struct snd_pcm_substream *substream;
+	int no_compat_mmap;
+};
+
+struct snd_pcm_hw_rule;
+typedef int (*snd_pcm_hw_rule_func_t)(struct snd_pcm_hw_params *params,
+				      struct snd_pcm_hw_rule *rule);
+
+struct snd_pcm_hw_rule {
+	unsigned int cond;
+	snd_pcm_hw_rule_func_t func;
+	int var;
+	int deps[4];
+	void *private;
+};
+
+struct snd_pcm_hw_constraints {
+	struct snd_mask masks[SNDRV_PCM_HW_PARAM_LAST_MASK - 
+			 SNDRV_PCM_HW_PARAM_FIRST_MASK + 1];
+	struct snd_interval intervals[SNDRV_PCM_HW_PARAM_LAST_INTERVAL -
+			     SNDRV_PCM_HW_PARAM_FIRST_INTERVAL + 1];
+	unsigned int rules_num;
+	unsigned int rules_all;
+	struct snd_pcm_hw_rule *rules;
+};
+
+static inline struct snd_mask *constrs_mask(struct snd_pcm_hw_constraints *constrs,
+					    snd_pcm_hw_param_t var)
+{
+	return &constrs->masks[var - SNDRV_PCM_HW_PARAM_FIRST_MASK];
+}
+
+static inline struct snd_interval *constrs_interval(struct snd_pcm_hw_constraints *constrs,
+						    snd_pcm_hw_param_t var)
+{
+	return &constrs->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];
+}
+
+struct snd_ratnum {
+	unsigned int num;
+	unsigned int den_min, den_max, den_step;
+};
+
+struct snd_ratden {
+	unsigned int num_min, num_max, num_step;
+	unsigned int den;
+};
+
+struct snd_pcm_hw_constraint_ratnums {
+	int nrats;
+	struct snd_ratnum *rats;
+};
+
+struct snd_pcm_hw_constraint_ratdens {
+	int nrats;
+	struct snd_ratden *rats;
+};
+
+struct snd_pcm_hw_constraint_list {
+	unsigned int count;
+	unsigned int *list;
+	unsigned int mask;
+};
+
+struct snd_pcm_runtime {
+	/* -- Status -- */
+	struct snd_pcm_substream *trigger_master;
+	struct timespec trigger_tstamp;	/* trigger timestamp */
+	int overrange;
+	snd_pcm_uframes_t avail_max;
+	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
+	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time*/
+
+	/* -- HW params -- */
+	snd_pcm_access_t access;	/* access mode */
+	snd_pcm_format_t format;	/* SNDRV_PCM_FORMAT_* */
+	snd_pcm_subformat_t subformat;	/* subformat */
+	unsigned int rate;		/* rate in Hz */
+	unsigned int channels;		/* channels */
+	snd_pcm_uframes_t period_size;	/* period size */
+	unsigned int periods;		/* periods */
+	snd_pcm_uframes_t buffer_size;	/* buffer size */
+	unsigned int tick_time;		/* tick time */
+	snd_pcm_uframes_t min_align;	/* Min alignment for the format */
+	size_t byte_align;
+	unsigned int frame_bits;
+	unsigned int sample_bits;
+	unsigned int info;
+	unsigned int rate_num;
+	unsigned int rate_den;
+
+	/* -- SW params -- */
+	int tstamp_mode;		/* mmap timestamp is updated */
+  	unsigned int period_step;
+	unsigned int sleep_min;		/* min ticks to sleep */
+	snd_pcm_uframes_t xfer_align;	/* xfer size need to be a multiple */
+	snd_pcm_uframes_t start_threshold;
+	snd_pcm_uframes_t stop_threshold;
+	snd_pcm_uframes_t silence_threshold; /* Silence filling happens when
+						noise is nearest than this */
+	snd_pcm_uframes_t silence_size;	/* Silence filling size */
+	snd_pcm_uframes_t boundary;	/* pointers wrap point */
+
+	snd_pcm_uframes_t silence_start; /* starting pointer to silence area */
+	snd_pcm_uframes_t silence_filled; /* size filled with silence */
+
+	union snd_pcm_sync_id sync;	/* hardware synchronization ID */
+
+	/* -- mmap -- */
+	struct snd_pcm_mmap_status *status;
+	struct snd_pcm_mmap_control *control;
+
+	/* -- locking / scheduling -- */
+	wait_queue_head_t sleep;
+	struct timer_list tick_timer;
+	struct fasync_struct *fasync;
+
+	/* -- private section -- */
+	void *private_data;
+	void (*private_free)(struct snd_pcm_runtime *runtime);
+
+	/* -- hardware description -- */
+	struct snd_pcm_hardware hw;
+	struct snd_pcm_hw_constraints hw_constraints;
+
+	/* -- interrupt callbacks -- */
+	void (*transfer_ack_begin)(struct snd_pcm_substream *substream);
+	void (*transfer_ack_end)(struct snd_pcm_substream *substream);
+
+	/* -- timer -- */
+	unsigned int timer_resolution;	/* timer resolution */
+
+	/* -- DMA -- */           
+	unsigned char *dma_area;	/* DMA area */
+	dma_addr_t dma_addr;		/* physical bus address (not accessible from main CPU) */
+	size_t dma_bytes;		/* size of DMA area */
+
+	struct snd_dma_buffer *dma_buffer_p;	/* allocated buffer */
+
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	/* -- OSS things -- */
+	struct snd_pcm_oss_runtime oss;
+#endif
+};
+
+struct snd_pcm_group {		/* keep linked substreams */
+	spinlock_t lock;
+	struct list_head substreams;
+	int count;
+};
+
+struct snd_pcm_substream {
+	struct snd_pcm *pcm;
+	struct snd_pcm_str *pstr;
+	void *private_data;		/* copied from pcm->private_data */
+	int number;
+	char name[32];			/* substream name */
+	int stream;			/* stream (direction) */
+	char latency_id[20];		/* latency identifier */
+	size_t buffer_bytes_max;	/* limit ring buffer size */
+	struct snd_dma_buffer dma_buffer;
+	unsigned int dma_buf_id;
+	size_t dma_max;
+	/* -- hardware operations -- */
+	struct snd_pcm_ops *ops;
+	/* -- runtime information -- */
+	struct snd_pcm_runtime *runtime;
+        /* -- timer section -- */
+	struct snd_timer *timer;		/* timer */
+	unsigned timer_running: 1;	/* time is running */
+	spinlock_t timer_lock;
+	/* -- next substream -- */
+	struct snd_pcm_substream *next;
+	/* -- linked substreams -- */
+	struct list_head link_list;	/* linked list member */
+	struct snd_pcm_group self_group;	/* fake group for non linked substream (with substream lock inside) */
+	struct snd_pcm_group *group;		/* pointer to current group */
+	/* -- assigned files -- */
+	void *file;
+	int ref_count;
+	atomic_t mmap_count;
+	unsigned int f_flags;
+	void (*pcm_release)(struct snd_pcm_substream *);
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	/* -- OSS things -- */
+	struct snd_pcm_oss_substream oss;
+#endif
+#ifdef CONFIG_SND_VERBOSE_PROCFS
+	struct snd_info_entry *proc_root;
+	struct snd_info_entry *proc_info_entry;
+	struct snd_info_entry *proc_hw_params_entry;
+	struct snd_info_entry *proc_sw_params_entry;
+	struct snd_info_entry *proc_status_entry;
+	struct snd_info_entry *proc_prealloc_entry;
+	struct snd_info_entry *proc_prealloc_max_entry;
+#endif
+	/* misc flags */
+	unsigned int hw_opened: 1;
+};
+
+#define SUBSTREAM_BUSY(substream) ((substream)->ref_count > 0)
+
+
+struct snd_pcm_str {
+	int stream;				/* stream (direction) */
+	struct snd_pcm *pcm;
+	/* -- substreams -- */
+	unsigned int substream_count;
+	unsigned int substream_opened;
+	struct snd_pcm_substream *substream;
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	/* -- OSS things -- */
+	struct snd_pcm_oss_stream oss;
+#endif
+#ifdef CONFIG_SND_VERBOSE_PROCFS
+	struct snd_info_entry *proc_root;
+	struct snd_info_entry *proc_info_entry;
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
+	unsigned int xrun_debug;	/* 0 = disabled, 1 = verbose, 2 = stacktrace */
+	struct snd_info_entry *proc_xrun_debug_entry;
+#endif
+#endif
+};
+
+struct snd_pcm {
+	struct snd_card *card;
+	struct list_head list;
+	unsigned int device;	/* device number */
+	unsigned int info_flags;
+	unsigned short dev_class;
+	unsigned short dev_subclass;
+	char id[64];
+	char name[80];
+	struct snd_pcm_str streams[2];
+	struct mutex open_mutex;
+	wait_queue_head_t open_wait;
+	void *private_data;
+	void (*private_free) (struct snd_pcm *pcm);
+	struct device *dev; /* actual hw device this belongs to */
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	struct snd_pcm_oss oss;
+#endif
+};
+
+struct snd_pcm_notify {
+	int (*n_register) (struct snd_pcm * pcm);
+	int (*n_disconnect) (struct snd_pcm * pcm);
+	int (*n_unregister) (struct snd_pcm * pcm);
+	struct list_head list;
+};
+
+/*
+ *  Registering
+ */
+
+extern const struct file_operations snd_pcm_f_ops[2];
+
+int snd_pcm_new(struct snd_card *card, char *id, int device,
+		int playback_count, int capture_count,
+		struct snd_pcm **rpcm);
+int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count);
+
+int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree);
+
+/*
+ *  Native I/O
+ */
+
+extern rwlock_t snd_pcm_link_rwlock;
+
+int snd_pcm_info(struct snd_pcm_substream *substream, struct snd_pcm_info *info);
+int snd_pcm_info_user(struct snd_pcm_substream *substream,
+		      struct snd_pcm_info __user *info);
+int snd_pcm_status(struct snd_pcm_substream *substream,
+		   struct snd_pcm_status *status);
+int snd_pcm_start(struct snd_pcm_substream *substream);
+int snd_pcm_stop(struct snd_pcm_substream *substream, int status);
+int snd_pcm_drain_done(struct snd_pcm_substream *substream);
+#ifdef CONFIG_PM
+int snd_pcm_suspend(struct snd_pcm_substream *substream);
+int snd_pcm_suspend_all(struct snd_pcm *pcm);
+#endif
+int snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream, unsigned int cmd, void *arg);
+int snd_pcm_open_substream(struct snd_pcm *pcm, int stream, struct file *file,
+			   struct snd_pcm_substream **rsubstream);
+void snd_pcm_release_substream(struct snd_pcm_substream *substream);
+int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream, struct file *file,
+			     struct snd_pcm_substream **rsubstream);
+void snd_pcm_detach_substream(struct snd_pcm_substream *substream);
+void snd_pcm_vma_notify_data(void *client, void *data);
+int snd_pcm_mmap_data(struct snd_pcm_substream *substream, struct file *file, struct vm_area_struct *area);
+
+#if BITS_PER_LONG >= 64
+
+static inline void div64_32(u_int64_t *n, u_int32_t div, u_int32_t *rem)
+{
+	*rem = *n % div;
+	*n /= div;
+}
+
+#elif defined(i386)
+
+static inline void div64_32(u_int64_t *n, u_int32_t div, u_int32_t *rem)
+{
+	u_int32_t low, high;
+	low = *n & 0xffffffff;
+	high = *n >> 32;
+	if (high) {
+		u_int32_t high1 = high % div;
+		high /= div;
+		asm("divl %2":"=a" (low), "=d" (*rem):"rm" (div), "a" (low), "d" (high1));
+		*n = (u_int64_t)high << 32 | low;
+	} else {
+		*n = low / div;
+		*rem = low % div;
+	}
+}
+#else
+
+static inline void divl(u_int32_t high, u_int32_t low,
+			u_int32_t div,
+			u_int32_t *q, u_int32_t *r)
+{
+	u_int64_t n = (u_int64_t)high << 32 | low;
+	u_int64_t d = (u_int64_t)div << 31;
+	u_int32_t q1 = 0;
+	int c = 32;
+	while (n > 0xffffffffU) {
+		q1 <<= 1;
+		if (n >= d) {
+			n -= d;
+			q1 |= 1;
+		}
+		d >>= 1;
+		c--;
+	}
+	q1 <<= c;
+	if (n) {
+		low = n;
+		*q = q1 | (low / div);
+		*r = low % div;
+	} else {
+		*r = 0;
+		*q = q1;
+	}
+	return;
+}
+
+static inline void div64_32(u_int64_t *n, u_int32_t div, u_int32_t *rem)
+{
+	u_int32_t low, high;
+	low = *n & 0xffffffff;
+	high = *n >> 32;
+	if (high) {
+		u_int32_t high1 = high % div;
+		u_int32_t low1 = low;
+		high /= div;
+		divl(high1, low1, div, &low, rem);
+		*n = (u_int64_t)high << 32 | low;
+	} else {
+		*n = low / div;
+		*rem = low % div;
+	}
+}
+#endif
+
+/*
+ *  PCM library
+ */
+
+static inline int snd_pcm_stream_linked(struct snd_pcm_substream *substream)
+{
+	return substream->group != &substream->self_group;
+}
+
+static inline void snd_pcm_stream_lock(struct snd_pcm_substream *substream)
+{
+	read_lock(&snd_pcm_link_rwlock);
+	spin_lock(&substream->self_group.lock);
+}
+
+static inline void snd_pcm_stream_unlock(struct snd_pcm_substream *substream)
+{
+	spin_unlock(&substream->self_group.lock);
+	read_unlock(&snd_pcm_link_rwlock);
+}
+
+static inline void snd_pcm_stream_lock_irq(struct snd_pcm_substream *substream)
+{
+	read_lock_irq(&snd_pcm_link_rwlock);
+	spin_lock(&substream->self_group.lock);
+}
+
+static inline void snd_pcm_stream_unlock_irq(struct snd_pcm_substream *substream)
+{
+	spin_unlock(&substream->self_group.lock);
+	read_unlock_irq(&snd_pcm_link_rwlock);
+}
+
+#define snd_pcm_stream_lock_irqsave(substream, flags) \
+do { \
+	read_lock_irqsave(&snd_pcm_link_rwlock, (flags)); \
+	spin_lock(&substream->self_group.lock); \
+} while (0)
+
+#define snd_pcm_stream_unlock_irqrestore(substream, flags) \
+do { \
+	spin_unlock(&substream->self_group.lock); \
+	read_unlock_irqrestore(&snd_pcm_link_rwlock, (flags)); \
+} while (0)
+
+#define snd_pcm_group_for_each_entry(s, substream) \
+	list_for_each_entry(s, &substream->group->substreams, link_list)
+
+static inline int snd_pcm_running(struct snd_pcm_substream *substream)
+{
+	return (substream->runtime->status->state == SNDRV_PCM_STATE_RUNNING ||
+		(substream->runtime->status->state == SNDRV_PCM_STATE_DRAINING &&
+		 substream->stream == SNDRV_PCM_STREAM_PLAYBACK));
+}
+
+static inline ssize_t bytes_to_samples(struct snd_pcm_runtime *runtime, ssize_t size)
+{
+	return size * 8 / runtime->sample_bits;
+}
+
+static inline snd_pcm_sframes_t bytes_to_frames(struct snd_pcm_runtime *runtime, ssize_t size)
+{
+	return size * 8 / runtime->frame_bits;
+}
+
+static inline ssize_t samples_to_bytes(struct snd_pcm_runtime *runtime, ssize_t size)
+{
+	return size * runtime->sample_bits / 8;
+}
+
+static inline ssize_t frames_to_bytes(struct snd_pcm_runtime *runtime, snd_pcm_sframes_t size)
+{
+	return size * runtime->frame_bits / 8;
+}
+
+static inline int frame_aligned(struct snd_pcm_runtime *runtime, ssize_t bytes)
+{
+	return bytes % runtime->byte_align == 0;
+}
+
+static inline size_t snd_pcm_lib_buffer_bytes(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	return frames_to_bytes(runtime, runtime->buffer_size);
+}
+
+static inline size_t snd_pcm_lib_period_bytes(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	return frames_to_bytes(runtime, runtime->period_size);
+}
+
+/*
+ *  result is: 0 ... (boundary - 1)
+ */
+static inline snd_pcm_uframes_t snd_pcm_playback_avail(struct snd_pcm_runtime *runtime)
+{
+	snd_pcm_sframes_t avail = runtime->status->hw_ptr + runtime->buffer_size - runtime->control->appl_ptr;
+	if (avail < 0)
+		avail += runtime->boundary;
+	else if ((snd_pcm_uframes_t) avail >= runtime->boundary)
+		avail -= runtime->boundary;
+	return avail;
+}
+
+/*
+ *  result is: 0 ... (boundary - 1)
+ */
+static inline snd_pcm_uframes_t snd_pcm_capture_avail(struct snd_pcm_runtime *runtime)
+{
+	snd_pcm_sframes_t avail = runtime->status->hw_ptr - runtime->control->appl_ptr;
+	if (avail < 0)
+		avail += runtime->boundary;
+	return avail;
+}
+
+static inline snd_pcm_sframes_t snd_pcm_playback_hw_avail(struct snd_pcm_runtime *runtime)
+{
+	return runtime->buffer_size - snd_pcm_playback_avail(runtime);
+}
+
+static inline snd_pcm_sframes_t snd_pcm_capture_hw_avail(struct snd_pcm_runtime *runtime)
+{
+	return runtime->buffer_size - snd_pcm_capture_avail(runtime);
+}
+
+/**
+ * snd_pcm_playback_ready - check whether the playback buffer is available
+ * @substream: the pcm substream instance
+ *
+ * Checks whether enough free space is available on the playback buffer.
+ *
+ * Returns non-zero if available, or zero if not.
+ */
+static inline int snd_pcm_playback_ready(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	return snd_pcm_playback_avail(runtime) >= runtime->control->avail_min;
+}
+
+/**
+ * snd_pcm_capture_ready - check whether the capture buffer is available
+ * @substream: the pcm substream instance
+ *
+ * Checks whether enough capture data is available on the capture buffer.
+ *
+ * Returns non-zero if available, or zero if not.
+ */
+static inline int snd_pcm_capture_ready(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	return snd_pcm_capture_avail(runtime) >= runtime->control->avail_min;
+}
+
+/**
+ * snd_pcm_playback_data - check whether any data exists on the playback buffer
+ * @substream: the pcm substream instance
+ *
+ * Checks whether any data exists on the playback buffer. If stop_threshold
+ * is bigger or equal to boundary, then this function returns always non-zero.
+ *
+ * Returns non-zero if exists, or zero if not.
+ */
+static inline int snd_pcm_playback_data(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	
+	if (runtime->stop_threshold >= runtime->boundary)
+		return 1;
+	return snd_pcm_playback_avail(runtime) < runtime->buffer_size;
+}
+
+/**
+ * snd_pcm_playback_empty - check whether the playback buffer is empty
+ * @substream: the pcm substream instance
+ *
+ * Checks whether the playback buffer is empty.
+ *
+ * Returns non-zero if empty, or zero if not.
+ */
+static inline int snd_pcm_playback_empty(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	return snd_pcm_playback_avail(runtime) >= runtime->buffer_size;
+}
+
+/**
+ * snd_pcm_capture_empty - check whether the capture buffer is empty
+ * @substream: the pcm substream instance
+ *
+ * Checks whether the capture buffer is empty.
+ *
+ * Returns non-zero if empty, or zero if not.
+ */
+static inline int snd_pcm_capture_empty(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	return snd_pcm_capture_avail(runtime) == 0;
+}
+
+static inline void snd_pcm_trigger_done(struct snd_pcm_substream *substream, 
+					struct snd_pcm_substream *master)
+{
+	substream->runtime->trigger_master = master;
+}
+
+static inline int hw_is_mask(int var)
+{
+	return var >= SNDRV_PCM_HW_PARAM_FIRST_MASK &&
+		var <= SNDRV_PCM_HW_PARAM_LAST_MASK;
+}
+
+static inline int hw_is_interval(int var)
+{
+	return var >= SNDRV_PCM_HW_PARAM_FIRST_INTERVAL &&
+		var <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL;
+}
+
+static inline struct snd_mask *hw_param_mask(struct snd_pcm_hw_params *params,
+				     snd_pcm_hw_param_t var)
+{
+	return &params->masks[var - SNDRV_PCM_HW_PARAM_FIRST_MASK];
+}
+
+static inline struct snd_interval *hw_param_interval(struct snd_pcm_hw_params *params,
+					     snd_pcm_hw_param_t var)
+{
+	return &params->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];
+}
+
+static inline const struct snd_mask *hw_param_mask_c(const struct snd_pcm_hw_params *params,
+					     snd_pcm_hw_param_t var)
+{
+	return &params->masks[var - SNDRV_PCM_HW_PARAM_FIRST_MASK];
+}
+
+static inline const struct snd_interval *hw_param_interval_c(const struct snd_pcm_hw_params *params,
+						     snd_pcm_hw_param_t var)
+{
+	return &params->intervals[var - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL];
+}
+
+#define params_access(p) snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_ACCESS))
+#define params_format(p) snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_FORMAT))
+#define params_subformat(p) snd_mask_min(hw_param_mask((p), SNDRV_PCM_HW_PARAM_SUBFORMAT))
+#define params_channels(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_CHANNELS)->min
+#define params_rate(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_RATE)->min
+#define params_period_size(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_PERIOD_SIZE)->min
+#define params_period_bytes(p) ((params_period_size(p)*snd_pcm_format_physical_width(params_format(p))*params_channels(p))/8)
+#define params_periods(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_PERIODS)->min
+#define params_buffer_size(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_BUFFER_SIZE)->min
+#define params_buffer_bytes(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_BUFFER_BYTES)->min
+#define params_tick_time(p) hw_param_interval((p), SNDRV_PCM_HW_PARAM_TICK_TIME)->min
+
+
+int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v);
+void snd_interval_mul(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c);
+void snd_interval_div(const struct snd_interval *a, const struct snd_interval *b, struct snd_interval *c);
+void snd_interval_muldivk(const struct snd_interval *a, const struct snd_interval *b, 
+			  unsigned int k, struct snd_interval *c);
+void snd_interval_mulkdiv(const struct snd_interval *a, unsigned int k,
+			  const struct snd_interval *b, struct snd_interval *c);
+int snd_interval_list(struct snd_interval *i, unsigned int count, unsigned int *list, unsigned int mask);
+int snd_interval_ratnum(struct snd_interval *i,
+			unsigned int rats_count, struct snd_ratnum *rats,
+			unsigned int *nump, unsigned int *denp);
+
+void _snd_pcm_hw_params_any(struct snd_pcm_hw_params *params);
+void _snd_pcm_hw_param_setempty(struct snd_pcm_hw_params *params, snd_pcm_hw_param_t var);
+int snd_pcm_hw_params_choose(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params);
+
+int snd_pcm_hw_refine(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params);
+
+int snd_pcm_hw_constraints_init(struct snd_pcm_substream *substream);
+int snd_pcm_hw_constraints_complete(struct snd_pcm_substream *substream);
+
+int snd_pcm_hw_constraint_mask(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
+			       u_int32_t mask);
+int snd_pcm_hw_constraint_mask64(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
+				 u_int64_t mask);
+int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var,
+				 unsigned int min, unsigned int max);
+int snd_pcm_hw_constraint_integer(struct snd_pcm_runtime *runtime, snd_pcm_hw_param_t var);
+int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime, 
+			       unsigned int cond,
+			       snd_pcm_hw_param_t var,
+			       struct snd_pcm_hw_constraint_list *l);
+int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, 
+				  unsigned int cond,
+				  snd_pcm_hw_param_t var,
+				  struct snd_pcm_hw_constraint_ratnums *r);
+int snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime, 
+				  unsigned int cond,
+				  snd_pcm_hw_param_t var,
+				  struct snd_pcm_hw_constraint_ratdens *r);
+int snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime, 
+				 unsigned int cond,
+				 unsigned int width,
+				 unsigned int msbits);
+int snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,
+			       unsigned int cond,
+			       snd_pcm_hw_param_t var,
+			       unsigned long step);
+int snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,
+			       unsigned int cond,
+			       snd_pcm_hw_param_t var);
+int snd_pcm_hw_rule_add(struct snd_pcm_runtime *runtime,
+			unsigned int cond,
+			int var,
+			snd_pcm_hw_rule_func_t func, void *private,
+			int dep, ...);
+
+int snd_pcm_format_signed(snd_pcm_format_t format);
+int snd_pcm_format_unsigned(snd_pcm_format_t format);
+int snd_pcm_format_linear(snd_pcm_format_t format);
+int snd_pcm_format_little_endian(snd_pcm_format_t format);
+int snd_pcm_format_big_endian(snd_pcm_format_t format);
+#if 0 /* just for DocBook */
+/**
+ * snd_pcm_format_cpu_endian - Check the PCM format is CPU-endian
+ * @format: the format to check
+ *
+ * Returns 1 if the given PCM format is CPU-endian, 0 if
+ * opposite, or a negative error code if endian not specified.
+ */
+int snd_pcm_format_cpu_endian(snd_pcm_format_t format);
+#endif /* DocBook */
+#ifdef SNDRV_LITTLE_ENDIAN
+#define snd_pcm_format_cpu_endian(format) snd_pcm_format_little_endian(format)
+#else
+#define snd_pcm_format_cpu_endian(format) snd_pcm_format_big_endian(format)
+#endif
+int snd_pcm_format_width(snd_pcm_format_t format);			/* in bits */
+int snd_pcm_format_physical_width(snd_pcm_format_t format);		/* in bits */
+ssize_t snd_pcm_format_size(snd_pcm_format_t format, size_t samples);
+const unsigned char *snd_pcm_format_silence_64(snd_pcm_format_t format);
+int snd_pcm_format_set_silence(snd_pcm_format_t format, void *buf, unsigned int frames);
+snd_pcm_format_t snd_pcm_build_linear_format(int width, int unsignd, int big_endian);
+
+void snd_pcm_set_ops(struct snd_pcm * pcm, int direction, struct snd_pcm_ops *ops);
+void snd_pcm_set_sync(struct snd_pcm_substream *substream);
+int snd_pcm_lib_interleave_len(struct snd_pcm_substream *substream);
+int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream,
+		      unsigned int cmd, void *arg);                      
+int snd_pcm_update_hw_ptr(struct snd_pcm_substream *substream);
+int snd_pcm_playback_xrun_check(struct snd_pcm_substream *substream);
+int snd_pcm_capture_xrun_check(struct snd_pcm_substream *substream);
+int snd_pcm_playback_xrun_asap(struct snd_pcm_substream *substream);
+int snd_pcm_capture_xrun_asap(struct snd_pcm_substream *substream);
+void snd_pcm_playback_silence(struct snd_pcm_substream *substream, snd_pcm_uframes_t new_hw_ptr);
+void snd_pcm_tick_prepare(struct snd_pcm_substream *substream);
+void snd_pcm_tick_set(struct snd_pcm_substream *substream, unsigned long ticks);
+void snd_pcm_tick_elapsed(struct snd_pcm_substream *substream);
+void snd_pcm_period_elapsed(struct snd_pcm_substream *substream);
+snd_pcm_sframes_t snd_pcm_lib_write(struct snd_pcm_substream *substream,
+				    const void __user *buf,
+				    snd_pcm_uframes_t frames);
+snd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream,
+				   void __user *buf, snd_pcm_uframes_t frames);
+snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
+				     void __user **bufs, snd_pcm_uframes_t frames);
+snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
+				    void __user **bufs, snd_pcm_uframes_t frames);
+
+extern const struct snd_pcm_hw_constraint_list snd_pcm_known_rates;
+
+int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
+unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate);
+
+static inline void snd_pcm_set_runtime_buffer(struct snd_pcm_substream *substream,
+					      struct snd_dma_buffer *bufp)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	if (bufp) {
+		runtime->dma_buffer_p = bufp;
+		runtime->dma_area = bufp->area;
+		runtime->dma_addr = bufp->addr;
+		runtime->dma_bytes = bufp->bytes;
+	} else {
+		runtime->dma_buffer_p = NULL;
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
+	}
+}
+
+/*
+ *  Timer interface
+ */
+
+void snd_pcm_timer_resolution_change(struct snd_pcm_substream *substream);
+void snd_pcm_timer_init(struct snd_pcm_substream *substream);
+void snd_pcm_timer_done(struct snd_pcm_substream *substream);
+
+/*
+ *  Memory
+ */
+
+int snd_pcm_lib_preallocate_free(struct snd_pcm_substream *substream);
+int snd_pcm_lib_preallocate_free_for_all(struct snd_pcm *pcm);
+int snd_pcm_lib_preallocate_pages(struct snd_pcm_substream *substream,
+				  int type, struct device *data,
+				  size_t size, size_t max);
+int snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm,
+					  int type, void *data,
+					  size_t size, size_t max);
+int snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream, size_t size);
+int snd_pcm_lib_free_pages(struct snd_pcm_substream *substream);
+
+#define snd_pcm_substream_sgbuf(substream) ((substream)->runtime->dma_buffer_p->private_data)
+#define snd_pcm_sgbuf_pages(size) snd_sgbuf_aligned_pages(size)
+#define snd_pcm_sgbuf_get_addr(sgbuf,ofs) snd_sgbuf_get_addr(sgbuf,ofs)
+struct page *snd_pcm_sgbuf_ops_page(struct snd_pcm_substream *substream, unsigned long offset);
+
+/* handle mmap counter - PCM mmap callback should handle this counter properly */
+static inline void snd_pcm_mmap_data_open(struct vm_area_struct *area)
+{
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)area->vm_private_data;
+	atomic_inc(&substream->mmap_count);
+}
+
+static inline void snd_pcm_mmap_data_close(struct vm_area_struct *area)
+{
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)area->vm_private_data;
+	atomic_dec(&substream->mmap_count);
+}
+
+/* mmap for io-memory area */
+#if defined(CONFIG_X86) || defined(CONFIG_PPC) || defined(CONFIG_ALPHA)
+#define SNDRV_PCM_INFO_MMAP_IOMEM	SNDRV_PCM_INFO_MMAP
+int snd_pcm_lib_mmap_iomem(struct snd_pcm_substream *substream, struct vm_area_struct *area);
+#else
+#define SNDRV_PCM_INFO_MMAP_IOMEM	0
+#define snd_pcm_lib_mmap_iomem	NULL
+#endif
+
+static inline void snd_pcm_limit_isa_dma_size(int dma, size_t *max)
+{
+	*max = dma < 4 ? 64 * 1024 : 128 * 1024;
+}
+
+/*
+ *  Misc
+ */
+
+#define SNDRV_PCM_DEFAULT_CON_SPDIF	(IEC958_AES0_CON_EMPHASIS_NONE|\
+					 (IEC958_AES1_CON_ORIGINAL<<8)|\
+					 (IEC958_AES1_CON_PCM_CODER<<8)|\
+					 (IEC958_AES3_CON_FS_48000<<24))
+
+#endif /* __SOUND_PCM_H */
